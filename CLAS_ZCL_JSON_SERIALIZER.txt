==================================================
ZCL_JSON_SERIALIZER===========CCDEF
==================================================
*"* use this source file for any type declarations (class
*"* definitions, interfaces or data types) you need for method
*"* implementation or private method's signature

class lcl_test definition
    for testing "#AU Risk_Level Harmless
    inheriting from cl_aunit_assert .
  private section .
    methods:
      setup ,
      teardown ,
      test_struct for testing ,
      test_itab for testing ,
      test_deep for testing .
    types:
      begin of t_struct ,
        c1 type string ,
        c2 type string ,
      end of t_struct .
    data:
      serializer type ref to cl_trex_json_serializer ,
      result type string .
endclass .
==================================================
ZCL_JSON_SERIALIZER===========CCIMP
==================================================
*"* local class implementation for public class
*"* use this source file for the implementation part of
*"* local helper classes

class lcl_test implementation .
  method setup .
  endmethod .
  method teardown .
    clear serializer .
  endmethod .
  method test_struct .
    data l_struct type t_struct .

    l_struct-c1 = 'comp1' .
    l_struct-c2 = 'comp2' .

    create object serializer exporting data = l_struct .
    serializer->serialize( ) .

    result = serializer->get_data( ) .
    assert_equals(
        exp = '{c1: "comp1", c2: "comp2"}'
        act = result ) .
  endmethod .
  method test_itab .
    data l_itab type standard table of string .

    append 'line1' to l_itab .
    append 'line2' to l_itab .

    create object serializer exporting data = l_itab .
    serializer->serialize( ) .

    result = serializer->get_data( ) .
    assert_equals(
        exp = '["line1", "line2"]'
        act = result ) .
  endmethod .
  method test_deep .
    data:
      begin of l_deep ,
        itab1 type standard table of t_struct ,
        itab2 type standard table of t_struct ,
      end of l_deep ,
      l_row type t_struct .

    l_row-c1 = 'comp1' .
    l_row-c2 = 'comp2' .
    append l_row to l_deep-itab1 .
    append l_row to l_deep-itab1 .
    append l_row to l_deep-itab2 .
    append l_row to l_deep-itab2 .

    create object serializer exporting data = l_deep .
    serializer->serialize( ) .

    result = serializer->get_data( ) .

    constants c_exp_comp type string value '{c1: "comp1", c2: "comp2"}' .
    data l_expected type string value
          '{itab1: [&comp, &comp], itab2: [&comp, &comp]}' .
    replace all occurrences of '&comp' in l_expected with c_exp_comp .

    assert_equals(
        exp = l_expected
        act = result ) .
  endmethod .
endclass .
==================================================
ZCL_JSON_SERIALIZER===========CCMAC
==================================================
*"* use this source file for any macro definitions you need
*"* in the implementation part of the class

==================================================
ZCL_JSON_SERIALIZER===========CI
==================================================
*"* private components of class CL_TREX_JSON_SERIALIZER
*"* do not include other source files here!!!
private section.

  data FRAGMENTS type TREXT_STRING .
  data DATA_REF type ref to DATA .
  class-data C_COLON type STRING .
  class-data C_COMMA type STRING .

  methods RECURSE
    importing
      !DATA type DATA .
==================================================
ZCL_JSON_SERIALIZER===========CO
==================================================
*"* protected components of class CL_TREX_JSON_SERIALIZER
*"* do not include other source files here!!!
protected section.
==================================================
ZCL_JSON_SERIALIZER===========CP
==================================================
class-pool .
*"* class pool for class ZCL_JSON_SERIALIZER

*"* local type definitions
include ZCL_JSON_SERIALIZER===========ccdef.

*"* class ZCL_JSON_SERIALIZER definition
*"* public declarations
  include ZCL_JSON_SERIALIZER===========cu.
*"* protected declarations
  include ZCL_JSON_SERIALIZER===========co.
*"* private declarations
  include ZCL_JSON_SERIALIZER===========ci.
endclass. "ZCL_JSON_SERIALIZER definition

*"* macro definitions
include ZCL_JSON_SERIALIZER===========ccmac.
*"* local class implementation
include ZCL_JSON_SERIALIZER===========ccimp.

class ZCL_JSON_SERIALIZER implementation.
*"* method's implementations
  include methods.
endclass. "ZCL_JSON_SERIALIZER implementation

==================================================
ZCL_JSON_SERIALIZER===========CU
==================================================
class ZCL_JSON_SERIALIZER definition
  public
  final
  create public .

*"* public components of class ZCL_JSON_SERIALIZER
*"* do not include other source files here!!!
public section.

  class-methods CLASS_CONSTRUCTOR .
  methods CONSTRUCTOR
    importing
      !DATA type DATA .
  methods SERIALIZE .
  methods GET_DATA
    returning
      value(RVAL) type STRING .
==================================================
ZCL_JSON_SERIALIZER=CLASS_CONSTRUCTOR
==================================================
method CLASS_CONSTRUCTOR.
  cl_abap_string_utilities=>c2str_preserving_blanks(
      exporting source = ': '
      importing dest   = c_colon ) .
  cl_abap_string_utilities=>c2str_preserving_blanks(
      exporting source = ', '
      importing dest   = c_comma ) .
endmethod.
==================================================
ZCL_JSON_SERIALIZER=CONSTRUCTOR
==================================================
method CONSTRUCTOR.
  get reference of data into me->data_ref .
endmethod.
==================================================
ZCL_JSON_SERIALIZER=GET_DATA
==================================================
method GET_DATA.
  concatenate lines of me->fragments into rval .
endmethod.
==================================================
ZCL_JSON_SERIALIZER=RECURSE
==================================================
method RECURSE.
*  data:
*    l_type  type c ,
*    l_comps type i ,
*    l_lines type i ,
*    l_index type i ,
*    l_value type string .
*  field-symbols:
*    <itab> type any table ,
*    <comp> type any .
*
*  describe field data type l_type components l_comps .
*
*  if l_type = cl_abap_typedescr=>typekind_table .
**   itab -> array
*    append '[' to me->fragments .
*    assign data to <itab> .
*    l_lines = lines( <itab> ) .
*    loop at <itab> assigning <comp> .
*      add 1 to l_index .
*      recurse( <comp> ) .
*      if l_index < l_lines .
*        append c_comma to me->fragments .
*      endif .
*    endloop .
*    append ']' to fragments .
*  else .
*    if l_comps is initial .
**     field -> scalar
**     todo: format
*      l_value = data .
*      replace all occurrences of '\' in l_value with '\\' .
*      replace all occurrences of '"' in l_value with '\"' .
*      replace all occurrences of '''' in l_value with '\''' .
*      concatenate '"' l_value '"' into l_value .
*      append l_value to me->fragments .
*    else .
**     structure -> object
*      data l_typedescr type ref to cl_abap_structdescr .
*      field-symbols <abapcomp> type abap_compdescr .
*
*      append '{' to me->fragments .
*      l_typedescr ?= cl_abap_typedescr=>describe_by_data( data ) .
*      loop at l_typedescr->components assigning <abapcomp> .
*        l_index = sy-tabix .
*        concatenate <abapcomp>-name c_colon into l_value .
*        translate l_value to lower case .
*        append l_value to me->fragments .
*        assign component <abapcomp>-name of structure data to <comp> .
*        recurse( <comp> ) .
*        if l_index < l_comps .
*          append c_comma to me->fragments .
*
*        endif .
*      endloop .
*      append '}' to me->fragments .
*    endif .
*  endif .

   data:
     l_type  type c ,
     l_comps type i ,
     l_lines type i ,
     l_index type i ,
     l_value type string .
   field-symbols:
     <itab> type any table ,
     <comp> type any .

   describe field data type l_type components l_comps .

   if l_type = cl_abap_typedescr=>typekind_table .
*   itab -> array
     append '[' to me->fragments .
     assign data to <itab> .
     l_lines = lines( <itab> ) .
     loop at <itab> assigning <comp> .
       add 1 to l_index .
       recurse( <comp> ) .
       if l_index < l_lines .
         append c_comma to me->fragments .
       endif .
     endloop .
     append ']' to fragments .
   else .
     if l_comps is initial .
*     field -> scalar
*     todo: format
       l_value = data .
       replace all occurrences of '\' in l_value with '\\' .
       replace all occurrences of '''' in l_value with '\''' .
       replace all occurrences of '"' in l_value with '\"' .
       replace all occurrences of '&' in l_value with '\&' .
       replace all occurrences of cl_abap_char_utilities=>cr_lf in l_value with '\r\n' .
       replace all occurrences of cl_abap_char_utilities=>newline in l_value with '\n' .
       replace all occurrences of cl_abap_char_utilities=>horizontal_tab in l_value with '\t' .
       replace all occurrences of cl_abap_char_utilities=>backspace in l_value with '\b' .
       replace all occurrences of cl_abap_char_utilities=>form_feed in l_value with '\f' .
*     space at the end of numbers
       CONDENSE l_value.
       concatenate '"' l_value '"' into l_value .
       append l_value to me->fragments .
     else .
*     structure -> object
       data l_typedescr type ref to cl_abap_structdescr .
       field-symbols <abapcomp> type abap_compdescr .

       append '{' to me->fragments .
       l_typedescr ?= cl_abap_typedescr=>describe_by_data( data ) .
       loop at l_typedescr->components assigning <abapcomp> .
         l_index = sy-tabix .
*         concatenate <abapcomp>-name c_colon into l_value .
         CONCATENATE '"' <abapcomp>-name '"' c_colon INTO l_value .
         translate l_value to lower case .
         append l_value to me->fragments .
         assign component <abapcomp>-name of structure data to <comp> .
         recurse( <comp> ) .
         if l_index < l_comps .
           append c_comma to me->fragments .
         endif .
       endloop .
       append '}' to me->fragments .
     endif .
   endif .
endmethod.
==================================================
ZCL_JSON_SERIALIZER=SERIALIZE
==================================================
method SERIALIZE.
  field-symbols <data> type data .

  assign me->data_ref->* to <data> .
  recurse( <data> ) .
endmethod.

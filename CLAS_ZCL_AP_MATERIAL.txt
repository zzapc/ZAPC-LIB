* Tabla caché con algunos datos importantes de material
TYPES: BEGIN OF t_mat,
         matnr TYPE matnr,
         meins TYPE meins,
       END OF t_mat,
       tt_mat TYPE SORTED TABLE OF t_mat WITH UNIQUE KEY matnr.
TYPES: BEGIN OF t_mat_conv_ctd,
         matnr  TYPE matnr,
         unori  TYPE meins, "Unidad origen
         undes  TYPE meins, "Unidad destino
         ctori  TYPE mengev, "Cantidad origen
         ctdes  TYPE mengev, "Cantidad destino
       END OF t_mat_conv_ctd,
       tt_mat_conv_ctd TYPE SORTED TABLE OF t_mat_conv_ctd WITH UNIQUE KEY matnr unori undes ctori ctdes.
CLASS zcl_ap_material DEFINITION
  PUBLIC
  CREATE PUBLIC.

  PUBLIC SECTION.
    TYPES:
      BEGIN OF t_mb5b,
        bwkey         TYPE mbew-bwkey,
        werks         TYPE mseg-werks,
        matnr         TYPE mseg-matnr,
        charg         TYPE mseg-charg,
        endmenge(09)  TYPE p          DECIMALS 3,
        anfmenge(09)  TYPE p          DECIMALS 3,
        meins         TYPE mara-meins,
        endwert(09)   TYPE p          DECIMALS 2,
        anfwert(09)   TYPE p          DECIMALS 2,
        soll(09)      TYPE p          DECIMALS 3,
        haben(09)     TYPE p          DECIMALS 3,
        sollwert(09)  TYPE p          DECIMALS 2,
        habenwert(09) TYPE p          DECIMALS 2,
        waers         TYPE t001-waers,
      END OF t_mb5b.
    TYPES tt_mb5b            TYPE STANDARD TABLE OF t_mb5b.
    TYPES tt_bapi_matreturn2 TYPE STANDARD TABLE OF bapi_matreturn2.
    TYPES tt_matnr           TYPE matnr18.

    DATA return   TYPE bapiret2.
    DATA headdata TYPE bapimathead.
    DATA messages TYPE tt_bapi_matreturn2.

    CLASS-DATA c_tipo_gos TYPE sibftypeid VALUE 'BUS1001006' ##NO_TEXT.

    CLASS-METHODS visualizar
      IMPORTING matnr     TYPE mara-matnr
                vistas    TYPE t130m-pstat OPTIONAL
                nvista    TYPE i           OPTIONAL
                werks     TYPE rmmg1-werks OPTIONAL
                lgort     TYPE rmmg1-lgort OPTIONAL
                lgnum     TYPE rmmg1-lgnum OPTIONAL
                lgtyp     TYPE rmmg1-lgtyp OPTIONAL
                vkorg     TYPE mvke-vkorg  OPTIONAL
                vtweg     TYPE mvke-vtweg  OPTIONAL
                modificar TYPE abap_bool   DEFAULT ''.

    CLASS-METHODS get_descripcion
      IMPORTING matnr        TYPE any        OPTIONAL
                spras        TYPE makt-spras DEFAULT sy-langu
      PREFERRED PARAMETER matnr
      RETURNING VALUE(maktx) TYPE makt-maktx.

    CLASS-METHODS get_unidad_base
      IMPORTING matnr        TYPE any
      RETURNING VALUE(meins) TYPE mara-meins.

    CLASS-METHODS convertir_unidad
      IMPORTING matnr            TYPE any
                cantidad         TYPE any
                unidad_origen    TYPE meins
                unidad_destino   TYPE meins
      RETURNING VALUE(resultado) TYPE menge_d.

    CLASS-METHODS ver_stocks
      IMPORTING matnr   TYPE matnr
                werks   TYPE werks_d         OPTIONAL
                lgort   TYPE lgort_d         OPTIONAL
                charg   TYPE charg_d         OPTIONAL
                lotes   TYPE any             DEFAULT ''
                kzlso   TYPE abap_bool       DEFAULT 'X'
                kzlon   TYPE abap_bool       DEFAULT 'X'
                s_lgort TYPE range_t_lgort_d OPTIONAL
                s_werks TYPE range_t_werks_d OPTIONAL.

    CLASS-METHODS get_detalle_costes
      IMPORTING matnr TYPE matnr
                werks TYPE werks_d.

    CLASS-METHODS get_valor
      IMPORTING matnr        TYPE matnr
                werks        TYPE werks_d
                cantidad     TYPE menge_d OPTIONAL
                meins        TYPE meins   OPTIONAL
                campo        TYPE any     DEFAULT ''
      RETURNING VALUE(valor) TYPE dmbtr.

    METHODS get_descr
      IMPORTING matnr        TYPE makt-matnr OPTIONAL
                spras        TYPE makt-spras DEFAULT sy-langu
      PREFERRED PARAMETER matnr
      RETURNING VALUE(maktx) TYPE makt-maktx.

    CLASS-METHODS get_grupo_articulos
      IMPORTING matnr        TYPE matnr
      RETURNING VALUE(matkl) TYPE matkl.

    CLASS-METHODS get_texto_string
      IMPORTING matnr         TYPE matnr
                !id           TYPE any
                spras         TYPE spras DEFAULT sy-langu
                vkorg         TYPE vkorg DEFAULT ''
                vtweg         TYPE vtweg DEFAULT ''
      RETURNING VALUE(string) TYPE string.

    METHODS update.

    METHODS ini_update
      IMPORTING matnr TYPE matnr.

    METHODS add_datos_basicos
      IMPORTING mara TYPE mara.

    METHODS add_textos_breves
      IMPORTING i_makt TYPE makt_tab.

    METHODS add_datos_ventas
      IMPORTING mvke TYPE mvke.

    METHODS add_datos_impuestos
      IMPORTING i_mlan             TYPE mlan_tab    OPTIONAL
                taxclassifications TYPE t_bapi_mlan OPTIONAL
      PREFERRED PARAMETER i_mlan.

    CLASS-METHODS determina_cambios_campos
      IMPORTING original        TYPE any
                modificacion    TYPE any  OPTIONAL
                pos_ini_cambios TYPE int2 DEFAULT 0
      CHANGING  cambios         TYPE any.

    METHODS add_datos_centro
      IMPORTING marc              TYPE marc
                compras           TYPE sicht_e   DEFAULT ''
                mrp               TYPE sicht_d   DEFAULT ''
                prep_trabajo      TYPE sicht_a   DEFAULT ''
                comercial         TYPE sicht_v   DEFAULT ''
                costes            TYPE sicht_b   DEFAULT ''
                calidad           TYPE sicht_q   DEFAULT ''
                almacen           TYPE sicht_l   DEFAULT ''
                vistas_existentes TYPE abap_bool DEFAULT ''.

    METHODS add_datos_contabilidad
      IMPORTING mbew         TYPE mbew
                contabilidad TYPE abap_bool DEFAULT 'X'
                costes       TYPE abap_bool DEFAULT ''.

    CLASS-METHODS edit_clasificacion
      IMPORTING matnr      TYPE matnr
                visualizar TYPE abap_bool DEFAULT 'X'.

    METHODS add_datos_almacen_wm
      IMPORTING mlgn TYPE mlgn OPTIONAL
                mlgt TYPE mlgt OPTIONAL
      PREFERRED PARAMETER mlgn.

    METHODS add_unidades_medida
      IMPORTING i_marm TYPE marm_tab
                meins  TYPE meins
                borrar TYPE abap_bool DEFAULT ''.

    METHODS add_datos_almacen
      IMPORTING mard TYPE mard.

    CLASS-METHODS get_mrp
      IMPORTING matnr              TYPE any
                werks              TYPE werks_d
                plscn              TYPE plscn DEFAULT '000'
      RETURNING VALUE(i_mrp_lines) TYPE zt_bapi_mrp_ind_lines.

    METHODS conv_unidad
      IMPORTING matnr            TYPE matnr
                cantidad         TYPE any
                unidad_origen    TYPE meins
                unidad_destino   TYPE meins
      RETURNING VALUE(resultado) TYPE menge_d.

    METHODS conv_unidad_base
      IMPORTING matnr            TYPE matnr
                cantidad         TYPE any
                unidad_origen    TYPE meins
      RETURNING VALUE(resultado) TYPE menge_d.

    CLASS-METHODS formato_externo
      IMPORTING matnr          TYPE matnr
      RETURNING VALUE(externo) TYPE matnr.

    CLASS-METHODS formato_interno
      IMPORTING matnr          TYPE any
      RETURNING VALUE(interno) TYPE matnr.

    CLASS-METHODS get_texto
      IMPORTING matnr         TYPE matnr
                !id           TYPE any
                spras         TYPE spras DEFAULT sy-langu
      RETURNING VALUE(lineas) TYPE tlinetab.

    CLASS-METHODS get_valor_clas
      IMPORTING matnr       TYPE matnr
                klart       TYPE ausp-klart DEFAULT '001'
                caract      TYPE any        OPTIONAL
                atinn       TYPE atinn      OPTIONAL
      RETURNING VALUE(ausp) TYPE ausp.

    CLASS-METHODS get_valor_clas_c
      IMPORTING matnr        TYPE matnr
                klart        TYPE ausp-klart DEFAULT '001'
                caract       TYPE any        OPTIONAL
                atinn        TYPE atinn      OPTIONAL
                descripcion  TYPE abap_bool  DEFAULT ''
                spras        TYPE sy-langu   DEFAULT sy-langu
      RETURNING VALUE(atwrt) TYPE atwrt.

    CLASS-METHODS get_valor_clas_p
      IMPORTING matnr        TYPE matnr
                klart        TYPE ausp-klart DEFAULT '001'
                caract       TYPE any        OPTIONAL
                atinn        TYPE atinn      OPTIONAL
      RETURNING VALUE(atflv) TYPE atflv.

    CLASS-METHODS get_peso
      IMPORTING matnr           TYPE matnr
                unidad          TYPE meins     DEFAULT ''
                tipo_peso       TYPE char1     DEFAULT 'N'
                cantidad_origen TYPE mengv13   OPTIONAL
                unidad_origen   TYPE meins     OPTIONAL
                cualquiera      TYPE abap_bool DEFAULT ''
      RETURNING VALUE(peso)     TYPE mara-ntgew.

    CLASS-METHODS esta_clasificado
      IMPORTING matnr     TYPE matnr
                !class    TYPE any
                klart     TYPE any DEFAULT '001'
      RETURNING VALUE(si) TYPE abap_bool.

    CLASS-METHODS get_datos_gos
      IMPORTING matnr        TYPE any
                atta         TYPE abap_bool DEFAULT ''
                url          TYPE abap_bool DEFAULT ''
                notas        TYPE abap_bool DEFAULT ''
      RETURNING VALUE(tabla) TYPE ztab_url_gos.

    CLASS-METHODS esta_bloqueado
      IMPORTING matnr            TYPE matnr     OPTIONAL
                werks            TYPE werks_d   DEFAULT ''
                solo_en_centro   TYPE abap_bool DEFAULT ''
      PREFERRED PARAMETER matnr
      RETURNING VALUE(bloqueado) TYPE abap_bool.

    CLASS-METHODS convertir_peso
      IMPORTING cantidad         TYPE any
                unidad_origen    TYPE meins
                unidad_destino   TYPE meins
      RETURNING VALUE(resultado) TYPE menge_d.

    METHODS get_unidad
      IMPORTING matnr        TYPE matnr OPTIONAL
      PREFERRED PARAMETER matnr
      RETURNING VALUE(meins) TYPE meins.

    CLASS-METHODS insertar_log_modificaciones
      IMPORTING matnr    TYPE matnr
                tcode    TYPE sy-tcode DEFAULT sy-tcode
                marc_new TYPE marc     OPTIONAL
                marc_old TYPE marc     OPTIONAL
                mara_new TYPE mara     OPTIONAL
                mara_old TYPE mara     OPTIONAL.

    CLASS-METHODS get_kg
      IMPORTING matnr        TYPE matnr
                cantidad     TYPE any
                unidad       TYPE meins
      RETURNING VALUE(kilos) TYPE menge_d.

    CLASS-METHODS upd_clase_inspeccion
      IMPORTING matnr                       TYPE matnr
                werks                       TYPE werks_d
                art                         TYPE qmat-art
                stichprver                  TYPE qmat-stichprver DEFAULT '?'
                activo                      TYPE xfeld           DEFAULT '?'
                segundos_espera_si_bloqueos TYPE i               DEFAULT 5
                !commit                     TYPE abap_bool       DEFAULT 'X'
                art2                        TYPE qmat-art        DEFAULT ''
                activo2                     TYPE xfeld           DEFAULT '?'
                stichprver2                 TYPE qmat-stichprver DEFAULT '?'
      RETURNING VALUE(message)              TYPE bapi_msg.

    CLASS-METHODS get_stock_a_fecha
      IMPORTING werks              TYPE werks_d         OPTIONAL
                lgort              TYPE lgort_d         OPTIONAL
                fecha              TYPE dats
                r_matnr            TYPE range_t_matnr   OPTIONAL
                matnr              TYPE matnr           OPTIONAL
                solo_mat_suj_lotes TYPE am07m-xchrg     DEFAULT ''
                r_werks            TYPE range_t_werks_d OPTIONAL
                r_lgort            TYPE range_t_lgort_d OPTIONAL
      RETURNING VALUE(i_stocks)    TYPE mchb_tty.

    CLASS-METHODS set_texto_string
      IMPORTING matnr           TYPE matnr
                !id             TYPE any
                spras           TYPE spras     DEFAULT sy-langu
                vkorg           TYPE vkorg     DEFAULT ''
                vtweg           TYPE vtweg     DEFAULT ''
                !string         TYPE string
                longitud        TYPE i         DEFAULT 72
                word_wrap       TYPE abap_bool DEFAULT 'X'
                delimiter       TYPE c         DEFAULT ''
                savemode_direct TYPE abap_bool DEFAULT 'X'
                !insert         TYPE abap_bool DEFAULT 'X'.

    CLASS-METHODS get_stock
      IMPORTING matnr           TYPE matnr
                charg           TYPE charg_d    DEFAULT ''
                libre           TYPE abap_bool  DEFAULT 'X'
                bloqueado       TYPE abap_bool  DEFAULT ''
                calidad         TYPE abap_bool  DEFAULT ''
                bestq           TYPE vepo-bestq DEFAULT ''
                otros           TYPE abap_bool  DEFAULT ''
                traslado        TYPE abap_bool  DEFAULT '*'
                werks           TYPE werks_d    DEFAULT ''
                lgort           TYPE lgort_d    DEFAULT ''
                meins           TYPE meins      DEFAULT ''
                vbeln           TYPE vbeln_va   DEFAULT ''
                sobkz           TYPE sobkz
      RETURNING VALUE(cantidad) TYPE mchb-clabs.

    CLASS-METHODS get_cambios_caract
      IMPORTING caract         TYPE any        OPTIONAL
                klart          TYPE ausp-klart OPTIONAL
                r_udate        TYPE rstt_t_range_date
      RETURNING VALUE(i_cdpos) TYPE iscdpos_tab.

  PROTECTED SECTION.
    DATA clientdata  TYPE bapi_mara.
    DATA clientdatax TYPE bapi_marax.
    DATA material    TYPE matnr.
    DATA new_mara    TYPE mara.

  PRIVATE SECTION.
    TYPES:
      BEGIN OF mat_meins_s,
        matnr TYPE matnr,
        meins TYPE meins,
      END OF mat_meins_s.
    TYPES mat_meins_tt TYPE STANDARD TABLE OF mat_meins_s.

    DATA i_makt               TYPE makt_tab.
    DATA materialdescription  TYPE t_bapi_makt.
    DATA salesdata            TYPE bapi_mvke.
    DATA salesdatax           TYPE bapi_mvkex.
    DATA taxclassifications   TYPE t_bapi_mlan.
    DATA plantdata            TYPE bapi_marc.
    DATA plantdatax           TYPE bapi_marcx.
    DATA valuationdata        TYPE bapi_mbew.
    DATA valuationdatax       TYPE bapi_mbewx.
    DATA warehousenumberdata  TYPE bapi_mlgn.
    DATA warehousenumberdatax TYPE bapi_mlgnx.
    DATA unitsofmeasure       TYPE t_bapi_marm.
    DATA unitsofmeasurex      TYPE t_bapi_marmx.
    DATA storagelocationdata  TYPE bapi_mard.
    DATA storagelocationdatax TYPE bapi_mardx.
    DATA i_mat                TYPE tt_mat.
    DATA i_mat_conv_ctd       TYPE tt_mat_conv_ctd.
    DATA i_mat_meins          TYPE mat_meins_tt.
    DATA storagetypedata      TYPE bapi_mlgt.
    DATA storagetypedatax     TYPE bapi_mlgtx.

    METHODS get_datos_mat
      IMPORTING matnr        TYPE matnr
      RETURNING VALUE(datos) TYPE t_mat.
endclass. "ZCL_AP_MATERIAL definition
class ZCL_AP_MATERIAL implementation.
  METHOD add_datos_almacen.
    DATA: l_tabla               TYPE tabname,
          l_mard                TYPE mard,
          l_bapi_mard_ga        TYPE bapi_mard_ga,
          l_storagelocationdata TYPE bapi_mard.

* Recupero datos en BD para comporar
    l_tabla = 'MARD'.
    SELECT SINGLE * FROM (l_tabla)              "#EC CI_ALL_FIELDS_NEEDED
      INTO l_mard
     WHERE matnr = material
       AND werks = mard-werks
       AND lgort = mard-lgort.

    CALL FUNCTION 'MAP2E_MARD_TO_BAPI_MARD_GA'
      EXPORTING
        mard         = l_mard
      CHANGING
        bapi_mard_ga = l_bapi_mard_ga.

    MOVE-CORRESPONDING l_bapi_mard_ga TO l_storagelocationdata.

* Convierto a estructura de la BAPI
    CALL FUNCTION 'MAP2E_MARD_TO_BAPI_MARD_GA'
      EXPORTING
        mard         = mard
      CHANGING
        bapi_mard_ga = l_bapi_mard_ga.

    MOVE-CORRESPONDING l_bapi_mard_ga TO storagelocationdata.

    determina_cambios_campos( EXPORTING original     = l_storagelocationdata
                                        modificacion = storagelocationdata
                              CHANGING  cambios      = storagelocationdatax ).

    storagelocationdatax-plant    = storagelocationdata-plant.
    storagelocationdatax-stge_loc = storagelocationdata-stge_loc.
    headdata-storage_view = 'X'.
  ENDMETHOD.
  METHOD add_datos_almacen_wm.
    DATA: l_tabla               TYPE tabname,
          l_mlgn                TYPE mlgn,
          l_bapi_mlgn_ga        TYPE bapi_mlgn_ga,
          l_warehousenumberdata TYPE bapi_mlgn,
          l_mlgt                TYPE mlgt,
          l_bapi_mlgt_ga        TYPE bapi_mlgt_ga,
          l_storagetypedata     TYPE bapi_mlgt.

* Recupero datos en BD para comparar
    IF NOT mlgn IS INITIAL.
      l_tabla = 'MLGN'.
      SELECT SINGLE * FROM (l_tabla)            "#EC CI_ALL_FIELDS_NEEDED
        INTO l_mlgn
       WHERE matnr = material
         AND lgnum = mlgn-lgnum.

      CALL FUNCTION 'MAP2E_MLGN_TO_BAPI_MLGN_GA'
        EXPORTING
          mlgn         = l_mlgn
        CHANGING
          bapi_mlgn_ga = l_bapi_mlgn_ga.

      MOVE-CORRESPONDING l_bapi_mlgn_ga TO l_warehousenumberdata.

* Convierto a estructura de la BAPI
      CALL FUNCTION 'MAP2E_MLGN_TO_BAPI_MLGN_GA'
        EXPORTING
          mlgn         = mlgn
        CHANGING
          bapi_mlgn_ga = l_bapi_mlgn_ga.

      MOVE-CORRESPONDING l_bapi_mlgn_ga TO warehousenumberdata.

      determina_cambios_campos( EXPORTING original     = l_warehousenumberdata
                                          modificacion = warehousenumberdata
                                CHANGING  cambios      = warehousenumberdatax ).

      warehousenumberdatax-whse_no = warehousenumberdata-whse_no.
      headdata-warehouse_view = 'X'.
    ENDIF.

    IF NOT mlgt IS INITIAL.
      l_tabla = 'MLGT'.
      SELECT SINGLE * FROM (l_tabla)            "#EC CI_ALL_FIELDS_NEEDED
        INTO l_mlgt
       WHERE matnr = material
         AND lgnum = mlgt-lgnum
         AND lgtyp = mlgt-lgtyp.

      CALL FUNCTION 'MAP2E_MLGT_TO_BAPI_MLGT_GA'
        EXPORTING
          mlgt         = l_mlgt
        CHANGING
          bapi_mlgt_ga = l_bapi_mlgt_ga.

      MOVE-CORRESPONDING l_bapi_mlgt_ga TO l_storagetypedata.

* Convierto a estructura de la BAPI
      CALL FUNCTION 'MAP2E_MLGT_TO_BAPI_MLGT_GA'
        EXPORTING
          mlgt         = mlgt
        CHANGING
          bapi_mlgt_ga = l_bapi_mlgt_ga.

      MOVE-CORRESPONDING l_bapi_mlgt_ga TO storagetypedata.

      determina_cambios_campos( EXPORTING original     = l_storagetypedata
                                          modificacion = storagetypedata
                                CHANGING  cambios      = storagetypedatax ).

      storagetypedatax-whse_no   = storagetypedata-whse_no.
      storagetypedatax-stge_type = storagetypedata-stge_type.
      headdata-warehouse_view = 'X'.
    ENDIF.
  ENDMETHOD.
  METHOD add_datos_basicos.
    DATA: l_tabla      TYPE tabname,
          l_mara       TYPE mara,
          l_clientdata TYPE bapi_mara.

* Recupero datos en BD para comporar
    l_tabla = 'MARA'.
    SELECT SINGLE * FROM (l_tabla)              "#EC CI_ALL_FIELDS_NEEDED
      INTO l_mara
     WHERE matnr = material.

    CALL FUNCTION 'CFX_MAP2E_MARA_TO_BAPI_MARA'
      EXPORTING
        mara      = l_mara
      CHANGING
        bapi_mara = l_clientdata.

* Convierto a estructura de la BAPI
    CALL FUNCTION 'CFX_MAP2E_MARA_TO_BAPI_MARA'
      EXPORTING
        mara      = mara
      CHANGING
        bapi_mara = clientdata.

    determina_cambios_campos( EXPORTING original     = l_clientdata
                                        modificacion = clientdata
                              CHANGING  cambios      = clientdatax ).

    IF NOT mara IS INITIAL.
      headdata-ind_sector = mara-mbrsh.
      headdata-matl_type  = mara-mtart.
    ENDIF.

    headdata-basic_view = 'X'.

    IF clientdatax-stor_conds = 'X' OR clientdatax-temp_conds = 'X'.
      headdata-storage_view = 'X'.
    ENDIF.

    new_mara = mara.
  ENDMETHOD.
  METHOD add_datos_centro.
    DATA: l_tabla     TYPE tabname,
          l_marc      TYPE marc,
          l_plantdata TYPE bapi_marc.

* Recupero datos en BD para comparar
    l_tabla = 'MARC'.
    SELECT SINGLE * FROM (l_tabla)              "#EC CI_ALL_FIELDS_NEEDED
      INTO l_marc
     WHERE matnr = material
       AND werks = marc-werks.

*  CALL FUNCTION 'CFX_MAP2E_MARC_TO_BAPI_MARC'     "APC20180806
    CALL FUNCTION 'MAP2E_MARC_TO_BAPI_MARC'
      EXPORTING
        marc                         = l_marc
        currency_amount_bapi_to_sap  = 'EUR'         " APC20180806
      CHANGING
        bapi_marc                    = l_plantdata
      EXCEPTIONS
        error_converting_curr_amount = 1
        OTHERS                       = 2.
    IF sy-subrc <> 0.
*
    ENDIF.

* Convierto a estructura de la BAPI
*  CALL FUNCTION 'CFX_MAP2E_MARC_TO_BAPI_MARC'     "APC20180806
    CALL FUNCTION 'MAP2E_MARC_TO_BAPI_MARC'
      EXPORTING
        marc                         = marc
        currency_amount_bapi_to_sap  = 'EUR'         " APC20180806
      CHANGING
        bapi_marc                    = plantdata
      EXCEPTIONS
        error_converting_curr_amount = 1
        OTHERS                       = 2.

    IF sy-subrc <> 0.
*
    ENDIF.

    determina_cambios_campos( EXPORTING original     = l_plantdata
                                        modificacion = plantdata
                              CHANGING  cambios      = plantdatax ).

    plantdatax-plant = plantdata-plant.
    headdata-purchase_view   = compras.
    headdata-mrp_view        = mrp.
    headdata-work_sched_view = prep_trabajo.
    headdata-sales_view      = comercial.
    headdata-cost_view       = costes.
    headdata-quality_view    = calidad.
    headdata-storage_view    = almacen.

    IF vistas_existentes = 'X' AND NOT l_marc IS INITIAL.
      IF l_marc-pstat CS 'E'.
        headdata-purchase_view = 'X'.
      ENDIF.
      IF l_marc-pstat CS 'D'.
        headdata-mrp_view = 'X'.
      ENDIF.
      IF l_marc-pstat CS 'A'.
        headdata-work_sched_view = 'X'.
      ENDIF.
      IF l_marc-pstat CS 'V'.
        headdata-sales_view = 'X'.
      ENDIF.
      IF l_marc-pstat CS 'B'.
        headdata-cost_view = 'X'.
      ENDIF.
      IF l_marc-pstat CS 'Q'.
        headdata-quality_view = 'X'.
      ENDIF.
      IF l_marc-pstat CS 'L'.
        headdata-storage_view = 'X'.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD add_datos_contabilidad.
    DATA: l_tabla         TYPE tabname,
          l_mbew          TYPE mbew,
          l_bapi_mbew_ga  TYPE bapi_mbew_ga,
          l_valuationdata TYPE bapi_mbew.

* Recupero datos en BD para comporar
    l_tabla = 'MBEW'.
    SELECT  * FROM (l_tabla)                  "#EC CI_ALL_FIELDS_NEEDED
      INTO l_mbew
      UP TO 1 ROWS
     WHERE matnr = material
       AND bwkey = mbew-bwkey.
    ENDSELECT.

    CALL FUNCTION 'MAP2E_MBEW_TO_BAPI_MBEW_GA'
      EXPORTING
        mbew                         = l_mbew
        h_waers                      = 'EUR'
      CHANGING
        bapi_mbew_ga                 = l_bapi_mbew_ga
      EXCEPTIONS
        error_converting_curr_amount = 1
        OTHERS                       = 2.
    IF sy-subrc <> 0.
*
    ENDIF.

    MOVE-CORRESPONDING l_bapi_mbew_ga TO l_valuationdata.

* Convierto a estructura de la BAPI
    CALL FUNCTION 'MAP2E_MBEW_TO_BAPI_MBEW_GA'
      EXPORTING
        mbew                         = mbew
        h_waers                      = 'EUR'
      CHANGING
        bapi_mbew_ga                 = l_bapi_mbew_ga
      EXCEPTIONS
        error_converting_curr_amount = 1
        OTHERS                       = 2.
    IF sy-subrc <> 0.
*
    ENDIF.
    MOVE-CORRESPONDING l_bapi_mbew_ga TO valuationdata.

    determina_cambios_campos( EXPORTING original     = l_valuationdata
                                        modificacion = valuationdata
                              CHANGING  cambios      = valuationdatax ).

    valuationdatax-val_area = valuationdata-val_area.
    headdata-account_view = contabilidad.
    headdata-cost_view    = costes.
  ENDMETHOD.
  METHOD add_datos_impuestos.
    DATA: l_mlan      TYPE mlan,
          l_bapi_mlan TYPE bapi_mlan,
          i_tstl      TYPE TABLE OF tstl,
          l_tstl      TYPE tstl.

    IF taxclassifications IS INITIAL.
      LOOP AT i_mlan INTO l_mlan.
        CLEAR l_bapi_mlan.
        l_bapi_mlan-depcountry = l_mlan-aland.

        SELECT * FROM tstl
          INTO TABLE i_tstl
         WHERE talnd = l_mlan-aland
          ORDER BY PRIMARY KEY.
        l_bapi_mlan-taxclass_1 = l_mlan-taxm1.
        READ TABLE i_tstl INTO l_tstl WITH KEY lfdnr = '1'. "#EC CI_STDSEQ
        IF sy-subrc = 0.
          l_bapi_mlan-tax_type_1 = l_tstl-tatyp.
        ENDIF.
        l_bapi_mlan-taxclass_2 = l_mlan-taxm2.
        READ TABLE i_tstl INTO l_tstl WITH KEY lfdnr = '2'. "#EC CI_STDSEQ
        IF sy-subrc = 0.
          l_bapi_mlan-tax_type_2 = l_tstl-tatyp.
        ENDIF.
        APPEND l_bapi_mlan TO me->taxclassifications.
      ENDLOOP.
    ELSE.
      me->taxclassifications = taxclassifications.
    ENDIF.

    headdata-basic_view = 'V'.
  ENDMETHOD.
  METHOD add_datos_ventas.
    DATA: l_tabla        TYPE tabname,
          l_mvke         TYPE mvke,
          l_bapi_mvke_ga TYPE bapi_mvke_ga,
          l_salesdata    TYPE bapi_mvke.

* Recupero datos en BD para comporar
    l_tabla = 'MVKE'.
    SELECT SINGLE * FROM (l_tabla)            "#EC CI_ALL_FIELDS_NEEDED
      INTO l_mvke
     WHERE matnr = material
       AND vkorg = mvke-vkorg
       AND vtweg = mvke-vtweg.

    CALL FUNCTION 'MAP2E_MVKE_TO_BAPI_MVKE_GA'
      EXPORTING
        mvke         = l_mvke
      CHANGING
        bapi_mvke_ga = l_bapi_mvke_ga.

    MOVE-CORRESPONDING l_bapi_mvke_ga TO l_salesdata.

* Convierto a estructura de la BAPI
    CALL FUNCTION 'MAP2E_MVKE_TO_BAPI_MVKE_GA'
      EXPORTING
        mvke         = mvke
      CHANGING
        bapi_mvke_ga = l_bapi_mvke_ga.

    MOVE-CORRESPONDING l_bapi_mvke_ga TO salesdata.

    determina_cambios_campos( EXPORTING original     = l_salesdata
                                        modificacion = salesdata
                              CHANGING  cambios      = salesdatax ).

    salesdatax-sales_org  = salesdata-sales_org.
    salesdatax-distr_chan = salesdata-distr_chan.
    headdata-sales_view = 'X'.
  ENDMETHOD.
  METHOD add_textos_breves.
    DATA: l_makt      TYPE makt,
          l_bapi_makt TYPE bapi_makt,
          " TODO: variable is assigned but never used (ABAP cleaner)
          l_makt_bd   TYPE makt.

    LOOP AT i_makt INTO l_makt.
      CLEAR l_bapi_makt.
      l_bapi_makt-langu     = l_makt-spras.
      l_bapi_makt-matl_desc = l_makt-maktx.

      IF l_makt-maktx = ''.
        SELECT SINGLE matnr FROM makt
          INTO l_makt_bd-matnr
         WHERE matnr = material
           AND spras = l_makt-spras.
        IF sy-subrc = 0.
          l_bapi_makt-del_flag = 'X'.
        ENDIF.
      ENDIF.
      APPEND l_bapi_makt TO materialdescription.
    ENDLOOP.

    headdata-basic_view = 'X'.
  ENDMETHOD.
  METHOD add_unidades_medida.
    DATA: i_marm_bd    TYPE TABLE OF marm,
          l_marm       TYPE marm,
          l_bapi_marm  TYPE bapi_marm,
          l_bapi_marmx TYPE bapi_marmx,
          l_marm_bd    TYPE marm.

    SELECT meinh umren umrez FROM marm                      ##TOO_MANY_ITAB_FIELDS
      INTO CORRESPONDING FIELDS OF TABLE i_marm_bd
     WHERE matnr  = material
       AND meinh <> meins
     ORDER BY matnr meinh.

    LOOP AT i_marm INTO l_marm WHERE ty2tq <> 'D'.         "#EC CI_STDSEQ
      CLEAR l_bapi_marm.
      l_bapi_marm-alt_unit   = l_marm-meinh.
      l_bapi_marm-numerator  = l_marm-umrez.
      l_bapi_marm-denominatr = l_marm-umren.

      l_bapi_marm-gross_wt   = l_marm-brgew.
      l_bapi_marm-unit_of_wt = l_marm-gewei.
      l_bapi_marm-length     = l_marm-laeng.
      l_bapi_marm-width      = l_marm-breit.
      l_bapi_marm-height     = l_marm-hoehe.
      l_bapi_marm-unit_dim   = l_marm-meabm.
      APPEND l_bapi_marm TO unitsofmeasure.

      CLEAR l_bapi_marmx.
      l_bapi_marmx-alt_unit = l_marm-meinh.
      CLEAR l_marm_bd.
      READ TABLE i_marm_bd INTO l_marm_bd WITH KEY meinh = l_marm-meinh BINARY SEARCH.

      IF l_marm_bd-umrez <> l_marm-umrez.
        l_bapi_marmx-numerator = 'X'.
      ENDIF.
      IF l_marm_bd-umren <> l_marm-umren.
        l_bapi_marmx-denominatr = 'X'.
      ENDIF.
      IF l_marm_bd-brgew <> l_marm-brgew.
        l_bapi_marmx-gross_wt = 'X'.
      ENDIF.
      IF l_marm_bd-gewei <> l_marm-gewei.
        l_bapi_marmx-unit_of_wt = 'X'.
      ENDIF.
      IF l_marm_bd-laeng <> l_marm-laeng.
        l_bapi_marmx-length = 'X'.
      ENDIF.
      IF l_marm_bd-breit <> l_marm-breit.
        l_bapi_marmx-width = 'X'.
      ENDIF.
      IF l_marm_bd-hoehe <> l_marm-hoehe.
        l_bapi_marmx-height = 'X'.
      ENDIF.
      IF l_marm_bd-meabm <> l_marm-meabm.
        l_bapi_marmx-unit_dim = 'X'.
      ENDIF.
      APPEND l_bapi_marmx TO unitsofmeasurex.

    ENDLOOP.

    IF borrar = 'X'.
      LOOP AT i_marm INTO l_marm_bd WHERE ty2tq = 'D'.     "#EC CI_STDSEQ
* Como la BAPI no permite borrado, lo hacemos a pelo
        DELETE FROM marm
         WHERE matnr = material
           AND meinh = l_marm_bd-meinh.
      ENDLOOP.
    ENDIF.

    headdata-basic_view = 'X'.
  ENDMETHOD.
  METHOD conv_unidad.
    DATA l_conv TYPE t_mat_conv_ctd.

    FIELD-SYMBOLS <conv> TYPE t_mat_conv_ctd.

    IF unidad_origen = unidad_destino.
      resultado = cantidad.
    ELSE.
      ASSIGN i_mat_conv_ctd[ matnr = matnr
                             unori = unidad_origen
                             undes = unidad_destino
                             ctori = cantidad ] TO <conv>.
      IF sy-subrc = 0.
        resultado = <conv>-ctdes.
      ELSE.
        CLEAR l_conv.
        l_conv-matnr = matnr.
        l_conv-unori = unidad_origen.
        l_conv-undes = unidad_destino.
        l_conv-ctori = cantidad.
        l_conv-ctdes = convertir_unidad( matnr          = matnr
                                         unidad_origen  = unidad_origen
                                         unidad_destino = unidad_destino
                                         cantidad       = cantidad ).
        INSERT l_conv INTO TABLE i_mat_conv_ctd.

        resultado = l_conv-ctdes.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD conv_unidad_base.
    DATA l_mat TYPE t_mat.

    l_mat = get_datos_mat( matnr ).

    IF unidad_origen = l_mat-meins.
      resultado = cantidad.
    ELSE.
      resultado = conv_unidad( matnr          = matnr
                               unidad_origen  = unidad_origen
                               unidad_destino = l_mat-meins
                               cantidad       = cantidad ).
    ENDIF.
  ENDMETHOD.
  METHOD convertir_peso.
    IF unidad_origen = unidad_destino.
      resultado = cantidad.
    ELSE.
      CALL FUNCTION 'UNIT_CONVERSION_SIMPLE'
        EXPORTING
          input                = cantidad
          no_type_check        = 'X'
          round_sign           = ' '
          unit_in              = unidad_origen
          unit_out             = unidad_destino
        IMPORTING
*         ADD_CONST            = ADD_CONST
*         DECIMALS             = DECIMALS
*         DENOMINATOR          = DENOMINATOR
*         NUMERATOR            = NUMERATOR
          output               = resultado
        EXCEPTIONS
          conversion_not_found = 1
          division_by_zero     = 2
          input_invalid        = 3
          output_invalid       = 4
          overflow             = 5
          type_invalid         = 6
          units_missing        = 7
          unit_in_not_found    = 8
          unit_out_not_found   = 9.
      IF sy-subrc <> 0.
*
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD convertir_unidad.
    DATA: l_matnr TYPE matnr,
          l_menge TYPE menge_d.

    l_matnr = matnr.
    l_menge = cantidad.
    CLEAR resultado.
    CALL FUNCTION 'MD_CONVERT_MATERIAL_UNIT'
      EXPORTING
        i_matnr              = l_matnr
        i_in_me              = unidad_origen
        i_out_me             = unidad_destino
        i_menge              = l_menge
      IMPORTING
        e_menge              = resultado
      EXCEPTIONS
        error_in_application = 1
        error                = 2
        OTHERS               = 3.
    IF sy-subrc <> 0.
*
    ENDIF.
  ENDMETHOD.
  METHOD determina_cambios_campos.
    DATA l_index TYPE i.

    FIELD-SYMBOLS: <original>          TYPE any,
                   <modificacion>      TYPE any,
                   <campo_x>           TYPE any,
                   <original_comp>     TYPE any,
                   <campo_x_comp>      TYPE any,
                   <modificacion_comp> TYPE any.

    CLEAR sy-subrc.

    ASSIGN: original TO <original>,
            modificacion TO <modificacion>,
            cambios TO <campo_x>.

    WHILE sy-subrc = 0.
      ASSIGN COMPONENT sy-index OF STRUCTURE <original> TO <original_comp>.
      IF sy-subrc <> 0.
        EXIT.
      ENDIF.

      l_index = sy-index + pos_ini_cambios.

      IF modificacion IS INITIAL.
        IF NOT <original_comp> IS INITIAL.
          ASSIGN COMPONENT l_index OF STRUCTURE <campo_x> TO <campo_x_comp>.
          <campo_x_comp> = 'X'.
        ENDIF.
      ELSE.
        ASSIGN COMPONENT sy-index OF STRUCTURE <modificacion> TO <modificacion_comp>.
        ASSIGN COMPONENT l_index OF STRUCTURE <campo_x> TO <campo_x_comp>.
        IF <original_comp> <> <modificacion_comp>.
          <campo_x_comp> = 'X'.
        ENDIF.
      ENDIF.
    ENDWHILE.
  ENDMETHOD.
  METHOD edit_clasificacion.
    DATA: l_object   TYPE rmclf-objek,
          l_maktx    TYPE rmclf-obtxt,
          l_klart    TYPE inob-klart,
          l_status   TYPE c LENGTH 1,
          classtype  TYPE rmclf-klart,
          updateflag TYPE rmclk-updat,
          typetext   TYPE rmclf-artxt.

    l_object = matnr.
    l_maktx = get_descripcion( matnr ).

    SELECT klart FROM inob
      INTO l_klart
      UP TO 1 ROWS
     WHERE obtab = 'MARA'
       AND objek = matnr.
    ENDSELECT.
    IF sy-subrc <> 0.
      SELECT klart FROM kssk
        INTO l_klart
        UP TO 1 ROWS
       WHERE objek = matnr.
      ENDSELECT.
    ENDIF.

    IF visualizar IS INITIAL.
      l_status = '2'.
    ELSE.
      l_status = '3'.
    ENDIF.

    DO.
      CALL FUNCTION 'CLFM_OBJECT_CLASSIFICATION'
        EXPORTING
          table                    = 'MARA'
          ptable                   = 'MARA'
          object                   = l_object
          objtxt                   = l_maktx
          classtype                = l_klart
*         typetext                 = 'XX'
          status                   = l_status
          initflag                 = 'X'
          ref_datuv                = sy-datum                " wk/4.0a
        IMPORTING
          updateflag               = updateflag
          classtype                = classtype
          typetext                 = typetext
*         CLASS                    = KLASSE               "mk/26.04.93
*         CLASS_TEXT               = KLASSENTEXT
          ok_code                  = sy-ucomm
        EXCEPTIONS
          classification_not_found = 1
          class_not_valid          = 2.           " ch zu 3.0D

      IF sy-subrc <> 0.
*
      ENDIF.

      IF sy-ucomm <> 'WECH'.
        EXIT.
      ENDIF.
    ENDDO.
    IF sy-ucomm = 'SAVE'.
      COMMIT WORK AND WAIT.
    ENDIF.
  ENDMETHOD.
  METHOD esta_bloqueado.
    IF NOT werks IS INITIAL.
      bloqueado = zcl_ap_utils=>comprobar_bloqueo( tabla = 'MARC'
                                                   clave = sy-mandt
                                                   clave2 = matnr
                                                   clave3 = werks ).
    ENDIF.

    IF bloqueado IS INITIAL AND solo_en_centro = ''.
      bloqueado = zcl_ap_utils=>comprobar_bloqueo( tabla = 'MARA'
                                                   clave = sy-mandt
                                                   clave2 = matnr ).
    ENDIF.
  ENDMETHOD.
  METHOD esta_clasificado.
    DATA: l_klah TYPE klah,
          " TODO: variable is assigned but never used (ABAP cleaner)
          l_kssk TYPE kssk.

    SELECT clint FROM  klah
      INTO l_klah-clint
     UP TO 1 ROWS
     WHERE klart = klart
       AND class = class
      ORDER BY PRIMARY KEY.
    ENDSELECT.
    IF sy-subrc = 0.
      SELECT objek FROM kssk
        INTO l_kssk-objek
        UP TO 1 ROWS
       WHERE objek = matnr
         AND clint = l_klah-clint.
      ENDSELECT.
      IF sy-subrc = 0.
        si = 'X'.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD formato_externo.
    CALL FUNCTION 'CONVERSION_EXIT_MATN1_OUTPUT'
      EXPORTING
        input  = matnr
      IMPORTING
        output = externo.
  ENDMETHOD.
  METHOD formato_interno.
    DATA l_mat TYPE text255.

    l_mat = matnr.
    CONDENSE l_mat.
    CALL FUNCTION 'CONVERSION_EXIT_MATN1_INPUT'
      EXPORTING
        input  = l_mat
      IMPORTING
        output = interno.
  ENDMETHOD.
  METHOD get_cambios_caract.
    i_cdpos = zcl_ap_clasificacion=>get_cambios_caract( caract = caract
                                                        r_udate = r_udate ).
    LOOP AT i_cdpos ASSIGNING FIELD-SYMBOL(<cdpos>).
      SELECT SINGLE klart, objek FROM inob
        INTO (@DATA(l_klart), @DATA(l_objek))
       WHERE cuobj = @<cdpos>-objectid(18)
         AND obtab = 'MARA'.  " Sólo cambios en mara
      IF sy-subrc <> 0.
        DELETE i_cdpos.
      ELSE.
        IF NOT klart IS INITIAL AND l_klart <> klart.
          DELETE i_cdpos.
        ELSE.
          <cdpos>-objectid = l_objek.
          <cdpos>-tabname  = l_klart.
          <cdpos>-tabkey   = zcl_ap_clasificacion=>get_caract_externo( CONV #( <cdpos>-tabkey+18(10) ) ).
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_datos_gos.
    tabla = zcl_ap_gos=>urls_gos_st( tipo  = c_tipo_gos
                                     clave = matnr
                                     atta  = atta
                                     url   = url
                                     notas = notas ).
  ENDMETHOD.
  METHOD get_datos_mat.
    READ TABLE i_mat INTO datos WITH KEY matnr = matnr.
    IF sy-subrc <> 0.
      CLEAR datos.
      datos-matnr = matnr.
      datos-meins = get_unidad_base( matnr ).
      INSERT datos INTO TABLE i_mat.
    ENDIF.
  ENDMETHOD.
  METHOD get_descr.
    DATA makt TYPE makt.

    READ TABLE i_makt INTO makt WITH KEY matnr = matnr
                                         spras = spras
         BINARY SEARCH.
    IF sy-subrc <> 0.
      READ TABLE i_makt INTO makt WITH KEY matnr = matnr. "#EC CI_STDSEQ
      IF sy-subrc <> 0.
        makt-maktx = get_descripcion( matnr = matnr
                                      spras = spras ).
        IF sy-subrc = 0.
          makt-matnr = matnr.
          makt-spras = spras.
          APPEND makt TO i_makt.
          SORT i_makt.
        ENDIF.
      ENDIF.
    ENDIF.
    maktx = makt-maktx.
  ENDMETHOD.
  METHOD get_descripcion.
    CLEAR maktx.
    SELECT SINGLE maktx FROM  makt                   "#EC CI_SEL_NESTED
      INTO maktx
     WHERE matnr = matnr
       AND spras = spras.
    IF sy-subrc = 0.
      RETURN.
    ENDIF.

* Si no encuentra el texto en el idioma dado, lo devuelve en inglés, si lo hay
    IF maktx IS INITIAL.
      SELECT SINGLE maktx FROM  makt               "#EC CI_SEL_NESTED
        INTO maktx
       WHERE matnr = matnr
         AND spras = 'E'.
    ENDIF.
* Sino en español, si lo hay
    IF spras <> 'S'.
      SELECT SINGLE maktx FROM  makt               "#EC CI_SEL_NESTED
        INTO maktx
       WHERE matnr = matnr
         AND spras = 'S'.
    ENDIF.
* Si no, en lo que encuentre
    IF maktx IS INITIAL.
      SELECT maktx FROM  makt                      "#EC CI_SEL_NESTED
        INTO maktx
        UP TO 1 ROWS
       WHERE matnr = matnr.
      ENDSELECT.
    ENDIF.
  ENDMETHOD.
  METHOD get_detalle_costes.
    DATA: l_tabla     TYPE tabname,
          e_head      TYPE kkb04_head,
          t_sa_tabin  TYPE ck_strukturtab,
          t_kis1      TYPE TABLE OF kis1,
          t_xheader   TYPE kkblo_t_listheader,
          t_kisk_obj  TYPE kkb03_citem,
          t_out_items TYPE kkb04_t_items.
    DATA keko TYPE keko.

    TYPE-POOLS: kkb03, kkbg0, kkb04, ck, kkblo.

    l_tabla = 'KEKO'.
    SELECT * FROM (l_tabla)
      INTO keko
      UP TO 1 ROWS
     WHERE werks = werks
       AND matnr = matnr
     ORDER BY kadky DESCENDING.
    ENDSELECT.

    CALL FUNCTION 'K_KKB_ITEMIZATION'
      EXPORTING
        i_kdauf              = ''
        i_kadky              = keko-kadky
        i_tvers              = '01'
        i_klvar              = keko-klvar
        i_kokrs              = keko-kokrs
        i_matnr              = keko-matnr
        i_werks              = keko-werks
        i_explosion          = ''
        i_auflo              = 0
        i_sicht              = '01'
        i_maton              = ''
        i_bz_losgr           = 1
        i_keko               = keko            "#EC *
        i_kalnr              = keko-kalnr
        i_erzka_given        = ''
        i_erzka              = ''
        i_no_output          = 'X'
      IMPORTING
        e_head               = e_head
      TABLES
        t_sa_tabin           = t_sa_tabin
        t_kis1               = t_kis1
        t_xheader            = t_xheader
        t_kisk_obj           = t_kisk_obj
        t_out_items          = t_out_items
      EXCEPTIONS
        input_incomplete     = 1
        input_not_unique     = 2
        no_calculation_found = 3
        no_items_found       = 4
        wrong_input          = 5
        user_abend           = 6
        OTHERS               = 7.
  ENDMETHOD.
  METHOD get_grupo_articulos.
    CLEAR matkl.
    SELECT SINGLE matkl FROM mara
      INTO matkl
     WHERE matnr = matnr.
  ENDMETHOD.
  METHOD get_kg.
    DATA: l_meins TYPE mara-meins,
          " TODO: variable is assigned but never used (ABAP cleaner)
          l_brgew TYPE mara-brgew,
          l_ntgew TYPE mara-ntgew,
          l_gewei TYPE mara-gewei.

    IF cantidad = 0.
      RETURN.
    ENDIF.

    kilos = convertir_unidad( matnr = matnr cantidad = cantidad unidad_origen = unidad unidad_destino = 'KG' ).
    IF kilos <> 0.
      RETURN.
    ENDIF.

    SELECT SINGLE meins brgew ntgew gewei FROM mara
      INTO (l_meins, l_brgew, l_ntgew, l_gewei)
     WHERE matnr = matnr.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    kilos = convertir_unidad( matnr = matnr cantidad = cantidad unidad_origen = unidad unidad_destino = l_meins ).
    IF kilos = 0.
      RETURN.
    ENDIF.

    TRY.
        kilos = kilos * l_ntgew.
        IF l_gewei <> 'KG'.
          CALL FUNCTION 'UNIT_CONVERSION_SIMPLE'
            EXPORTING
              input    = kilos
              unit_in  = l_gewei
              unit_out = 'KG'
            IMPORTING
              output   = kilos.
        ENDIF.
      CATCH cx_root. "#EC *
        IF l_gewei <> 'KG'.
          CALL FUNCTION 'UNIT_CONVERSION_SIMPLE'
            EXPORTING
              input    = kilos
              unit_in  = l_gewei
              unit_out = 'KG'
            IMPORTING
              output   = kilos.
        ENDIF.
        TRY.
            kilos = kilos * l_ntgew.
          CATCH cx_root. "#EC *
            kilos = 999999999.
        ENDTRY.
    ENDTRY.
  ENDMETHOD.
  METHOD get_mrp.
    DATA l_matnr_bapi TYPE bapi_mrp_mat_param-material.

    l_matnr_bapi = matnr.
    CLEAR i_mrp_lines.
    CALL FUNCTION 'BAPI_MATERIAL_STOCK_REQ_LIST'
      EXPORTING
        material      = l_matnr_bapi
        plant         = werks
*       MRP_AREA      =
        plan_scenario = plscn
*       SELECTION_RULE          =
*       DISPLAY_FILTER          =
*       PERIOD_INDICATOR        =
*       GET_ITEM_DETAILS        =
*       GET_IND_LINES = 'X'
*       GET_TOTAL_LINES         =
*       IGNORE_BUFFER =
*       MATERIAL_EVG  =
*   IMPORTING
*       MRP_LIST      =
*       MRP_CONTROL_PARAM       =
*       MRP_STOCK_DETAIL        =
*       RETURN        =
      TABLES
*       MRP_ITEMS     =
        mrp_ind_lines = i_mrp_lines.
*       MRP_TOTAL_LINES         =
*       EXTENSIONOUT  =
  ENDMETHOD.
  METHOD get_peso.
    DATA l_mara TYPE mara.

    SELECT SINGLE brgew ntgew gewei meins FROM mara
      INTO CORRESPONDING FIELDS OF l_mara
     WHERE matnr = matnr.

    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    IF tipo_peso = 'B'.
      peso = l_mara-brgew.
      IF peso IS INITIAL AND cualquiera = 'X'.
        peso = l_mara-ntgew.
      ENDIF.
    ELSE.
      peso = l_mara-ntgew.
      IF peso IS INITIAL AND cualquiera = 'X'.
        peso = l_mara-brgew.
      ENDIF.
    ENDIF.

    IF NOT cantidad_origen IS INITIAL AND NOT unidad_origen IS INITIAL.
      DATA(l_ctd) = convertir_unidad( matnr          = matnr
                                      cantidad       = cantidad_origen
                                      unidad_origen  = unidad_origen
                                      unidad_destino = l_mara-meins ).
      peso = l_ctd * peso.
    ENDIF.

    IF NOT peso IS INITIAL.
      IF unidad <> l_mara-gewei.
        CALL FUNCTION 'UNIT_CONVERSION_SIMPLE'
          EXPORTING
            input    = peso
            unit_in  = l_mara-gewei
            unit_out = unidad
          IMPORTING
            output   = peso.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD get_stock.
    IF NOT charg IS INITIAL.
      cantidad = zcl_ap_lote=>get_ctd_total(
          matnr     = matnr
          charg     = charg
          libre     = libre
          bloqueado = bloqueado
          calidad   = calidad
          bestq     = bestq
          otros     = otros
          traslado  = traslado
          werks     = werks
          lgort     = lgort
          meins     = meins ).
    ELSE.
      DATA: r_werks     TYPE RANGE OF werks_d,
            r_lgort     TYPE RANGE OF lgort_d,
            l_libre     TYPE c LENGTH 1,
            l_bloqueado TYPE c LENGTH 1,
            l_calidad   TYPE c LENGTH 1,
            l_traslado  TYPE c LENGTH 1,
            l_otros     TYPE c LENGTH 1,
            lr_werks    LIKE LINE OF r_werks,
            lr_lgort    LIKE LINE OF r_lgort,
            l_mard      TYPE mard.

      IF bestq = '*'.
        l_libre = libre.
        l_bloqueado = bloqueado.
        l_calidad = calidad.
        l_traslado = traslado.
        l_otros = otros.
      ELSEIF bestq = ''.
        l_libre = 'X'.
      ELSEIF bestq = 'S'.
        l_bloqueado = 'X'.
      ELSEIF bestq = 'Q'.
        l_calidad = 'X'.
      ENDIF.

      IF NOT werks IS INITIAL.
        CLEAR lr_werks.
        lr_werks-option = 'EQ'.
        lr_werks-sign   = 'I'.
        lr_werks-low    = werks.
        APPEND lr_werks TO r_werks.
      ENDIF.

      IF NOT lgort IS INITIAL.
        CLEAR lr_lgort.
        lr_lgort-option = 'EQ'.
        lr_lgort-sign   = 'I'.
        lr_lgort-low    = lgort.
        APPEND lr_lgort TO r_lgort.
      ENDIF.

      IF NOT vbeln IS INITIAL AND NOT sobkz IS INITIAL.
        SELECT SUM( kalab ) SUM( kains ) SUM( kaspe ) FROM mska
          INTO (l_mard-labst, l_mard-insme, l_mard-speme)
         WHERE matnr  = matnr
           AND vbeln  = vbeln
           AND sobkz  = sobkz
           AND werks IN r_werks
           AND lgort IN r_lgort.
      ELSE.
        SELECT SUM( labst ) SUM( umlme ) SUM( insme ) SUM( einme ) SUM( speme ) SUM( retme ) FROM mard
          INTO (l_mard-labst, l_mard-umlme, l_mard-insme, l_mard-einme, l_mard-speme, l_mard-retme)
         WHERE matnr  = matnr
           AND werks IN r_werks
           AND lgort IN r_lgort.
      ENDIF.

      IF l_libre = 'X'.
        cantidad = cantidad + l_mard-labst.
      ENDIF.
      IF l_calidad = 'X'.
        cantidad = cantidad + l_mard-insme.
      ENDIF.
      IF l_bloqueado = 'X'.
        cantidad = cantidad + l_mard-speme.
      ENDIF.
      IF l_traslado = 'X'.
        cantidad = cantidad + l_mard-umlme.
      ENDIF.
      IF l_otros = 'X'.
        cantidad = cantidad + l_mard-einme + l_mard-retme.
      ENDIF.

      IF NOT meins IS INITIAL AND cantidad <> 0.
        DATA(l_umb) = zcl_ap_material=>get_unidad_base( matnr ).
        IF l_umb <> meins.
          cantidad = zcl_ap_material=>convertir_unidad( matnr = matnr cantidad = cantidad unidad_origen = l_umb unidad_destino = meins ).
        ENDIF.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD get_stock_a_fecha.
** PARA QUE ESTO FUNCIONE, CREAR ENHANCEMENT EN PROGRAMA RM07MLBD
*FORM feldgruppen_aufbauen.
*"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""$"$\SE:(1) Forma FELDGRUPPEN_AUFBAUEN, Inicio                                                                                                                A
**$*$-Start: (1)---------------------------------------------------------------------------------$*$*
*ENHANCEMENT 1  ZTOCK_A_FECHA.    "active version
*data l_origen(40).
*
* GET PARAMETER ID 'ZPG' FIELD l_origen.
* if l_origen = 'ZTOCK_A_FECHA'.
*   SET PARAMETER ID 'ZPG' FIELD ''.
*   EXPORT bestand to MEMORY id 'ZTOCK_A_FECHA'.
*   leave PROGRAM.
* ENDIF.
*
*ENDENHANCEMENT.

    TYPES: BEGIN OF t_bestand,
             bwkey         TYPE mbew-bwkey,
             werks         TYPE mseg-werks,
             matnr         TYPE mseg-matnr,
             charg         TYPE mseg-charg,
             endmenge(09)  TYPE p          DECIMALS 3, " Bestand zu 'datum-high' XJD
             anfmenge(09)  TYPE p          DECIMALS 3, " Bestand zu 'datum-low'   XJD
             meins         TYPE mara-meins,            " Mengeneinheit
             endwert(09)   TYPE p          DECIMALS 2, " n497992
             anfwert(09)   TYPE p          DECIMALS 2, " n497992
             soll(09)      TYPE p          DECIMALS 3, " XJD
             haben(09)     TYPE p          DECIMALS 3, " XJD
             sollwert(09)  TYPE p          DECIMALS 2, " n497992
             habenwert(09) TYPE p          DECIMALS 2, " n497992
             waers         TYPE t001-waers,            " Währungsschlüssel
           END OF t_bestand.

    DATA: rr_matnr TYPE range_t_matnr,
          lr_matnr TYPE range_s_matnr,
          bestand  TYPE TABLE OF t_bestand,
          l_stocks TYPE mchb.
    DATA i_stock_inv TYPE tt_mb5b.

    FIELD-SYMBOLS <bestand> TYPE t_bestand.

    __def_rangoc budat.

    CLEAR i_stocks.

    CLEAR lr_budat.
    lr_budat-option = 'BT'.
    lr_budat-sign   = 'I'.
    lr_budat-low    = fecha.
    lr_budat-high   = fecha.
    APPEND lr_budat TO r_budat.

    rr_matnr = r_matnr.
    IF NOT matnr IS INITIAL.
      CLEAR lr_matnr.
      lr_matnr-option = 'EQ'.
      lr_matnr-sign   = 'I'.
      lr_matnr-low    = matnr.
      APPEND lr_matnr TO rr_matnr.
    ENDIF.

    IF NOT r_werks IS INITIAL.
      DATA(rr_werks) = r_werks.
    ELSEIF NOT werks IS INITIAL.
      rr_werks = VALUE #( ( option = 'EQ' sign = 'I' low = werks ) ).
    ENDIF.

    IF NOT r_lgort IS INITIAL.
      DATA(rr_lgort) = r_lgort.
    ELSEIF NOT lgort IS INITIAL.
      rr_lgort = VALUE #( ( option = 'EQ' sign = 'I' low = lgort ) ).
    ENDIF.

    FREE MEMORY ID 'ZTOCK_A_FECHA'.
    SET PARAMETER ID 'ZPG' FIELD 'ZTOCK_A_FECHA' ##EXISTS.

    SUBMIT rm07mlbd                                        "#EC CI_SUBMIT
       AND RETURN
           VIA SELECTION-SCREEN
           WITH werks IN rr_werks
           WITH matnr IN rr_matnr
           WITH lgort IN rr_lgort
           WITH datum IN r_budat
           WITH lgbst = 'X'
           WITH bwbst = ''
           WITH sbbst = ''
           WITH xsum  = ''
           WITH pa_sumfl = 'X'
           WITH xchar = solo_mat_suj_lotes " Sólo materiales sujetos a lote
           WITH pa_wdzer = 'X'
           WITH pa_wdzew = 'X'
           WITH pa_wdwiz = 'X'
           WITH pa_wdwuw = 'X'
           WITH pa_wdwew = 'X'
           WITH pa_ndzer = 'X'
           WITH pa_ndsto = 'X'.

    CLEAR bestand.
    IMPORT bestand TO bestand FROM MEMORY ID 'ZTOCK_A_FECHA'.
    IF sy-subrc <> 0.
      IMPORT i_stock_inv TO i_stock_inv FROM MEMORY ID 'ZTOCK_A_FECHA'.
      MOVE-CORRESPONDING i_stock_inv TO bestand.
    ENDIF.
    FREE MEMORY ID 'ZTOCK_A_FECHA'.

    LOOP AT bestand ASSIGNING <bestand>.
      CLEAR l_stocks.
      MOVE-CORRESPONDING <bestand> TO l_stocks.
      l_stocks-werks = werks.
      l_stocks-lgort = lgort.
      l_stocks-laeda = fecha.
      l_stocks-clabs = <bestand>-endmenge.
      APPEND l_stocks TO i_stocks.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_texto.
    lineas = zcl_ap_textos=>get_texto( id = id object = 'MATERIAL' name = matnr spras = spras ).
  ENDMETHOD.
  METHOD get_texto_string.
    DATA: l_name   TYPE stxh-tdname,
          l_object TYPE stxh-tdobject.

    IF vtweg IS INITIAL.
      l_name = matnr.
      l_object = 'MATERIAL'.
    ELSE.
      l_name(18) = matnr.
      l_name+18(4) = vkorg.
      l_name+22(2) = vtweg.
      l_object = 'MVKE'.
    ENDIF.

    string = zcl_ap_textos=>get_texto_string( id = id object = l_object name = l_name spras = spras ).
  ENDMETHOD.
  METHOD get_unidad.
    DATA l_mat_meins TYPE mat_meins_s.

    READ TABLE i_mat_meins INTO l_mat_meins WITH KEY matnr = matnr
         BINARY SEARCH.
    IF sy-subrc <> 0.
      SELECT SINGLE matnr meins FROM mara
        INTO (l_mat_meins-matnr, l_mat_meins-meins)
       WHERE matnr = matnr.
      IF sy-subrc = 0.
        APPEND l_mat_meins TO i_mat_meins.
        SORT i_mat_meins.
      ENDIF.
    ENDIF.
    meins = l_mat_meins-meins.
  ENDMETHOD.
  METHOD get_unidad_base.
    CLEAR meins.
    SELECT SINGLE meins FROM  mara
      INTO meins
     WHERE matnr = matnr.
  ENDMETHOD.
  METHOD get_valor.
    DATA: l_mbew  TYPE mbew,
          l_valor TYPE p LENGTH 8 DECIMALS 5,
          l_campo TYPE char40,
          l_meins TYPE meins,
          l_conv  TYPE p LENGTH 8 DECIMALS 5.

    FIELD-SYMBOLS <fs> TYPE any.

    SELECT peinh stprs verpr vprsv FROM mbew
      INTO CORRESPONDING FIELDS OF l_mbew
      UP TO 1 ROWS
     WHERE matnr = matnr
       AND bwkey = werks
     ORDER BY PRIMARY KEY.
    ENDSELECT.
    IF sy-subrc = 0.
      IF l_mbew-peinh <> 0.
        IF campo IS INITIAL.
          IF l_mbew-vprsv = 'V'.
            l_valor = l_mbew-verpr / l_mbew-peinh.
          ELSE.
            l_valor = l_mbew-stprs / l_mbew-peinh.
          ENDIF.
        ELSE.
          CONCATENATE 'L_MBEW-' campo INTO l_campo.
          ASSIGN (l_campo) TO <fs>.
          IF sy-subrc = 0.
            l_valor = <fs> / l_mbew-peinh.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    IF cantidad <> 0.
      l_valor = l_valor * cantidad.

      IF NOT meins IS INITIAL.
        SELECT SINGLE meins FROM mara
          INTO l_meins
         WHERE matnr = matnr.
        IF l_meins <> meins.
          l_conv = convertir_unidad( matnr = matnr cantidad = 1000 unidad_origen = meins unidad_destino = l_meins ).
          IF l_conv <> 0.
            l_valor = l_valor * l_conv / 1000.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    valor = l_valor.
  ENDMETHOD.
  METHOD get_valor_clas.
    DATA: l_cuobj TYPE inob-cuobj,
          l_objek TYPE ausp-objek,
          l_atinn TYPE atinn.

    SELECT cuobj FROM inob
      INTO l_cuobj
      UP TO 1 ROWS
     WHERE klart = klart
       AND obtab = 'MARA'
       AND objek = matnr.
    ENDSELECT.
    IF sy-subrc = 0.
      l_objek = l_cuobj.
    ELSE.
      SELECT objek FROM ausp
        INTO l_objek
        UP TO 1 ROWS
     WHERE objek = matnr
       AND mafid = 'O'
       AND klart = klart.
      ENDSELECT.
    ENDIF.

    IF NOT l_objek IS INITIAL.
      IF NOT atinn IS INITIAL.
        l_atinn = atinn.
      ELSE.
        l_atinn = zcl_ap_clasificacion=>get_caract_interno( caract ).
      ENDIF.

      SELECT * FROM ausp
        INTO ausp
        UP TO 1 ROWS
       WHERE objek = l_objek
         AND atinn = l_atinn
         AND mafid = 'O'
         AND klart = klart.
      ENDSELECT.
    ENDIF.
  ENDMETHOD.
  METHOD get_valor_clas_c.
    DATA l_ausp TYPE ausp.

    l_ausp = get_valor_clas( matnr = matnr klart = klart caract = caract atinn = atinn ).

    IF descripcion IS INITIAL.
      atwrt = l_ausp-atwrt.
    ELSE.
      atwrt = zcl_ap_clasificacion=>get_valor_caract_text( caract = caract caract_int = atinn  valor = l_ausp-atwrt spras = spras ).
      IF atwrt IS INITIAL.
        atwrt = l_ausp-atwrt.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD get_valor_clas_p.
    DATA l_ausp TYPE ausp.

    l_ausp = get_valor_clas( matnr = matnr klart = klart caract = caract atinn = atinn ).

    atflv = l_ausp-atflv.
  ENDMETHOD.
  METHOD ini_update.
    CLEAR: return, headdata, clientdata, materialdescription, new_mara, salesdata, salesdatax, taxclassifications,
           warehousenumberdata, warehousenumberdatax,
           storagetypedata, storagetypedatax.

    material = matnr.
    headdata-material = material.
  ENDMETHOD.
  METHOD insertar_log_modificaciones.
    DATA upd_mara        TYPE cdpos-chngind.
    DATA upd_marc        TYPE cdpos-chngind.
    DATA objectid        TYPE cdhdr-objectid.
    DATA utime           TYPE cdhdr-utime.
    DATA udate           TYPE cdhdr-udate.
    DATA username        TYPE cdhdr-username.
    DATA n_mare          TYPE mare.
    DATA o_mare          TYPE mare.
    DATA n_mard          TYPE mard.
    DATA o_mard          TYPE mard.
    DATA n_mbew          TYPE mbew.
    DATA o_mbew          TYPE mbew.
    DATA n_mfhm          TYPE mfhm.
    DATA o_mfhm          TYPE mfhm.
    DATA n_mlgn          TYPE mlgn.
    DATA o_mlgn          TYPE mlgn.
    DATA n_mlgt          TYPE mlgt.
    DATA o_mlgt          TYPE mlgt.
    DATA n_mpgd          TYPE mpgd.
    DATA o_mpgd          TYPE mpgd.
    DATA n_mpop          TYPE mpop.
    DATA o_mpop          TYPE mpop.
    DATA n_mvke          TYPE mvke.
    DATA o_mvke          TYPE mvke.
    DATA icdtxt_material TYPE STANDARD TABLE OF cdtxt.
    DATA xdgesv          TYPE STANDARD TABLE OF xdgesv.
    DATA ydgesv          TYPE STANDARD TABLE OF xdgesv.
    DATA xdmaex          TYPE STANDARD TABLE OF xdmaex.
    DATA ydmaex          TYPE STANDARD TABLE OF xdmaex.
    DATA xdmakt          TYPE STANDARD TABLE OF xdmakt.
    DATA ydmakt          TYPE STANDARD TABLE OF xdmakt.
    DATA xdmape          TYPE STANDARD TABLE OF xdmape.
    DATA ydmape          TYPE STANDARD TABLE OF xdmape.
    DATA xdmarm          TYPE STANDARD TABLE OF xdmarm.
    DATA ydmarm          TYPE STANDARD TABLE OF xdmarm.
    DATA xdmean          TYPE STANDARD TABLE OF xdmean.
    DATA ydmean          TYPE STANDARD TABLE OF xdmean.
    DATA xdmkal          TYPE STANDARD TABLE OF xdmkal.
    DATA ydmkal          TYPE STANDARD TABLE OF xdmkal.
    DATA xdmlan          TYPE STANDARD TABLE OF xdmlan.
    DATA ydmlan          TYPE STANDARD TABLE OF xdmlan.
    DATA xdprow          TYPE STANDARD TABLE OF xdprow.
    DATA ydprow          TYPE STANDARD TABLE OF xdprow.
    DATA xdqmat          TYPE STANDARD TABLE OF xdqmat.
    DATA ydqmat          TYPE STANDARD TABLE OF xdqmat.
    DATA xdungv          TYPE STANDARD TABLE OF xdungv.
    DATA ydungv          TYPE STANDARD TABLE OF xdungv.

    IF NOT mara_new IS INITIAL.
      IF mara_old IS INITIAL.
        upd_mara = 'I'.
      ELSE.
        upd_mara = 'U'.
      ENDIF.
    ENDIF.

    IF NOT marc_new IS INITIAL.
      IF marc_old IS INITIAL.
        upd_marc = 'I'.
      ELSE.
        upd_marc = 'U'.
      ENDIF.
    ENDIF.

    objectid = matnr.
    CALL FUNCTION 'MATERIAL_WRITE_DOCUMENT'
      EXPORTING
        objectid        = objectid
        tcode           = tcode
        utime           = sy-uzeit
        udate           = sy-datum
        username        = sy-uname
*       PLANNED_CHANGE_NUMBER         = ' '
*       OBJECT_CHANGE_INDICATOR       = 'U'
*       PLANNED_OR_REAL_CHANGES       = ' '
*       NO_CHANGE_POINTERS            = ' '
*       UPD_ICDTXT_MATERIAL           = ' '
*       UPD_DGESV       = ' '
*       UPD_DMAEX       = ' '
*       UPD_DMAKT       = ' '
*       UPD_DMAPE       = ' '
*       UPD_DMARM       = ' '
*       UPD_DMEAN       = ' '
*       UPD_DMKAL       = ' '
*       UPD_DMLAN       = ' '
*       UPD_DPROW       = ' '
*       UPD_DQMAT       = ' '
*       UPD_DUNGV       = ' '
        n_mara          = mara_new
        o_mara          = mara_old
        upd_mara        = upd_mara
        n_marc          = marc_new
        o_marc          = marc_old
        n_mare          = n_mare
        o_mare          = o_mare
        upd_marc        = upd_marc
        n_mard          = n_mard
        o_mard          = o_mard
*       UPD_MARD        = ' '
        n_mbew          = n_mbew
        o_mbew          = o_mbew
*       UPD_MBEW        = ' '
        n_mfhm          = n_mfhm
        o_mfhm          = o_mfhm
*       UPD_MFHM        = ' '
        n_mlgn          = n_mlgn
        o_mlgn          = o_mlgn
*       UPD_MLGN        = ' '
        n_mlgt          = n_mlgt
        o_mlgt          = o_mlgt
*       UPD_MLGT        = ' '
        n_mpgd          = n_mpgd
        o_mpgd          = o_mpgd
*       UPD_MPGD        = ' '
        n_mpop          = n_mpop
        o_mpop          = o_mpop
*       UPD_MPOP        = ' '
        n_mvke          = n_mvke
        o_mvke          = o_mvke
*       UPD_MVKE        = ' '
      TABLES
        icdtxt_material = icdtxt_material
        xdgesv          = xdgesv
        ydgesv          = ydgesv
        xdmaex          = xdmaex
        ydmaex          = ydmaex
        xdmakt          = xdmakt
        ydmakt          = ydmakt
        xdmape          = xdmape
        ydmape          = ydmape
        xdmarm          = xdmarm
        ydmarm          = ydmarm
        xdmean          = xdmean
        ydmean          = ydmean
        xdmkal          = xdmkal
        ydmkal          = ydmkal
        xdmlan          = xdmlan
        ydmlan          = ydmlan
        xdprow          = xdprow
        ydprow          = ydprow
        xdqmat          = xdqmat
        ydqmat          = ydqmat
        xdungv          = xdungv
        ydungv          = ydungv.
  ENDMETHOD.
  METHOD set_texto_string.
    DATA: l_name   TYPE stxh-tdname,
          l_object TYPE stxh-tdobject.

    IF vtweg IS INITIAL.
      l_name = matnr.
      l_object = 'MATERIAL'.
    ELSE.
      l_name(18) = matnr.
      l_name+18(4) = vkorg.
      l_name+22(2) = vtweg.
      l_object = 'MVKE'.
    ENDIF.

    IF string IS INITIAL.
      zcl_ap_textos=>borrar_texto( id = id
                                   object = l_object
                                   name = l_name
                                   spras = spras ).
    ELSE.
      zcl_ap_textos=>save_texto_string( id = id
                                        object = l_object
                                        name = l_name
                                        spras = spras
                                        string = string
                                        longitud   = longitud
                                        word_wrap  = word_wrap
                                        delimiter  = delimiter
                                        savemode_direct = savemode_direct
                                        insert = insert ).
    ENDIF.
  ENDMETHOD.
  METHOD upd_clase_inspeccion.
    DATA: qmat             TYPE qmat,
          tq34             TYPE tq34,
          i_return         TYPE STANDARD TABLE OF bapiret2,
          i_inspectionctrl TYPE STANDARD TABLE OF bapi1001004_qmat,
          return           TYPE bapiret2,
          inspectionctrl   TYPE bapi1001004_qmat.

    SELECT SINGLE * FROM qmat
      INTO qmat
     WHERE matnr = matnr
       AND werks = werks
       AND art   = art.
    IF sy-subrc <> 0.
      SELECT SINGLE * FROM tq34
        INTO tq34
       WHERE art = art.
      IF sy-subrc <> 0.
        __concat2 message 'No existe la clase de inspección'(nec) art.
        RETURN.
      ELSE.
        MOVE-CORRESPONDING tq34 TO qmat.
      ENDIF.
    ENDIF.

    CLEAR: i_return, i_inspectionctrl, return, inspectionctrl.

    IF    ( activo     <> '?' AND qmat-aktiv      <> activo )
       OR ( stichprver <> '?' AND qmat-stichprver <> stichprver ).
      CLEAR inspectionctrl.
      inspectionctrl-insptype             = art.
      inspectionctrl-material             = matnr.
      inspectionctrl-plant                = werks.
      inspectionctrl-qual_score_procedure = qmat-qkzverf.
      inspectionctrl-sampling_procedure   = qmat-stichprver.
      IF stichprver <> '?'.
        inspectionctrl-sampling_procedure = stichprver.
      ENDIF.
      inspectionctrl-ind_skips_allowed      = qmat-dyn.
      inspectionctrl-ind_manual_sample      = qmat-mpb.
      inspectionctrl-ind_manual_sample_calc = qmat-mst.
      inspectionctrl-ind_insp_with_tsk_list = qmat-ppl.
      inspectionctrl-ind_auto_assign        = qmat-app.
      inspectionctrl-ind_insp_by_charac     = qmat-mer.
      inspectionctrl-ind_post_to_insp_stock = qmat-insmk.
      inspectionctrl-ind_automatic_ud       = qmat-ave.
      IF activo <> '?'.
        inspectionctrl-ind_insptype_mat_active = activo.
      ENDIF.
      APPEND inspectionctrl TO i_inspectionctrl.
    ENDIF.

    IF NOT art2 IS INITIAL.
      SELECT SINGLE * FROM qmat
        INTO qmat
       WHERE matnr = matnr
         AND werks = werks
         AND art   = art2.
      IF sy-subrc <> 0.
        SELECT SINGLE * FROM tq34
          INTO tq34
         WHERE art = art2.
        IF sy-subrc <> 0.
          __concat2 message 'No existe la clase de inspección'(nec) art2.
          RETURN.
        ELSE.
          MOVE-CORRESPONDING tq34 TO qmat.
        ENDIF.
      ENDIF.

      IF    ( activo2     <> '?' AND qmat-aktiv      <> activo2 )
         OR ( stichprver2 <> '?' AND qmat-stichprver <> stichprver2 ).
        CLEAR inspectionctrl.
        inspectionctrl-insptype             = art2.
        inspectionctrl-material             = matnr.
        inspectionctrl-plant                = werks.
        inspectionctrl-qual_score_procedure = qmat-qkzverf.
        inspectionctrl-sampling_procedure   = qmat-stichprver.
        IF stichprver2 <> '?'.
          inspectionctrl-sampling_procedure = stichprver2.
        ENDIF.
        inspectionctrl-ind_skips_allowed      = qmat-dyn.
        inspectionctrl-ind_manual_sample      = qmat-mpb.
        inspectionctrl-ind_manual_sample_calc = qmat-mst.
        inspectionctrl-ind_insp_with_tsk_list = qmat-ppl.
        inspectionctrl-ind_auto_assign        = qmat-app.
        inspectionctrl-ind_insp_by_charac     = qmat-mer.
        inspectionctrl-ind_post_to_insp_stock = qmat-insmk.
        inspectionctrl-ind_automatic_ud       = qmat-ave.
        IF activo2 <> '?'.
          inspectionctrl-ind_insptype_mat_active = activo2.
        ENDIF.
        APPEND inspectionctrl TO i_inspectionctrl.
      ENDIF.
    ENDIF.

    IF i_inspectionctrl IS INITIAL.
      RETURN.
    ENDIF.

    DO segundos_espera_si_bloqueos TIMES.
      IF esta_bloqueado( matnr = matnr werks = werks ) = 'X'.
        MESSAGE s398(00) WITH 'Esperando por bloqueos en material'(ebm) matnr werks ''.
        WAIT UP TO 1 SECONDS.
      ELSE.
        CALL FUNCTION 'BAPI_MATINSPCTRL_SAVEREPLICA'
          TABLES
            return         = i_return
            inspectionctrl = i_inspectionctrl.

        LOOP AT i_return INTO return WHERE type = 'E'.   "#EC CI_STDSEQ
          __add_lista message return-message.
        ENDLOOP.
        IF sy-subrc <> 0.
          IF commit = 'X'.
            CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
              EXPORTING
                wait = 'X'.

            CALL FUNCTION 'DEQUEUE_ALL'.

          ENDIF.
        ENDIF.

        EXIT.
      ENDIF.
    ENDDO.
  ENDMETHOD.
  METHOD update.
    CALL FUNCTION 'BAPI_MATERIAL_SAVEDATA'
      EXPORTING
        headdata             = headdata
        clientdata           = clientdata
        clientdatax          = clientdatax
        plantdata            = plantdata
        plantdatax           = plantdatax
*     FORECASTPARAMETERS   =
*     FORECASTPARAMETERSX  =
*     PLANNINGDATA         =
*     PLANNINGDATAX        =
        storagelocationdata  = storagelocationdata
        storagelocationdatax = storagelocationdatax
        valuationdata        = valuationdata
        valuationdatax       = valuationdatax
        warehousenumberdata  = warehousenumberdata
        warehousenumberdatax = warehousenumberdatax
        salesdata            = salesdata
        salesdatax           = salesdatax
        storagetypedata      = storagetypedata
        storagetypedatax     = storagetypedatax
*     FLAG_ONLINE          = ' '
*     FLAG_CAD_CALL        = ' '
*     NO_DEQUEUE           = ' '
*     NO_ROLLBACK_WORK     = ' '
      IMPORTING
        return               = return
      TABLES
        materialdescription  = materialdescription
        unitsofmeasure       = unitsofmeasure
        unitsofmeasurex      = unitsofmeasurex
*     INTERNATIONALARTNOS  =
*     MATERIALLONGTEXT     =
        taxclassifications   = taxclassifications
        returnmessages       = messages.
*     PRTDATA              =
*     PRTDATAX             =
*     EXTENSIONIN          =
*     EXTENSIONINX         =

    CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'
      EXPORTING
        wait = 'X'.

    CALL FUNCTION 'DEQUEUE_ALL'.
  ENDMETHOD.
  METHOD ver_stocks.
    DATA: r_werks TYPE RANGE OF werks_d,
          r_lgort TYPE RANGE OF lgort_d,
          r_charg TYPE RANGE OF charg_d,
          r_lotes TYPE RANGE OF string,
          l_werks LIKE LINE OF r_werks,
          l_lgort LIKE LINE OF r_lgort,
          l_charg LIKE LINE OF r_charg,
          l_lotes LIKE LINE OF r_lotes.

    r_werks = s_werks.
    IF NOT werks IS INITIAL.
      l_werks-option = 'EQ'.
      l_werks-sign   = 'I'.
      l_werks-low    = werks.
      APPEND l_werks TO r_werks.
    ENDIF.

    r_lgort = s_lgort.
    IF NOT lgort IS INITIAL.
      l_lgort-option = 'EQ'.
      l_lgort-sign   = 'I'.
      l_lgort-low    = lgort.
      APPEND l_lgort TO r_lgort.
    ENDIF.

    IF NOT charg IS INITIAL.
      l_charg-option = 'EQ'.
      l_charg-sign   = 'I'.
      l_charg-low    = charg.
      APPEND l_charg TO r_charg.
    ENDIF.

    IF NOT lotes IS INITIAL.
      r_lotes = zcl_ap_string=>lista2rango( lotes ).

      LOOP AT r_lotes INTO l_lotes.
        MOVE-CORRESPONDING l_lotes TO l_charg.
        APPEND l_charg TO r_charg.
      ENDLOOP.
    ENDIF.

    SUBMIT rmmmbestn                                     "#EC CI_SUBMIT
       AND RETURN
           WITH ms_matnr = matnr
           WITH ms_werks IN r_werks
           WITH ms_lgort IN r_lgort
           WITH ms_charg IN r_charg
           WITH kzlon = kzlon "'  "Leer stocks abiertos
           WITH kzlso = kzlso. "''. "Leer stocks especiales
  ENDMETHOD.
  METHOD visualizar.
    DATA o_bi TYPE REF TO zcl_ap_batch_input.
    DATA: i_bdcmm     TYPE TABLE OF bdcdata,
          l_contvista TYPE i,
          l_bdcdata   TYPE bdcdata.
    " TODO: variable is assigned but never used (ABAP cleaner)
    DATA l_mensaje TYPE bapireturn1-message.

    o_bi = NEW #( ).

* Acceso: Nº de material, clase de material, ramo etc.
    o_bi->dynpro( program = 'SAPLMGMM' dynpro = '0060' ).
    o_bi->campos( campo = 'BDC_OKCODE' valor = '=AUSW' ).
    o_bi->campos( campo = 'RMMG1-MATNR' valor = matnr ). " Número de material

    FREE i_bdcmm.
    CALL FUNCTION 'MATERIAL_BTCI_SELECTION_NEW'
      EXPORTING
        material                  = matnr
        selection                 = vistas
        tcode                     = 'MM03'
      TABLES
        btci_d0070                = i_bdcmm
      EXCEPTIONS
        material_not_found        = 1
        material_number_missing   = 2
        material_type_missing     = 3
        material_type_not_found   = 4
        no_active_dynpro_selected = 5
        no_authority              = 6
        OTHERS                    = 7.
    IF sy-subrc <> 0.
*
    ENDIF.

    CLEAR l_contvista.
    LOOP AT i_bdcmm INTO l_bdcdata.
      IF sy-tabix > 17.
        DELETE i_bdcmm.
      ELSE.
        IF NOT nvista IS INITIAL.
          IF l_bdcdata-fval = 'X'.
            l_contvista = l_contvista + 1.
          ENDIF.
          IF l_contvista <> nvista.
            CLEAR l_bdcdata-fval.
            MODIFY i_bdcmm FROM l_bdcdata.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.

    o_bi->append_bdcdata( i_bdcmm ).

    IF    NOT werks IS INITIAL
       OR NOT lgort IS INITIAL
       OR NOT lgnum IS INITIAL
       OR NOT lgtyp IS INITIAL.
      o_bi->dynpro( program = 'SAPLMGMM' dynpro = '0080' ).
      IF NOT werks IS INITIAL.
        o_bi->campos( campo = 'RMMG1-WERKS' valor = werks ). " Centro
      ENDIF.
      IF NOT lgort IS INITIAL.
        o_bi->campos( campo = 'RMMG1-LGORT' valor = lgort ). " Almacén
      ENDIF.
      IF NOT lgnum IS INITIAL.
        o_bi->campos( campo = 'RMMG1-LGNUM' valor = lgnum ). " NºAlmacén
      ENDIF.
      IF NOT lgtyp IS INITIAL.
        o_bi->campos( campo = 'RMMG1-LGTYP' valor = lgtyp ). " Tipo Almacén
      ENDIF.
      IF NOT vkorg IS INITIAL.
        o_bi->campos( campo = 'RMMG1-VKORG' valor = vkorg ).
      ENDIF.
      IF NOT vtweg IS INITIAL.
        o_bi->campos( campo = 'RMMG1-VTWEG' valor = vtweg ).
      ENDIF.
    ENDIF.

    IF modificar IS INITIAL.
      l_mensaje = o_bi->llamar_transaccion( tcode = 'MM03'
                          modo = 'E' ).
    ELSE.
      l_mensaje = o_bi->llamar_transaccion( tcode = 'MM02'
                          modo = 'E' ).
    ENDIF.
  ENDMETHOD.

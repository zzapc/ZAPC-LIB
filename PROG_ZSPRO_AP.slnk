<?xml version="1.0" encoding="utf-8"?>
<PROG NAME="ZSPRO_AP" VARCL="X" SUBC="1" RSTAT="K" RMAND="100" RLOAD="E" FIXPT="X" UCCHECK="X">
 <textPool>
  <language SPRAS="E">
   <textElement ID="I" KEY="001" ENTRY="Data depend on mandant :" LENGTH="40 "/>
   <textElement ID="I" KEY="002" ENTRY="Yes" LENGTH="5 "/>
   <textElement ID="I" KEY="003" ENTRY="No" LENGTH="5 "/>
   <textElement ID="I" KEY="004" ENTRY="NO MAINTENANCE VIEW FOR THIS TABLE" LENGTH="50 "/>
   <textElement ID="I" KEY="005" ENTRY="Associated text table :" LENGTH="50 "/>
   <textElement ID="I" KEY="C01" ENTRY="Create folder" LENGTH="40 "/>
   <textElement ID="I" KEY="C02" ENTRY="Add entry" LENGTH="40 "/>
   <textElement ID="I" KEY="C03" ENTRY="Add entries in mass" LENGTH="40 "/>
   <textElement ID="I" KEY="C04" ENTRY="Where-used List" LENGTH="40 "/>
   <textElement ID="I" KEY="C05" ENTRY="Rename this entry" LENGTH="40 "/>
   <textElement ID="I" KEY="C06" ENTRY="Delete this entry" LENGTH="40 "/>
   <textElement ID="I" KEY="C07" ENTRY="Up in current folder" LENGTH="40 "/>
   <textElement ID="I" KEY="C08" ENTRY="Down in current folder" LENGTH="40 "/>
   <textElement ID="I" KEY="C09" ENTRY="Edit help" LENGTH="40 "/>
   <textElement ID="I" KEY="C10" ENTRY="View content" LENGTH="40 "/>
   <textElement ID="I" KEY="C11" ENTRY="Display code" LENGTH="40 "/>
   <textElement ID="I" KEY="C12" ENTRY="Display table definition" LENGTH="40 "/>
   <textElement ID="I" KEY="C13" ENTRY="Open file in modification (THOT)" LENGTH="40 "/>
   <textElement ID="I" KEY="C14" ENTRY="Display property/folder in THOT" LENGTH="40 "/>
   <textElement ID="I" KEY="C15" ENTRY="Display class" LENGTH="40 "/>
   <textElement ID="I" KEY="C16" ENTRY="Class name" LENGTH="30 "/>
   <textElement ID="I" KEY="C17" ENTRY="Display text table definition" LENGTH="40 "/>
   <textElement ID="I" KEY="M01" ENTRY="Target must be a folder" LENGTH="50 "/>
   <textElement ID="I" KEY="M02" ENTRY="Exit from specific customizing" LENGTH="50 "/>
   <textElement ID="I" KEY="M04" ENTRY="You must first save the data" LENGTH="50 "/>
   <textElement ID="I" KEY="M05" ENTRY="Saving not necessary. No changes were made" LENGTH="50 "/>
   <textElement ID="I" KEY="M06" ENTRY="Data saved successfully" LENGTH="50 "/>
   <textElement ID="I" KEY="M09" ENTRY="Tree successfully included in transport request" LENGTH="50 "/>
   <textElement ID="I" KEY="M10" ENTRY="The search has not produced any hits" LENGTH="50 "/>
   <textElement ID="I" KEY="M11" ENTRY="No further hits were found" LENGTH="50 "/>
   <textElement ID="I" KEY="M12" ENTRY="No entries for these selection criteria" LENGTH="50 "/>
   <textElement ID="I" KEY="M13" ENTRY="Tree control no longer exists" LENGTH="50 "/>
   <textElement ID="I" KEY="M14" ENTRY="Error calling a method of the tree control" LENGTH="50 "/>
   <textElement ID="I" KEY="M15" ENTRY="Use a Windows GUI for this program" LENGTH="50 "/>
   <textElement ID="I" KEY="M17" ENTRY="# table(s) added" LENGTH="50 "/>
   <textElement ID="I" KEY="M18" ENTRY="Do you wish to save your data first ?" LENGTH="70 "/>
   <textElement ID="I" KEY="M19" ENTRY="Action cancelled by the user" LENGTH="50 "/>
   <textElement ID="I" KEY="M20" ENTRY="Fill one object entry" LENGTH="50 "/>
   <textElement ID="I" KEY="M21" ENTRY="Cannot display selected link" LENGTH="50 "/>
   <textElement ID="I" KEY="M22" ENTRY="Action cancelled" LENGTH="50 "/>
   <textElement ID="I" KEY="M23" ENTRY="Choose file to create" LENGTH="50 "/>
   <textElement ID="I" KEY="M24" ENTRY="XML File (*.xml)|*.xml" LENGTH="50 "/>
   <textElement ID="I" KEY="M25" ENTRY="Choose file to import" LENGTH="50 "/>
   <textElement ID="I" KEY="M26" ENTRY="Confirm import of new tree" LENGTH="50 "/>
   <textElement ID="I" KEY="M27" ENTRY="Current tree will be replaced by content of file. Do you want to continue ?" LENGTH="100 "/>
   <textElement ID="I" KEY="M28" ENTRY="Error when parsing the input XML file" LENGTH="50 "/>
   <textElement ID="I" KEY="M29" ENTRY="Error when opening the input XML file" LENGTH="50 "/>
   <textElement ID="I" KEY="M30" ENTRY="Please select a folder in the tree" LENGTH="50 "/>
   <textElement ID="I" KEY="M31" ENTRY="Please not select a folder in the tree" LENGTH="50 "/>
   <textElement ID="R" ENTRY="Repository of specific objects" LENGTH="30 "/>
   <textElement ID="S" KEY="PDOUBLON" ENTRY="        Do not create duplicates" LENGTH="32 "/>
   <textElement ID="S" KEY="S_PROGRM" ENTRY="        Programs" LENGTH="16 "/>
   <textElement ID="S" KEY="S_TABLES" ENTRY="        Tables" LENGTH="14 "/>
  </language>
 </textPool>
 <dynpros>
  <dynpro PROG="ZSPRO_AP" DNUM="0100" FNUM="0100" BZMX="50 " BZBR="255 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="50 " NOCO="255 " VALP="0 " CUAN="G" SPRA="E" DTEXT="Main screen - tree of specific customizing">
   <dynprofield FNAM="TREE_CONTAINER_0100" DIDX="0032" FLG1="00" FLG2="30" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="FF" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="05" ADEZ="1E"/>
   <dynprofield FNAM="OKCODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
   <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE init_0100.
  MODULE status_0100.

PROCESS AFTER INPUT.
  MODULE user_command_0100 AT EXIT-COMMAND.
  MODULE user_command_0100.</dynproflowsource>
  </dynpro>
 </dynpros>
 <pfstatus>
  <pfstatus_sta CODE="STATUS_0100" MODAL="D" ACTCODE="000001" PFKCODE="000001" BUTCODE="0001" INT_NOTE="Main screen"/>
  <pfstatus_fun CODE="BACK" TEXTNO="001" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Back"/>
  <pfstatus_fun CODE="BACK" TEXTNO="002" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Exit"/>
  <pfstatus_fun CODE="BACK" TEXTNO="003" TYPE="E" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancel"/>
  <pfstatus_fun CODE="CANCEL" TEXTNO="001" TYPE="E" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancel"/>
  <pfstatus_fun CODE="CREA" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TRANSPORT" ICON_ID="@4A@" FUN_TEXT="Transport" ICON_TEXT="Transport"/>
  <pfstatus_fun CODE="DELETE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_DELETE" ICON_ID="@11@" FUN_TEXT="Delete entry" ICON_TEXT="Delete entry"/>
  <pfstatus_fun CODE="DOWN" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_PREVIOUS_VALUE" ICON_ID="@0H@" FUN_TEXT="Down"/>
  <pfstatus_fun CODE="EDITHELP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INFORMATION" ICON_ID="@0S@" FUN_TEXT="Edit help" ICON_TEXT="Edit help"/>
  <pfstatus_fun CODE="ENDE" TEXTNO="001" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Exit"/>
  <pfstatus_fun CODE="FILE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CREATE" ICON_ID="@0Y@" FUN_TEXT="Add entry" ICON_TEXT="Add entry"/>
  <pfstatus_fun CODE="FIND" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH" ICON_ID="@13@" FUN_TEXT="Find"/>
  <pfstatus_fun CODE="FOLDER" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CLOSED_FOLDER" ICON_ID="@FN@" FUN_TEXT="Create folder" ICON_TEXT="Create folder"/>
  <pfstatus_fun CODE="MASSFILE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SHOW_EXTERNAL_JOBS" ICON_ID="@EP@" FUN_TEXT="Add entries in mass" ICON_TEXT="Add entries in mass"/>
  <pfstatus_fun CODE="OKAY" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_OKAY" ICON_ID="@0V@" FUN_TEXT="OK"/>
  <pfstatus_fun CODE="RENAME" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CHANGE" ICON_ID="@0Z@" FUN_TEXT="Rename entry" ICON_TEXT="Rename entry"/>
  <pfstatus_fun CODE="SAVE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SYSTEM_SAVE" ICON_ID="@2L@" FUN_TEXT="Save"/>
  <pfstatus_fun CODE="SUITE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SEARCH_NEXT" ICON_ID="@4E@" FUN_TEXT="Find next"/>
  <pfstatus_fun CODE="SWITCH" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TOGGLE_DISPLAY_CHANGE" ICON_ID="@3I@" FUN_TEXT="Change/display"/>
  <pfstatus_fun CODE="TECH" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TOOLS" ICON_ID="@45@" FUN_TEXT="Display technical name"/>
  <pfstatus_fun CODE="UP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_NEXT_VALUE" ICON_ID="@0I@" FUN_TEXT="Up"/>
  <pfstatus_fun CODE="WHEREUSED" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_REFERENCE_LIST" ICON_ID="@3A@" FUN_TEXT="Where-used list" ICON_TEXT="Where-used list"/>
  <pfstatus_fun CODE="XML" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXPORT" ICON_ID="@49@" FUN_TEXT="Export XML" ICON_TEXT="Export XML"/>
  <pfstatus_fun CODE="XMLI" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_IMPORT" ICON_ID="@48@" FUN_TEXT="Import XML" ICON_TEXT="Import XML"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="01" PFNO="14"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="02" PFNO="17"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="03" PFNO="18"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="04" PFNO="19"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="05" PFNO="20"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="06" PFNO="21"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="07" PFNO="S"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="08" PFNO="16"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="09" PFNO="13"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="10" PFNO="23"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="11" PFNO="S"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="12" PFNO="26"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="13" PFNO="27"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="14" PFNO="06"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="15" PFNO="29"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="16" PFNO="25"/>
  <pfstatus_pfk CODE="000001" PFNO="03" FUNCODE="BACK" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="06" FUNCODE="TECH" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="11" FUNCODE="SAVE" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="12" FUNCODE="BACK" FUNNO="003"/>
  <pfstatus_pfk CODE="000001" PFNO="13" FUNCODE="EDITHELP" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="14" FUNCODE="SWITCH" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="15" FUNCODE="BACK" FUNNO="002"/>
  <pfstatus_pfk CODE="000001" PFNO="16" FUNCODE="WHEREUSED" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="17" FUNCODE="FOLDER" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="18" FUNCODE="FILE" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="19" FUNCODE="MASSFILE" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="20" FUNCODE="DELETE" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="21" FUNCODE="RENAME" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="23" FUNCODE="CREA" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="25" FUNCODE="XMLI" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="26" FUNCODE="UP" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="27" FUNCODE="DOWN" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="29" FUNCODE="XML" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="71" FUNCODE="FIND" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="84" FUNCODE="SUITE" FUNNO="001"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="BACK"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="CANCEL"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="CREA"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="DELETE"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="DOWN"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="EDITHELP"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="ENDE"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="FILE"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="FIND"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="FOLDER"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="MASSFILE"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="RENAME"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="SAVE"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="SUITE"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="SWITCH"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="TECH"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="UP"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="WHEREUSED"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="XML"/>
  <pfstatus_set STATUS="STATUS_0100" FUNCTION="XMLI"/>
  <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000001" MODAL="D" INT_NOTE="Main screen"/>
  <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000001" SUB_CODE="0001" MODAL="D" INT_NOTE="Main screen"/>
  <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000001" MODAL="D" INT_NOTE="Main screen"/>
  <pfstatus_tit CODE="TITLE_0100" TEXT="Repository of specific objects"/>
 </pfstatus>
 <source>*----------------------------------------------------------------------*
*  Program : ZSPRO_AP
*  Author  : S. Hermann
*  Date    : 17.09.2017
*  Version : 2.5.1
*  Required: Table ZSPRO_AP
*----------------------------------------------------------------------*
*  This program allow you to manage a hierarchy of objects
*  Objects can be from several types :
*  - table
*  - program
*  - transaction
*  - function module
*  - url
*  - IMG activity
*  - class
*
*  Typically usage is to build a repository of specific tables/programm
*  like SAP do it with SPRO.
*
*  You can click on any table to display help and structure, or double
*  click to manage content (if maintenance view exist) or display
*  content. You can also display table definition.
*
*  You can click on any program to display help or double click to
*  execute the program. You can also display code.
*
*  You can click on any transaction to display help or double click to
*  execute the transaction.
*
*  You can click on any function module to display help or double click
*  to display screen with input parameters.  You can also display code.
*
*  You can click on any IMG activity to display help or double click to
*  execute the activity.
*
*  You can double click on any URL/application to execute it
*
*  The edition mode embed allow you to add/change/delete entries
*  graphically in the transaction.
*  It allow you also to edit help for specific objets
*
*  To initiate easilly the repository, you can add in mass
*  tables /program and then assign them to correct folder
*
*  This tool can be used by functionnal team to fill specific
*  customizing tables without knowing his technical name
*
*  Another usage of this program is to build a repository of utilities
*  programs. IT team can easilly execute usefull program centralised
*  in this place
*
*  Please send comment &amp; improvements to http://quelquepart.biz
*----------------------------------------------------------------------*
* History
* 2017.09.17 V2.5.1: Fix Better display of program documentation
*                    Fix Add object with a standard empty description
* 2017.01.28 v2.5  : Add Management of stylized abap documentation
*                    Add Interface methods in class documentation
*                    Add default background image for screen rigth part
* 2015.09.18 V2.4  : Add icon for url type image &amp; email
*                    Add Text table on ddic table html display
*                    Add Context menu to Jump to SE11 on Text table
* 2015.05.10 v2.3  : Add XML import
*                    Add node : Class type
*                    Mod help link management for specific cases
*                    Mod Code cleaned
* 2014.11.15 v2.2  : Add node : IMG type
*                    Add node : Function module type
*                    Mod XML generation class to increase compatibility
*                    Fix bug on display techname function
*                    Mod Display &quot;Edit help&quot; only for specific objects
*                    Add link management in help display
* 2014.05.11 v2.1.1: Fix bug on reorder items in tree
* 2014.03.08 v2.1  : Add XML export
* 2014.02.03 v2.0.2: Add separate icons for doc/xls/ppt/pdf links
*                    Mod Transport all the tree content in 1 entry
* 2014.01.03 v2.0.1: Mod Allow transport into an existing request
* 2013.10.12 v2.0  : Mod Big rework to allow more different object types
*                        as nodes
*                    Add node : Transaction type
*                    Add node : Url type
* 2013.08.28 v1.06 : Mod Better display of autodoc on program entries
* 2013.07.05 v1.05 : Mod Better jump to SE11, SE16 &amp; SE38
* 2013.06.14 v1.04 : Add jump to SE11 for table entry
*                    Add Display technical name on/off (in tree)
* 2013.06.12 v1.03 : Add jump to SE38 for program entry
* 2013.06.09 v1.02 : Add table name in documentation for table entry
* 2013.04.04 v1.01 : Add autodoc on program entries
* v1.0  : Initial release
*----------------------------------------------------------------------*
* ajouter sapwr aux link
* ajouter sap aux link : fichier a ouvrir et folder a ouvrir via zal11
PROGRAM ZSPRO_AP.

*######################################################################*
*
*                             DATA SECTION
*
*######################################################################*

* Object declaration deferred
CLASS : lcl_application DEFINITION DEFERRED,
        lcl_gui_simple_tree DEFINITION DEFERRED,
        cl_gui_cfw DEFINITION LOAD.

* Objects declaration
* Spliter
DATA : o_splitter        TYPE REF TO cl_gui_splitter_container,
       o_container       TYPE REF TO cl_gui_custom_container,
       o_container_left  TYPE REF TO cl_gui_container,
       o_container_right TYPE REF TO cl_gui_container,
* html view
       o_html_control    TYPE REF TO cl_gui_html_viewer,
* Tree
       o_application     TYPE REF TO lcl_application,
       o_tree            TYPE REF TO lcl_gui_simple_tree,
       o_behaviour       TYPE REF TO cl_dragdrop,

       o_pic             TYPE REF TO cl_gui_picture.

* Data declaration
* Tree data
DATA : w_handle_tree TYPE i,

       s_ZSPRO_AP       TYPE ZSPRO_AP,
       t_ZSPRO_AP       LIKE SORTED TABLE OF s_ZSPRO_AP WITH UNIQUE KEY node_key,
       t_ZSPRO_AP_copy  LIKE TABLE OF s_ZSPRO_AP,
       s_ZSPRO_AP_upd   TYPE ZSPRO_AP,
       r_ZSPRO_AP_del   TYPE RANGE OF ZSPRO_AP-node_key,
       s_ZSPRO_AP_del   LIKE LINE OF r_ZSPRO_AP_del,
       w_node_key    TYPE ZSPRO_AP-node_key,
       s_node        TYPE ZSPRO_AP.

* General data
DATA : okcode         LIKE sy-ucomm, &quot;screen function code
       w_okcode       LIKE okcode,
       w_first_time   TYPE c,
       w_mode_change  TYPE c,
       w_data_changed TYPE c, &quot;to know if data changed need to be save
       BEGIN OF s_find, &quot;Search structure
         nodetype  TYPE ZSPRO_AP-nodetype,
         nodeparam TYPE ZSPRO_AP-nodeparam,
         patern    TYPE ZSPRO_AP-text,
         index     TYPE i,
* TODO : delete
         tabname   TYPE tabname,
         programm  TYPE programm,
       END OF s_find,
       t_excluded_nochange TYPE TABLE OF sy-ucomm,
       w_techname          TYPE i. &quot;display techname in tree on/off

* Constants
CONSTANTS : c_action_enqueue         TYPE c VALUE &apos;E&apos;,
            c_action_dequeue         TYPE c VALUE &apos;D&apos;,
            c_enqueue_mode_exclusive TYPE c VALUE &apos;E&apos;,
            c_tree_table             TYPE tabname VALUE &apos;ZSPRO_AP&apos;,
            c_wildcard               TYPE c VALUE &apos;#&apos;,
            c_state_active           TYPE ddobjstate VALUE &apos;A&apos;,
            c_msg_abort              TYPE c VALUE &apos;A&apos;,
            c_msg_error              TYPE c VALUE &apos;E&apos;,
            c_msg_succes             TYPE c VALUE &apos;S&apos;,
            c_langu_default          TYPE sy-langu VALUE &apos;E&apos;,
            c_doktyp_technical       TYPE dokil-typ VALUE &apos;T&apos;,
            c_doktyp_enduser         TYPE dokil-typ VALUE &apos;E&apos;,
            c_doctype_table          TYPE doku_id VALUE &apos;TB&apos;,
            c_doctype_prog           TYPE doku_id VALUE &apos;RE&apos;,
            c_doctype_img            TYPE doku_id VALUE &apos;HY&apos;,
            c_doctype_fm             TYPE doku_id VALUE &apos;FU&apos;,
            c_doctype_cls            TYPE doku_id VALUE &apos;CL&apos;,
            c_doctype_meth           TYPE doku_id VALUE &apos;CO&apos;,
            c_doctype_clsattr        TYPE doku_id VALUE &apos;CA&apos;,
            c_popup_file             TYPE c VALUE space,
            c_popup_folder           TYPE c VALUE &apos;X&apos;,
            c_popup_find             TYPE c VALUE &apos;F&apos;,
            c_icon_table(4)          TYPE c VALUE &apos;@36@&apos;,
            c_icon_table_nomaint(4)  TYPE c VALUE &apos;@3W@&apos;,
            c_icon_prog(4)           TYPE c VALUE &apos;@9U@&apos;,
            c_icon_transac(4)        TYPE c VALUE &apos;@15@&apos;,
            c_icon_url(4)            TYPE c VALUE &apos;@CQ@&apos;,
            c_icon_url_broken(4)     TYPE c VALUE &apos;@CR@&apos;,
            c_icon_xls(4)            TYPE c VALUE &apos;@J2@&apos;,
            c_icon_doc(4)            TYPE c VALUE &apos;@J7@&apos;,
            c_icon_ppt(4)            TYPE c VALUE &apos;@J5@&apos;,
            c_icon_pdf(4)            TYPE c VALUE &apos;@IT@&apos;,
            c_icon_img(4)            TYPE c VALUE &apos;@5H@&apos;,
            c_icon_fm(4)             TYPE c VALUE &apos;@12@&apos;,
            c_icon_cls(4)            TYPE c VALUE &apos;@7C@&apos;,
            c_icon_mail(4)           TYPE c VALUE &apos;@E2@&apos;,
            c_icon_png(4)            TYPE c VALUE &apos;@IU@&apos;,
            c_icon_unknown(4)        TYPE c VALUE &apos;@AH@&apos;,
            c_techname_on            TYPE i VALUE 1,
            c_url_broken(1)          TYPE c VALUE &apos;#&apos;,
            c_nodetype_node          TYPE ZSPRO_AP-nodetype VALUE &apos;0&apos;,
            c_nodetype_table         TYPE ZSPRO_AP-nodetype VALUE &apos;1&apos;,
            c_nodetype_program       TYPE ZSPRO_AP-nodetype VALUE &apos;2&apos;,
            c_nodetype_transac       TYPE ZSPRO_AP-nodetype VALUE &apos;3&apos;,
            c_nodetype_url           TYPE ZSPRO_AP-nodetype VALUE &apos;4&apos;,
            c_nodetype_fm            TYPE ZSPRO_AP-nodetype VALUE &apos;5&apos;,
            c_nodetype_img           TYPE ZSPRO_AP-nodetype VALUE &apos;6&apos;,
            c_nodetype_cls           TYPE ZSPRO_AP-nodetype VALUE &apos;7&apos;,
            c_xmltype_table          TYPE string VALUE &apos;Table&apos;, &quot;#EC NOTEXT
            c_xmltype_program        TYPE string VALUE &apos;Program&apos;, &quot;#EC NOTEXT
            c_xmltype_transac        TYPE string VALUE &apos;Transaction&apos;, &quot;#EC NOTEXT
            c_xmltype_url            TYPE string VALUE &apos;Link&apos;, &quot;#EC NOTEXT
            c_xmltype_fm             TYPE string VALUE &apos;Function&apos;, &quot;#EC NOTEXT
            c_xmltype_img            TYPE string VALUE &apos;IMG&apos;,
            c_xmltype_cls            TYPE string VALUE &apos;Class&apos;, &quot;#EC NOTEXT
            c_xmlnode_root           TYPE string VALUE &apos;root&apos;,
            c_xmlnode_folder         TYPE string VALUE &apos;node&apos;,
            c_xmlnode_file           TYPE string VALUE &apos;item&apos;,
            c_xmlattr_folder_text    TYPE string VALUE &apos;name&apos;,
            c_xmlattr_file_text      TYPE string VALUE &apos;description&apos;,
            c_xmlattr_file_type      TYPE string VALUE &apos;type&apos;,
            c_xmlattr_file_param     TYPE string VALUE &apos;value&apos;,
            c_welcome_bg             TYPE string VALUE &apos;ZTOOLBG&apos;.

*######################################################################*
*
*                             CLASS SECTION
*
*######################################################################*

*----------------------------------------------------------------------*
*       CLASS LCL_APPLICATION DEFINITION
*----------------------------------------------------------------------*
*       Class to handle application events
*----------------------------------------------------------------------*
CLASS lcl_application DEFINITION FINAL.
  PUBLIC SECTION.
    METHODS:
      handle_select
      FOR EVENT selection_changed
                    OF cl_gui_simple_tree
        IMPORTING node_key,
      handle_node_double_click
      FOR EVENT node_double_click
                    OF cl_gui_simple_tree
        IMPORTING node_key,
      drag
      FOR EVENT on_drag
                    OF cl_gui_simple_tree
        IMPORTING node_key drag_drop_object,
      drop
      FOR EVENT on_drop
                    OF cl_gui_simple_tree
        IMPORTING node_key drag_drop_object,
      handle_node_context_menu_req
      FOR EVENT node_context_menu_request
                    OF cl_gui_simple_tree
        IMPORTING node_key menu,
      handle_def_context_menu_req
      FOR EVENT default_context_menu_request
                    OF cl_gui_simple_tree
        IMPORTING menu,
      handle_def_context_menu_sel
      FOR EVENT default_context_menu_select
                    OF cl_gui_simple_tree
        IMPORTING fcode,
      handle_node_context_menu_sel
      FOR EVENT node_context_menu_select
                    OF cl_gui_simple_tree
        IMPORTING fcode,
      handle_link_clic_html
      FOR EVENT sapevent
                    OF cl_gui_html_viewer
        IMPORTING action.

ENDCLASS.                    &quot;lcl_application DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_gui_simple_tree DEFINITION
*----------------------------------------------------------------------*
* Redefinition of cl_gui_simple_tree to allow events
* SELECTION_CHANGED + NODE_DOUBLE_CLICK
*----------------------------------------------------------------------*
CLASS lcl_gui_simple_tree DEFINITION FINAL
                          INHERITING FROM cl_gui_simple_tree.
  PUBLIC SECTION.
    METHODS set_registered_events REDEFINITION.

ENDCLASS.                    &quot;lcl_gui_simple_tree DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_drag_object DEFINITION
*----------------------------------------------------------------------*
*       Drag&amp;Drop object to keep dragged node_key
*----------------------------------------------------------------------*
CLASS lcl_drag_object DEFINITION FINAL.
  PUBLIC SECTION.
    DATA node_key TYPE ZSPRO_AP-node_key.
ENDCLASS.                    &quot;lcl_drag_object DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_gui_simple_tree IMPLEMENTATION
*----------------------------------------------------------------------*
* Redefinition of cl_gui_simple_tree to allow events
* SELECTION_CHANGED + NODE_DOUBLE_CLICK
*----------------------------------------------------------------------*
CLASS lcl_gui_simple_tree IMPLEMENTATION.
  METHOD set_registered_events.
    DATA: simple_event    TYPE cntl_simple_event,
          ex_event        TYPE cntl_event,
          events_ex       TYPE cntl_events,
          sel_change_used TYPE as4flag.                     &quot;#EC NEEDED

* check if control is alive
    IF h_control IS INITIAL.
      MESSAGE &apos;Tree control no longer exists&apos;(m13) TYPE c_msg_abort.
    ENDIF.

* check if selection_change event is used
    READ TABLE events WITH KEY eventid = eventid_selection_changed
      TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      IF node_selection_mode &lt;&gt; node_sel_mode_single.
        RAISE illegal_event_combination.
      ENDIF.
      sel_change_used = abap_true.
    ENDIF.
* Register drag drop event. This event only occurs when cl_dragdrop
* is also used --&gt; no need for explicit registration by control user.
    ex_event-is_shellevent = abap_true.
    ex_event-is_systemevent = abap_true.
    ex_event-eventid = cl_gui_control=&gt;shellevt_dragdrop.
    APPEND ex_event TO events_ex.

* map simple_event into ex_event, append to events_ex
    LOOP AT events INTO simple_event.
      CASE simple_event-eventid.
        WHEN eventid_expand_no_children.
        WHEN eventid_node_keypress.
        WHEN eventid_node_double_click.
*          IF NOT sel_change_used IS INITIAL.
*          RAISE ILLEGAL_EVENT_COMBINATION.
*          ENDIF.
        WHEN eventid_selection_changed.
        WHEN eventid_node_context_menu_req
             OR eventid_def_context_menu_req.
* Register context menu select event
          ex_event-eventid = shellevt_ctxmnu_sel.
          ex_event-is_shellevent = abap_true.
          ex_event-is_systemevent = ctx_men_select_system.
          APPEND ex_event TO events_ex.
        WHEN OTHERS.
          RAISE illegal_event_combination.
      ENDCASE.
      ex_event-eventid = simple_event-eventid.
      CLEAR ex_event-is_shellevent.
      IF simple_event-appl_event IS INITIAL.
        ex_event-is_systemevent = abap_true.
      ELSE.
        CLEAR ex_event-is_systemevent.
      ENDIF.
      APPEND ex_event TO events_ex.

    ENDLOOP.

    CALL METHOD me-&gt;set_registered_events_ex
      EXPORTING
        eventtab                  = events_ex
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3
        OTHERS                    = 4.
    CASE sy-subrc.
      WHEN 1. RAISE cntl_error.
      WHEN 2. RAISE cntl_system_error.
      WHEN 3. RAISE illegal_event_combination.
      WHEN 4. RAISE cntl_error.
    ENDCASE.

    registered_simple_events[] = events.

  ENDMETHOD.                    &quot;SET_REGISTERED_EVENTS
ENDCLASS.                    &quot;lcl_gui_simple_tree IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS LCL_APPLICATION IMPLEMENTATION
*----------------------------------------------------------------------*
*       Class to handle application events
*----------------------------------------------------------------------*
CLASS lcl_application IMPLEMENTATION.

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD handle_link_clic_html
*&amp;---------------------------------------------------------------------*
*  When user clic to a link in documentation, jump to the linked object
*  dockat DS:KENO seem &quot;sap help&quot; link in web browser
*  dockat DS:REPO seem object structure display (no really help)
*----------------------------------------------------------------------*
  METHOD handle_link_clic_html.
    DATA : l_dummy   TYPE c,                                &quot;#EC NEEDED
           l_object  TYPE ZSPRO_AP-nodeparam,
           l_doctype TYPE doku_id,
           l_dockat  TYPE dsysh-dokclass.

    SPLIT action AT &apos;:&apos; INTO l_dummy l_object.
    SPLIT l_object AT &apos;.&apos; INTO l_dockat l_object.

* Display external link in browser (KENO)
* Display linked object (REPO)
    IF l_dockat = &apos;KENO&apos; OR l_dockat = &apos;REPO&apos;.
      CALL FUNCTION &apos;DSYS_SHOW&apos;
        EXPORTING
          dokclass         = l_dockat
          dokname          = l_object
        EXCEPTIONS
          class_unknown    = 0
          object_not_found = 0
          OTHERS           = 0.
    ELSE.
      IF l_dockat = &apos;SIMG&apos;. &quot;link between img activity
        l_doctype = c_doctype_img.
      ELSE.
        l_doctype = l_dockat.
      ENDIF.
      PERFORM write_html_obj USING l_object l_doctype.
    ENDIF.
  ENDMETHOD. &quot;handle_link_clic_html

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD handle_select
*&amp;---------------------------------------------------------------------*
* When a node is selected, display info in the HTML part of the screen
*----------------------------------------------------------------------*
  METHOD handle_select.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = node_key.
    PERFORM init_html.
  ENDMETHOD.                    &quot;handle_select

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD handle_def_context_menu_req
*&amp;---------------------------------------------------------------------*
* This method handles the node context menu request event of the tree
* control instance
*----------------------------------------------------------------------*
  METHOD  handle_def_context_menu_req.

*   Allow only in change mode
    IF w_mode_change NE abap_true.
      RETURN.
    ENDIF.

    CALL METHOD menu-&gt;add_function
      EXPORTING
        text  = &apos;Create folder&apos;(c01)
        fcode = &apos;FOLDER&apos;.
    CALL METHOD menu-&gt;add_function
      EXPORTING
        text  = &apos;Add entry&apos;(c02)
        fcode = &apos;FILE&apos;.
    CALL METHOD menu-&gt;add_function
      EXPORTING
        text  = &apos;Add entries in mass&apos;(c03)
        fcode = &apos;MASSFILE&apos;.

  ENDMETHOD.                    &quot;handle_def_context_menu_req

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD handle_def_context_menu_sel
*&amp;---------------------------------------------------------------------*
* This method handles the node context select event of the tree control
* instance
*----------------------------------------------------------------------*
  METHOD  handle_def_context_menu_sel.
*   Restricted to change mode only
    IF w_mode_change NE abap_true.
      RETURN.
    ENDIF.

    okcode = fcode.
  ENDMETHOD.                    &quot;handle_def_context_menu_sel

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD handle_node_context_menu_req
*&amp;---------------------------------------------------------------------*
* This method handles the node context menu request event of the tree
* control instance
*----------------------------------------------------------------------*
  METHOD  handle_node_context_menu_req.
    DATA : l_tabletxt TYPE dd08v-tabname,
           l_table    TYPE tabname.

    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = node_key.
    IF s_ZSPRO_AP-isfolder = abap_true.
      IF w_mode_change = abap_true.
        CALL METHOD menu-&gt;add_function
          EXPORTING
            text  = &apos;Create folder&apos;(c01)
            fcode = &apos;FOLDER&apos;.
        CALL METHOD menu-&gt;add_function
          EXPORTING
            text  = &apos;Add entry&apos;(c02)
            fcode = &apos;FILE&apos;.
        CALL METHOD menu-&gt;add_function
          EXPORTING
            text  = &apos;Add entries in mass&apos;(c03)
            fcode = &apos;MASSFILE&apos;.
      ENDIF.
    ELSE.
* Where-used not applicable for url &amp; IMG
      IF s_ZSPRO_AP-nodetype NE c_nodetype_url
      AND s_ZSPRO_AP-nodetype NE c_nodetype_img.
        CALL METHOD menu-&gt;add_function
          EXPORTING
            text  = &apos;Where-used List&apos;(c04)
            fcode = &apos;WHEREUSED&apos;.
      ENDIF.
* Help applicable for specific objects only
      IF w_mode_change = abap_true
      AND ( s_ZSPRO_AP-nodeparam(1) = &apos;Z&apos; OR s_ZSPRO_AP-nodeparam(1) = &apos;Y&apos; )
      AND s_ZSPRO_AP-nodetype NE c_nodetype_url
      AND s_ZSPRO_AP-nodetype NE c_nodetype_transac.
        CALL METHOD menu-&gt;add_function
          EXPORTING
            text  = &apos;Edit help&apos;(c09)
            fcode = &apos;EDITHELP&apos;.
      ENDIF.
      IF s_ZSPRO_AP-nodetype = c_nodetype_table.
        CALL METHOD menu-&gt;add_function
          EXPORTING
            text  = &apos;View content&apos;(c10)
            fcode = &apos;SE16&apos;.
        CALL METHOD menu-&gt;add_function
          EXPORTING
            text  = &apos;Display table definition&apos;(c12)
            fcode = &apos;SE11&apos;.

        l_table = s_ZSPRO_AP-nodeparam.
        CALL FUNCTION &apos;DDUT_TEXTTABLE_GET&apos;
          EXPORTING
            tabname   = l_table
          IMPORTING
            texttable = l_tabletxt.
        IF NOT l_tabletxt IS INITIAL.
          CALL METHOD menu-&gt;add_function
            EXPORTING
              text  = &apos;Display text table definition&apos;(c17)
              fcode = &apos;SE11T&apos;.
        ENDIF.
      ENDIF.
      IF s_ZSPRO_AP-nodetype = c_nodetype_cls.
        CALL METHOD menu-&gt;add_function
          EXPORTING
            text  = &apos;Display class&apos;(c15)
            fcode = &apos;SE24&apos;.
      ENDIF.
      IF s_ZSPRO_AP-nodetype = c_nodetype_program
      OR s_ZSPRO_AP-nodetype = c_nodetype_fm.
        CALL METHOD menu-&gt;add_function
          EXPORTING
            text  = &apos;Display code&apos;(c11)
            fcode = &apos;SE38&apos;.
      ENDIF.
    ENDIF.
    IF w_mode_change = abap_true.
      CALL METHOD menu-&gt;add_function
        EXPORTING
          text  = &apos;Rename this entry&apos;(c05)
          fcode = &apos;RENAME&apos;.

      CALL METHOD menu-&gt;add_function
        EXPORTING
          text  = &apos;Delete this entry&apos;(c06)
          fcode = &apos;DELETE&apos;.

      CALL METHOD menu-&gt;add_separator.

      CALL METHOD menu-&gt;add_function
        EXPORTING
          text  = &apos;Up in current folder&apos;(c07)
          fcode = &apos;UP&apos;.

      CALL METHOD menu-&gt;add_function
        EXPORTING
          text  = &apos;Down in current folder&apos;(c08)
          fcode = &apos;DOWN&apos;.
    ENDIF.
  ENDMETHOD.                    &quot;handle_node_context_menu_req

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD handle_node_context_menu_sel
*&amp;---------------------------------------------------------------------*
* This method handles the node context select event of the tree control
* instance
*----------------------------------------------------------------------*
  METHOD  handle_node_context_menu_sel.
    okcode = fcode.
  ENDMETHOD.                    &quot;handle_node_context_menu_sel


*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD handle_node_double_click
*&amp;---------------------------------------------------------------------*
* This method handles the node double click event of the tree control
* instance
*----------------------------------------------------------------------*
  METHOD  handle_node_double_click.
    DATA : lt_node_key TYPE treev_nks,
           l_tabname   TYPE tabname,
           l_url       TYPE string,
           l_img       TYPE cus_act,
           l_function  TYPE rs38l-name.

    READ TABLE t_ZSPRO_AP WITH KEY node_key = node_key INTO s_ZSPRO_AP.

    IF s_ZSPRO_AP-isfolder = abap_true.
*     Dbl click on a node, expand or collapse.
      CLEAR lt_node_key.
      CALL METHOD o_tree-&gt;get_expanded_nodes
        CHANGING
          node_key_table = lt_node_key.

      READ TABLE lt_node_key FROM node_key TRANSPORTING NO FIELDS.
      IF sy-subrc &lt;&gt; 0.
*       Node is collapsed, it will be expanded
        CALL METHOD o_tree-&gt;expand_node
          EXPORTING
            node_key = node_key.
      ELSE.
*       Node is expanded, it will be collapsed
        CALL METHOD o_tree-&gt;collapse_subtree
          EXPORTING
            node_key = node_key.
      ENDIF.
    ELSE.
*     Click on a final node, it will be opened
      CASE s_ZSPRO_AP-nodetype.
        WHEN c_nodetype_table.
          l_tabname = s_ZSPRO_AP-nodeparam.
          IF s_ZSPRO_AP-nomaint = space.
            CALL FUNCTION &apos;VIEW_MAINTENANCE_CALL&apos;
              EXPORTING
                action                       = &apos;S&apos;
                view_name                    = l_tabname
                check_ddic_mainflag          = abap_true
              EXCEPTIONS
                client_reference             = 1
                foreign_lock                 = 2
                invalid_action               = 3
                no_clientindependent_auth    = 4
                no_database_function         = 5
                no_editor_function           = 6
                no_show_auth                 = 7
                no_tvdir_entry               = 8
                no_upd_auth                  = 9
                only_show_allowed            = 10
                system_failure               = 11
                unknown_field_in_dba_sellist = 12
                view_not_found               = 13
                maintenance_prohibited       = 14
                OTHERS                       = 15.
            IF sy-subrc &lt;&gt; 0.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ENDIF.
          ELSE.
            CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
              EXPORTING
                operation   = &apos;TAB_CONT&apos;
                object_name = l_tabname
                object_type = &apos;TABL&apos;.
          ENDIF.
        WHEN c_nodetype_program.
* Execute program
          SUBMIT (s_ZSPRO_AP-nodeparam) VIA SELECTION-SCREEN AND RETURN.
        WHEN c_nodetype_transac.
* Execute transaction
          CALL TRANSACTION s_ZSPRO_AP-nodeparam.
        WHEN c_nodetype_url.
* Do not try to open broken link
          IF s_ZSPRO_AP-nodeparam = c_url_broken.
            RETURN.
          ENDIF.

* Open link
          l_url = s_ZSPRO_AP-nodeparam.
          CALL METHOD cl_gui_frontend_services=&gt;execute
            EXPORTING
              application = l_url
            EXCEPTIONS
              OTHERS      = 10.
          IF sy-subrc NE 0.
            MESSAGE &apos;Cannot display selected link&apos;(m21)
                    TYPE c_msg_succes DISPLAY LIKE c_msg_error.
          ENDIF.
        WHEN c_nodetype_img.
* Open IMG activity
          l_img = s_ZSPRO_AP-nodeparam.
          CALL FUNCTION &apos;S_CUS_ACTIVITY_EXECUTE&apos;
            EXPORTING
              activity = l_img.
        WHEN c_nodetype_fm.
* Start the test environement of the function module
          l_function = s_ZSPRO_AP-nodeparam.
          CALL FUNCTION &apos;SFCS_FA_TEST_FUNCTION&apos;
            EXPORTING
              funcname = l_function
            EXCEPTIONS
              OTHERS   = 0.
        WHEN c_nodetype_cls.
* Display class
          PERFORM start_se24.
      ENDCASE.
    ENDIF.
  ENDMETHOD.                    &quot;handle_node_double_click

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD drag
*&amp;---------------------------------------------------------------------*
* Handle the drag action on a node, in change mode
*----------------------------------------------------------------------*
  METHOD  drag.
    DATA lo_drag_object TYPE REF TO lcl_drag_object.

*   Restricted to change mode only
    IF w_mode_change NE abap_true.
      RETURN.
    ENDIF.

    CREATE OBJECT lo_drag_object.
    lo_drag_object-&gt;node_key = node_key.
    drag_drop_object-&gt;object = lo_drag_object.

  ENDMETHOD.                    &quot;handle_node_drag_drop

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD drop
*&amp;---------------------------------------------------------------------*
* Handle the drop action on a node, in change mode.
* Drop is allowed only on a folder
*----------------------------------------------------------------------*
  METHOD drop.
    DATA : lo_drag_object TYPE REF TO lcl_drag_object,
           l_newkey       LIKE node_key,
           l_sort         TYPE i.

*   Restricted to change mode only
    IF w_mode_change NE abap_true.
      RETURN.
    ENDIF.

    CATCH SYSTEM-EXCEPTIONS move_cast_error = 1.
      lo_drag_object ?= drag_drop_object-&gt;object.
    ENDCATCH.
    IF sy-subrc = 1.
* Data object has unexpected class =&gt; cancel Drag &amp; Drop operation
      CALL METHOD drag_drop_object-&gt;abort.
      RETURN.
    ENDIF.

* drag_object-&gt;node_key contain the dragged object
* node_key contain the target object
* Check drop node is folder
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP
               WITH KEY node_key = node_key.
    IF s_ZSPRO_AP-isfolder IS INITIAL.
      MESSAGE &apos;Target must be a folder&apos;(m01) TYPE c_msg_succes.
      CALL METHOD drag_drop_object-&gt;abort.
      RETURN.
    ENDIF.

    PERFORM get_free_number USING node_key
                            CHANGING l_newkey l_sort.

    CLEAR s_ZSPRO_AP.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP
               WITH KEY node_key = lo_drag_object-&gt;node_key.

* Affect the new parent for the droped node
    s_ZSPRO_AP-relatkey = node_key.
    s_ZSPRO_AP-updated = abap_true.
    s_ZSPRO_AP-sort = l_sort.
    MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP INDEX sy-tabix.

    CALL METHOD o_tree-&gt;move_node
      EXPORTING
        node_key  = lo_drag_object-&gt;node_key
        relatkey  = node_key
        relatship = cl_gui_simple_tree=&gt;relat_last_child.

* Rebuild sort position for the sibbling
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP
               WITH KEY node_key = lo_drag_object-&gt;node_key.
    PERFORM renum_nodes USING s_ZSPRO_AP-relatkey.

    w_data_changed = abap_true.

  ENDMETHOD.                    &quot;handle_node_drag_drop

ENDCLASS.                    &quot;lcl_application IMPLEMENTATION


*######################################################################*
*
*                             SCREEN SECTION
*
*######################################################################*

SELECTION-SCREEN BEGIN OF SCREEN 200.
SELECT-OPTIONS : s_tables FOR s_find-tabname,
                 s_progrm FOR s_find-programm.
PARAMETERS pdoublon AS CHECKBOX DEFAULT &apos;X&apos;.
SELECTION-SCREEN END OF SCREEN 200.



*######################################################################*
*
*                             MAIN SECTION
*
*######################################################################*

START-OF-SELECTION.
* Creation of application object
* Allow to catch events
  CREATE OBJECT o_application.

* Call of the main screen
  SET SCREEN 100.

END-OF-SELECTION.


*######################################################################*
*
*                             PBO SECTION
*
*######################################################################*

*&amp;---------------------------------------------------------------------*
*&amp;      Module  STATUS_0100  OUTPUT
*&amp;---------------------------------------------------------------------*
*       Define status for main screen
*----------------------------------------------------------------------*
MODULE status_0100 OUTPUT.
* In change mode, set status 100 with full access
  IF w_mode_change = abap_true.
    SET PF-STATUS &apos;STATUS_0100&apos;.
* In display mode, set status 100 with restricted acces
  ELSE.
    SET PF-STATUS &apos;STATUS_0100&apos; EXCLUDING t_excluded_nochange.
  ENDIF.
  SET TITLEBAR &apos;TITLE_0100&apos;. &quot;Repository of specific objects
ENDMODULE.                 &quot; STATUS_0100  OUTPUT

*&amp;---------------------------------------------------------------------*
*&amp;      Module  INIT_0100  OUTPUT
*&amp;---------------------------------------------------------------------*
*       Initialization of all objects
*----------------------------------------------------------------------*
MODULE init_0100 OUTPUT.
  IF w_first_time = space.
    w_first_time = abap_true.
    w_mode_change = space.

    PERFORM ctrl_active_x.
    PERFORM split_container.
    PERFORM init_tree.      &quot;container menu
    CLEAR s_ZSPRO_AP.
    PERFORM init_html.

    PERFORM init_excluded.

  ENDIF.
ENDMODULE.                 &quot; INIT_0100  OUTPUT

*######################################################################*
*
*                             PAI SECTION
*
*######################################################################*

*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_0100  INPUT
*&amp;---------------------------------------------------------------------*
*       User command for main screen
*----------------------------------------------------------------------*
MODULE user_command_0100 INPUT.
* CL_GUI_CFW=&gt;DISPATCH must be called if events are registered
* that trigger PAI
* this method calls the event handler method of an event
  IF okcode NE &apos;BACK&apos;.
    CALL METHOD cl_gui_cfw=&gt;dispatch.
*      IMPORTING
*        return_code = w_return_code.
*    IF w_return_code &lt;&gt; cl_gui_cfw=&gt;rc_noevent.
*    A control event occured =&gt; exit PAI
*    CLEAR okcode.
*    exit.
*    ENDIF.
  ENDIF.

  w_okcode = okcode.
  CLEAR okcode.
  CASE w_okcode.
    WHEN &apos;BACK&apos;.
      PERFORM fonction_back.

    WHEN &apos;FOLDER&apos;.
      PERFORM create_folder.

    WHEN &apos;FILE&apos;.
      PERFORM create_file.

    WHEN &apos;MASSFILE&apos;.
      PERFORM create_mass.

    WHEN &apos;DELETE&apos;.
      PERFORM delete_nodes.

    WHEN &apos;RENAME&apos;.
      PERFORM rename_node.

    WHEN &apos;SAVE&apos;.
      PERFORM save_tree.

    WHEN &apos;CREA&apos;.
      PERFORM create_ot.

    WHEN &apos;UP&apos;.
      PERFORM move USING -1.

    WHEN &apos;DOWN&apos;.
      PERFORM move USING 1.

    WHEN &apos;FIND&apos;.
      PERFORM find_entry.

    WHEN &apos;SUITE&apos;.
      PERFORM find_entry_continue.

    WHEN  &apos;WHEREUSED&apos;.
      PERFORM where_used.

    WHEN &apos;SE16&apos;.
      PERFORM start_se16.

    WHEN &apos;SE24&apos;.
      PERFORM start_se24.

    WHEN &apos;SE11&apos;.
      PERFORM start_se11 USING space.

    WHEN &apos;SE11T&apos;.
      PERFORM start_se11 USING abap_true.

    WHEN &apos;SE38&apos;.
      PERFORM start_se38.

    WHEN &apos;EDITHELP&apos;.
      PERFORM edit_help.

    WHEN &apos;SWITCH&apos;.
      PERFORM switch_disp_edit.

    WHEN &apos;TECH&apos;.
      PERFORM switch_techname_tree.

    WHEN &apos;XML&apos;.
      PERFORM export_xml.

    WHEN &apos;XMLI&apos;.
      PERFORM import_xml.
  ENDCASE.

ENDMODULE.                 &quot; USER_COMMAND_0100  INPUT

*######################################################################*
*
*                             FORM SECTION
*
*######################################################################*
*&amp;---------------------------------------------------------------------*
*&amp;      Form  CTRL_ACTIVE_X
*&amp;---------------------------------------------------------------------*
*       Check that Active X objects are allowed
*----------------------------------------------------------------------*
FORM ctrl_active_x.
  DATA l_has_activex TYPE c.

  CALL FUNCTION &apos;GUI_HAS_ACTIVEX&apos;
    IMPORTING
      return = l_has_activex.
  IF l_has_activex = space.
    MESSAGE &apos;Use a Windows GUI for this program&apos;(m15) TYPE c_msg_error.
  ENDIF.
ENDFORM.                    &quot; CTRL_ACTIVE_X

*&amp;---------------------------------------------------------------------*
*&amp;      Form  INIT_TREE
*&amp;---------------------------------------------------------------------*
*       Initialization of tree object
*----------------------------------------------------------------------*
FORM init_tree.
  DATA: lt_events TYPE cntl_simple_events,
        ls_event  TYPE cntl_simple_event.

  IF o_tree IS INITIAL.

* Create a tree control
    CREATE OBJECT o_tree
      EXPORTING
        parent                      = o_container_left
        node_selection_mode         = cl_gui_simple_tree=&gt;node_sel_mode_single
      EXCEPTIONS
        lifetime_error              = 1
        cntl_system_error           = 2
        create_error                = 3
        failed                      = 4
        illegal_node_selection_mode = 5.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE &apos;Error calling a method of the tree control&apos;(m14)
              TYPE c_msg_abort.
    ENDIF.

* Define the events which will be passed to the backend
* node double click
    ls_event-eventid = cl_gui_simple_tree=&gt;eventid_node_double_click.
    ls_event-appl_event = abap_true. &quot; process PAI if event occurs
    APPEND ls_event TO lt_events.

* node click
    ls_event-eventid = cl_gui_simple_tree=&gt;eventid_selection_changed.
    ls_event-appl_event = abap_true. &quot; process PAI if event occurs
    APPEND ls_event TO lt_events.

* node context menu request
    ls_event-eventid = cl_gui_simple_tree=&gt;eventid_node_context_menu_req.
    ls_event-appl_event = space. &quot; no PAI if event occurs
    APPEND ls_event TO lt_events.

* default context menu request
    ls_event-eventid = cl_gui_simple_tree=&gt;eventid_def_context_menu_req.
    ls_event-appl_event = space. &quot; no PAI if event occurs
    APPEND ls_event TO lt_events.

* process PAI if context menu select event occurs
    CALL METHOD o_tree-&gt;set_ctx_menu_select_event_appl
      EXPORTING
        appl_event = abap_true.

* Register events
    CALL METHOD o_tree-&gt;set_registered_events
      EXPORTING
        events                    = lt_events
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3.
    IF sy-subrc &lt;&gt; 0.
      MESSAGE &apos;Error calling a method of the tree control&apos;(m14)
              TYPE c_msg_abort.
    ENDIF.

* Definition of drag drop behaviour
    CREATE OBJECT o_behaviour.
    CALL METHOD o_behaviour-&gt;add
      EXPORTING
        flavor         = &apos;Tree_move&apos;                        &quot;#EC NOTEXT
        dragsrc        = abap_true
        droptarget     = abap_true
        effect         = cl_dragdrop=&gt;move
        effect_in_ctrl = cl_dragdrop=&gt;move.
    CALL METHOD o_behaviour-&gt;get_handle
      IMPORTING
        handle = w_handle_tree.

* Create the application object
* This object is needed to handle the ABAP Objects Events of controls
    CREATE OBJECT o_application.

* Assign event handlers in the application class to each desired event
    SET HANDLER :
        o_application-&gt;handle_node_double_click FOR o_tree,
        o_application-&gt;handle_select FOR o_tree,
        o_application-&gt;drag FOR o_tree,
        o_application-&gt;drop FOR o_tree,
        o_application-&gt;handle_node_context_menu_req FOR o_tree,
        o_application-&gt;handle_def_context_menu_req FOR o_tree,
        o_application-&gt;handle_node_context_menu_sel FOR o_tree,
        o_application-&gt;handle_def_context_menu_sel FOR o_tree.

    PERFORM load_node USING abap_true.

  ENDIF.
ENDFORM.                    &quot; INIT_TREE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  LOAD_NODE
*&amp;---------------------------------------------------------------------*
*       Load tree nodes from DB table ZSPRO_AP
*       or from internal table t_ZSPRO_AP
*----------------------------------------------------------------------*
*      --&gt;FP_FROM_DB X to load data from DB table
*----------------------------------------------------------------------*
FORM load_node USING fp_from_db TYPE c.
* Add some nodes to the tree control
* NOTE: the tree control does not store data at the backend. If an
* application wants to access tree data later, it must store the
* tree data itself.
* Build the node table.
* Caution: The nodes are inserted into the tree according to the order
* in which they occur in the table. In consequence, a node must not
* occur in the node table before its parent node.
  DATA lt_node_table LIKE STANDARD TABLE OF s_node.

* Fill t_ZSPRO_AP from DB if required
  IF fp_from_db = abap_true.
    REFRESH : r_ZSPRO_AP_del,
              t_ZSPRO_AP.
    SELECT * FROM ZSPRO_AP INTO TABLE t_ZSPRO_AP.
  ENDIF.

* Check coherence data
  LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP.
*   Node key have not correct format : num2 for level, num4 for position
    IF NOT ( s_ZSPRO_AP-node_key(10) CO &apos;0123456789&apos;).
      DELETE t_ZSPRO_AP.
    ENDIF.

*   No parent and relation number indicate child level
    IF s_ZSPRO_AP-relatkey IS INITIAL AND s_ZSPRO_AP-relatship &lt;&gt; 0.
      DELETE t_ZSPRO_AP.
    ENDIF.

    CHECK NOT s_ZSPRO_AP-relatkey IS INITIAL.

    READ TABLE t_ZSPRO_AP WITH KEY node_key = s_ZSPRO_AP-relatkey
                       TRANSPORTING NO FIELDS.
    IF sy-subrc &lt;&gt; 0.
*   Parent not found
      DELETE t_ZSPRO_AP.
    ENDIF.
  ENDLOOP.

* Allow drag&amp;drop
  LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP.
    s_ZSPRO_AP-dragdropid = w_handle_tree.
    MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP.
  ENDLOOP.

  INSERT LINES OF t_ZSPRO_AP INTO TABLE lt_node_table.
  SORT lt_node_table BY relatkey sort.
*refresh lt_node_table. &quot;test shn TODO delete
  CALL METHOD o_tree-&gt;add_nodes
    EXPORTING
      table_structure_name           = c_tree_table
      node_table                     = lt_node_table
    EXCEPTIONS
      failed                         = 1
      error_in_node_table            = 2
      dp_error                       = 3
      table_structure_name_not_found = 4
      OTHERS                         = 5.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE &apos;Error calling a method of the tree control&apos;(m14)
            TYPE c_msg_abort.
  ENDIF.
ENDFORM.                    &quot; LOAD_NODE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  SPLIT_CONTAINER
*&amp;---------------------------------------------------------------------*
*       Split the screen into 2 parts :
*  - Tree on the left
*  - Infos (html) on the right
*----------------------------------------------------------------------*
FORM split_container.
  IF o_container IS INITIAL.
* Create main container
    CREATE OBJECT o_container
      EXPORTING
        container_name = &apos;TREE_CONTAINER_0100&apos;.

* Split the main container into 2 parts
    CREATE OBJECT o_splitter
      EXPORTING
        parent  = o_container
        rows    = 1
        columns = 2.

* Get container of the part 1
    CALL METHOD o_splitter-&gt;get_container
      EXPORTING
        row       = 1
        column    = 1
      RECEIVING
        container = o_container_left.

* Get container of the part 2
    CALL METHOD o_splitter-&gt;get_container
      EXPORTING
        row       = 1
        column    = 2
      RECEIVING
        container = o_container_right.
  ENDIF.
ENDFORM.                    &quot; SPLIT_CONTAINER

*&amp;---------------------------------------------------------------------*
*&amp;      Form  CREATE_FOLDER
*&amp;---------------------------------------------------------------------*
*       Create a folder
*----------------------------------------------------------------------*
FORM create_folder.
  DATA : l_subfolder   TYPE c,   &quot; To do subfolder special operations
         l_new_key     LIKE w_node_key,
         l_rc          TYPE c,
         l_sort        TYPE i,
         lt_node_table LIKE STANDARD TABLE OF s_node.

* Get the parent node for the creating folder
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = w_node_key.

  IF w_node_key IS INITIAL.
    CLEAR l_subfolder.
  ELSE.
    l_subfolder = abap_true.
  ENDIF.

  IF l_subfolder = abap_true.
*   Check parent is a folder.
    CLEAR s_ZSPRO_AP.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.

    IF s_ZSPRO_AP-isfolder IS INITIAL.
      MESSAGE &apos;Please select a folder in the tree&apos;(m30)
              TYPE c_msg_succes DISPLAY LIKE c_msg_error.
      RETURN.
    ENDIF.
  ENDIF.

  PERFORM get_free_number USING w_node_key
                          CHANGING l_new_key l_sort.
  CLEAR : s_ZSPRO_AP.

  s_ZSPRO_AP-node_key = l_new_key.
  IF l_subfolder = abap_true.
    s_ZSPRO_AP-relatkey = w_node_key.
    s_ZSPRO_AP-relatship = cl_gui_simple_tree=&gt;relat_last_child.
  ENDIF.
  s_ZSPRO_AP-isfolder = abap_true.

* Prompt for folder name
  PERFORM popup_get_value USING    s_ZSPRO_AP-isfolder
                          CHANGING s_ZSPRO_AP-nodetype
                                   s_ZSPRO_AP-nodeparam
                                   s_ZSPRO_AP-text
                                   l_rc.
  IF l_rc NE space AND l_rc NE 0.
    RETURN.
  ENDIF.

  s_ZSPRO_AP-nodetype = c_nodetype_node.
  s_ZSPRO_AP-new_line = abap_true.
  s_ZSPRO_AP-sort = l_sort.
  s_ZSPRO_AP-dragdropid = w_handle_tree.

  INSERT s_ZSPRO_AP INTO TABLE t_ZSPRO_AP.
  s_node = s_ZSPRO_AP.
  INSERT s_node INTO TABLE lt_node_table.

  CALL METHOD o_tree-&gt;add_nodes
    EXPORTING
      table_structure_name           = c_tree_table
      node_table                     = lt_node_table
    EXCEPTIONS
      failed                         = 1
      error_in_node_table            = 2
      dp_error                       = 3
      table_structure_name_not_found = 4
      OTHERS                         = 5.

  IF l_subfolder = abap_true.
*   Expand parent of the new node
    CALL METHOD o_tree-&gt;expand_node
      EXPORTING
        node_key = w_node_key.
  ENDIF.

  w_data_changed = abap_true.

ENDFORM.                    &quot; CREATE_FOLDER

*&amp;---------------------------------------------------------------------*
*&amp;      Form  get_free_number
*&amp;---------------------------------------------------------------------*
*       Create node_key for a new node
*----------------------------------------------------------------------*
*      --&gt;L_NODEKEY  Parent node
*      &lt;--L_NEWKEY   New node key generated by the function
*      &lt;--L_SORT     New sort position (first free)
*----------------------------------------------------------------------*
FORM get_free_number USING l_nodekey TYPE ZSPRO_AP-node_key
                     CHANGING l_newkey TYPE ZSPRO_AP-node_key
                              l_sort TYPE i.
  DATA : l_key(10) TYPE n,
         lt_ZSPRO_AP  LIKE TABLE OF s_ZSPRO_AP,
         ls_ZSPRO_AP  LIKE s_ZSPRO_AP,
         l_n       TYPE i.

* Search the greater nodekey number
  lt_ZSPRO_AP = t_ZSPRO_AP.
  SORT lt_ZSPRO_AP BY node_key.
  DESCRIBE TABLE lt_ZSPRO_AP LINES l_n.
  READ TABLE lt_ZSPRO_AP INTO ls_ZSPRO_AP INDEX l_n.
  l_key = ls_ZSPRO_AP-node_key.

* Add 1 to this nodekey number to have the new nodekey
  l_key = l_key + 1.
  l_newkey = l_key.

* Search the greater sort position for the childrens of the new node
* parent
  CLEAR l_sort.
  LOOP AT lt_ZSPRO_AP INTO ls_ZSPRO_AP WHERE relatkey = l_nodekey.
    IF ls_ZSPRO_AP-sort &gt; l_sort.
      l_sort = ls_ZSPRO_AP-sort.
    ENDIF.
  ENDLOOP.
* Add 1 to this position to place the new node at the end of the list
  ADD 1 TO l_sort.

ENDFORM.                    &quot; GET_FREE_NUMBER

*&amp;---------------------------------------------------------------------*
*&amp;      Form  delete_nodes
*&amp;---------------------------------------------------------------------*
*       Delete a node
*----------------------------------------------------------------------*
FORM delete_nodes.
  DATA : l_nodekey TYPE ZSPRO_AP-node_key,
         lt_nodes  LIKE TABLE OF w_node_key,
         lt_peres  LIKE TABLE OF w_node_key WITH HEADER LINE.


* Get node to delete
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = l_nodekey.
  IF l_nodekey IS INITIAL.
    RETURN.
  ENDIF.

  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = l_nodekey.
  IF sy-subrc NE 0.
    RETURN.
  ENDIF.
  DELETE t_ZSPRO_AP INDEX sy-tabix.
  IF s_ZSPRO_AP-isfolder NE space.
    APPEND l_nodekey TO lt_peres.
  ENDIF.

* If the deleted node is already stored in DB, keep del info to
* physically delete the node when user will save the changes
  IF s_ZSPRO_AP-new_line IS INITIAL.
    s_ZSPRO_AP_del = &apos;IEQ&apos;.
    s_ZSPRO_AP_del-low = s_ZSPRO_AP-node_key.
    APPEND s_ZSPRO_AP_del TO r_ZSPRO_AP_del.
  ENDIF.

* Do same operation for all childrens of the deleted node
  DO.
    LOOP AT lt_peres.
      LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP WHERE relatkey = lt_peres.
        IF s_ZSPRO_AP-isfolder NE space.
          APPEND s_ZSPRO_AP-node_key TO lt_nodes.
        ENDIF.
        IF s_ZSPRO_AP-new_line IS INITIAL.
          s_ZSPRO_AP_del = &apos;IEQ&apos;.
          s_ZSPRO_AP_del-low = s_ZSPRO_AP-node_key.
          APPEND s_ZSPRO_AP_del TO r_ZSPRO_AP_del.
        ENDIF.
        DELETE t_ZSPRO_AP.
      ENDLOOP.
    ENDLOOP.
    IF lt_nodes[] IS INITIAL.
      EXIT.
    ELSE.
      lt_peres[] = lt_nodes[].
      REFRESH lt_nodes.
    ENDIF.
  ENDDO.

* Delete selected nodes in the displayed tree
  CALL METHOD o_tree-&gt;delete_node
    EXPORTING
      node_key = l_nodekey.
  w_data_changed = abap_true.

ENDFORM.                    &quot;delete_nodes

*&amp;---------------------------------------------------------------------*
*&amp;      Form  CREATE_FILE
*&amp;---------------------------------------------------------------------*
*       Add a node (table)
*----------------------------------------------------------------------*
FORM create_file.
  DATA : l_new_key     LIKE w_node_key,
         l_subfolder   TYPE c, &quot; To do subfolder special operations
         l_rc,
         l_sort        TYPE i,
         lt_node_table LIKE STANDARD TABLE OF s_node,
         l_tabname     TYPE tabname.

* Get parent node
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = w_node_key.

  IF w_node_key IS INITIAL.
    CLEAR l_subfolder.
  ELSE.
    l_subfolder = abap_true.
  ENDIF.

  IF l_subfolder = abap_true.
*   Check parent is a folder.
    CLEAR s_ZSPRO_AP.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
    IF s_ZSPRO_AP-isfolder IS INITIAL.
      MESSAGE &apos;Please select a folder in the tree&apos;(m30)
              TYPE c_msg_succes DISPLAY LIKE c_msg_error.
      RETURN.
    ENDIF.
  ENDIF.

  PERFORM get_free_number USING w_node_key
                          CHANGING l_new_key l_sort.
  CLEAR : s_ZSPRO_AP.

* Prompt for object name
  PERFORM popup_get_value USING    s_ZSPRO_AP-isfolder
                          CHANGING s_ZSPRO_AP-nodetype
                                   s_ZSPRO_AP-nodeparam
                                   s_ZSPRO_AP-text
                                   l_rc.
  IF l_rc NE space AND l_rc NE 0.
    RETURN.
  ENDIF.

  s_ZSPRO_AP-node_key = l_new_key.
  IF l_subfolder = abap_true.
    s_ZSPRO_AP-relatkey = w_node_key.
    s_ZSPRO_AP-relatship = cl_gui_simple_tree=&gt;relat_last_child.
  ENDIF.

  s_ZSPRO_AP-new_line = abap_true.
  s_ZSPRO_AP-sort = l_sort.
  s_ZSPRO_AP-dragdropid = w_handle_tree.
  IF s_ZSPRO_AP-nodetype = c_nodetype_table.
    l_tabname = s_ZSPRO_AP-nodeparam.
*   Check if maintenance view exist
    SELECT SINGLE tabname
           INTO l_tabname
           FROM tvdir
           WHERE tabname = l_tabname.
    IF sy-subrc = 0.
      s_ZSPRO_AP-n_image = c_icon_table.
    ELSE.
      s_ZSPRO_AP-nomaint = abap_true.
      s_ZSPRO_AP-n_image = c_icon_table_nomaint.
    ENDIF.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_program.
    s_ZSPRO_AP-n_image = c_icon_prog.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_transac.
    s_ZSPRO_AP-n_image = c_icon_transac.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_url.
    PERFORM get_url_icon USING s_ZSPRO_AP-nodeparam
                         CHANGING s_ZSPRO_AP-n_image.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_img.
    s_ZSPRO_AP-n_image = c_icon_img.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_fm.
    s_ZSPRO_AP-n_image = c_icon_fm.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_cls.
    s_ZSPRO_AP-n_image = c_icon_cls.
  ELSE.
    s_ZSPRO_AP-n_image = c_icon_unknown.
  ENDIF.
  INSERT s_ZSPRO_AP INTO TABLE t_ZSPRO_AP.

* Add techname if relevant (not for url)
  IF w_techname = c_techname_on AND s_ZSPRO_AP-nodetype NE c_nodetype_url.
    IF NOT s_ZSPRO_AP-nodeparam IS INITIAL.
      CONCATENATE s_ZSPRO_AP-nodeparam &apos;-&apos; s_ZSPRO_AP-text INTO s_ZSPRO_AP-text
                  SEPARATED BY space.
    ENDIF.
  ENDIF.

  s_node = s_ZSPRO_AP.
  INSERT s_node INTO TABLE lt_node_table.

  CALL METHOD o_tree-&gt;add_nodes
    EXPORTING
      table_structure_name           = c_tree_table
      node_table                     = lt_node_table
    EXCEPTIONS
      failed                         = 1
      error_in_node_table            = 2
      dp_error                       = 3
      table_structure_name_not_found = 4
      OTHERS                         = 5.

  IF l_subfolder = abap_true.
*   Expand parent of the new node
    CALL METHOD o_tree-&gt;expand_node
      EXPORTING
        node_key = w_node_key.
  ENDIF.

  w_data_changed = abap_true.

ENDFORM.                    &quot; CREATE_FILE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  check_table
*&amp;---------------------------------------------------------------------*
*       Check if table exist and get text if not filled
*----------------------------------------------------------------------*
*      --&gt;FP_TABLE   Table to check
*      --&gt;FP_TEXT    Label of the table : empty if table does not exist
*----------------------------------------------------------------------*
FORM check_table  USING    fp_table TYPE ZSPRO_AP-nodeparam
                  CHANGING fp_text  TYPE ZSPRO_AP-text.
  DATA : l_tabname        TYPE tabname,
         l_dd02l_tabclass TYPE dd02l-tabclass,
         ls_dd25d         TYPE dd25v.
  l_tabname = fp_table.
  SELECT SINGLE tabclass FROM dd02l INTO l_dd02l_tabclass
           WHERE tabname EQ l_tabname
           AND as4local EQ c_state_active
           AND as4vers EQ &apos;0000&apos;.
  IF sy-subrc EQ 0.
* Table exists
* If text is not given, find it in the db
    IF NOT fp_text IS INITIAL.
      RETURN.
    ENDIF.
    IF l_dd02l_tabclass EQ &apos;VIEW&apos;.
      CALL FUNCTION &apos;DDIF_VIEW_GET&apos;
        EXPORTING
          name          = l_tabname
          state         = c_state_active
          langu         = sy-langu
        IMPORTING
          dd25v_wa      = ls_dd25d
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.
      IF sy-subrc &lt;&gt; 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ELSE.
        MOVE ls_dd25d-ddtext TO fp_text.
      ENDIF.
    ELSE.
      SELECT SINGLE ddtext FROM dd02t INTO fp_text
             WHERE tabname EQ l_tabname
             AND ddlanguage EQ sy-langu
             AND as4local EQ c_state_active
             AND as4vers EQ &apos;0000&apos;.
    ENDIF.

* Empty standard text =&gt; fill text with key
    IF fp_text IS INITIAL.
      fp_text = fp_table.
    ENDIF.
  ELSE.
* If table does not exists, clear text
    CLEAR fp_text.
  ENDIF.
ENDFORM.                    &quot; check_table

*&amp;---------------------------------------------------------------------*
*&amp;      Form  check_prog
*&amp;---------------------------------------------------------------------*
*       Check if program exist and get text if not filled
*----------------------------------------------------------------------*
*      --&gt;FP_PROG  Program to check
*      --&gt;FP_TEXT  Label of the program : empty if prog does not exist
*----------------------------------------------------------------------*
FORM check_prog   USING    fp_prog TYPE ZSPRO_AP-nodeparam
                  CHANGING fp_text TYPE ZSPRO_AP-text.
  DATA l_prog TYPE programm.
  l_prog = fp_prog.

  SELECT SINGLE name INTO l_prog
                FROM trdir
                WHERE name = l_prog.
  IF sy-subrc NE 0.
    CLEAR fp_text.
    RETURN.
  ENDIF.

  IF fp_text = space.
    SELECT SINGLE text INTO fp_text
                  FROM trdirt
                  WHERE name = l_prog
                  AND sprsl = sy-langu.
    IF sy-subrc NE 0.
      SELECT SINGLE text INTO fp_text
                    FROM trdirt
                    WHERE name = l_prog.                    &quot;#EC WARNOK
    ENDIF.
  ENDIF.

* Empty standard text =&gt; fill text with key
  IF fp_text = space.
    fp_text = fp_prog.
  endif.
ENDFORM.                    &quot; check_prog

*&amp;---------------------------------------------------------------------*
*&amp;      Form  check_cls
*&amp;---------------------------------------------------------------------*
*       Check if class exists and get text if not filled
*----------------------------------------------------------------------*
*      --&gt;FP_CLS   Class to check
*      --&gt;FP_TEXT  Label of the class : empty if class does not exist
*----------------------------------------------------------------------*
FORM check_cls   USING    fp_cls TYPE ZSPRO_AP-nodeparam
                 CHANGING fp_text TYPE ZSPRO_AP-text.

  DATA l_cls TYPE seoclsname.
  l_cls = fp_cls.

  SELECT SINGLE clsname INTO l_cls
                FROM seoclass
                WHERE clsname = l_cls.
  IF sy-subrc NE 0.
    CLEAR fp_text.
    RETURN.
  ENDIF.

  IF fp_text = space.
    SELECT SINGLE descript INTO fp_text
                  FROM seoclasstx
                  WHERE clsname = l_cls
                  AND langu = sy-langu.
    IF sy-subrc NE 0.
      SELECT SINGLE descript INTO fp_text
                    FROM seoclasstx
                    WHERE clsname = l_cls.                  &quot;#EC WARNOK
    ENDIF.
  ENDIF.

* Empty standard text =&gt; fill text with key
  IF fp_text = space.
    fp_text = fp_cls.
  endif.
ENDFORM.                    &quot; check_cls

*&amp;---------------------------------------------------------------------*
*&amp;      Form  check_transac
*&amp;---------------------------------------------------------------------*
*       Check if transaction exist and get text if not filled
*----------------------------------------------------------------------*
*      --&gt;FP_TRANSAC Transaction to check
*      --&gt;FP_TEXT    Label of the transaction : empty if dont exist
*----------------------------------------------------------------------*
FORM check_transac USING    fp_transac TYPE ZSPRO_AP-nodeparam
                   CHANGING fp_text TYPE ZSPRO_AP-text.
  DATA l_transac TYPE tstc-tcode.
  l_transac = fp_transac.

  SELECT SINGLE tcode INTO l_transac
                FROM tstc
                WHERE tcode = l_transac.
  IF sy-subrc NE 0.
    CLEAR fp_text.
    RETURN.
  ENDIF.

  IF fp_text = space.
    SELECT SINGLE ttext INTO fp_text
                  FROM tstct
                  WHERE tcode = l_transac
                  AND sprsl = sy-langu.
    IF sy-subrc NE 0.
      SELECT SINGLE ttext INTO fp_text
                    FROM tstct
                    WHERE tcode = l_transac.                &quot;#EC WARNOK
    ENDIF.
  ENDIF.

* Empty standard text =&gt; fill text with key
    IF fp_text IS INITIAL.
      fp_text = fp_transac.
    ENDIF.
ENDFORM.                    &quot; check_transac

*&amp;---------------------------------------------------------------------*
*&amp;      Form  check_img
*&amp;---------------------------------------------------------------------*
*       Check if SAP IMG Activity exist and get text if not filled
*----------------------------------------------------------------------*
*      --&gt;FP_IMG     IMG Activity
*      --&gt;FP_TEXT    Label of the activity : empty if dont exist
*----------------------------------------------------------------------*
FORM check_img USING    fp_img TYPE ZSPRO_AP-nodeparam
               CHANGING fp_text TYPE ZSPRO_AP-text.
  DATA l_img TYPE cus_acth-act_id.
  l_img = fp_img.

  SELECT SINGLE act_id INTO l_img
                FROM cus_acth
                WHERE act_id = l_img.
  IF sy-subrc NE 0.
    CLEAR fp_text.
    RETURN.
  ENDIF.

  IF fp_text = space.
    SELECT SINGLE text INTO fp_text
                  FROM cus_actt
                  WHERE act_id = l_img
                  AND spras = sy-langu.
    IF sy-subrc NE 0.
      SELECT SINGLE text INTO fp_text
                    FROM cus_actt
                    WHERE act_id = l_img.                   &quot;#EC WARNOK
    ENDIF.
  ENDIF.
ENDFORM.                    &quot; check_img

*&amp;---------------------------------------------------------------------*
*&amp;      Form  check_fm
*&amp;---------------------------------------------------------------------*
*       Check if function module exist and get text if not filled
*----------------------------------------------------------------------*
*      --&gt;FP_FM     Function module
*      --&gt;FP_TEXT   Label of the function : empty if dont exist
*----------------------------------------------------------------------*
FORM check_fm USING    fp_fm TYPE ZSPRO_AP-nodeparam
              CHANGING fp_text TYPE ZSPRO_AP-text.
  DATA l_fm TYPE tfdir-funcname.
  l_fm = fp_fm.

  SELECT SINGLE funcname INTO l_fm
         FROM tfdir
         WHERE funcname = l_fm.
  IF sy-subrc NE 0.
    CLEAR fp_text.
    RETURN.
  ENDIF.

  IF fp_text = space.
    SELECT SINGLE stext INTO fp_text
           FROM tftit
           WHERE funcname = l_fm
           AND spras = sy-langu.
    IF sy-subrc NE 0.
      SELECT SINGLE stext INTO fp_text
             FROM tftit
             WHERE funcname = l_fm.                         &quot;#EC WARNOK
    ENDIF.
  ENDIF.

* Empty standard text =&gt; fill text with key
    IF fp_text IS INITIAL.
      fp_text = fp_fm.
    ENDIF.
ENDFORM.                    &quot; check_fm

*&amp;---------------------------------------------------------------------*
*&amp;      Form  RENAME_NODE
*&amp;---------------------------------------------------------------------*
*       Rename node
*----------------------------------------------------------------------*
FORM rename_node.
  DATA : l_tabix LIKE sy-tabix,
         l_rc    TYPE c.

* Get node to rename
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = w_node_key.
  IF w_node_key IS INITIAL.
    RETURN.
  ENDIF.

  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  l_tabix = sy-tabix.

* Prompt for table/programm/folder name
  PERFORM popup_get_value USING    s_ZSPRO_AP-isfolder
                          CHANGING s_ZSPRO_AP-nodetype
                                   s_ZSPRO_AP-nodeparam
                                   s_ZSPRO_AP-text
                                   l_rc.
  IF l_rc NE space AND l_rc NE 0.
    RETURN.
  ENDIF.

  IF s_ZSPRO_AP-nodetype = c_nodetype_url.
    PERFORM get_url_icon USING s_ZSPRO_AP-nodeparam
                         CHANGING s_ZSPRO_AP-n_image.
  ENDIF.

* Node to be updated in table ZSPRO_AP
  s_ZSPRO_AP-updated = abap_true.

  MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP INDEX l_tabix.

* Add techname if relevant (not for url
  IF w_techname = c_techname_on AND s_ZSPRO_AP-nodetype NE c_nodetype_url.
    IF NOT s_ZSPRO_AP-nodeparam IS INITIAL.
      CONCATENATE s_ZSPRO_AP-nodeparam &apos;-&apos; s_ZSPRO_AP-text INTO s_ZSPRO_AP-text
                  SEPARATED BY space.
    ENDIF.
  ENDIF.

* Modify the node text
  CALL METHOD o_tree-&gt;node_set_text
    EXPORTING
      node_key = w_node_key
      text     = s_ZSPRO_AP-text.

* Modify icon for url
  IF s_ZSPRO_AP-nodetype = c_nodetype_url.
    CALL METHOD o_tree-&gt;node_set_n_image
      EXPORTING
        node_key = w_node_key
        n_image  = s_ZSPRO_AP-n_image.
  ENDIF.

  w_data_changed = abap_true.
ENDFORM.                    &quot; RENAME_NODE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  SAVE_TREE
*&amp;---------------------------------------------------------------------*
*       Save tree changes in the DB (ZSPRO_AP DB Table)
*----------------------------------------------------------------------*
FORM save_tree.
* Check that changes are done
  IF w_data_changed IS INITIAL.
    MESSAGE &apos;Saving not necessary. No changes were made&apos;(m05)
            TYPE c_msg_succes.
  ELSE.
* Delete entries that has been deleted
    IF NOT r_ZSPRO_AP_del IS INITIAL.
      DELETE FROM ZSPRO_AP WHERE node_key IN r_ZSPRO_AP_del.
    ENDIF.
    REFRESH r_ZSPRO_AP_del.

* Add/change entries that has been changed/created
    LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP.
      CHECK s_ZSPRO_AP-new_line = abap_true OR s_ZSPRO_AP-updated = abap_true.
      IF s_ZSPRO_AP-new_line = abap_true.
        CLEAR : s_ZSPRO_AP-new_line, s_ZSPRO_AP-updated.
        MOVE-CORRESPONDING s_ZSPRO_AP TO s_ZSPRO_AP_upd.
        INSERT ZSPRO_AP FROM s_ZSPRO_AP_upd.
      ELSEIF s_ZSPRO_AP-updated = abap_true.
        CLEAR s_ZSPRO_AP-updated.
        MOVE-CORRESPONDING s_ZSPRO_AP TO s_ZSPRO_AP_upd.
        UPDATE ZSPRO_AP FROM s_ZSPRO_AP_upd.
      ENDIF.
      MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP TRANSPORTING new_line updated.
    ENDLOOP.
    CLEAR w_data_changed.
    MESSAGE &apos;Data saved successfully&apos;(m06) TYPE c_msg_succes.
  ENDIF.
ENDFORM.                    &quot; SAVE_TREE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  FONCTION_BACK
*&amp;---------------------------------------------------------------------*
*  Leave transaction
*  In change mode, ask to save before extif a modification is done
*----------------------------------------------------------------------*
FORM fonction_back.
  DATA : l_message(70) TYPE c,
         l_titel(50)   TYPE c, &quot;Message text variable
         l_answer      TYPE c. &quot;Popup to decide return code

* If data changed, ask to save before exit
  IF w_data_changed = abap_true.
    l_message = &apos;Do you wish to save your data first ?&apos;(m18).
    l_titel = &apos;Exit from specific customizing&apos;(m02).

    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        titlebar              = l_titel
        text_question         = l_message
        default_button        = &apos;1&apos;
        display_cancel_button = abap_true
      IMPORTING
        answer                = l_answer.

    IF l_answer = &apos;1&apos;.
      okcode = &apos;SAVE&apos;.
    ELSEIF l_answer = &apos;2&apos;.
      CLEAR w_mode_change.
      CLEAR w_first_time.
      CALL FUNCTION &apos;VIEW_ENQUEUE&apos;
        EXPORTING
          action       = c_action_dequeue
          enqueue_mode = c_enqueue_mode_exclusive
          view_name    = c_tree_table.
      LEAVE PROGRAM.
    ENDIF.

* If no data changed, exit directly
  ELSE.                  &quot; Display mode or unchanged data
    IF w_mode_change = abap_true.
      CLEAR w_mode_change.
      CLEAR w_first_time.
      CALL FUNCTION &apos;VIEW_ENQUEUE&apos;
        EXPORTING
          action       = c_action_dequeue
          enqueue_mode = c_enqueue_mode_exclusive
          view_name    = c_tree_table.
    ENDIF.
    LEAVE PROGRAM.
  ENDIF.
ENDFORM.                    &quot; FONCTION_BACK

*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_ot
*&amp;---------------------------------------------------------------------*
*       Create transport request with all tree nodes
*----------------------------------------------------------------------*
FORM create_ot .
*  TYPE-POOLS trwbo.
*
*  DATA : lt_e071_empty TYPE TABLE OF e071,
*         lt_e071       TYPE TABLE OF ko200,
*         ls_e071       LIKE LINE OF lt_e071,
*         lt_e071k      TYPE e071k OCCURS 0 WITH HEADER LINE.
*  DATA l_ot TYPE trkorr.
** Ask for Transport request number
*  CALL FUNCTION &apos;TRINT_ORDER_CHOICE&apos;
*    IMPORTING
*      we_order = l_ot
*    TABLES
*      wt_e071  = lt_e071_empty
*      wt_e071k = lt_e071k
*    EXCEPTIONS
*      OTHERS   = 6.
*  IF sy-subrc &lt;&gt; 0.
*    MESSAGE &apos;Action cancelled&apos;(m22) TYPE c_msg_error.
*    RETURN.
*  ENDIF.
*
*  REFRESH lt_e071.
*  CLEAR ls_e071.
*  ls_e071-as4pos = 1.
*  ls_e071-pgmid = &apos;R3TR&apos;.
*  ls_e071-object = &apos;TABU&apos;.
*  ls_e071-obj_name = c_tree_table.
*  ls_e071-objfunc = &apos;K&apos;.
*  APPEND ls_e071 TO lt_e071.
*
*  REFRESH lt_e071k.
*  CLEAR lt_e071k.
*  lt_e071k-pgmid = ls_e071-pgmid.
*  lt_e071k-object = ls_e071-object.
*  lt_e071k-objname = ls_e071-obj_name.
*  lt_e071k-mastertype = ls_e071-object.
*  lt_e071k-mastername = ls_e071-obj_name.
*  lt_e071k-as4pos = sy-tabix.
*  lt_e071k-tabkey = &apos;*&apos;.
*  APPEND lt_e071k.
*
*  CALL FUNCTION &apos;SMGF_TRANSPORT_ADD_OBJECTS&apos;
*    TABLES
*      wt_e071    = lt_e071
*      wt_e071k   = lt_e071k
*    CHANGING
*      ta_request = l_ot.
*  MESSAGE &apos;Tree successfully included in transport request&apos;(m09)
*          TYPE c_msg_succes.
  DATA : ls_object  TYPE rs_s_tr_object,
         lt_objects LIKE TABLE OF ls_object,
         lt_msg     TYPE rs_t_msg,
         ls_msg     LIKE LINE OF lt_msg.

  ls_object-object = &apos;TABU&apos;.
  ls_object-obj_name = c_tree_table.
  APPEND ls_object TO lt_objects.

* Add table entries to request
  CALL FUNCTION &apos;RS_TR_WRITE_OBJECTS_TO_REQUEST&apos;
    EXPORTING
      i_t_tr_object = lt_objects
    IMPORTING
      e_t_msg       = lt_msg.

* Display return message
  READ TABLE lt_msg INTO ls_msg INDEX 1.
  MESSAGE ID ls_msg-msgid TYPE ls_msg-msgty NUMBER ls_msg-msgno
          WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.

ENDFORM.                    &quot; create_ot

*&amp;---------------------------------------------------------------------*
*&amp;      Form  renum_nodes
*&amp;---------------------------------------------------------------------*
*       Rebuild sort number of all childrens of given node
*       Used for drag folder in a drap/drop operation
*----------------------------------------------------------------------*
*      --&gt;l_node_key : Folder which children must be reordered
*----------------------------------------------------------------------*
FORM renum_nodes USING l_nodekey TYPE ZSPRO_AP-node_key.
  DATA : lt_ZSPRO_AP LIKE TABLE OF s_ZSPRO_AP,
         ls_ZSPRO_AP LIKE LINE OF lt_ZSPRO_AP,
         l_count  TYPE i.

  lt_ZSPRO_AP = t_ZSPRO_AP.
  SORT lt_ZSPRO_AP BY relatkey sort.
  CLEAR l_count.
  LOOP AT lt_ZSPRO_AP INTO ls_ZSPRO_AP WHERE relatkey = l_nodekey.
    ADD 1 TO l_count.
    IF l_count NE ls_ZSPRO_AP-sort.
      ls_ZSPRO_AP-sort = l_count.
      ls_ZSPRO_AP-updated = abap_true.
      MODIFY lt_ZSPRO_AP FROM ls_ZSPRO_AP TRANSPORTING updated sort.
      w_data_changed = abap_true.
    ENDIF.
  ENDLOOP.
  SORT lt_ZSPRO_AP BY node_key.
  t_ZSPRO_AP = lt_ZSPRO_AP.
ENDFORM.                    &quot; renum_nodes

*&amp;---------------------------------------------------------------------*
*&amp;      Form  move
*&amp;---------------------------------------------------------------------*
*       Move a node in the same folder
*----------------------------------------------------------------------*
*      --&gt;delta : To know if node go up or down
*----------------------------------------------------------------------*
FORM move USING delta TYPE i.
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = w_node_key.
  IF w_node_key IS INITIAL.
    RETURN.
  ENDIF.
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  s_ZSPRO_AP-sort = s_ZSPRO_AP-sort + delta.
  IF s_ZSPRO_AP-sort LT 1.
    RETURN.
  ENDIF.
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY relatkey = s_ZSPRO_AP-relatkey
                                           sort = s_ZSPRO_AP-sort.
* If destination node not found, try to renum all children of the parent
  IF sy-subrc NE 0.
    PERFORM renum_nodes USING s_ZSPRO_AP-relatkey.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
    s_ZSPRO_AP-sort = s_ZSPRO_AP-sort + delta.
    IF s_ZSPRO_AP-sort LT 1.
      RETURN.
    ENDIF.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY relatkey = s_ZSPRO_AP-relatkey
                                             sort = s_ZSPRO_AP-sort.
  ENDIF.
  IF sy-subrc NE 0.
    RETURN.
  ENDIF.
  s_ZSPRO_AP-sort = s_ZSPRO_AP-sort - delta.
  s_ZSPRO_AP-updated = abap_true.
  MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP INDEX sy-tabix
                 TRANSPORTING updated sort.

* Move the node regarding his sibbling
  IF delta = 1.
    CALL METHOD o_tree-&gt;move_node
      EXPORTING
        node_key  = w_node_key
        relatkey  = s_ZSPRO_AP-node_key
        relatship = cl_gui_simple_tree=&gt;relat_next_sibling.
  ELSE.
    CALL METHOD o_tree-&gt;move_node
      EXPORTING
        node_key  = w_node_key
        relatkey  = s_ZSPRO_AP-node_key
        relatship = cl_gui_simple_tree=&gt;relat_prev_sibling.
  ENDIF.

  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  s_ZSPRO_AP-sort = s_ZSPRO_AP-sort + delta.
  s_ZSPRO_AP-updated = abap_true.
  MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP INDEX sy-tabix
                 TRANSPORTING updated sort.
  w_data_changed = abap_true.

* If a node move, reset find structure
  CLEAR s_find.
ENDFORM.                    &quot; move

*&amp;---------------------------------------------------------------------*
*&amp;      Form  init_html
*&amp;---------------------------------------------------------------------*
*       Initialization of html object
*----------------------------------------------------------------------*
FORM init_html.
  DATA : l_program TYPE ZSPRO_AP-nodeparam,
         lt_events TYPE cntl_simple_events,
         ls_event  TYPE cntl_simple_event.

* Create html object
  IF o_html_control IS INITIAL.
    CREATE OBJECT o_html_control
      EXPORTING
        parent = o_container_right.

    ls_event-eventid = o_html_control-&gt;m_id_sapevent.
    ls_event-appl_event = &apos;x&apos;.
    APPEND ls_event TO lt_events.
    CALL METHOD o_html_control-&gt;set_registered_events
      EXPORTING
        events = lt_events.

    SET HANDLER o_application-&gt;handle_link_clic_html FOR o_html_control.
  ENDIF.

  CASE s_ZSPRO_AP-nodetype.
* For table, display table informations
    WHEN c_nodetype_table.
      PERFORM write_html_table USING s_ZSPRO_AP-nodeparam.
* For program, display program informations
    WHEN c_nodetype_program.
      PERFORM write_html_prog USING s_ZSPRO_AP-nodeparam.
* For transaction, display program informations
    WHEN c_nodetype_transac.
      SELECT SINGLE pgmna INTO l_program
             FROM tstc
             WHERE tcode = s_ZSPRO_AP-nodeparam.
      IF sy-subrc = 0 AND l_program NE space.
        PERFORM write_html_prog USING l_program.
      ENDIF.
* For SAP IMG activity, display associated help
    WHEN c_nodetype_img.
      PERFORM write_html_obj USING s_ZSPRO_AP-nodeparam c_doctype_img.
* For Function module, display documentation
    WHEN c_nodetype_fm.
      &quot;PERFORM write_html_fm USING s_ZSPRO_AP-nodeparam.
      PERFORM write_html_obj USING s_ZSPRO_AP-nodeparam c_doctype_fm.
    WHEN c_nodetype_cls.
      PERFORM write_html_obj USING s_ZSPRO_AP-nodeparam c_doctype_cls.
*    WHEN c_nodetype_url.
* No specific right part for link, display default
    WHEN OTHERS.
      PERFORM write_html_default.
  ENDCASE.

ENDFORM.                    &quot; init_html

*&amp;---------------------------------------------------------------------*
*&amp;      Form  write_html_default
*&amp;---------------------------------------------------------------------*
*       Display default background for right part of the screen
*----------------------------------------------------------------------*
FORM write_html_default.
  DATA : lw_url(2048) TYPE c,
         lt_pic_data  LIKE w3mime OCCURS 0,
         lw_pic_size  TYPE i,
         lw_pic       TYPE string.

  DATA : ls_data_pic TYPE htmlline,
         lt_data_pic TYPE  htmltable.

  DEFINE htmlp.
    ls_data_pic = &amp;1.
    append ls_data_pic to lt_data_pic.
  END-OF-DEFINITION.

  IF o_pic IS INITIAL.
    CREATE OBJECT o_pic EXPORTING parent = o_container_right.
    CALL METHOD o_pic-&gt;set_display_mode
      EXPORTING
        display_mode = cl_gui_picture=&gt;display_mode_fit_center.
    IF c_welcome_bg IS INITIAL.
      lw_pic = &apos;HTMLCNTL_TESTHTM2_SAP_AG&apos;.
    ELSE.
      lw_pic = c_welcome_bg.
    ENDIF.
    PERFORM load_pic_from_db
            TABLES lt_pic_data
            USING lw_pic
            CHANGING lw_pic_size.

* Request an URL from the data provider by exporting the pic_data.
    CLEAR lw_url.
    CALL FUNCTION &apos;DP_CREATE_URL&apos;
      EXPORTING
        type     = &apos;image&apos;
        subtype  = cndp_sap_tab_unknown
        size     = lw_pic_size
        lifetime = cndp_lifetime_transaction
      TABLES
        data     = lt_pic_data
      CHANGING
        url      = lw_url
      EXCEPTIONS
        OTHERS   = 1.

    CALL METHOD o_pic-&gt;load_picture_from_url
      EXPORTING
        url = lw_url.
  ENDIF.
  o_html_control-&gt;set_visible( abap_false ).
  o_pic-&gt;set_visible( abap_true ).

ENDFORM.

*---------------------------------------------------------------------*
*       FORM load_pic_from_db                                         *
*---------------------------------------------------------------------*
*       Load given picture from Web Repository                        *
*---------------------------------------------------------------------*
FORM load_pic_from_db
     TABLES ft_pic_data
     USING fw_pic_name
     CHANGING fw_pic_size.
  DATA : lt_query_table    LIKE w3query OCCURS 1 WITH HEADER LINE,
         lt_html_table     LIKE w3html OCCURS 1,
         lw_return_code    LIKE  w3param-ret_code,
         lw_content_type   LIKE  w3param-cont_type,
         lw_content_length LIKE  w3param-cont_len.

  CLEAR lt_query_table.
  lt_query_table-name = &apos;_OBJECT_ID&apos;.
  lt_query_table-value = fw_pic_name.
  APPEND lt_query_table.

  CALL FUNCTION &apos;WWW_GET_MIME_OBJECT&apos;
    TABLES
      query_string        = lt_query_table
      html                = lt_html_table
      mime                = ft_pic_data
    CHANGING
      return_code         = lw_return_code
      content_type        = lw_content_type
      content_length      = lw_content_length
    EXCEPTIONS
      invalid_table       = 1
      parameter_not_found = 2
      OTHERS              = 3.
  IF sy-subrc = 0.
    fw_pic_size = lw_content_length.
  ENDIF.
ENDFORM.

*&amp;---------------------------------------------------------------------*
*&amp;      Form  write_html_table
*&amp;---------------------------------------------------------------------*
*       Display table info in HTML format
*----------------------------------------------------------------------*
*      --&gt;FP_TABLE   table name
*----------------------------------------------------------------------*
FORM write_html_table USING fp_table TYPE ZSPRO_AP-nodeparam.
  DATA : ls_data_table  TYPE htmlline,
         lt_data_table  TYPE  htmltable,
         l_url(2048),
         lt_sel         LIKE TABLE OF vimsellist WITH HEADER LINE,
         lt_head        LIKE TABLE OF vimdesc WITH HEADER LINE,
         lt_tab         LIKE TABLE OF vimnamtab WITH HEADER LINE,
         l_object       TYPE  doku_obj,
         lt_lines       LIKE TABLE OF tline WITH HEADER LINE,
         l_docu_to_html TYPE REF TO cl_epss_docu_to_html,
         l_n            TYPE i,
         l_mandant(1)   TYPE c,
         lt_nametab     TYPE TABLE OF dntab WITH HEADER LINE,
         l_table        TYPE tabname,
         l_tabletxt     TYPE dd08v-tabname.

  DEFINE htmlt.
    ls_data_table = &amp;1.
    append ls_data_table to lt_data_table.
  END-OF-DEFINITION.

  l_table = fp_table.

  CALL FUNCTION &apos;VIEW_GET_DDIC_INFO&apos;
    EXPORTING
      viewname        = l_table
    TABLES
      sellist         = lt_sel
      x_header        = lt_head
      x_namtab        = lt_tab
    EXCEPTIONS
      no_tvdir_entry  = 1
      table_not_found = 2
      OTHERS          = 3.
  CASE sy-subrc.
    WHEN 1.
*  l_nomaint = abap_true.
    WHEN 0.
*  l_nomaint = space.
    WHEN OTHERS.
      RETURN.
  ENDCASE.

  l_object = fp_table.

  SELECT SINGLE object INTO l_object
         FROM  dokil
         WHERE id         = c_doctype_table
         AND   object     = l_object
         AND   langu      = sy-langu
         AND   typ        = c_doktyp_enduser.
  IF sy-subrc EQ 0.
    CALL FUNCTION &apos;DOCU_GET&apos;
      EXPORTING
        id     = c_doctype_table
        object = l_object
        langu  = sy-langu
      TABLES
        line   = lt_lines
      EXCEPTIONS
        OTHERS = 2.
    IF sy-subrc NE 0.
      CLEAR lt_lines.
    ENDIF.
  ELSE.
    SELECT SINGLE object INTO l_object
           FROM  dokil
           WHERE id         = c_doctype_table
           AND   object     = l_object
           AND   langu      = c_langu_default
           AND   typ        = c_doktyp_enduser.

    IF sy-subrc EQ 0.
      CALL FUNCTION &apos;DOCU_GET&apos;
        EXPORTING
          id     = c_doctype_table
          object = l_object
          langu  = c_langu_default
        TABLES
          line   = lt_lines
        EXCEPTIONS
          OTHERS = 2.
      IF sy-subrc NE 0.
        CLEAR lt_lines.
      ENDIF.
    ENDIF.
  ENDIF.

* If no maint view title found, search table title
  IF lt_head-ddtext IS INITIAL.
    SELECT SINGLE ddtext INTO lt_head-ddtext
           FROM dd02t
           WHERE tabname = l_table
           AND as4local = c_state_active
           AND ddlanguage = sy-langu
           AND as4vers = space. &quot;not used field
    IF sy-subrc NE 0.
      SELECT SINGLE ddtext INTO lt_head-ddtext
             FROM dd02t
             WHERE tabname = l_table
             AND as4local = c_state_active
             AND ddlanguage = c_langu_default
             AND as4vers = space. &quot;not used field
    ENDIF.
  ENDIF.

* Write Header tags
  REFRESH lt_data_table.
  htmlt &apos;&lt;html&gt;&apos;.
  htmlt &apos;&lt;title&gt;Table info&lt;/title&gt;&apos;.
  htmlt &apos;&lt;body bgcolor=#EEF4FB&gt;&apos;.
  htmlt &apos;&lt;table width=100%&gt;&lt;tr&gt;&apos;.
  htmlt &apos;&lt;td align=&quot;center&quot; colspan=2&gt;&lt;strong&gt;&apos;.
  htmlt fp_table.
  htmlt &apos;-&apos;.
  htmlt lt_head-ddtext.
  htmlt &apos;&lt;/strong&gt;&lt;br&gt;&amp;nbsp;&apos;.
  htmlt &apos;&lt;/td&gt;&lt;/tr&gt;&apos;.

* If doc found, display it in html
  IF NOT lt_lines[] IS INITIAL.
* Create doc html converter
    CREATE OBJECT l_docu_to_html.
    CONCATENATE &apos;DS:&apos; c_doctype_table &apos;.&apos; l_object
                INTO l_docu_to_html-&gt;doc_link.
* Load doc into converter
    l_docu_to_html-&gt;itflines = lt_lines[].
* Convert doc into html
    CALL METHOD l_docu_to_html-&gt;convert_itf_to_html.
    CALL METHOD l_docu_to_html-&gt;add_sapicons_to_html.

* Delete end tags &lt;/body&gt; and &lt;/html&gt;
    DESCRIBE TABLE l_docu_to_html-&gt;htmllines LINES l_n.
    DELETE l_docu_to_html-&gt;htmllines INDEX l_n.
    l_n = l_n - 1.
    DELETE l_docu_to_html-&gt;htmllines INDEX l_n.

* Delete all header until &lt;body&gt;
    LOOP AT l_docu_to_html-&gt;htmllines INTO ls_data_table.
      TRANSLATE ls_data_table TO UPPER CASE.
      CONDENSE ls_data_table NO-GAPS.
      DELETE l_docu_to_html-&gt;htmllines.
      IF ls_data_table(5) NE &apos;&lt;BODY&apos;.
        CONTINUE.
      ELSE.
        EXIT.
      ENDIF.
    ENDLOOP.

* Write doc
    htmlt &apos;&lt;tr&gt;&lt;td colspan=2&gt;&apos;.
    APPEND LINES OF l_docu_to_html-&gt;htmllines TO lt_data_table.
    htmlt &apos;&lt;hr color=black&gt;&lt;br&gt;&apos;.
    htmlt &apos;&lt;/td&gt;&lt;/tr&gt;&apos;.
  ENDIF.

  CLEAR l_mandant.
* Display maintenance view fields
  LOOP AT lt_tab.
    IF lt_tab-domname = &apos;MANDT&apos; AND sy-tabix = 1.
      l_mandant = abap_true.
    ELSE.
      htmlt &apos;&lt;tr&gt;&lt;td&gt;&apos;.
      htmlt lt_tab-viewfield.
      htmlt &apos;&lt;/td&gt;&lt;td&gt;&apos;.
      htmlt lt_tab-scrtext.
      htmlt &apos;&lt;/td&gt;&lt;/tr&gt;&apos;.
    ENDIF.
  ENDLOOP.
  IF sy-subrc NE 0.
* If no maintenance view exists, inform user and get table fields
    htmlt &apos;&lt;tr&gt;&lt;td colspan=2 align=center&gt;&lt;strong&gt;&apos;.
    htmlt &apos;NO MAINTENANCE VIEW FOR THIS TABLE&apos;(004).
    htmlt &apos;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&apos;.

    CALL FUNCTION &apos;NAMETAB_GET&apos;
      EXPORTING
        langu               = sy-langu
        tabname             = l_table
      TABLES
        nametab             = lt_nametab
      EXCEPTIONS
        internal_error      = 1
        table_has_no_fields = 2
        table_not_activ     = 3
        no_texts_found      = 4
        OTHERS              = 5.
    IF sy-subrc EQ 0.
      htmlt &apos;&lt;tr&gt;&lt;td colspan=2&gt;&lt;br&gt;&lt;hr color=black&gt;&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&apos;.
      LOOP AT lt_nametab.
        IF lt_nametab-fieldname = &apos;MANDT&apos; AND sy-tabix = 1.
          l_mandant = abap_true.
        ELSE.
          htmlt &apos;&lt;tr&gt;&lt;td&gt;&apos;.
          htmlt lt_nametab-fieldname.
          htmlt &apos;&lt;/td&gt;&lt;td&gt;&apos;.
          htmlt lt_nametab-fieldtext.
          htmlt &apos;&lt;/td&gt;&lt;/tr&gt;&apos;.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.

* Add mandant dependance
  htmlt &apos;&lt;tr&gt;&lt;td colspan=2&gt;&lt;br&gt;&apos;.
  htmlt &apos;Data depend on mandant :&apos;(001).
  htmlt &apos;&lt;strong&gt;&apos;.
  IF l_mandant IS INITIAL.
    htmlt &apos;No&apos;(003).
  ELSE.
    htmlt &apos;Yes&apos;(002).
  ENDIF.
  htmlt &apos;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&apos;.

* Add text table info
  CALL FUNCTION &apos;DDUT_TEXTTABLE_GET&apos;
    EXPORTING
      tabname   = l_table
    IMPORTING
      texttable = l_tabletxt.
  IF l_tabletxt IS INITIAL.
    l_tabletxt = &apos;-&apos;.
  ENDIF.
  htmlt &apos;&lt;tr&gt;&lt;td colspan=2&gt;&lt;br&gt;&apos;.
  htmlt &apos;Associated text table :&apos;(005).
  htmlt &apos;&lt;strong&gt;&apos;.
  htmlt l_tabletxt.
  htmlt &apos;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&apos;.

* Write end tags
  htmlt &apos;&lt;/table&gt;&apos;.
  htmlt &apos;&lt;/body&gt;&lt;/html&gt;&apos;.

* Generate url from html data
  CALL METHOD o_html_control-&gt;load_data
    IMPORTING
      assigned_url = l_url
    CHANGING
      data_table   = lt_data_table.

* Display page
  CALL METHOD o_html_control-&gt;show_url
    EXPORTING
      url = l_url.
  o_pic-&gt;set_visible( abap_false ).
  o_html_control-&gt;set_visible( abap_true ).

ENDFORM.                    &quot;write_html_table

*&amp;---------------------------------------------------------------------*
*&amp;      Form  write_html_prog
*&amp;---------------------------------------------------------------------*
*       Display program info in HTML format
*----------------------------------------------------------------------*
*      --&gt;FP_PROG    Program name
*----------------------------------------------------------------------*
FORM write_html_prog USING fp_prog TYPE ZSPRO_AP-nodeparam.
  DATA : l_object           TYPE doku_obj,
         ls_data_table      TYPE htmlline,
         lt_data_table      LIKE TABLE OF ls_data_table,
         lt_lines           LIKE TABLE OF tline WITH HEADER LINE,
         l_docu_to_html     TYPE REF TO cl_epss_docu_to_html,
         l_n                TYPE i,
         l_url(2048),
         l_report           TYPE string,
         l_report_char1(1)  TYPE c,
         lt_report          LIKE TABLE OF l_report,
         l_comment_found(1) TYPE c,
         l_prog             TYPE programm,
         l_style(1)         TYPE c,
         l_open(1)          TYPE c.

  DEFINE htmlp.
    ls_data_table = &amp;1.
    append ls_data_table to lt_data_table.
  END-OF-DEFINITION.

  l_object = fp_prog.
* Get doc language
  SELECT SINGLE object INTO l_object
         FROM  dokil
         WHERE id         = c_doctype_prog
         AND   object     = l_object
         AND   langu      = sy-langu
         AND   typ        = c_doktyp_enduser.
  IF sy-subrc EQ 0.
    CALL FUNCTION &apos;DOCU_GET&apos;
      EXPORTING
        id     = c_doctype_prog
        object = l_object
        langu  = sy-langu
      TABLES
        line   = lt_lines
      EXCEPTIONS
        OTHERS = 2.
    IF sy-subrc NE 0.
      CLEAR lt_lines.
    ENDIF.
  ELSE.
    SELECT SINGLE object INTO l_object
           FROM  dokil
           WHERE id         = c_doctype_prog
           AND   object     = l_object
           AND   langu      = c_langu_default
           AND   typ        = c_doktyp_enduser.

    IF sy-subrc EQ 0.
      CALL FUNCTION &apos;DOCU_GET&apos;
        EXPORTING
          id     = c_doctype_prog
          object = l_object
          langu  = c_langu_default
        TABLES
          line   = lt_lines
        EXCEPTIONS
          OTHERS = 2.
      IF sy-subrc NE 0.
        CLEAR lt_lines.
      ENDIF.
    ENDIF.
  ENDIF.

* Write Header tags
  REFRESH lt_data_table.
  htmlp &apos;&lt;html&gt;&apos;.
  htmlp &apos;&lt;title&gt;Program info&lt;/title&gt;&apos;.
  htmlp &apos;&lt;style type=&quot;text/css&quot;&gt;&apos;.
  htmlp &apos;p{margin:0;}&apos;.
  htmlp &apos;.spacer{margin-top:10px;}&apos;.
  htmlp &apos;.code{font-family:courier;}&apos;.
  htmlp &apos;&lt;/style&gt;&apos;.
  htmlp &apos;&lt;body bgcolor=#EEF4FB&gt;&apos;.

* If doc found, display it in html
  IF NOT lt_lines[] IS INITIAL.
* Create doc html converter
    CREATE OBJECT l_docu_to_html.
    CONCATENATE &apos;DS:&apos; c_doctype_prog &apos;.&apos; l_object
                INTO l_docu_to_html-&gt;doc_link.
* Load doc into converter
    l_docu_to_html-&gt;itflines = lt_lines[].
* Convert doc into html
    CALL METHOD l_docu_to_html-&gt;convert_itf_to_html.
    CALL METHOD l_docu_to_html-&gt;add_sapicons_to_html.

* Delete end tags &lt;/body&gt; and &lt;/html&gt;
    DESCRIBE TABLE l_docu_to_html-&gt;htmllines LINES l_n.
    DELETE l_docu_to_html-&gt;htmllines INDEX l_n.
    l_n = l_n - 1.
    DELETE l_docu_to_html-&gt;htmllines INDEX l_n.

* Delete all header until &lt;body&gt;
    LOOP AT l_docu_to_html-&gt;htmllines INTO ls_data_table.
      TRANSLATE ls_data_table TO UPPER CASE.
      CONDENSE ls_data_table NO-GAPS.
      DELETE l_docu_to_html-&gt;htmllines.
      IF ls_data_table(5) NE &apos;&lt;BODY&apos;.
        CONTINUE.
      ELSE.
        EXIT.
      ENDIF.
    ENDLOOP.

* Write doc
    APPEND LINES OF l_docu_to_html-&gt;htmllines TO lt_data_table.
  ELSE.
* if no help is found, display the header of the program
    l_prog = fp_prog.
    READ REPORT l_prog INTO lt_report.
    CLEAR l_comment_found.
    CLEAR l_open.
    LOOP AT lt_report INTO l_report.
      l_report_char1 = l_report.
      IF l_report_char1 NE &apos;*&apos;.
        IF l_comment_found = abap_true.
          EXIT.
        ELSE.
          CONTINUE.
        ENDIF.
      ELSE.
        l_comment_found = abap_true.
        l_report = l_report+1.
        CLEAR l_style.
        IF NOT l_report IS INITIAL AND l_report(1) CA &apos;&amp;=23E&apos;.
          l_style = l_report(1).
          l_report = l_report+1.
        ENDIF.

* Try top remove &amp;* at end of line
        if not l_report is initial.
          l_n = strlen( l_report ) - 1.
          if l_report+l_n(1) = &apos;*&apos;.
            l_report = l_report(l_n).
            l_n = l_n - 1.
            if l_n gt 0 and l_report+l_n(1) = &apos;&amp;&apos;.
              l_report = l_report(l_n).
            endif.
          endif.
        endif.
        IF l_report IS INITIAL or l_report co &apos;*&amp; &apos;.
          IF l_open = abap_true.
            htmlp &apos;&lt;/p&gt;&apos;.
            CLEAR l_open.
          ENDIF.
          htmlp &apos;&lt;p class=&quot;spacer&quot;&gt; &lt;/p&gt;&apos;.
        ELSEIF l_report CO &apos;*&amp;-&apos; AND l_report CA &apos;-&apos;.
          IF l_open = abap_true.
            htmlp &apos;&lt;/p&gt;&apos;.
            CLEAR l_open.
          ENDIF.
          htmlp &apos;&lt;hr&gt;&apos;.
        ELSEIF NOT l_style IS INITIAL.
          CASE l_style.
            WHEN &apos;3&apos;.
              IF l_open = abap_true.
                htmlp &apos;&lt;/p&gt;&apos;.
                CLEAR l_open.
              ENDIF.
              CONCATENATE &apos;&lt;h3&gt;&apos; l_report &apos;&lt;/h3&gt;&apos; INTO l_report.
              htmlp l_report.
            WHEN &apos;2&apos;.
              IF l_open = abap_true.
                htmlp &apos;&lt;/p&gt;&apos;.
                CLEAR l_open.
              ENDIF.
              CONCATENATE &apos;&lt;h2&gt;&apos; l_report &apos;&lt;/h2&gt;&apos; INTO l_report.
              htmlp l_report.
            WHEN &apos;=&apos;.
              htmlp l_report.
            WHEN &apos;E&apos;.
              IF l_open = abap_true.
                htmlp &apos;&lt;/p&gt;&apos;.
                CLEAR l_open.
              ENDIF.
              htmlp &apos;&lt;p class=&quot;code&quot;&gt;&apos;.
              htmlp l_report.
              l_open = abap_true.
            WHEN OTHERS.
              IF l_open = abap_true.
                htmlp &apos;&lt;/p&gt;&apos;.
                CLEAR l_open.
              ENDIF.
              htmlp &apos;&lt;p&gt;&apos;.
              htmlp l_report.
              l_open = abap_true.
          ENDCASE.
        ELSE.
          IF l_open = abap_true.
            htmlp &apos;&lt;/p&gt;&apos;.
            CLEAR l_open.
          ENDIF.
          htmlp &apos;&lt;p&gt;&apos;.
          htmlp l_report.
          l_open = abap_true.
        ENDIF.
      ENDIF.
    ENDLOOP.
    IF sy-subrc NE 0 OR NOT l_comment_found = abap_true.
      htmlp &apos;&lt;p align=&quot;center&quot;&gt;No Help for this program&lt;/p&gt;&apos;.
    ENDIF.
    IF l_open = abap_true.
      htmlp &apos;&lt;/p&gt;&apos;.
      CLEAR l_open.
    ENDIF.
  ENDIF.

* Write end tags
  htmlp &apos;&lt;/body&gt;&lt;/html&gt;&apos;.

  CALL METHOD o_html_control-&gt;load_data
    IMPORTING
      assigned_url = l_url
    CHANGING
      data_table   = lt_data_table.

  CALL METHOD o_html_control-&gt;show_url
    EXPORTING
      url = l_url.

  o_pic-&gt;set_visible( abap_false ).
  o_html_control-&gt;set_visible( abap_true ).
ENDFORM.                    &quot; write_html_prog

*&amp;---------------------------------------------------------------------*
*&amp;      Form  write_html_obj
*&amp;---------------------------------------------------------------------*
*       Display Object info in HTML format
*----------------------------------------------------------------------*
*      --&gt;FP_OBJ     Object name
*      --&gt;FP_OBJTYPE Object type
*----------------------------------------------------------------------*
FORM write_html_obj USING fp_obj TYPE ZSPRO_AP-nodeparam
                          fp_objtype TYPE doku_id.

  DATA : l_object       TYPE doku_obj,
         ls_data_table  TYPE htmlline,
         lt_data_table  LIKE TABLE OF ls_data_table,
         lt_lines       LIKE TABLE OF tline WITH HEADER LINE,
         lt_lines2      LIKE TABLE OF tline,
         l_docu_to_html TYPE REF TO cl_epss_docu_to_html,
         l_url(2048),
         l_title        TYPE dsyst-doktitle,
         l_doctype      TYPE dokil-typ,
         l_langu        TYPE sy-langu,
         lt_styles      TYPE tlinetab,
         l_stylename    TYPE doku_obj.
  DATA : BEGIN OF ls_clsmeth,
           clsname  TYPE seocompo-clsname,
           cmpname  TYPE seocompo-cmpname,
           descript TYPE seocompotx-descript,
         END OF ls_clsmeth,
         lt_clsmeth LIKE TABLE OF ls_clsmeth.

  DEFINE htmlo.
    ls_data_table = &amp;1.
    append ls_data_table to lt_data_table.
  END-OF-DEFINITION.

  IF fp_objtype = c_doctype_img.
* Search Documentation
    SELECT SINGLE docu_id INTO l_object
           FROM cus_imgach
           WHERE activity = fp_obj.
    IF sy-subrc NE 0.
* If no specific documentation, try to display object documentation
      CONCATENATE &apos;SIMG&apos; fp_obj INTO l_object.
    ENDIF.
  ELSE.
    l_object = fp_obj.
  ENDIF.

* Get doc
  DO 4 TIMES.
* Search in first enduser doc in connexion language
    IF sy-index = 1.
      l_langu = sy-langu.
      l_doctype = c_doktyp_enduser.
* If not found, search enduser doc in english
    ELSEIF sy-index = 2.
      l_langu = c_langu_default.
      l_doctype = c_doktyp_enduser.
* If not found, search technical doc in connexion language
    ELSEIF sy-index = 3.
      l_langu = c_langu_default.
      l_doctype = c_doktyp_technical.
* If not found, search technical doc in english
    ELSEIF sy-index = 4.
      l_langu = sy-langu.
      l_doctype = c_doktyp_technical.
    ELSE.
      EXIT. &quot; exit do
    ENDIF.

    SELECT SINGLE object INTO l_object
           FROM  dokil
           WHERE id         = fp_objtype
           AND   object     = l_object
           AND   langu      = l_langu
           AND   typ        = l_doctype.
    IF sy-subrc EQ 0.
      CLEAR l_title.
      CALL FUNCTION &apos;DOCU_GET&apos;
        EXPORTING
          id       = fp_objtype
          object   = l_object
          langu    = l_langu
          typ      = l_doctype
        IMPORTING
          doktitle = l_title
        TABLES
          line     = lt_lines
        EXCEPTIONS
          OTHERS   = 2.
      IF sy-subrc NE 0.
        CLEAR lt_lines.
      ELSE.
* Add appendix
        CALL FUNCTION &apos;DOCU_GET_APPENDIX&apos;
          EXPORTING
            langu  = l_langu
            id     = fp_objtype
            object = l_object
          TABLES
            docu   = lt_lines2.
        APPEND LINES OF lt_lines2 TO lt_lines.
      ENDIF.
      EXIT. &quot;exit do
    ENDIF.
  ENDDO.

* Write Header tags
  REFRESH lt_data_table.
  htmlo &apos;&lt;html&gt;&lt;head&gt;&apos;.
  htmlo &apos;&lt;title&gt;Object&apos;.
  htmlo l_object.
  htmlo &apos;info&lt;/title&gt;&apos;.

* Add sap style
* check for customer style, since modifications or other
* includes/commands we will not be supported here
* this style should exist only in English, since before SAP one existed
* only in German (DE)
  SELECT SINGLE object FROM dokil INTO l_stylename
    WHERE id = &apos;TX&apos;
      AND object = &apos;Z_EPSS_STYLES&apos;
      AND langu = &apos;E&apos;
      AND typ = c_doktyp_enduser.
  IF sy-subrc = 0.
* Get EPSS styles from SE61 store
    CALL FUNCTION &apos;DOCU_GET&apos;
      EXPORTING
        id     = &apos;TX&apos;
        langu  = &apos;E&apos;
        object = l_stylename
      TABLES
        line   = lt_styles
      EXCEPTIONS
        OTHERS = 1.
  ENDIF.
  IF sy-subrc &lt;&gt; 0 OR lt_styles[] IS INITIAL.
* customer styles is not found, check for SAP one
    l_stylename = &apos;EPSS_STYLES&apos;.
* Get EPSS styles from SE61 store
    CALL FUNCTION &apos;DOCU_GET&apos;
      EXPORTING
        id     = &apos;TX&apos;
        langu  = &apos;D&apos;
        object = l_stylename
      TABLES
        line   = lt_styles
      EXCEPTIONS
        OTHERS = 0.
    IF lt_styles[] IS INITIAL.
* second language
      CALL FUNCTION &apos;DOCU_GET&apos;
        EXPORTING
          id     = &apos;TX&apos;
          langu  = &apos;E&apos;
          object = l_stylename
        TABLES
          line   = lt_styles
        EXCEPTIONS
          OTHERS = 0.
    ENDIF.
  ENDIF.
* Insert styles into HTML lines
  IF lt_styles[] IS NOT INITIAL.
    APPEND LINES OF lt_styles TO lt_data_table.
  ENDIF.

  htmlo &apos;&lt;/head&gt;&lt;body bgcolor=#EEF4FB&gt;&apos;.

* For class, search Method list
  IF fp_objtype = c_doctype_cls.
    SELECT t1~clsname t1~cmpname t2~descript
           INTO TABLE lt_clsmeth
           FROM seocompo AS t1
           LEFT JOIN seocompotx AS t2

           ON t1~clsname = t2~clsname
           AND t1~cmpname = t2~cmpname
           AND t2~langu = c_langu_default
           WHERE ( t1~clsname = fp_obj
           OR t1~clsname IN ( SELECT refclsname
                              FROM vseoimplem
                              WHERE clsname = fp_obj )
                  )
           AND t1~cmptype = &apos;1&apos;. &quot;method

    IF sy-subrc = 0.
      CLEAR lt_lines.
      lt_lines-tdformat = &apos;U1&apos;.
      lt_lines-tdline = &apos;Methods&apos;.
      APPEND lt_lines.

      LOOP AT lt_clsmeth INTO ls_clsmeth.
        CLEAR lt_lines.
        lt_lines-tdformat = &apos;AS&apos;.

* For each method, search if a doc exist.
* If found, add a link to the method documentaiton
        CLEAR l_object.
        l_object(30) = ls_clsmeth-clsname.
        l_object+30 = ls_clsmeth-cmpname.
        SELECT SINGLE object INTO l_object
               FROM dokil
               WHERE id = c_doctype_meth
               AND object = l_object.
        IF sy-subrc = 0.
          CONCATENATE &apos;&lt;DS:CO.&apos; l_object &apos;&gt;&apos; ls_clsmeth-cmpname
                      &apos;&lt;/&gt;&apos;
                      INTO lt_lines-tdline.
        ELSE.
          IF ls_clsmeth-clsname = fp_obj.
            lt_lines-tdline = ls_clsmeth-cmpname.
          ELSE.
            CONCATENATE ls_clsmeth-clsname ls_clsmeth-cmpname
                        INTO lt_lines-tdline SEPARATED BY &apos;~&apos;.
          ENDIF.
        ENDIF.
        IF NOT ls_clsmeth-descript IS INITIAL.
          CONCATENATE lt_lines-tdline ls_clsmeth-descript
                      INTO lt_lines-tdline SEPARATED BY &apos; : &apos;.
        ENDIF.
        APPEND lt_lines.
      ENDLOOP.
    ENDIF.
  ENDIF.

* If doc found, display it in html
  IF NOT lt_lines[] IS INITIAL.
* Add doc title
    IF l_title IS INITIAL.
      IF fp_objtype = c_doctype_img.
        SELECT SINGLE text INTO l_title
               FROM cus_imgact
               WHERE activity = fp_obj
               AND spras = sy-langu.
        IF sy-subrc NE 0.
          SELECT SINGLE text INTO l_title
                 FROM cus_imgact
                 WHERE activity = fp_obj
                 AND spras = c_langu_default.
        ENDIF.
      ELSEIF fp_objtype = c_doctype_fm.
        SELECT SINGLE stext INTO l_title
               FROM tftit
               WHERE funcname = fp_obj
               AND spras = sy-langu.
        IF sy-subrc NE 0.
          SELECT SINGLE stext INTO l_title
                 FROM tftit
                 WHERE funcname = fp_obj
                 AND spras = c_langu_default.
        ENDIF.
      ELSEIF fp_objtype = c_doctype_cls.
        l_title = fp_obj.
      ELSEIF fp_objtype = c_doctype_meth
      OR fp_objtype = c_doctype_clsattr.
        CONCATENATE fp_obj(30) &apos;-&gt;&apos; fp_obj+30 INTO l_title.
        CONDENSE l_title NO-GAPS.
      ENDIF.
    ENDIF.
    IF l_title NE space.
      CLEAR lt_lines.
      lt_lines-tdformat = &apos;U1&apos;.
      lt_lines-tdline = l_title.
      INSERT lt_lines INDEX 1.
    ENDIF.

* Create doc html converter
    CREATE OBJECT l_docu_to_html.
    CONCATENATE &apos;DS:&apos; fp_objtype &apos;.&apos; l_object
                INTO l_docu_to_html-&gt;doc_link.
* Load doc into converter
    l_docu_to_html-&gt;itflines = lt_lines[].

* Fill header
    l_docu_to_html-&gt;header-tdname = l_object.
    l_docu_to_html-&gt;header-tdid = fp_objtype.
    l_docu_to_html-&gt;header-tdform = &apos;S_DOCU_SHOW&apos;.
    l_docu_to_html-&gt;header-tdstyle = &apos;S_DOCUS1&apos;.
    IF fp_objtype = c_doctype_img.
      l_docu_to_html-&gt;header-tdobject = &apos;DSYS&apos;.
    ELSE.
      l_docu_to_html-&gt;header-tdobject = &apos;DOKU&apos;.
    ENDIF.

* Convert doc into html
    CALL METHOD l_docu_to_html-&gt;convert_itf_to_html.
    CALL METHOD l_docu_to_html-&gt;add_sapicons_to_html.

* Delete all header until &lt;body&gt;
    LOOP AT l_docu_to_html-&gt;htmllines INTO ls_data_table.
      TRANSLATE ls_data_table TO UPPER CASE.
      CONDENSE ls_data_table NO-GAPS.
      DELETE l_docu_to_html-&gt;htmllines.
      IF ls_data_table(5) NE &apos;&lt;BODY&apos;.
        CONTINUE.
      ELSE.
        EXIT.
      ENDIF.
    ENDLOOP.

* Write doc
    APPEND LINES OF l_docu_to_html-&gt;htmllines TO lt_data_table.
  ELSE.
* No help found
    htmlo &apos;&lt;p align=&quot;center&quot;&gt;No Help for this entry&lt;/p&gt;&apos;.
    htmlo &apos;&lt;/body&gt;&lt;/html&gt;&apos;.
  ENDIF.

  CALL METHOD o_html_control-&gt;load_data
    IMPORTING
      assigned_url = l_url
    CHANGING
      data_table   = lt_data_table.

  CALL METHOD o_html_control-&gt;show_url
    EXPORTING
      url = l_url.

  o_pic-&gt;set_visible( abap_false ).
  o_html_control-&gt;set_visible( abap_true ).
ENDFORM.                    &quot; write_html_img

*&amp;---------------------------------------------------------------------*
*&amp;      Form  find_entry
*&amp;---------------------------------------------------------------------*
*       Search popup to find an entry by name or label
*----------------------------------------------------------------------*
FORM find_entry .
  DATA l_rc TYPE c.

  CLEAR s_ZSPRO_AP.

* Prompt for table/programm name
  PERFORM popup_get_value USING    c_popup_find
                          CHANGING s_ZSPRO_AP-nodetype
                                   s_ZSPRO_AP-nodeparam
                                   s_ZSPRO_AP-text
                                   l_rc.
  IF l_rc NE space AND l_rc NE 0.
    RETURN.
  ENDIF.

  CLEAR s_find.
  IF NOT s_ZSPRO_AP-nodetype IS INITIAL.
    s_find-nodetype = s_ZSPRO_AP-nodetype.
  ENDIF.
  s_find-nodeparam = s_ZSPRO_AP-nodeparam.
  s_find-patern = s_ZSPRO_AP-text.

  IF NOT s_find IS INITIAL.
    PERFORM find_entry_continue.
  ENDIF.

ENDFORM.                    &quot; find_entry

*&amp;--------------------------------------------------------------------*
*&amp;      Form  find_entry_continue
*&amp;--------------------------------------------------------------------*
*       Search an entry
*---------------------------------------------------------------------*
FORM find_entry_continue.
  DATA : l_index  TYPE i,
         lt_ZSPRO_AP LIKE TABLE OF s_ZSPRO_AP.

  IF s_find IS INITIAL.
    PERFORM find_entry.
  ENDIF.

  lt_ZSPRO_AP = t_ZSPRO_AP.
  SORT lt_ZSPRO_AP STABLE BY relatkey sort.

  l_index = s_find-index + 1.
  IF NOT s_find-nodetype IS INITIAL.
    LOOP AT lt_ZSPRO_AP INTO s_ZSPRO_AP FROM l_index.
      IF s_ZSPRO_AP-nodetype = s_find-nodetype
      AND s_ZSPRO_AP-nodeparam = s_find-nodeparam.
        s_find-index = sy-tabix.
        EXIT.
      ENDIF.
    ENDLOOP.
  ELSE.
    LOOP AT lt_ZSPRO_AP INTO s_ZSPRO_AP FROM l_index.
      FIND s_find-patern IN s_ZSPRO_AP-text IGNORING CASE.
      IF sy-subrc IS INITIAL.
        s_find-index = sy-tabix.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.

  l_index = l_index - 1.
  IF s_find-index IS INITIAL.
    MESSAGE &apos;The search has not produced any hits&apos;(m10)
            TYPE c_msg_succes.
  ELSEIF s_find-index = l_index.
    MESSAGE &apos;No further hits were found&apos;(m11) TYPE c_msg_succes.
  ELSE.
    CALL METHOD o_tree-&gt;set_selected_node
      EXPORTING
        node_key = s_ZSPRO_AP-node_key.
    PERFORM init_html.
  ENDIF.
ENDFORM.                    &quot;find_entry_continue

*&amp;---------------------------------------------------------------------*
*&amp;      Form  create_mass
*&amp;---------------------------------------------------------------------*
*       Insert table/program in mass
*----------------------------------------------------------------------*
FORM create_mass .
  DATA : l_new_key      LIKE w_node_key,
         l_sort         TYPE i,
         l_subfolder(1) TYPE c,   &quot; To do subfolder special operations
         lt_tables      LIKE TABLE OF dd02l-tabname WITH HEADER LINE,
         lt_progs       LIKE TABLE OF trdir-name WITH HEADER LINE,
         l_message(100) TYPE c,
         l_nbtable      TYPE string,
         l_n            TYPE i,
         lt_node_table  LIKE STANDARD TABLE OF s_node,
         l_table        TYPE tabname.

* Get parent folder node
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = w_node_key.

  IF w_node_key IS INITIAL.
    CLEAR l_subfolder.
  ELSE.
    l_subfolder = abap_true.
  ENDIF.

  IF l_subfolder = abap_true.
*   Check parent is a folder.
    CLEAR s_ZSPRO_AP.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
    IF s_ZSPRO_AP-isfolder IS INITIAL.
      MESSAGE &apos;Please select a folder in the tree&apos;(m30)
              TYPE c_msg_succes DISPLAY LIKE c_msg_error.
      RETURN.
    ENDIF.
  ENDIF.

  CLEAR s_ZSPRO_AP.

* Prompt table range to add in mass
  CALL SELECTION-SCREEN 200 STARTING AT 10 10.
  IF s_tables[] IS INITIAL AND s_progrm[] IS INITIAL.
    MESSAGE &apos;Action cancelled by the user&apos;(m19) TYPE c_msg_succes
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

  IF NOT s_tables[] IS INITIAL.
    SELECT tabname INTO TABLE lt_tables
           FROM dd02l
           WHERE tabname IN s_tables.

    LOOP AT lt_tables.
      IF pdoublon NE space.
* Delete tables already in the tree
        READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP
                           WITH KEY nodetype = c_nodetype_table
                                    nodeparam = lt_tables.
        CHECK sy-subrc NE 0.
      ENDIF.

      PERFORM get_free_number USING w_node_key
                              CHANGING l_new_key l_sort.

      CLEAR s_ZSPRO_AP.

      s_ZSPRO_AP-node_key = l_new_key.
      IF l_subfolder = abap_true.
        s_ZSPRO_AP-relatkey = w_node_key.
        s_ZSPRO_AP-relatship = cl_gui_simple_tree=&gt;relat_last_child.
      ENDIF.
      s_ZSPRO_AP-nodetype = c_nodetype_table.
      s_ZSPRO_AP-nodeparam = lt_tables.
*   Check if maintenance view exist
      l_table = s_ZSPRO_AP-nodeparam.
      SELECT SINGLE tabname
             INTO l_table
             FROM tvdir
             WHERE tabname = l_table.
      IF sy-subrc = 0.
        s_ZSPRO_AP-n_image = c_icon_table.
      ELSE.
        s_ZSPRO_AP-nomaint = abap_true.
        s_ZSPRO_AP-n_image = c_icon_table_nomaint.
      ENDIF.

      PERFORM check_table USING s_ZSPRO_AP-nodeparam CHANGING s_ZSPRO_AP-text.

      CHECK NOT s_ZSPRO_AP-text IS INITIAL.
      CHECK NOT s_ZSPRO_AP-nodeparam IS INITIAL.
      s_ZSPRO_AP-new_line = abap_true.
      s_ZSPRO_AP-sort = l_sort.
      s_ZSPRO_AP-dragdropid = w_handle_tree.
      INSERT s_ZSPRO_AP INTO TABLE t_ZSPRO_AP.

* Add techname if relevant
      IF w_techname = c_techname_on.
        CONCATENATE s_ZSPRO_AP-nodeparam &apos;-&apos; s_ZSPRO_AP-text INTO s_ZSPRO_AP-text
                    SEPARATED BY space.
      ENDIF.
      s_node = s_ZSPRO_AP.
      INSERT s_node INTO TABLE lt_node_table.
    ENDLOOP.
  ENDIF.

  IF NOT s_progrm[] IS INITIAL.
    SELECT name INTO TABLE lt_progs
           FROM trdir
           WHERE name IN s_progrm.

    LOOP AT lt_progs.
      IF pdoublon NE space.
* Delete programs already in the tree
        READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP
                           WITH KEY nodetype = c_nodetype_program
                                    nodeparam = lt_progs.
        CHECK sy-subrc NE 0.
      ENDIF.

      PERFORM get_free_number USING w_node_key
                              CHANGING l_new_key l_sort.

      CLEAR s_ZSPRO_AP.

      s_ZSPRO_AP-node_key = l_new_key.
      IF l_subfolder = abap_true.
        s_ZSPRO_AP-relatkey = w_node_key.
        s_ZSPRO_AP-relatship = cl_gui_simple_tree=&gt;relat_last_child.
      ENDIF.
      s_ZSPRO_AP-nodetype = c_nodetype_program.
      s_ZSPRO_AP-nodeparam = lt_progs.
      s_ZSPRO_AP-n_image = c_icon_prog.

      PERFORM check_prog USING s_ZSPRO_AP-nodeparam CHANGING s_ZSPRO_AP-text.

      CHECK NOT s_ZSPRO_AP-text IS INITIAL.
      CHECK NOT s_ZSPRO_AP-nodeparam IS INITIAL.
      s_ZSPRO_AP-new_line = abap_true.
      s_ZSPRO_AP-sort = l_sort.
      s_ZSPRO_AP-dragdropid = w_handle_tree.
      INSERT s_ZSPRO_AP INTO TABLE t_ZSPRO_AP.

* Add techname if relevant
      IF w_techname = c_techname_on.
        CONCATENATE s_ZSPRO_AP-nodeparam &apos;-&apos; s_ZSPRO_AP-text INTO s_ZSPRO_AP-text
                    SEPARATED BY space.
      ENDIF.
      s_node = s_ZSPRO_AP.
      INSERT s_node INTO TABLE lt_node_table.
    ENDLOOP.
  ENDIF.

  REFRESH : s_tables, s_progrm.

  DESCRIBE TABLE lt_node_table LINES l_n.
  IF l_n IS INITIAL.
    MESSAGE &apos;No entries for these selection criteria&apos;(m12)
            TYPE c_msg_succes.
  ELSE.
    CALL METHOD o_tree-&gt;add_nodes
      EXPORTING
        table_structure_name           = c_tree_table
        node_table                     = lt_node_table
      EXCEPTIONS
        failed                         = 1
        error_in_node_table            = 2
        dp_error                       = 3
        table_structure_name_not_found = 4
        OTHERS                         = 5.
    IF sy-subrc = 0.
      l_message = &apos;# table(s) added&apos;(m17).
      l_nbtable = l_n.
      REPLACE c_wildcard WITH l_nbtable INTO l_message.
      MESSAGE l_message TYPE c_msg_succes.
    ENDIF.

    IF l_subfolder = abap_true.
*   Expand parent of the new node
      CALL METHOD o_tree-&gt;expand_node
        EXPORTING
          node_key = w_node_key.
    ENDIF.
    w_data_changed = abap_true.
  ENDIF.
ENDFORM.                    &quot; create_mass

*&amp;---------------------------------------------------------------------*
*&amp;      Form  where_used
*&amp;---------------------------------------------------------------------*
*       Where-used function
*----------------------------------------------------------------------*
FORM where_used.
  DATA : l_obj_type TYPE rseuap-obj_type,
         l_objname  TYPE rseuap-obj_name,
         l_tabclass LIKE dd02l-tabclass.

* Get node
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check node is not IMG or url
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF s_ZSPRO_AP-nodetype NE c_nodetype_table
  AND s_ZSPRO_AP-nodetype NE c_nodetype_program
  AND s_ZSPRO_AP-nodetype NE c_nodetype_transac
  AND s_ZSPRO_AP-nodetype NE c_nodetype_fm
  AND s_ZSPRO_AP-nodetype NE c_nodetype_cls.
    RETURN.
  ENDIF.

  l_objname = s_ZSPRO_AP-nodeparam.
  IF s_ZSPRO_AP-nodetype = c_nodetype_table.
    SELECT SINGLE tabclass FROM dd02l INTO l_tabclass
           WHERE tabname EQ l_objname
           AND as4local EQ c_state_active
           AND as4vers EQ &apos;0000&apos;.
    IF l_tabclass = &apos;VIEW&apos;.
      l_obj_type = &apos;DV&apos;.
    ELSE.
      l_obj_type = &apos;DT&apos;.
    ENDIF.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_program.
    l_obj_type = &apos;P&apos;.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_transac.
    l_obj_type = &apos;T&apos;.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_fm.
    l_obj_type = &apos;FF&apos;.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_cls.
    l_obj_type = &apos;OC&apos;.
  ENDIF.

  SUBMIT wb_mngr_start_from_tool_access AND RETURN
         WITH action   = &apos;WHEREUSED&apos;
         WITH obj_type = l_obj_type
         WITH obj_name = l_objname
         WITH tool     = &apos;CL_WB_INFOSYSTEM&apos;.
ENDFORM.                    &quot;where_used

*&amp;---------------------------------------------------------------------*
*&amp;      Form  edit_help
*&amp;---------------------------------------------------------------------*
*       Edit standard help of table/program/IMG/Function module
*----------------------------------------------------------------------*
FORM edit_help.
  DATA : l_object TYPE doku_obj,
         l_id     TYPE doku_id.

* Get active node
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check that node is not a folder
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF NOT s_ZSPRO_AP-isfolder IS INITIAL.
    MESSAGE &apos;Please not select a folder in the tree&apos;(m31)
            TYPE c_msg_succes DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

* Call Help editor
  IF s_ZSPRO_AP-nodetype = c_nodetype_table.
    l_id = c_doctype_table.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_program.
    l_id = c_doctype_prog.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_img.
    l_id = c_doctype_img.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_fm.
    l_id = c_doctype_fm.
  ELSE.
* Help only for table, program, function, IMG
    RETURN.
  ENDIF.
  l_object = s_ZSPRO_AP-nodeparam.
  CALL FUNCTION &apos;DOCU_CALL&apos;
    EXPORTING
      id     = l_id
      langu  = sy-langu
      object = l_object.
ENDFORM.                    &quot;edit_help

*&amp;---------------------------------------------------------------------*
*&amp;      Form  switch_disp_edit
*&amp;---------------------------------------------------------------------*
*       Switch between edit and display mode
*       Display is the default mode
*----------------------------------------------------------------------*
FORM switch_disp_edit.
  IF w_mode_change = abap_true.
    IF w_data_changed NE space.
      MESSAGE &apos;You must first save the data&apos;(m04) TYPE c_msg_error.
      RETURN.
    ENDIF.
    CLEAR w_mode_change.
    CALL FUNCTION &apos;VIEW_ENQUEUE&apos;
      EXPORTING
        action       = c_action_dequeue
        enqueue_mode = c_enqueue_mode_exclusive
        view_name    = c_tree_table.
  ELSE.
    CALL FUNCTION &apos;VIEW_ENQUEUE&apos;
      EXPORTING
        action               = c_action_enqueue
        enqueue_mode         = c_enqueue_mode_exclusive
        view_name            = c_tree_table
      EXCEPTIONS
        client_reference     = 1
        foreign_lock         = 2
        invalid_action       = 3
        invalid_enqueue_mode = 4
        system_failure       = 5
        table_not_found      = 6
        OTHERS               = 7.
    IF sy-subrc EQ 0.
      w_mode_change = abap_true.
    ELSE.
      w_mode_change = space.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.
ENDFORM.                    &quot;switch_disp_edit

*&amp;---------------------------------------------------------------------*
*&amp;      Form  INIT_EXCLUDED
*&amp;---------------------------------------------------------------------*
*       Fill table t_excluded_nochange with list of forbidden okcode
*       in display mode
*----------------------------------------------------------------------*
FORM init_excluded .
  REFRESH t_excluded_nochange.
  APPEND &apos;FOLDER&apos; TO t_excluded_nochange.
  APPEND &apos;FILE&apos; TO t_excluded_nochange.
  APPEND &apos;MASSFILE&apos; TO t_excluded_nochange.
  APPEND &apos;DELETE&apos; TO t_excluded_nochange.
  APPEND &apos;RENAME&apos; TO t_excluded_nochange.
  APPEND &apos;EDITHELP&apos; TO t_excluded_nochange.
  APPEND &apos;CREA&apos; TO t_excluded_nochange.
  APPEND &apos;UP&apos; TO t_excluded_nochange.
  APPEND &apos;DOWN&apos; TO t_excluded_nochange.
  APPEND &apos;SAVE&apos; TO t_excluded_nochange.
  APPEND &apos;XMLI&apos; TO t_excluded_nochange.
ENDFORM.                    &quot; INIT_EXCLUDED

*&amp;---------------------------------------------------------------------*
*&amp;      Form  POPUP_GET_VALUE
*&amp;---------------------------------------------------------------------*
*       Display popup to ask table/program/label
*----------------------------------------------------------------------*
*      --&gt;FP_ACTION  Type of popup to display, controls to do
*      &lt;--FP_TABNAME Table Name
*      &lt;--FP_PRGNAME Program Name
*      &lt;--FP_LABEL   Label of the program/table
*      &lt;--FP_RC Return code : space if OK
*----------------------------------------------------------------------*
FORM popup_get_value  USING    fp_action TYPE c
                      CHANGING fp_nodetype TYPE ZSPRO_AP-nodetype
                               fp_nodeparam TYPE ZSPRO_AP-nodeparam
                               fp_label TYPE ZSPRO_AP-text
                               fp_rc TYPE c.
  DATA : ls_sval LIKE sval,
         lt_sval LIKE TABLE OF ls_sval.

  IF fp_action NE c_popup_folder.
* Table - 1
    CLEAR ls_sval.
    ls_sval-tabname = &apos;DD02L&apos;.
    ls_sval-fieldname = &apos;TABNAME&apos;.
    IF fp_nodetype = c_nodetype_table.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* Program - 2
    CLEAR ls_sval.
    ls_sval-tabname = &apos;REPOSRC&apos;.
    ls_sval-fieldname = &apos;PROGNAME&apos;.
    IF fp_nodetype = c_nodetype_program.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* Function module - 5
    CLEAR ls_sval.
    ls_sval-tabname = &apos;TFDIR&apos;.
    ls_sval-fieldname = &apos;FUNCNAME&apos;.
    IF fp_nodetype = c_nodetype_fm.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* Class - 7
    CLEAR ls_sval.
    ls_sval-tabname = &apos;SEOCLASS&apos;.
    ls_sval-fieldname = &apos;CLSNAME&apos;.
    ls_sval-fieldtext = &apos;Class name&apos;(c16).
    IF fp_nodetype = c_nodetype_cls.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* Transaction code - 3
    CLEAR ls_sval.
    ls_sval-tabname = &apos;TSTC&apos;.
    ls_sval-fieldname = &apos;TCODE&apos;.
    IF fp_nodetype = c_nodetype_transac.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* URL - 4
    CLEAR ls_sval.
    ls_sval-tabname = &apos;AGR_BUFFI&apos;.
    ls_sval-fieldname = &apos;URL&apos;. &quot;string
    IF fp_nodetype = c_nodetype_url.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* IMG Activity - 6
    CLEAR ls_sval.
    ls_sval-tabname = &apos;CUS_ACTH&apos;.
    ls_sval-fieldname = &apos;ACT_ID&apos;.
    IF fp_nodetype = c_nodetype_img.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
  ENDIF.
  ls_sval-tabname = &apos;ZSPRO_AP&apos;.
  ls_sval-fieldname = &apos;TEXT&apos;.
  ls_sval-value = fp_label.
  APPEND ls_sval TO lt_sval.
  fp_rc = 0.
  DO.
    CALL FUNCTION &apos;POPUP_GET_VALUES&apos;
      EXPORTING
        popup_title     = space
      IMPORTING
        returncode      = fp_rc
      TABLES
        fields          = lt_sval
      EXCEPTIONS
        error_in_fields = 1
        OTHERS          = 2.
    IF sy-subrc NE 0 OR fp_rc NE space.
      fp_rc = 8.
      EXIT.
    ELSEIF fp_action = c_popup_folder.
      fp_rc = 0.
      READ TABLE lt_sval INTO ls_sval INDEX 1.
      fp_label = ls_sval-value.
      EXIT.
    ENDIF.
    CLEAR fp_nodetype.
    fp_rc = 0.
    LOOP AT lt_sval INTO ls_sval.
      IF ls_sval-fieldname = &apos;TEXT&apos;.
        fp_label = ls_sval-value.
        CONTINUE.
      ENDIF.
      IF ls_sval-value NE space.
        IF fp_nodetype IS INITIAL.
          CASE ls_sval-fieldname.
            WHEN &apos;TABNAME&apos;.
              fp_nodetype = c_nodetype_table.
            WHEN &apos;PROGNAME&apos;.
              fp_nodetype = c_nodetype_program.
            WHEN &apos;FUNCNAME&apos;.
              fp_nodetype = c_nodetype_fm.
            WHEN &apos;CLSNAME&apos;.
              fp_nodetype = c_nodetype_cls.
            WHEN &apos;TCODE&apos;.
              fp_nodetype = c_nodetype_transac.
            WHEN &apos;URL&apos;.
              fp_nodetype = c_nodetype_url.
            WHEN &apos;ACT_ID&apos;.
              fp_nodetype = c_nodetype_img.
            WHEN OTHERS.
              CLEAR fp_nodetype.
          ENDCASE.
          fp_nodeparam = ls_sval-value.
        ELSE.
          fp_rc = 1.
          EXIT.
        ENDIF.
      ENDIF.
    ENDLOOP.
    IF fp_action = c_popup_file
    AND ( fp_nodetype IS INITIAL OR fp_rc = 1 ).
      MESSAGE &apos;Fill one object entry&apos;(m20) TYPE c_msg_succes
              DISPLAY LIKE c_msg_error.
    ELSE.
      fp_rc = 0.
      EXIT.
    ENDIF.
  ENDDO.
  IF fp_rc NE 0.
    MESSAGE &apos;Action cancelled by the user&apos;(m19) TYPE c_msg_succes
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

* For file popup, check table name
  IF fp_nodetype = c_nodetype_table AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_table USING fp_nodeparam CHANGING fp_label.
  ENDIF.
* For file popup, check program name
  IF fp_nodetype = c_nodetype_program AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_prog USING fp_nodeparam CHANGING fp_label.
  ENDIF.
* For file popup, check class name
  IF fp_nodetype = c_nodetype_cls AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_cls USING fp_nodeparam CHANGING fp_label.
  ENDIF.
* For file popup, check transaction name
  IF fp_nodetype = c_nodetype_transac AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_transac USING fp_nodeparam CHANGING fp_label.
  ENDIF.
* For file popup, copy url in url name if empty
  IF fp_nodetype = c_nodetype_url AND fp_nodeparam NE space
  AND fp_action = c_popup_file AND fp_label = space.
    fp_label = fp_nodeparam.
  ENDIF.
* For file popup, check img name
  IF fp_nodetype = c_nodetype_img AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_img USING fp_nodeparam CHANGING fp_label.
  ENDIF.
* For file popup, check function name
  IF fp_nodetype = c_nodetype_fm AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_fm USING fp_nodeparam CHANGING fp_label.
  ENDIF.

* For file/folder popup, Cancel if text not filled
* For find, cancel if none of the fields is filled
  IF fp_label IS INITIAL
  AND ( fp_action NE c_popup_find OR fp_nodeparam IS INITIAL ).
    fp_rc = 8.
    RETURN.
  ENDIF.
ENDFORM.                    &quot; POPUP_GET_VALUE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  START_SE16
*&amp;---------------------------------------------------------------------*
*       Display table content in SE16
*----------------------------------------------------------------------*
FORM start_se16.
  DATA l_table TYPE tabname.

* Get node
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check node is a table
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF s_ZSPRO_AP-nodetype NE c_nodetype_table.
    RETURN.
  ENDIF.

* Display selection-screen from SE16
  l_table = s_ZSPRO_AP-nodeparam.
  CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
    EXPORTING
      operation   = &apos;TAB_CONT&apos;
      object_name = l_table
      object_type = &apos;TABL&apos;.
ENDFORM.                    &quot; START_SE16

*&amp;---------------------------------------------------------------------*
*&amp;      Form  START_SE24
*&amp;---------------------------------------------------------------------*
*       Display class in SE24
*----------------------------------------------------------------------*
FORM start_se24.
  DATA l_cls TYPE seoclsname.

* Get node
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check node is a class
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF s_ZSPRO_AP-nodetype NE c_nodetype_cls.
    RETURN.
  ENDIF.

* Display class method
  l_cls = s_ZSPRO_AP-nodeparam.
  CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
    EXPORTING
      operation   = &apos;SHOW&apos;
      object_name = l_cls
      object_type = &apos;CLAS&apos;.

ENDFORM.                    &quot; START_SE24

*&amp;---------------------------------------------------------------------*
*&amp;      Form  START_SE38
*&amp;---------------------------------------------------------------------*
*       Display program code in SE38
*----------------------------------------------------------------------*
FORM start_se38.
  DATA : l_prog TYPE programm,
         l_name TYPE rs38l-include,
         l_numb TYPE tfdir-include.

* Get node
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check node is a program or a fm
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF s_ZSPRO_AP-nodetype = c_nodetype_program.
    l_prog = s_ZSPRO_AP-nodeparam.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_fm.
    SELECT SINGLE pname include INTO (l_name, l_numb)
           FROM tfdir
           WHERE funcname = s_ZSPRO_AP-nodeparam.
    CALL FUNCTION &apos;FUNCTION_INCLUDE_CONCATENATE&apos;
      EXPORTING
        include_number = l_numb
      IMPORTING
        include        = l_prog
      CHANGING
        program        = l_name
      EXCEPTIONS
        OTHERS         = 4.
    IF sy-subrc &lt;&gt; 0 OR l_prog IS INITIAL.
      RETURN.
    ENDIF.
  ELSE.
    RETURN.
  ENDIF.

* Display code in SE38
  EDITOR-CALL FOR REPORT l_prog DISPLAY-MODE.
ENDFORM.                    &quot; START_SE38

*&amp;---------------------------------------------------------------------*
*&amp;      Form  START_SE11
*&amp;---------------------------------------------------------------------*
*       Display table definition in SE11
*----------------------------------------------------------------------*
*      --&gt;FP_TEXT    Display text table instead of main table
*----------------------------------------------------------------------*
FORM start_se11 USING fp_text.
  DATA l_table TYPE tabname.
* Get node
  CALL METHOD o_tree-&gt;get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check node is a table
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF s_ZSPRO_AP-nodetype NE c_nodetype_table.
    RETURN.
  ENDIF.

  l_table = s_ZSPRO_AP-nodeparam.

* Search text table name
  IF fp_text NE space.
    CALL FUNCTION &apos;DDUT_TEXTTABLE_GET&apos;
      EXPORTING
        tabname   = l_table
      IMPORTING
        texttable = l_table.
    IF l_table IS INITIAL.
      RETURN.
    ENDIF.
  ENDIF.

* Display table definition in SE11
  CALL METHOD cl_wb_ddic=&gt;access_ddic_via_manager
    EXPORTING
      p_obj_name  = l_table
      p_obj_type  = &apos;TABL&apos;
      p_operation = &apos;S&apos;. &quot;display
ENDFORM.                    &quot; START_SE11

*&amp;---------------------------------------------------------------------*
*&amp;      Form  SWITCH_TECHNAME_TREE
*&amp;---------------------------------------------------------------------*
*       Redraw tree with or without techname
*----------------------------------------------------------------------*
FORM switch_techname_tree .
  w_techname = 1 - w_techname.

  LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP.
    IF w_techname = c_techname_on
    AND NOT s_ZSPRO_AP-nodetype = c_nodetype_url
    AND s_ZSPRO_AP-isfolder = space.
      CONCATENATE s_ZSPRO_AP-nodeparam &apos;-&apos; s_ZSPRO_AP-text INTO s_ZSPRO_AP-text
                  SEPARATED BY space.
    ENDIF.
    CALL METHOD o_tree-&gt;node_set_text
      EXPORTING
        node_key = s_ZSPRO_AP-node_key
        text     = s_ZSPRO_AP-text.
  ENDLOOP.
ENDFORM.                    &quot; SWITCH_TECHNAME_TREE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  GET_URL_ICON
*&amp;---------------------------------------------------------------------*
*       Get icon related to an url
*----------------------------------------------------------------------*
*      --&gt;FP_URL  : Url to scan
*      &lt;--FP_ICON : Icon related to this url
*----------------------------------------------------------------------*
FORM get_url_icon  USING    fp_url TYPE ZSPRO_AP-nodeparam
                   CHANGING fp_icon TYPE tv_image.
  DATA : lv_string TYPE string,
         lv_offset TYPE i.

* For empty link, return broken link icon
  IF fp_url = c_url_broken.
    fp_icon = c_icon_url_broken.
    RETURN.
  ENDIF.

* Try to find extension even if internet link
** For internet link, return link icon
*  IF fp_url(4) = &apos;http&apos;.
*    fp_icon = c_icon_url.
*    RETURN.
*  ENDIF.

* Search file extension
  lv_string = fp_url.
  DO.
    FIND FIRST OCCURRENCE OF &apos;.&apos; IN lv_string MATCH OFFSET lv_offset.
    IF sy-subrc NE 0.
      EXIT. &quot;exit do
    ELSE.
      lv_offset = lv_offset + 1.
      lv_string = lv_string+lv_offset.
    ENDIF.
  ENDDO.

* No extension found, return link icon
  IF lv_string = fp_url.
    fp_icon = c_icon_url.
    RETURN.
  ENDIF.

  TRANSLATE lv_string TO LOWER CASE.
  CASE lv_string.
* Excel file
    WHEN &apos;xls&apos; OR &apos;xlsx&apos; OR &apos;xlm&apos; OR &apos;xlam&apos;.
      fp_icon = c_icon_xls.
      RETURN.
* Word file
    WHEN &apos;doc&apos; OR &apos;docx&apos;.
      fp_icon = c_icon_doc.
      RETURN.
* Powerpoint file
    WHEN &apos;ppt&apos; OR &apos;pptx&apos;.
      fp_icon = c_icon_ppt.
      RETURN.
* PDF File
    WHEN &apos;pdf&apos;.
      fp_icon = c_icon_pdf.
      RETURN.
* Images File
    WHEN &apos;png&apos; OR &apos;bmp&apos; OR &apos;jpg&apos; OR &apos;jpeg&apos; OR &apos;gif&apos;.
      fp_icon = c_icon_png.
      RETURN.
* Email
    WHEN &apos;msg&apos;.
      fp_icon = c_icon_mail.
* No known extension, return link icon
    WHEN OTHERS.
      fp_icon = c_icon_url.
      RETURN.
  ENDCASE.
ENDFORM.                    &quot; GET_URL_ICON

*&amp;---------------------------------------------------------------------*
*&amp;      Form  Export_xml
*&amp;---------------------------------------------------------------------*
*       Export tree in xml format
*----------------------------------------------------------------------*
FORM export_xml.
  DATA : BEGIN OF ls_xml,
           line(256) TYPE x,
         END OF ls_xml,
         lt_xml     LIKE TABLE OF ls_xml,
         ls_ZSPRO_AP   LIKE s_ZSPRO_AP,
         l_filename TYPE string,
         l_path     TYPE string,
         l_fullpath TYPE string.
  DATA : lo_xml      TYPE REF TO if_ixml,
         lo_document TYPE REF TO if_ixml_document,
         lo_root     TYPE REF TO if_ixml_element,
         lo_element  TYPE REF TO if_ixml_element,
         lo_parent   TYPE REF TO if_ixml_element,
         BEGIN OF ls_node_link,
           nodekey LIKE ls_ZSPRO_AP-node_key,
           element TYPE REF TO if_ixml_element,
         END OF ls_node_link,
         lt_node_link     LIKE TABLE OF ls_node_link,
         lw_string        TYPE string,
         lo_streamfactory TYPE REF TO if_ixml_stream_factory,
         lo_ostream       TYPE REF TO if_ixml_ostream,
         lo_renderer      TYPE REF TO if_ixml_renderer,
         l_title          TYPE string,
         l_filter         TYPE string.

* Ask name of file to generate
  l_title = &apos;Choose file to create&apos;(m23).
  l_filter = &apos;XML File (*.xml)|*.xml&apos;(m24).
  CALL METHOD cl_gui_frontend_services=&gt;file_save_dialog
    EXPORTING
      window_title = l_title
      file_filter  = l_filter
    CHANGING
      path         = l_path
      filename     = l_filename
      fullpath     = l_fullpath
    EXCEPTIONS
      OTHERS       = 1.
  IF sy-subrc NE 0 OR l_filename IS INITIAL OR l_path IS INITIAL.
    MESSAGE &apos;Action cancelled by the user&apos;(m19) TYPE c_msg_succes
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

  t_ZSPRO_AP_copy = t_ZSPRO_AP.

  SORT t_ZSPRO_AP_copy BY relatkey sort.

  lo_xml = cl_ixml=&gt;create( ).
  lo_document = lo_xml-&gt;create_document( ).

  lo_root  = lo_document-&gt;create_simple_element( name = c_xmlnode_root
                                                 parent = lo_document ).
  LOOP AT t_ZSPRO_AP_copy INTO ls_ZSPRO_AP.

    IF ls_ZSPRO_AP-relatkey IS INITIAL.
      lo_parent = lo_root.
    ELSE.
      READ TABLE lt_node_link INTO ls_node_link
                 WITH KEY nodekey = ls_ZSPRO_AP-relatkey.
      lo_parent = ls_node_link-element.
    ENDIF.
    IF ls_ZSPRO_AP-isfolder NE space.
      lw_string = c_xmlnode_folder.
    ELSE.
      lw_string = c_xmlnode_file.
    ENDIF.

    lo_element  = lo_document-&gt;create_simple_element( name = lw_string
                                                      parent = lo_parent ).
    IF ls_ZSPRO_AP-isfolder NE space.
      lw_string = ls_ZSPRO_AP-text.
      lo_element-&gt;set_attribute( name = c_xmlattr_folder_text value = lw_string ).
    ELSE.
      CASE ls_ZSPRO_AP-nodetype.
        WHEN c_nodetype_table.
          lw_string = c_xmltype_table.
        WHEN c_nodetype_program.
          lw_string = c_xmltype_program.
        WHEN c_nodetype_transac.
          lw_string = c_xmltype_transac.
        WHEN c_nodetype_url.
          lw_string = c_xmltype_url.
        WHEN c_nodetype_img.
          lw_string = c_xmltype_img.
        WHEN c_nodetype_fm.
          lw_string = c_xmltype_fm.
        WHEN c_nodetype_cls.
          lw_string = c_xmltype_cls.
      ENDCASE.
      lo_element-&gt;set_attribute( name = c_xmlattr_file_type value = lw_string ).
      lw_string = ls_ZSPRO_AP-text.
      lo_element-&gt;set_attribute( name = c_xmlattr_file_text value = lw_string ).
      lw_string = ls_ZSPRO_AP-nodeparam.
      lo_element-&gt;set_attribute( name = c_xmlattr_file_param value = lw_string ).
    ENDIF.
    ls_node_link-element = lo_element.
    ls_node_link-nodekey = ls_ZSPRO_AP-node_key.
    APPEND ls_node_link TO lt_node_link.
  ENDLOOP.

  lo_streamfactory = lo_xml-&gt;create_stream_factory( ).

  lo_ostream  = lo_streamfactory-&gt;create_ostream_itable( lt_xml ).

  lo_renderer = lo_xml-&gt;create_renderer( ostream  = lo_ostream
                                         document = lo_document ).
  lo_ostream-&gt;set_pretty_print( abap_true ).
  lo_renderer-&gt;render( ).

  CALL METHOD cl_gui_frontend_services=&gt;gui_download
    EXPORTING
      filename = l_fullpath
      filetype = &apos;BIN&apos;
    CHANGING
      data_tab = lt_xml.
ENDFORM.                    &quot;Export_xml

*&amp;---------------------------------------------------------------------*
*&amp;      Form  Import_xml                                     @C.Cabrita
*&amp;---------------------------------------------------------------------*
*       Import tree in xml format
*----------------------------------------------------------------------*
FORM import_xml.
  DATA : lt_filetab       TYPE filetable,
         ls_file          TYPE file_table,
         l_filename       TYPE string,
         l_subrc          LIKE sy-subrc,
         l_xmldata        TYPE xstring,
         l_answer         TYPE c,
         lo_xml           TYPE REF TO if_ixml,
         lo_document      TYPE REF TO if_ixml_document,
         lo_streamfactory TYPE REF TO if_ixml_stream_factory,
         lo_stream        TYPE REF TO if_ixml_istream,
         lo_parser        TYPE REF TO if_ixml_parser,
         BEGIN OF ls_node_link,
           nodekey LIKE s_ZSPRO_AP-node_key,
           obj     TYPE x LENGTH 8,
         END OF ls_node_link,
         lt_node_link LIKE TABLE OF ls_node_link,
         l_sort       TYPE i.
  DATA: lo_iterator       TYPE REF TO if_ixml_node_iterator,
        lo_node           TYPE REF TO if_ixml_node,
        lo_element_parent TYPE REF TO if_ixml_element,
        l_node_name       TYPE string,
        lo_element        TYPE REF TO if_ixml_element,
        l_type            TYPE string,
        l_label           TYPE string,
        l_obj             TYPE string,
        l_tabname         TYPE tabname,
        l_title           TYPE string,
        l_filter          TYPE string.
  DATA : lo_obj TYPE REF TO cl_ixml_unknown.

* Choose file to import
  l_title = &apos;Choose file to import&apos;(m25).
  l_filter = &apos;XML File (*.xml)|*.xml&apos;(m24).
  CALL METHOD cl_gui_frontend_services=&gt;file_open_dialog
    EXPORTING
      window_title   = l_title
      file_filter    = l_filter
      multiselection = space
    CHANGING
      file_table     = lt_filetab
      rc             = l_subrc.

* Check user action (1 OPEN, 2 CANCEL)
  IF l_subrc NE 1.
    MESSAGE &apos;Action cancelled by the user&apos;(m19) TYPE c_msg_succes
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

* Read filetable
  READ TABLE lt_filetab INTO ls_file INDEX 1.
  l_filename = ls_file-filename.

* Popup to confirm
  CLEAR l_answer.
  CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
    EXPORTING
      titlebar              = &apos;Confirm import of new tree&apos;(m26)
      text_question         = &apos;Current tree will be replaced by content of file. Do you want to continue ?&apos;(m27)
      text_button_1         = &apos;Yes&apos;(002)
      text_button_2         = &apos;No&apos;(003)
      default_button        = &apos;2&apos;
      display_cancel_button = &apos;&apos;
    IMPORTING
      answer                = l_answer.

  IF l_answer &lt;&gt; 1.
    MESSAGE &apos;Action cancelled by the user&apos;(m19) TYPE c_msg_succes
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

* Get xml flow from file
* Or alternatively (if method does not exist) use the method
* cl_gui_frontend_services=&gt;gui_upload and then convert the
* x-tab to xstring
  TRY.
      l_xmldata = cl_openxml_helper=&gt;load_local_file( l_filename ).
    CATCH cx_openxml_not_found.
      MESSAGE &apos;Error when opening the input XML file&apos;(m29)
              TYPE c_msg_error.
      RETURN.
  ENDTRY.

  lo_xml = cl_ixml=&gt;create( ).

  lo_document = lo_xml-&gt;create_document( ).
  lo_streamfactory = lo_xml-&gt;create_stream_factory( ).
  lo_stream = lo_streamfactory-&gt;create_istream_xstring( string = l_xmldata ).

  lo_parser = lo_xml-&gt;create_parser( stream_factory = lo_streamfactory
                                     istream        = lo_stream
                                     document       = lo_document ).
*-- parse the stream
  IF lo_parser-&gt;parse( ) NE 0.
    IF lo_parser-&gt;num_errors( ) NE 0.
      MESSAGE &apos;Error when parsing the input XML file&apos;(m28)
              TYPE c_msg_error.
      RETURN.
    ENDIF.
  ENDIF.

*-- we don&apos;t need the stream any more, so let&apos;s close it...
  CALL METHOD lo_stream-&gt;close( ).
  CLEAR lo_stream.

* Flag all old nodes as deleted
  LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP.
    CLEAR s_ZSPRO_AP_del.
    s_ZSPRO_AP_del = &apos;IEQ&apos;.
    s_ZSPRO_AP_del-low = s_ZSPRO_AP-node_key.
    APPEND s_ZSPRO_AP_del TO r_ZSPRO_AP_del.
  ENDLOOP.

* Clear data
  REFRESH t_ZSPRO_AP.

* Rebuild itab t_ZSPRO_AP
  lo_iterator = lo_document-&gt;create_iterator( ).
  lo_node = lo_iterator-&gt;get_next( ).
  WHILE NOT lo_node IS INITIAL.
    l_node_name = lo_node-&gt;get_name( ).
    IF l_node_name = c_xmlnode_folder OR l_node_name = c_xmlnode_file.
      CLEAR s_ZSPRO_AP.
      s_ZSPRO_AP-new_line = abap_true.
      s_ZSPRO_AP-dragdropid = w_handle_tree.

* Cast node to element
      lo_element ?= lo_node. &quot;-&gt;query_interface( ixml_iid_element ).

* Get node_key of the parent
      lo_element_parent ?= lo_node-&gt;get_parent( ).
      lo_obj ?= lo_element_parent.
      READ TABLE lt_node_link INTO ls_node_link
                 WITH KEY obj = lo_obj-&gt;m_pointee.
      IF sy-subrc = 0.
        s_ZSPRO_AP-relatkey = ls_node_link-nodekey.
        s_ZSPRO_AP-relatship = cl_gui_simple_tree=&gt;relat_last_child.
      ENDIF.

      PERFORM get_free_number USING s_ZSPRO_AP-relatkey
                              CHANGING s_ZSPRO_AP-node_key
                                       l_sort.
      s_ZSPRO_AP-sort = l_sort.
* Keep the node for further reference (search parent)
      lo_obj ?= lo_element.
      ls_node_link-obj = lo_obj-&gt;m_pointee.
      ls_node_link-nodekey = s_ZSPRO_AP-node_key.
      APPEND ls_node_link TO lt_node_link.

      IF l_node_name = c_xmlnode_folder.
        l_label = lo_element-&gt;get_attribute( name = c_xmlattr_folder_text ).
        s_ZSPRO_AP-isfolder = abap_true.
        s_ZSPRO_AP-text = l_label.
        s_ZSPRO_AP-nodetype = c_nodetype_node.
      ELSE.
        l_type = lo_element-&gt;get_attribute( name = c_xmlattr_file_type ).
        l_label = lo_element-&gt;get_attribute( name = c_xmlattr_file_text ).
        l_obj = lo_element-&gt;get_attribute( name = c_xmlattr_file_param ).

        s_ZSPRO_AP-text = l_label.
        s_ZSPRO_AP-nodeparam = l_obj.
        CASE l_type.
          WHEN c_xmltype_table.
            s_ZSPRO_AP-nodetype = c_nodetype_table.
            l_tabname = s_ZSPRO_AP-nodeparam.
*   Check if maintenance view exist
            SELECT SINGLE tabname
                   INTO l_tabname
                   FROM tvdir
                   WHERE tabname = l_tabname.
            IF sy-subrc = 0.
              s_ZSPRO_AP-n_image = c_icon_table.
            ELSE.
              s_ZSPRO_AP-nomaint = abap_true.
              s_ZSPRO_AP-n_image = c_icon_table_nomaint.
            ENDIF.
          WHEN c_xmltype_program.
            s_ZSPRO_AP-nodetype = c_nodetype_program.
            s_ZSPRO_AP-n_image = c_icon_prog.
          WHEN c_xmltype_transac.
            s_ZSPRO_AP-nodetype = c_nodetype_transac.
            s_ZSPRO_AP-n_image = c_icon_transac.
          WHEN c_xmltype_url.
            s_ZSPRO_AP-nodetype = c_nodetype_url.
            PERFORM get_url_icon USING s_ZSPRO_AP-nodeparam
                                 CHANGING s_ZSPRO_AP-n_image.
          WHEN c_xmltype_img.
            s_ZSPRO_AP-nodetype = c_nodetype_img.
            s_ZSPRO_AP-n_image = c_icon_img.
          WHEN c_xmltype_fm.
            s_ZSPRO_AP-nodetype = c_nodetype_fm.
            s_ZSPRO_AP-n_image = c_icon_fm.
          WHEN c_xmltype_cls.
            s_ZSPRO_AP-nodetype = c_nodetype_cls.
            s_ZSPRO_AP-n_image = c_icon_cls.
          WHEN OTHERS.
            s_ZSPRO_AP-n_image = c_icon_unknown.
            CLEAR s_ZSPRO_AP-nodetype.
        ENDCASE.
      ENDIF.
      APPEND s_ZSPRO_AP TO t_ZSPRO_AP.
    ENDIF.
    lo_node = lo_iterator-&gt;get_next( ).
  ENDWHILE.

* Set data changed (to manage the save function)
  w_data_changed = abap_true.

* Delete all nodes
  CALL METHOD o_tree-&gt;delete_all_nodes.

* Reload all tree from internal tables t_ZSPRO_AP
  PERFORM load_node USING space.

ENDFORM.                    &quot;import_xml</source>
</PROG>

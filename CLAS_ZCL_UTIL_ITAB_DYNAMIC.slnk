<?xml version="1.0" encoding="utf-8"?>
<CLAS CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" VERSION="1" LANGU="E" DESCRIPT="Utilities ITAB dinámicas" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
 <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes</localImplementation>
 <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature</localTypes>
 <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
 <typeUsage CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X"/>
 <forwardDeclaration>ABAP</forwardDeclaration>
 <attribute CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="D_TEXT_TYPE" VERSION="1" LANGU="E" DESCRIPT="Literal of type in absolute name" EXPOSURE="1" STATE="1" EDITORDER="1 " ATTDECLTYP="1" ATTVALUE="&apos;TYPE=&apos;" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <method CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FIELDS_BASE" VERSION="1" LANGU="E" DESCRIPT="Create internat table from some base camps" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FIELDS_BASE" SCONAME="I_BASE_FIELDS" VERSION="1" LANGU="E" DESCRIPT="pointer to the type of data fields" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FIELDS_BASE" SCONAME="I_NEW_FIELDS" VERSION="1" LANGU="E" DESCRIPT="Catálogo campos p.ListViewerControl" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LVC_T_FCAT"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FIELDS_BASE" SCONAME="E_TABLE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
  <source>METHOD create_it_fields_base.
  DATA lo_data TYPE REF TO data.

  GET REFERENCE OF i_base_fields INTO lo_data.

  CALL METHOD zcl_util_itab_dynamic=&gt;create_it_fields_base_ref
    EXPORTING
      i_base_fields = lo_data
      i_new_fields  = i_new_fields
    IMPORTING
      e_table       = e_table.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FIELDS_BASE_REF" VERSION="1" LANGU="E" DESCRIPT="Create internat table from reference some base camps" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FIELDS_BASE_REF" SCONAME="I_BASE_FIELDS" VERSION="1" LANGU="E" DESCRIPT="pointer to the type of data fields" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FIELDS_BASE_REF" SCONAME="I_NEW_FIELDS" VERSION="1" LANGU="E" DESCRIPT="Catálogo campos p.ListViewerControl" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LVC_T_FCAT"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FIELDS_BASE_REF" SCONAME="E_TABLE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
  <source>METHOD CREATE_IT_FIELDS_BASE_REF.

  DATA: le_fcat TYPE lvc_s_fcat,
        lt_fcat TYPE lvc_t_fcat,
        tabname TYPE dd02l-tabname,
        new_line TYPE REF TO data.
  DATA lo_struct_ref TYPE REF TO cl_abap_structdescr.
  DATA ld_name_type TYPE string.
  DATA ld_dataref TYPE REF TO data.
  DATA lt_components TYPE cl_abap_structdescr=&gt;component_table.
  DATA lt_components_new TYPE cl_abap_structdescr=&gt;component_table.
  DATA lo_new_tab  TYPE REF TO cl_abap_tabledescr.
  DATA lo_new_wa TYPE REF TO cl_abap_structdescr.
  DATA lo_data TYPE REF TO data.
  FIELD-SYMBOLS &lt;component&gt; TYPE LINE OF abap_compdescr_tab.
  FIELD-SYMBOLS &lt;table&gt; TYPE STANDARD TABLE.

* Obtengo los componentes del tipo de datos
  lo_struct_ref ?= cl_abap_typedescr=&gt;describe_by_data_ref( i_base_fields ).

* Obtengo los componentes
  lt_components = lo_struct_ref-&gt;get_components( ).

* Convierto el fieldcat del campo en componentes
  CALL METHOD get_component_from_fcat
    EXPORTING
      i_fcat       = i_new_fields
    RECEIVING
      r_components = lt_components_new.

* Añado los nuevos componentes a los existentes
  APPEND LINES OF lt_components_new TO lt_components.

* Creo un nuevo tipo de datos con los componentes pasados.
  lo_struct_ref = cl_abap_structdescr=&gt;create( lt_components ).

* Creo que la nueva tabla interna
  lo_new_tab = cl_abap_tabledescr=&gt;create(
                  p_line_type  = lo_struct_ref
                  p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
                  p_unique     = abap_false ).

* Creamos el manejador de la nueva tabla
  CREATE DATA e_table TYPE HANDLE lo_new_tab.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FROM_STRUC" VERSION="1" LANGU="E" DESCRIPT="Create internal table from name of structure" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FROM_STRUC" SCONAME="I_STRUC" VERSION="1" LANGU="E" DESCRIPT="Estructura de datos" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FROM_STRUC" SCONAME="E_TABLE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_IT_FROM_STRUC" SCONAME="E_WORKAREA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
  <source>METHOD create_it_from_struc.
  DATA lo_error TYPE REF TO cx_sy_table_creation.
  DATA ld_txt_error TYPE string.
  DATA lo_struct_ref TYPE REF TO cl_abap_structdescr.
  DATA lt_components TYPE cl_abap_structdescr=&gt;component_table.
  DATA lo_new_tab  TYPE REF TO cl_abap_tabledescr.
  DATA lo_new_wa TYPE REF TO cl_abap_structdescr.

* Obtengo los componentes del tipo de datos
  lo_struct_ref ?= cl_abap_typedescr=&gt;describe_by_name( i_struc ).

* Obtengo los componentes
  lt_components = lo_struct_ref-&gt;get_components( ).

* Creo un nuevo tipo de datos con los componentes pasados.
  lo_new_wa = cl_abap_structdescr=&gt;create( lt_components ).

* Creo que la nueva tabla interna
  TRY.
      lo_new_tab = cl_abap_tabledescr=&gt;create(
                      p_line_type  = lo_new_wa
                      p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
                      p_unique     = abap_false ).

* Creamos el manejador de la nueva tabla
      CREATE DATA e_table TYPE HANDLE lo_new_tab.

* Y su cabecera
      CREATE DATA e_workarea TYPE HANDLE lo_new_wa.


    CATCH cx_sy_table_creation INTO lo_error.
      ld_txt_error = lo_error-&gt;get_text( ).
  ENDTRY.


ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_WA_FROM_STRUC" VERSION="1" LANGU="E" DESCRIPT="Create work area from name of structure" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_WA_FROM_STRUC" SCONAME="I_STRUC" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="CREATE_WA_FROM_STRUC" SCONAME="E_WORKAREA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="3" TYPE="DATA"/>
  <source>METHOD create_wa_from_struc.
  DATA lo_error TYPE REF TO cx_sy_struct_creation.
  DATA d_txt_error TYPE string.
  DATA lo_struct_ref TYPE REF TO cl_abap_structdescr.
  DATA lt_components TYPE cl_abap_structdescr=&gt;component_table.
  DATA lo_wa TYPE REF TO cl_abap_structdescr.
  FIELD-SYMBOLS &lt;component&gt; TYPE LINE OF abap_compdescr_tab.

* Obtengo los componentes del tipo de datos
  lo_struct_ref ?= cl_abap_typedescr=&gt;describe_by_name( i_struc ).

* Obtengo los componentes
  lt_components = lo_struct_ref-&gt;get_components( ).

* Creo un nuevo tipo de datos con los componentes pasados.
  TRY.
      lo_wa = cl_abap_structdescr=&gt;create( lt_components ).

* Creamos el manejador de la nueva tabla
      CREATE DATA e_workarea TYPE HANDLE lo_wa.

    CATCH cx_sy_struct_creation INTO lo_error.
      d_txt_error = lo_error-&gt;get_text( ).

  ENDTRY.



ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="GET_COMPONENT_FROM_FCAT" VERSION="1" LANGU="E" DESCRIPT="Get components from fieldcat" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="GET_COMPONENT_FROM_FCAT" SCONAME="I_FCAT" VERSION="1" LANGU="E" DESCRIPT="Catálogo campos p.ListViewerControl" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="LVC_T_FCAT"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="GET_COMPONENT_FROM_FCAT" SCONAME="R_COMPONENTS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CL_ABAP_STRUCTDESCR=&gt;COMPONENT_TABLE"/>
  <source>METHOD get_component_from_fcat.
  DATA le_component TYPE LINE OF cl_abap_structdescr=&gt;component_table.
  DATA lo_typedescr TYPE REF TO cl_abap_typedescr.
  DATA lo_structdesc TYPE REF TO cl_abap_structdescr.
  DATA ld_type_elem TYPE string.

  FIELD-SYMBOLS &lt;ls_fcat&gt; TYPE LINE OF lvc_t_fcat.

  CLEAR r_components.

  LOOP AT i_fcat ASSIGNING &lt;ls_fcat&gt;.

    le_component-name = &lt;ls_fcat&gt;-fieldname.

* Obtengo la información del elementos de datos
    lo_typedescr = cl_abap_elemdescr=&gt;describe_by_name( &lt;ls_fcat&gt;-rollname ).

    ld_type_elem = lo_typedescr-&gt;type_kind.

    CASE ld_type_elem.

      WHEN cl_abap_elemdescr=&gt;typekind_char.
        le_component-type = cl_abap_elemdescr=&gt;get_c( p_length   = lo_typedescr-&gt;length ).

      WHEN cl_abap_elemdescr=&gt;typekind_packed.
* Obtengo el tipo de datos segun el componente
        le_component-type = cl_abap_elemdescr=&gt;get_p( p_length   = lo_typedescr-&gt;length
                                                      p_decimals = lo_typedescr-&gt;decimals ).

      WHEN cl_abap_elemdescr=&gt;typekind_num.
        le_component-type = cl_abap_elemdescr=&gt;get_n( p_length   = lo_typedescr-&gt;length ).

      WHEN cl_abap_elemdescr=&gt;typekind_date.
        le_component-type = cl_abap_elemdescr=&gt;get_d( ).

      WHEN cl_abap_elemdescr=&gt;typekind_string.
        le_component-type = cl_abap_elemdescr=&gt;get_string( ).

      WHEN cl_abap_elemdescr=&gt;typekind_int.
        le_component-type = cl_abap_elemdescr=&gt;get_i( ).

      WHEN cl_abap_elemdescr=&gt;typekind_struct1. &quot; Estructura diccionario

        le_component-type ?= cl_abap_typedescr=&gt;describe_by_name( &lt;ls_fcat&gt;-rollname ).

      WHEN cl_abap_elemdescr=&gt;typekind_table. &quot; Tabla interna

        le_component-type ?= cl_abap_typedescr=&gt;describe_by_name( &lt;ls_fcat&gt;-rollname ).

*    when cl_abap_elemdescr=&gt;TYPEKIND_struct2.
*    when cl_abap_elemdescr=&gt;TYPEKIND_INT1
*    when cl_abap_elemdescr=&gt;TYPEKIND_CLASS.

    ENDCASE.
    IF le_component IS NOT INITIAL.
      APPEND le_component TO r_components.
      CLEAR le_component.
      FREE lo_typedescr.
    ENDIF.


  ENDLOOP.



*    DATA lo_typedescr  TYPE REF TO cl_abap_elemdescr.
*  DATA le_component TYPE LINE OF cl_abap_structdescr=&gt;component_table.
*
*  FIELD-SYMBOLS &lt;ls_fcat&gt; TYPE LINE OF lvc_t_fcat.
*
*  CLEAR r_components.
*
*  LOOP AT i_fcat ASSIGNING &lt;ls_fcat&gt;.
*
*    le_component-name = &lt;ls_fcat&gt;-fieldname.
*
** Obtengo la información del elementos de datos
*    lo_typedescr ?= cl_abap_elemdescr=&gt;describe_by_name( &lt;ls_fcat&gt;-rollname ).
*
**    TYPE_KIND
*case
** Obtengo el tipo de datos segun el componente
*    le_component-type = cl_abap_elemdescr=&gt;get_p( p_length   = lo_typedescr-&gt;length
*                                                  p_decimals = lo_typedescr-&gt;decimals ).
*
*    APPEND le_component TO r_components.
*    CLEAR le_component.
*    FREE lo_typedescr.
*
*  ENDLOOP.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="GET_NAME_OF_TYPE" VERSION="1" LANGU="E" DESCRIPT="Gets the name of the pointer data type" EXPOSURE="1" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="GET_NAME_OF_TYPE" SCONAME="I_ABSOLUTE_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_ABSTYPENAME"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="GET_NAME_OF_TYPE" SCONAME="R_NAME_TYPE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method GET_NAME_OF_TYPE.
  DATA ld_pos TYPE i.

  CLEAR r_name_type.

* Busco donde empieza el literal TYPE=.
  FIND FIRST OCCURRENCE OF d_text_type IN i_absolute_name MATCH OFFSET ld_pos.
  IF sy-subrc = 0.

* Obtengo el literal desde la posición donde esta el valor DE TYPE=
    r_name_type = i_absolute_name+ld_pos.

* Eliminio el TYPE= para quedarme con el nombre
    REPLACE ALL OCCURRENCES OF d_text_type IN r_name_type WITH space.

  ENDIF.


endmethod.</source>
 </method>
 <method CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="PIVOT_TABLE" VERSION="1" LANGU="E" DESCRIPT="Pivot table based on another" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="PIVOT_TABLE" SCONAME="I_PIVOT_PATTERN" VERSION="1" LANGU="E" DESCRIPT="Pivot field pattern" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="PIVOT_TABLE" SCONAME="I_MOVE_FIELD" VERSION="1" LANGU="E" DESCRIPT="Field that moves to the pivot fields" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="PIVOT_TABLE" SCONAME="I_ITAB_SOURCE" VERSION="1" LANGU="E" DESCRIPT="Table data source" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STANDARD TABLE"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="PIVOT_TABLE" SCONAME="I_PIVOT_FIELD" VERSION="1" LANGU="E" DESCRIPT="Pivot field" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_UTIL_ITAB_DYNAMIC" CMPNAME="PIVOT_TABLE" SCONAME="C_PIVOT_TABLE" VERSION="1" LANGU="E" DESCRIPT="Pivot table destination" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="STANDARD TABLE"/>
  <source>method PIVOT_TABLE.
  FIELD-SYMBOLS &lt;le_pivot&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;le_source&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;le_pivot_field&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;le_field&gt; TYPE ANY.
  FIELD-SYMBOLS &lt;le_move_field&gt; TYPE ANY.
  DATA le_pivot TYPE REF TO data.
  DATA ld_field TYPE string.

* Creo la workarea de la tabla pivote
  CREATE DATA le_pivot LIKE LINE OF c_pivot_table.
  ASSIGN le_pivot-&gt;* TO &lt;le_pivot&gt;.

* Recorro la tabla de origen
  LOOP AT i_itab_source ASSIGNING &lt;le_source&gt;.

* Muevo los campos comunes
    MOVE-CORRESPONDING &lt;le_source&gt; TO &lt;le_pivot&gt;.

* Obtengo el valor del campo que se va pivotar
    ASSIGN COMPONENT i_pivot_field OF STRUCTURE &lt;le_source&gt; TO &lt;le_field&gt;.

    IF sy-subrc = 0.

* Creo el campo donde se pondra el valor en la tabla pivote.
      CONCATENATE &apos;&lt;LE_PIVOT&gt;-&apos; i_pivot_pattern &lt;le_field&gt; INTO ld_field.
      ASSIGN (ld_field) TO &lt;le_pivot_field&gt;.

      IF sy-subrc = 0.

* Obtengo el valor del campo que se va mover su valor al del
* campo de la tabla pivote.
        CONCATENATE &apos;&lt;LE_SOURCE&gt;-&apos; i_move_field INTO ld_field.
        ASSIGN (ld_field) TO &lt;le_move_field&gt;.
        IF sy-subrc = 0.

          &lt;le_pivot_field&gt; = &lt;le_move_field&gt;.
          COLLECT &lt;le_pivot&gt; INTO c_pivot_table.
          CLEAR &lt;le_pivot&gt;.

        ENDIF.
      ENDIF.

    ENDIF.

  ENDLOOP.

endmethod.</source>
 </method>
</CLAS>

*&------------------------------------------------------------------------------------------------------------*
*& Report  ZSQL_FREE
*&
*&------------------------------------------------------------------------------------------------------------*
*&                                            Hovitaga OpenSQL Editor
*&
*&                                      FREE EDITION for 7.00 basis release
*&
*&                                 upgrade to full version at www.hovitaga.com
*&
*&   The full version has additional features like:
*&
*&   - edit unlimited number of commands, save and load, can be organized to folders
*&   - report generation based on a select command: generate 150-1000+ lines of code with a push of a button
*&   - select for all entries syntax
*&   - field selector wizard
*&   - Tree display mode
*&   - the result set is editable, easy modification of table contents possible (only with authorizations!)
*&   - import data from Excel/Access (only with authorizations!)
*&   - executing ABAP code on the result set of a query (only with authorizations!)
*&   - record and column level authorizations
*&   - mass update, mass delete (only with authorizations!)
*&
*&   INSTALL INSTRUCTIONS
*&
*&   1, Just execute the report for the first time to install it
*&   2, Execute again to run it
*&
*&-------------------------------------------------------------------------------------------------------------*

REPORT zsql_free MESSAGE-ID zsql_free.

CONSTANTS: gc_version(2) TYPE c VALUE '10',
           gc_hash(32) TYPE c VALUE 'e38d66f9d63497f735b10d2b2562ef6f'.

TYPE-POOLS: abap, icon, rsds, sqlt, trdev, slis.

TYPES: lty_commandtype(2) TYPE n.
TYPES: lty_keycol_type TYPE c.
TYPES: lty_last_display_mode TYPE c.
TYPES: lty_commandid TYPE i.
TYPES: lty_gen_prog_nro(10) TYPE n.
TYPES: lty_zhtdb_table_type TYPE c.

TYPES: lty_zhtdb_vrange_text(255) TYPE c.

TYPES: BEGIN OF lty_zhtdb_alv_tab,
        ddtext  TYPE lty_zhtdb_vrange_text,
        tablename	TYPE tabname,
        fieldname	TYPE fieldname,
        alias	TYPE tabname,
       END OF lty_zhtdb_alv_tab.

TYPES: BEGIN OF lty_zhtdb_checktable_struc,
        tabname	TYPE tabname,
        fieldname	TYPE forfield,
        forkey  TYPE forkey,
        cardleft  TYPE cardleft,
        card  TYPE card,
        checktable  TYPE checktable,
       END OF lty_zhtdb_checktable_struc.

TYPES: lty_zhtdb_join_text(512) TYPE c.

TYPES: BEGIN OF lty_zhtdb_checktable_struc_alv,
            tabname	TYPE tabname,
            ddtext  TYPE as4text,
            longtext  TYPE lty_zhtdb_join_text,
         END OF lty_zhtdb_checktable_struc_alv.

TYPES: BEGIN OF lty_zhtdb_fieldinfo,
         table  TYPE tabname,
         field  TYPE fieldname,
         is_key	TYPE flag,
         orig_field	TYPE char50,
         field_alias  TYPE char50,
         table_alias  TYPE char50,
         agg_function	TYPE char50,
         distinctf  TYPE flag,
         generated_field  TYPE char50,
         samecount  TYPE int4,
       END OF lty_zhtdb_fieldinfo.

TYPES: BEGIN OF lty_zhtdb_keyword,
        keyword	TYPE string,
         required	TYPE c,
         order_pos  TYPE i,
         begins_at  TYPE i,
         ends_at  TYPE i,
         additions  TYPE string,
         text	TYPE string,
  END OF lty_zhtdb_keyword.

TYPES: BEGIN OF lty_zhtdb_sign_pos,
          position TYPE i,
          type(3) TYPE c,
       END OF lty_zhtdb_sign_pos.

TYPES: BEGIN OF lty_zhtdb_table_aliases,
         table  TYPE tabname,
         alias  TYPE  string,
         explain_alias    TYPE string,
         type	TYPE lty_zhtdb_table_type,
         position	TYPE i,
       END OF lty_zhtdb_table_aliases.

TYPES: lty_zhtdbt_string_tab TYPE TABLE OF string.


TYPES: lty_zhtdb_fieldinfo_tt TYPE TABLE OF lty_zhtdb_fieldinfo.
TYPES: lty_zhtdb_sign_pos_tt TYPE TABLE OF lty_zhtdb_sign_pos.



TYPES: lty_zhtdb_table_aliases_tt TYPE TABLE OF lty_zhtdb_table_aliases.

TYPES: BEGIN OF lty_zhdb_vrange,
         alias      TYPE tabname,
         rsds_range TYPE rsds_range,
       END OF lty_zhdb_vrange.

TYPES: lty_zhdb_vrange_tab TYPE STANDARD TABLE OF lty_zhdb_vrange.

CONSTANTS: gc_line_length            TYPE i VALUE 132.

CONSTANTS: gc_ctype_select           TYPE lty_commandtype VALUE 1,
           gc_ctype_update           TYPE lty_commandtype VALUE 2,
           gc_ctype_delete           TYPE lty_commandtype VALUE 3,
           gc_ctype_lawb             TYPE lty_commandtype VALUE 4,
           gc_ctype_selfae           TYPE lty_commandtype VALUE 5,
           gc_ctype_script           TYPE lty_commandtype VALUE 6.

CONSTANTS: gc_style_repo_folder      TYPE i VALUE 101,
           gc_style_obj_list         TYPE i VALUE 103,
           gc_style_my_repo          TYPE i VALUE 104,
           gc_style_curr_comm        TYPE i VALUE 105,
           gc_style_pkg_content      TYPE i VALUE 106,
           gc_style_pkg_name         TYPE i VALUE 107,
           gc_style_obj_list_elem    TYPE i VALUE 108,
           gc_style_native           TYPE i VALUE 109,
           gc_style_select_fae       TYPE i VALUE 110,
           gc_style_lawb             TYPE i VALUE 111,
           gc_style_script           TYPE i VALUE 112,
           gc_style_delete_command   TYPE i VALUE 113,
           gc_style_update_command   TYPE i VALUE 114,
           gc_style_select_command   TYPE i VALUE 115,
           gc_style_bo               TYPE i VALUE 116,
           gc_style_bo_folder        TYPE i VALUE 117,
           gc_style_rfc_select       TYPE i VALUE 140,
           gc_style_rfc_selfae       TYPE i VALUE 141,
           gc_style_param_displ      TYPE i VALUE 142,
           gc_style_lonakafasza      TYPE i VALUE 118.

* Distinguish the possible nodes
CONSTANTS: sem5_node_type_class      TYPE n VALUE  0, " class
           sem5_node_type_interface  TYPE n VALUE  1, " interface
           sem5_node_type_appl_comp  TYPE n VALUE  7, " application component
           sem5_node_type_dev_class  TYPE n VALUE  6, " development class
           sem5_node_type_category   TYPE n VALUE  8, " classes / interfaces
           sem5_node_type_pred_succ  TYPE n VALUE  9. " 'inherits from' etc.

CONSTANTS: gc_result_page_size       TYPE i VALUE 200,
           gc_result_size_warning    TYPE i VALUE 5000.


TYPES: lty_colmn_header TYPE c.

TYPES: BEGIN OF ty_notes,
         line(gc_line_length) TYPE c,
       END OF ty_notes.

TYPES: gty_tb_name       TYPE dd02d-dbtabname,
       gty_fld_name      TYPE dd03p-fieldname.

TYPES: gty_fieldinfo     TYPE lty_zhtdb_fieldinfo.

TYPES: gty_table_aliases TYPE lty_zhtdb_table_aliases.

TYPES: BEGIN OF gty_ddicref,
         fieldname     TYPE gty_fld_name,
         checktable    TYPE tabname,
         ref_table     TYPE gty_tb_name,
         ref_field     TYPE gty_fld_name,
         key           TYPE c,
       END OF gty_ddicref.

TYPES: BEGIN OF source,
         line(gc_line_length) TYPE c,
       END OF source.

*source_table TYPE rcg_bag_rssource.
TYPES: source_table    TYPE soli_tab.

TYPES: gty_commandtext TYPE string.

TYPES: BEGIN OF gty_linkedquery,
         fcode         TYPE ui_func,
         tabname       TYPE gty_tb_name,
         checktable    TYPE gty_tb_name,
         fieldname     TYPE gty_fld_name,
         checkfield    TYPE gty_fld_name,
         text(40)      TYPE c,
         longtext(255) TYPE c,
         join_type     TYPE c,
         ddtext        TYPE dd02t-ddtext,
         primpos       TYPE dd05m-primpos,
       END OF gty_linkedquery.

TYPES: BEGIN OF gty_ranges,
*        tablename     TYPE dd02d-dbtabname,
         table_alias   TYPE string,
         fieldname     TYPE dd03p-fieldname,
         range         TYPE rsds_selopt_t,
         node_text     TYPE lvc_value,
         node_key      TYPE lvc_nkey,
         where_text    TYPE string,
       END OF gty_ranges.

TYPES: BEGIN OF gty_tab_node_xref,
         node_key      TYPE lvc_nkey,
         tablename     TYPE tabname,
         alias         TYPE string,
       END OF gty_tab_node_xref.

TYPES: BEGIN OF gty_alias_ranges,
         table_alias   TYPE string,
         fields        TYPE rsdsfields_t,
         expr          TYPE rsds_texpr, " zhtdb_exprtab,
         sel_id        TYPE rsdynsel-selid,
         active        TYPE i,
       END OF gty_alias_ranges.

TYPES: BEGIN OF mty_t_type,
         line(255),
       END OF mty_t_type.

TYPES: mty_tt_type TYPE STANDARD TABLE OF mty_t_type WITH
                          NON-UNIQUE DEFAULT KEY INITIAL SIZE 500.


FIELD-SYMBOLS: <gt_result>    TYPE STANDARD TABLE,
               <gt_display>   TYPE STANDARD TABLE,
               <gt_temp>      TYPE STANDARD TABLE,
               <gt_tree>      TYPE STANDARD TABLE,
               <gt_undo>      TYPE STANDARD TABLE,
               <gs_result>,
               <gf_result>,
               <gs_temp>,
               <gs_undo>,
               <gf_temp>,
                <itab>        TYPE STANDARD TABLE,
               <ntab>         TYPE STANDARD TABLE.


DATA: gv_def_col_hdr         TYPE lty_colmn_header,
      gv_def_keycol_type         TYPE lty_keycol_type,

      gv_0100_first_run      TYPE flag VALUE 'X'.

DATA: gt_tab_node_xref       TYPE TABLE OF gty_tab_node_xref,
      gs_tab_node_xref       TYPE gty_tab_node_xref.

DATA: gs_linkedquery         TYPE gty_linkedquery,
      gt_linkedquery         TYPE TABLE OF gty_linkedquery,

      gs_linkedquery_comp    TYPE gty_linkedquery,
      gt_linkedquery_comp    TYPE TABLE OF gty_linkedquery.


DATA: gt_prev_table_aliases  TYPE TABLE OF gty_table_aliases.

DATA: gs_ranges              TYPE gty_ranges.

DATA: ok_code                TYPE sy-ucomm,
      ok_code_200            TYPE sy-ucomm,
      ok_code_300            TYPE sy-ucomm,
      ok_code_400            TYPE sy-ucomm,
      ok_code_500            TYPE sy-ucomm,
      ok_code_700            TYPE sy-ucomm,
      ok_code_800            TYPE sy-ucomm,
      ok_code_900            TYPE sy-ucomm,
      ok_code_950            TYPE sy-ucomm,
      ok_code_1000           TYPE sy-ucomm.

DATA: gv_dynnr(4)            TYPE n VALUE '0101',
      gv_dynnr2(4)           TYPE n VALUE '0101'.

DATA: g_textedit             TYPE REF TO cl_gui_abapedit. "cl_gui_textedit.

DATA: g_container_textedit_200 TYPE REF TO cl_gui_custom_container,
      g_textedit_200         TYPE REF TO cl_gui_textedit.

DATA: g_alv                  TYPE REF TO cl_gui_alv_grid,
      go_field_selector_alv  TYPE REF TO cl_gui_alv_grid,
      go_selscr_fields_alv   TYPE REF TO cl_gui_alv_grid,
      gs_fcat                TYPE lvc_s_fcat,
      gt_fcat                TYPE lvc_t_fcat,
      gs_layo                TYPE lvc_s_layo,
      gt_toolbar_exclude     TYPE ui_functions,
      gs_toolbar_exclude     TYPE ui_func,
      gt_toolbar_table       TYPE ttb_button.

DATA: g_tree_tb              TYPE REF TO cl_gui_alv_tree,
      gs_fcat_tb             TYPE lvc_s_fcat,
      gt_fcat_tb             TYPE lvc_t_fcat,
      gs_layo_tb             TYPE lvc_s_layo,
      gt_toolbar_exclude_tb  TYPE ui_functions,
      gs_toolbar_exclude_tb  TYPE ui_func,
      gt_toolbar_table_tb    TYPE ttb_button,
      gs_outtab_tb           TYPE lty_zhtdb_alv_tab,
      g_toolbar_textedit     TYPE REF TO cl_gui_toolbar,
      g_toolbar_tb_tree      TYPE REF TO cl_gui_toolbar,
      g_toolbar_commands     TYPE REF TO cl_gui_toolbar.

DATA: autotrace(1)           TYPE c,
      lockresults(1)         TYPE c,
      clientspecified(1)     TYPE c,
      clientspec_ud(1)       TYPE c,
      bypassingbuffer(1)     TYPE c,
      orderbypk(1)           TYPE c,
      rfc_destination        TYPE rfcdest.

DATA: gv_styce_colname       TYPE lvc_fname,

      gt_prev_text           TYPE source_table,
      gv_prev_nodekey        TYPE lvc_nkey,
      gt_prev_fcat           TYPE lvc_t_fcat.


PERFORM install.
PERFORM update.

CALL SCREEN 100.

*&---------------------------------------------------------------------*
*&  Include           ZHTDB_CLASSES                                    *
*&---------------------------------------------------------------------*



CLASS lcl_toolbox DEFINITION.

*"* public components of class LCL_TOOLBOX
*"* do not include other source files here!!!
  PUBLIC SECTION.

    CLASS-METHODS split_string
       IMPORTING
         !iv_string TYPE string
         !iv_maxlen TYPE i
         !iv_log_handle TYPE balloghndl OPTIONAL
       EXPORTING
         !et_string_tab TYPE lty_zhtdbt_string_tab.
    CLASS-METHODS get_word_at_pos
      IMPORTING
        !iv_string TYPE string
        !iv_position TYPE i
      EXPORTING
        !ev_word TYPE string.
    CLASS-METHODS parse_aptph
      IMPORTING
        !iv_condense TYPE flag DEFAULT 'X'
        !iv_log_handle TYPE balloghndl OPTIONAL
      EXPORTING
        !et_aptph_pos TYPE lty_zhtdb_sign_pos_tt
        !et_paranth TYPE lty_zhtdb_sign_pos_tt
      CHANGING
        !cv_string TYPE string
      EXCEPTIONS
        missing_aptph
        missing_parnth .
    CLASS-METHODS select_single_gen
      IMPORTING
        !is_key_value TYPE REF TO data
        !iv_table_name TYPE strukname
        !it_keyf_list TYPE lty_zhtdbt_string_tab
      EXPORTING
        !es_record TYPE REF TO data .
    CLASS-METHODS convert_to_uppercase
      CHANGING
        !cv_string TYPE string .
    CLASS-METHODS pretty_printer
      CHANGING
        !ct_source TYPE soli_tab .
    CLASS-METHODS is_client_field
      IMPORTING
        !iv_tabname TYPE tabname
        !iv_fieldname TYPE fieldname
      RETURNING
        value(ev_client_field) TYPE char1 .
    CLASS-METHODS has_client_field
      IMPORTING
        !iv_tabname TYPE tabname
      RETURNING
        value(ev_has_client_field) TYPE char1 .
    CLASS-METHODS pretty_printer_string
      CHANGING
        !ct_source TYPE lty_zhtdbt_string_tab .
    CLASS-METHODS determinte_tab_type
      IMPORTING
        !iv_table TYPE tabname
      RETURNING
        value(ev_type) TYPE lty_zhtdb_table_type
      EXCEPTIONS
        table_not_exist .

ENDCLASS.                    "LCL_TOOLBOX DEFINITION

*----------------------------------------------------------------------*
*       CLASS LCL_TOOLBOX IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_toolbox IMPLEMENTATION.

  METHOD get_word_at_pos.

    DATA: lv_length TYPE i,
          lv_char   TYPE char1,
          lv_shift  TYPE i,
          lv_start  TYPE i,
          lv_end    TYPE i.


    lv_length = STRLEN( iv_string ).

* check if position is valid
    IF lv_length   < iv_position OR
       iv_position < 1.
      RETURN.
    ENDIF.

    lv_shift = iv_position - 1.
    lv_char = iv_string+lv_shift(1).

* space does not matter
    IF lv_char = space.
      RETURN.
    ENDIF.

* determine start
    DO.
      lv_char = iv_string+lv_shift(1).

      IF lv_char = space.
        lv_start = lv_shift + 1.
        EXIT.
      ENDIF.

      lv_shift = lv_shift - 1.
      IF lv_shift < 0.
        lv_start = lv_shift + 1.
        EXIT.
      ENDIF.
    ENDDO.

* determine end
    lv_shift = iv_position - 1.
    DO.
      lv_char = iv_string+lv_shift(1).

      IF lv_char = space.
        lv_end = lv_shift.
        EXIT.
      ENDIF.

      lv_shift = lv_shift + 1.
      IF lv_shift = lv_length.
        lv_end = lv_shift.
        EXIT.
      ENDIF.
    ENDDO.

    lv_length = lv_end - lv_start.
    ev_word = iv_string+lv_start(lv_length).

  ENDMETHOD.                    "

  METHOD split_string.

    DATA: lt_aptph_pos TYPE lty_zhtdb_sign_pos_tt,
          ls_aptph_pos TYPE lty_zhtdb_sign_pos,
          lv_string    TYPE string,
          lv_newstr    TYPE string,
          lv_actstr    TYPE string,
          lv_char      TYPE c,
          lv_shift     TYPE i,
          lv_lastsp    TYPE i,
          lv_length    TYPE i,
          lv_strg_lgth TYPE i,
          lv_index     TYPE i.


    IF iv_string IS INITIAL.
      RETURN.
    ENDIF.

    lv_string = iv_string.

    parse_aptph( EXPORTING  iv_condense   = space
                            iv_log_handle = iv_log_handle
                 IMPORTING  et_aptph_pos  = lt_aptph_pos
                 CHANGING   cv_string     = lv_string
                 EXCEPTIONS OTHERS        = 1 ).

    lv_shift = -1.
    lv_strg_lgth = STRLEN( lv_string ).

    DO.
      lv_shift = lv_shift + 1.
      IF lv_shift >= lv_strg_lgth.
        EXIT.
      ENDIF.

      lv_char = lv_string+lv_shift(1).  " current character

      IF lv_char = space.
        CONCATENATE lv_actstr lv_char INTO lv_actstr
          SEPARATED BY space.   " otherwise the SPACE will be lost ...
        lv_length = lv_length + 1.

*     check, if the SPACE is inside of apostrophes
        lv_index = lv_shift + 1.
        READ TABLE lt_aptph_pos INDEX lv_index INTO ls_aptph_pos.

        IF ls_aptph_pos-type = 'O'.  " outside of apostrophes
          IF lv_length > iv_maxlen.
*       the length of actual line is bigger than the maximum allowed
            IF lv_lastsp <> 0.   " there is a right position to cut
*           cut string at the last SPACE to get the current line
              lv_newstr = lv_actstr(lv_lastsp).
              IF lv_newstr(1) = '*'.
                SHIFT lv_newstr RIGHT BY 1 PLACES.
              ENDIF.

*           the rest is the new line
              lv_actstr = lv_actstr+lv_lastsp.
              lv_length = lv_length - lv_lastsp.
              lv_lastsp = lv_length.
              APPEND lv_newstr TO et_string_tab.

*           the new line might be already longer, than allowed
              IF lv_length >= iv_maxlen.
                IF lv_actstr(1) = '*'.
                  SHIFT lv_actstr RIGHT BY 1 PLACES.
                ENDIF.
                APPEND lv_actstr TO et_string_tab.
                CLEAR lv_actstr.
                lv_length = 0.
              ENDIF.
            ELSE.    " there is no right position to cut
              IF lv_actstr(1) = '*'.
                SHIFT lv_actstr RIGHT BY 1 PLACES.
              ENDIF.
              APPEND lv_actstr TO et_string_tab.
              CLEAR lv_actstr.
              lv_length = 0.
            ENDIF.
          ELSE.
*         this is the position of the last SPACE, where the string can be cut,
*         if no better position will be found
            lv_lastsp = lv_length.
          ENDIF.
        ENDIF.
      ELSE.    " not a SPACE
        CONCATENATE lv_actstr lv_char INTO lv_actstr.
        lv_length = lv_length + 1.
      ENDIF.
    ENDDO.

    IF lv_actstr IS NOT INITIAL.
      IF lv_length > iv_maxlen.
*   the length of actual line is bigger than the maximum allowed
        IF lv_lastsp <> 0.   " there is a right position to cut
*       cut string at the last SPACE to get the current line
          lv_newstr = lv_actstr(lv_lastsp).
          IF lv_newstr(1) = '*'.
            SHIFT lv_newstr RIGHT BY 1 PLACES.
          ENDIF.
          APPEND lv_newstr TO et_string_tab.

*       the rest is the new line
          lv_actstr = lv_actstr+lv_lastsp.
          IF lv_actstr(1) = '*'.
            SHIFT lv_actstr RIGHT BY 1 PLACES.
          ENDIF.
          APPEND lv_actstr TO et_string_tab.
        ELSE.    " there is no right position to cut
          IF lv_actstr(1) = '*'.
            SHIFT lv_actstr RIGHT BY 1 PLACES.
          ENDIF.
          APPEND lv_actstr TO et_string_tab.
        ENDIF.
      ELSE.  " length OK
        IF lv_actstr(1) = '*'.
          SHIFT lv_actstr RIGHT BY 1 PLACES.
        ENDIF.
        APPEND lv_actstr TO et_string_tab.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD parse_aptph.
* fills up the et_aptph_pos table: for each character of the command
* it sets the following flag:
*  - O - if the character is not part of a text
*  - A - if it is an apostrophe
*  - I - if it is part of a text

* fills up the et_paranth table with the positions of paranthesis

* executes a kind of CONDENSE, but outside of apostrophes only

    DATA: ls_aptph      LIKE LINE OF et_aptph_pos,
          ls_paranth    LIKE LINE OF et_aptph_pos,

          lv_strg_lgth  TYPE i,
          lv_char       TYPE c,

          lv_shift      TYPE i,
          lv_shift_sp   TYPE i,
          lv_shift_end  TYPE i,
          lv_next       TYPE i,
          lv_in_apostr  TYPE xfeld,
          lv_par_cnt    TYPE i.


    IF cv_string IS INITIAL.
      RETURN.
    ENDIF.

    lv_shift = -1.
    lv_strg_lgth = STRLEN( cv_string ).

    DO.
      lv_shift = lv_shift + 1.
      IF lv_shift >= lv_strg_lgth.
        EXIT.
      ENDIF.

      lv_char = cv_string+lv_shift(1).  " current character

      IF lv_char = ''''.

        IF lv_in_apostr = ' '.
*       => beginning of a text
          lv_in_apostr = 'X'.   " mark, that we are within a text

          ls_aptph-position = lv_shift + 1.
          ls_aptph-type = 'A'.
          APPEND ls_aptph TO et_aptph_pos.

          CONTINUE.
        ENDIF.

*     we are within a text

*     the next apostrophe closes the text, if it isn't doubled!
*     then both will be ignored
*     => the next character must be checked
        lv_next = lv_shift + 1.

        IF lv_next < lv_strg_lgth.

          IF cv_string+lv_next(1) = ''''.
*         these two apostrophes will be ignored
            ls_aptph-position = lv_shift + 1.
            ls_aptph-type = 'I'.
            APPEND ls_aptph TO et_aptph_pos.

            ls_aptph-position = lv_shift + 2.
            APPEND ls_aptph TO et_aptph_pos.

            lv_shift = lv_shift + 1.  " skip next character
          ELSE.
*         this apostrophe closes the text
            IF lv_in_apostr = 'X'.
              lv_in_apostr = ' '.   " mark, that we are not in a text
            ENDIF.
            ls_aptph-position = lv_shift + 1.
            ls_aptph-type = 'A'.
            APPEND ls_aptph TO et_aptph_pos.
          ENDIF.

        ELSE.

*       this apostrophe closes the text
          IF lv_in_apostr = 'X'.
            lv_in_apostr = ' '.   " mark, that we are not in a text
          ENDIF.
          ls_aptph-position = lv_shift + 1.
          ls_aptph-type = 'A'.
          APPEND ls_aptph TO et_aptph_pos.

        ENDIF.

      ELSE.  " lv_char <> ''''

        ls_aptph-position = lv_shift + 1.
        IF lv_in_apostr = 'X'.  " inside a text
          ls_aptph-type = 'I'.
        ELSE.
          ls_aptph-type = 'O'.  " outside of text
        ENDIF.
        APPEND ls_aptph TO et_aptph_pos.

*     check for '('
        IF lv_char      = '(' AND
           lv_in_apostr = ' '.    " not in a text

          lv_par_cnt = lv_par_cnt + 1.
          ls_paranth-type = lv_par_cnt.
          ls_paranth-position = lv_shift + 1.
          APPEND ls_paranth TO et_paranth.

        ENDIF.

*     check for ')'
        IF lv_char      = ')' AND
           lv_in_apostr = ' '.    " not in a text

          ls_paranth-type = lv_par_cnt.
          lv_par_cnt = lv_par_cnt - 1.
          ls_paranth-position = lv_shift + 1.
          APPEND ls_paranth TO et_paranth.

        ENDIF.

        IF iv_condense = 'X'.
*       condense SPACEs (outside of apostrophes only!)
          IF lv_char      = space AND
             lv_in_apostr = ' '.

            lv_shift_sp  = lv_shift + 1.
            lv_shift_end = lv_shift + 2.

            IF lv_shift_sp >= lv_strg_lgth.
              EXIT.
            ENDIF.

            DO.
              IF lv_shift_sp >= lv_strg_lgth.
                EXIT.
              ENDIF.

              lv_char = cv_string+lv_shift_sp(1).
              IF lv_char = space.
                lv_strg_lgth = lv_strg_lgth - 1.
*             remove SPACE from position lv_shift_sp + 1
                CONCATENATE cv_string(lv_shift_sp) cv_string+lv_shift_end INTO cv_string.
              ELSE.
                EXIT.
              ENDIF.
            ENDDO.

          ENDIF.
        ENDIF.

      ENDIF.

    ENDDO.

    IF lv_in_apostr = 'X'.  " the command was not closed properly

      IF iv_log_handle IS INITIAL.
*     Message: An ending apostrophe is missing
        MESSAGE e005 RAISING missing_aptph.
      ELSE.
        RAISE missing_aptph.
      ENDIF.

    ENDIF.

    IF lv_par_cnt <> 0.  " the command was not closed properly
      IF iv_log_handle IS INITIAL.
*     Message: An closing paranthesis is missing
        MESSAGE e059 RAISING missing_parnth.
      ELSE.
        RAISE missing_parnth.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD select_single_gen.

    DATA: lv_keyfield TYPE fieldname,
          lr_data     TYPE REF TO data,
          lv_where    TYPE string,
          lv_keyval   TYPE string.

    FIELD-SYMBOLS: <ls_data>      TYPE ANY,
                   <lv_keyval>    TYPE ANY,
                   <ls_keyfields> TYPE ANY.


* create work area
    CREATE DATA lr_data TYPE (iv_table_name).
    ASSIGN lr_data->* TO <ls_data>.

    ASSIGN is_key_value->* TO <ls_keyfields>.

* create WHERE clause
    LOOP AT it_keyf_list INTO lv_keyfield.
      IF lv_where IS NOT INITIAL.
        CONCATENATE lv_where 'AND' INTO lv_where
          SEPARATED BY space.
      ENDIF.

      ASSIGN COMPONENT lv_keyfield OF STRUCTURE <ls_keyfields> TO <lv_keyval>.
      lv_keyval = <lv_keyval>.

      CONCATENATE lv_where lv_keyfield '= ''' INTO lv_where
        SEPARATED BY space.
      CONCATENATE lv_where lv_keyval '''' INTO lv_where.
    ENDLOOP.

    SELECT SINGLE * FROM (iv_table_name) INTO <ls_data>
      WHERE (lv_where).

    es_record = lr_data.

  ENDMETHOD.                    "

  METHOD convert_to_uppercase.

    DATA: lt_aptph_pos TYPE lty_zhtdb_sign_pos_tt,
          lv_aptph     TYPE lty_zhtdb_sign_pos,
          lv_char      TYPE c,
          lv_uppercase TYPE string.


    CALL METHOD lcl_toolbox=>parse_aptph
      EXPORTING
        iv_condense    = ' '
        iv_log_handle  = 'DUMMY'
      IMPORTING
        et_aptph_pos   = lt_aptph_pos
      CHANGING
        cv_string      = cv_string
      EXCEPTIONS
        missing_aptph  = 1
        missing_parnth = 2
        OTHERS         = 3.

    LOOP AT lt_aptph_pos INTO lv_aptph.

      lv_aptph-position = lv_aptph-position - 1.
      lv_char = cv_string+lv_aptph-position(1).

      IF lv_aptph-type EQ 'O'.
        TRANSLATE lv_char TO UPPER CASE.
      ENDIF.

      IF lv_char = space.
        CONCATENATE lv_uppercase lv_char INTO lv_uppercase SEPARATED BY space.   " otherwise the SPACE will be lost ...
      ELSE.
        CONCATENATE lv_uppercase lv_char INTO lv_uppercase.
      ENDIF.

    ENDLOOP.

    cv_string = lv_uppercase.

  ENDMETHOD.                    "convert_to_uppercase

  METHOD pretty_printer.

    DATA: ls_source LIKE LINE OF ct_source,
          lv_string TYPE string,
          lv_tabix  TYPE i.


    LOOP AT ct_source INTO ls_source.
      lv_tabix = sy-tabix.
      lv_string = ls_source-line.

      CALL METHOD lcl_toolbox=>convert_to_uppercase
        CHANGING
          cv_string = lv_string.

      ls_source-line = lv_string.

      MODIFY ct_source FROM ls_source INDEX lv_tabix.
    ENDLOOP.

  ENDMETHOD.                    "pretty_printer

  METHOD is_client_field.

    DATA: lv_datatype   TYPE dd03l-datatype,
          lv_fieldname  TYPE fieldname,
          lv_tabname    TYPE tabname,

          lt_x031l_tab  TYPE TABLE OF x031l,
          ls_x031l      TYPE x031l.

    CLEAR ev_client_field.

    lv_tabname   = iv_tabname.
    lv_fieldname = iv_fieldname.

    TRANSLATE lv_tabname   TO UPPER CASE.
    TRANSLATE lv_fieldname TO UPPER CASE.

    SELECT SINGLE datatype
      FROM dd03l INTO lv_datatype
      WHERE tabname   = lv_tabname AND
            fieldname = lv_fieldname AND
            keyflag   = 'X'.

    IF sy-subrc EQ 0.
      CALL FUNCTION 'DD_DICTIONARY_TO_NAMETAB'
        EXPORTING
          foreign_key = ' '
          status      = 'A'
          tabname     = lv_tabname
        TABLES
          x031l_tab   = lt_x031l_tab.

      IF sy-subrc EQ 0.
        READ TABLE lt_x031l_tab INTO ls_x031l
          WITH KEY fieldname = lv_fieldname.

        IF ls_x031l-dtyp = 'CLNT' AND ls_x031l-position = 1.
          ev_client_field = 'X'.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "is_client_field

  METHOD has_client_field.

    DATA: x030l_wa TYPE x030l.


    CLEAR ev_has_client_field.

    CHECK iv_tabname IS NOT INITIAL.

    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = iv_tabname
      IMPORTING
        x030l_wa       = x030l_wa
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
         WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    IF x030l_wa-clpos NE 0.
      ev_has_client_field = 'X'.
    ENDIF.

  ENDMETHOD.                    "has_client_field

  METHOD pretty_printer_string.

    DATA: ls_source LIKE LINE OF ct_source,
          lv_tabix  TYPE i.


    LOOP AT ct_source INTO ls_source.
      lv_tabix = sy-tabix.

      CALL METHOD lcl_toolbox=>convert_to_uppercase
        CHANGING
          cv_string = ls_source.

      MODIFY ct_source FROM ls_source INDEX lv_tabix.
    ENDLOOP.

  ENDMETHOD.                    "pretty_printer_string

  METHOD determinte_tab_type.

    DATA: lv_tabname TYPE tabname.


* check if it is a transparent table
    SELECT SINGLE tabname
      INTO lv_tabname FROM dd03vv
      WHERE tabname   = iv_table AND
            tabclass  = 'TRANSP' AND
            as4local  = 'A' AND
            fieldname NOT LIKE '.%' AND
            fieldname NOT LIKE '*%' AND
            fieldname NOT LIKE '$_%' ESCAPE '$' AND
            fieldname NOT LIKE '$%%' ESCAPE '$'.

* not transparent table
    IF sy-subrc EQ 4.

*   check if it is a view
*   viewfield instead of fieldname, field alias may be defined in a view!
      SELECT SINGLE viewname
        INTO lv_tabname FROM dd27s
        WHERE viewname  = iv_table AND
              as4local  = 'A' AND
*           possible to define * in views to include all fields from a table, and - to exclude a field
              viewfield <> '*' AND
              viewfield <> '-' AND
              fieldname NOT LIKE '.%' AND
              fieldname NOT LIKE '*%' AND
              fieldname NOT LIKE '$_%' ESCAPE '$' AND
              fieldname NOT LIKE '$%%' ESCAPE '$'.

*   not a view
      IF sy-subrc EQ 4.

*     check if it is a Clustered table
        SELECT SINGLE dd16s~sqltab
          INTO lv_tabname
          FROM dd16s INNER JOIN dd06l ON dd06l~sqltab = dd16s~sqltab
          WHERE dd16s~sqltab = iv_table AND
                dd06l~as4local = 'A' AND
                dd06l~sqlclass = 'CLUSTER' AND
                dd16s~fieldname NOT LIKE '.%' AND
                dd16s~fieldname NOT LIKE '*%' AND
                dd16s~fieldname NOT LIKE '$_%' ESCAPE '$' AND
                dd16s~fieldname NOT LIKE '$%%' ESCAPE '$'.

*     not a Clustered table
        IF sy-subrc EQ 4.

*       check if it is a Pooled table
          SELECT SINGLE dd16s~sqltab
            INTO lv_tabname
            FROM dd16s INNER JOIN dd06l ON dd06l~sqltab = dd16s~sqltab
            WHERE dd16s~sqltab = iv_table AND
                  dd06l~sqlclass = 'POOL' AND
                  dd06l~as4local = 'A' AND
                  dd16s~fieldname NOT LIKE '.%' AND
                  dd16s~fieldname NOT LIKE '*%' AND
                  dd16s~fieldname NOT LIKE '$_%' ESCAPE '$' AND
                  dd16s~fieldname NOT LIKE '$%%' ESCAPE '$'.

*       not a Pooled table
          IF sy-subrc EQ 4.
            RAISE table_not_exist.
*       it is a Pooled table
          ELSE.
            ev_type = 'P'.
          ENDIF.

*     it is a Clustered table
        ELSE.
          ev_type = 'C'.
*        CLEAR mv_can_edit.
        ENDIF.

*   it is a view
      ELSE.
        ev_type = 'V'.

*      DATA: lv_viewgrant TYPE dd25l-viewgrant.
*
*      SELECT SINGLE viewgrant
*        INTO lv_viewgrant
*        FROM dd25l
*        WHERE viewname = iv_table AND
*              as4local = 'A'.
*
*      IF sy-subrc EQ 0.
*        IF lv_viewgrant EQ 'R'.
*          CLEAR mv_can_edit.
*        ENDIF.
*      ENDIF.

      ENDIF.

* it is a transparent table
    ELSE.
      ev_type = 'T'.
    ENDIF.

  ENDMETHOD.                    "determinte_tab_type


ENDCLASS.                    "LCL_TOOLBOX IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_lawb DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_lawb DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    "lcl_lawb DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_lawb IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_lawb IMPLEMENTATION.

ENDCLASS.                    "lcl_lawb IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_select_fae_command DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_select_fae_command DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    "lcl_select_fae_command DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_select_fae_command IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_select_fae_command IMPLEMENTATION.

ENDCLASS.                    "lcl_select_fae_command IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_update_command DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_update_command DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    "lcl_update_command DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_update_command IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_update_command IMPLEMENTATION.

ENDCLASS.                    "lcl_update_command IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_delete_command DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_delete_command DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    "lcl_delete_command DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_delete_command IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_delete_command IMPLEMENTATION.

ENDCLASS.                    "lcl_delete_command IMPLEMENTATION




*----------------------------------------------------------------------*
*       CLASS LCL_HTDB_CL_COMMAND DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command DEFINITION.

*"* public components of class lcl_htdb_cl_command
*"* do not include other source files here!!!
  PUBLIC SECTION.

    TYPES: BEGIN OF lty_zhdb_vrange,
            alias      TYPE tabname,
            rsds_range TYPE rsds_range,
          END OF lty_zhdb_vrange.

    TYPES: lty_zhdb_vrange_tab TYPE STANDARD TABLE OF lty_zhdb_vrange.

    METHODS create_new
      IMPORTING
        !iv_command_id TYPE lty_commandid OPTIONAL
        !iv_command TYPE string
        !it_vranges TYPE lty_zhdb_vrange_tab OPTIONAL
        !iv_log_handle TYPE balloghndl OPTIONAL
        !iv_test_from_file TYPE c OPTIONAL
      EXCEPTIONS
        no_id .
    METHODS is_client_spec
      RETURNING
        value(ev_cspec) TYPE flag .
    METHODS constructor
      EXCEPTIONS
        no_id .
    METHODS get_id
      EXPORTING
        !ev_id TYPE guid_32 .
    METHODS execute
      IMPORTING
        !iv_simulation TYPE flag OPTIONAL
        !iv_bg_proc TYPE flag OPTIONAL
        !iv_bg_date TYPE tbtcjob-sdlstrtdt OPTIONAL
        !iv_bg_time TYPE tbtcjob-sdlstrttm OPTIONAL
      EXPORTING
        value(er_result) TYPE REF TO data
        !ev_dbcnt TYPE sy-dbcnt
        value(er_lock_argument) TYPE REF TO data
        !er_exc TYPE REF TO cx_root
        !ev_job_name TYPE btcjob
        !ev_job_count TYPE btcjobcnt
        !et_srccode TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        parse_error
        exec_error
        job_submit_error
        table_locked
        no_auth_for_table
        no_auth_for_columns .
    METHODS parse
      EXCEPTIONS
        parse_error
        no_auth_for_table .
    METHODS get_message_dropped
      RETURNING
        value(ev_message_dropped) TYPE char1 .
    METHODS get_where
      RETURNING
        value(es_where) TYPE lty_zhtdb_keyword .
    METHODS get_command
      RETURNING
        value(ev_command) TYPE string .
    TYPE-POOLS rsds .

*"* protected components of class lcl_htdb_cl_command
*"* do not include other source files here!!!
  PROTECTED SECTION.

    TYPES gty_keyword TYPE lty_zhtdb_keyword .

    DATA mv_command_id TYPE lty_commandid .
    DATA mv_parsed TYPE flag .
    DATA mv_prog_id TYPE guid_32. "lty_gen_prog_nro .
    DATA mv_command TYPE string .
    DATA mt_vranges TYPE lty_zhdb_vrange_tab .
    DATA:
      mt_keywords TYPE STANDARD TABLE OF gty_keyword .
    DATA mt_aptph_pos TYPE lty_zhtdb_sign_pos_tt .
    CONSTANTS mc_prog_prefix TYPE string VALUE 'Z'.  " 'ZENITH_'. "#EC NOTEXT
    DATA mv_log_handle TYPE balloghndl .
    DATA ms_s_msg TYPE bal_s_msg .
    DATA mv_test_from_file TYPE c .
    DATA mv_message_dropped TYPE char1 .
    DATA mt_paranth TYPE lty_zhtdb_sign_pos_tt .
    DATA mt_query_depth TYPE lty_zhtdb_sign_pos_tt .
    DATA mv_jobname TYPE btcjob .
    DATA mv_jobcount TYPE btcjobcnt .
    DATA mv_command_id_ui TYPE lty_commandid .

    METHODS call_gen_form
      IMPORTING
        !iv_program TYPE programm
        !iv_bg_proc TYPE flag OPTIONAL
        !iv_bg_date TYPE tbtcjob-sdlstrtdt OPTIONAL
        !iv_bg_time TYPE tbtcjob-sdlstrttm OPTIONAL
      EXPORTING
        !ev_dbcnt TYPE sy-dbcnt
        value(er_result) TYPE REF TO data
        value(er_lock_argument) TYPE REF TO data
        !er_exc TYPE REF TO cx_root
      EXCEPTIONS
        error
        job_submit_error
        table_locked .
    METHODS create_program
      IMPORTING
        !iv_program TYPE programm
        !it_srccode TYPE lty_zhtdbt_string_tab
        !iv_force_insert_report TYPE c OPTIONAL
      EXPORTING
        !ev_msg TYPE string
        !ev_line TYPE int4
      EXCEPTIONS
        syntax_error
        internal_error .
    METHODS det_subquery .
    METHODS execute_int
      IMPORTING
        !iv_simulation TYPE flag OPTIONAL
        !iv_bg_proc TYPE flag OPTIONAL
        !iv_bg_date TYPE tbtcjob-sdlstrtdt OPTIONAL
        !iv_bg_time TYPE tbtcjob-sdlstrttm OPTIONAL
      EXPORTING
        !ev_dbcnt TYPE sy-dbcnt
        value(er_result) TYPE REF TO data
        value(er_lock_argument) TYPE REF TO data
        !er_exc TYPE REF TO cx_root
        !et_srccode TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        syntax_error
        error
        job_submit_error
        table_locked
        no_auth_for_columns .
    METHODS generate_srccode
      EXPORTING
        value(et_srccode) TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        error
        no_auth_for_columns .
    METHODS generate_vranges
      EXPORTING
        !et_srccode TYPE lty_zhtdbt_string_tab .
    METHODS parse_keywords
      EXCEPTIONS
        missing_keyword
        wrong_position
        wrong_keyword .
    METHODS parse_check_dot
      EXCEPTIONS
        parse_error .
    METHODS split_string
      IMPORTING
        !iv_string TYPE string
      EXPORTING
        value(et_words) TYPE lty_zhtdbt_string_tab .
    METHODS add_message
      IMPORTING
        !iv_msgty TYPE symsgty
        !iv_msgid TYPE symsgid
        !iv_msgno TYPE symsgno
        !iv_msgv1 TYPE any OPTIONAL
        !iv_msgv2 TYPE any OPTIONAL
        !iv_msgv3 TYPE any OPTIONAL
        !iv_msgv4 TYPE any OPTIONAL .

    TYPE-POOLS rsds .

ENDCLASS.                    "LCL_HTDB_CL_COMMAND DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_HTDB_CL_COMMAND IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command IMPLEMENTATION.


  METHOD call_gen_form.
* calls the generated program to execute the command

    DATA: lx_root   TYPE REF TO cx_root,
          lv_locked TYPE flag.

* execute command
    TRY.
        PERFORM exec_command IN PROGRAM (iv_program)
          TABLES mt_vranges
          CHANGING lv_locked
                   ev_dbcnt.
      CATCH cx_root INTO lx_root.
*     Message: Internal error: generated program could not be called
        MESSAGE e003 RAISING error.
    ENDTRY.

    IF lv_locked = 'X'.
*   Message: Table could not be locked
      MESSAGE e146 RAISING table_locked.
    ENDIF.

  ENDMETHOD.                    "

  METHOD create_program.
* creates a repository program, which includes the command

    DATA: lv_program  TYPE programm,
          lv_msg      TYPE string,
          lv_line     TYPE n,
          lv_word     TYPE char50,
          lt_str      TYPE TABLE OF string,
          ls_trdir    TYPE trdir,

          lv_str1     TYPE string,
          lv_str2     TYPE string,
          lv_str3     TYPE string,
          lv_str4     TYPE string.


    IF iv_program IS INITIAL.
      RETURN.
    ELSE.
      lv_program = iv_program.
    ENDIF.

* syntax check
    SYNTAX-CHECK FOR it_srccode
      MESSAGE lv_msg
      LINE lv_line
      WORD lv_word
      PROGRAM 'ZENITH_GENERATED_SQ'.

    IF sy-subrc = 4.
      ev_line = lv_line.
      ev_msg  = lv_msg.

      IF mv_log_handle IS INITIAL.
        MESSAGE lv_msg TYPE 'I' DISPLAY LIKE 'E'.
        MESSAGE e019 RAISING syntax_error.
      ELSE.
*     split message to four parts (for four placeholders)
        CALL METHOD lcl_toolbox=>split_string
          EXPORTING
            iv_log_handle = mv_log_handle
            iv_string     = lv_msg
            iv_maxlen     = 50
          IMPORTING
            et_string_tab = lt_str.

        READ TABLE lt_str INTO lv_str1 INDEX 1.
        READ TABLE lt_str INTO lv_str2 INDEX 2.
        READ TABLE lt_str INTO lv_str3 INDEX 3.
        READ TABLE lt_str INTO lv_str4 INDEX 4.

        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '085' iv_msgv1 = lv_str1
          iv_msgv2 = lv_str2 iv_msgv3 = lv_str3 iv_msgv4 = lv_str4 ).

        IF iv_force_insert_report EQ 'X'.
*       create program in repository
          TRANSLATE lv_program TO UPPER CASE.            "#EC TRANSLANG
          INSERT REPORT lv_program FROM it_srccode.
        ENDIF.

        RAISE syntax_error.
      ENDIF.

    ELSEIF sy-subrc = 8.
*   Message: Internal error during syntax check

      IF mv_log_handle IS INITIAL.
        MESSAGE e002 RAISING internal_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '002' ).
        RAISE internal_error.
      ENDIF.

    ENDIF.

* create program in repository
    TRANSLATE lv_program TO UPPER CASE.                  "#EC TRANSLANG

    lt_str[] = it_srccode[].

    CALL METHOD lcl_toolbox=>pretty_printer_string
      CHANGING
        ct_source = lt_str.

    ls_trdir-subc = '1'.
    ls_trdir-fixpt = 'X'.
    ls_trdir-uccheck = 'X'.

    INSERT REPORT lv_program FROM lt_str DIRECTORY ENTRY ls_trdir.

* mert a zsql futtataskor torli a nem lockoltakat!


    CALL FUNCTION 'ENQUEUE_ES_PROG'
     EXPORTING
       mode_trdir           = 'E'
       name                 = lv_program
*       X_NAME               = ' '
*       _SCOPE               = '2'
*       _WAIT                = ' '
*       _COLLECT             = ' '
     EXCEPTIONS
       foreign_lock         = 1
       system_failure       = 2
       OTHERS               = 3.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ELSE.
        CALL METHOD add_message( iv_msgty = sy-msgty iv_msgid = sy-msgid iv_msgno = sy-msgno
          iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        RAISE internal_error.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD det_subquery.

    DATA: lv_str_lgth     TYPE i,
          lt_query_depth  LIKE mt_query_depth,
          ls_query_depth  LIKE LINE OF mt_query_depth,
          ls_depth_old    LIKE LINE OF mt_query_depth,
          ls_depth_new    LIKE LINE OF mt_query_depth,
          lv_act_depth    TYPE i,
          ls_aptph        LIKE LINE OF mt_aptph_pos,
          lv_shift        TYPE i,
          lv_position     TYPE i,
          lv_subq_end     TYPE i,
          lt_subq_end     TYPE STANDARD TABLE OF i,
          lv_depth_old    TYPE i,
          lv_depth_new    TYPE i.


    IF mv_command IS INITIAL.
      RETURN.
    ENDIF.

    lv_str_lgth  = STRLEN( mv_command ).
    lv_act_depth = 1.
    lv_subq_end  = lv_str_lgth.
    APPEND lv_subq_end TO lt_subq_end.

* init lt_query_depth
    ls_query_depth-position = 1.
    ls_query_depth-type     = 1.
    APPEND ls_query_depth TO lt_query_depth.
    ls_query_depth-position = lv_str_lgth.
    ls_query_depth-type     = -1.
    APPEND ls_query_depth TO lt_query_depth.

    DO.
      lv_shift = lv_position + 1.

      SEARCH mv_command
        FOR '. ( SELECT .'
        STARTING AT lv_shift.

      IF sy-subrc EQ 0.
        lv_position = sy-fdpos + lv_shift + 1.

        READ TABLE mt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_position.

        IF ls_aptph-type = 'O'.  " it's not inside a text => found a new subquery
*       determine depth of the suqquery
          LOOP AT lt_subq_end INTO lv_subq_end.
            IF lv_position < lv_subq_end.
              lv_act_depth = lv_act_depth + 1.
              EXIT.
            ELSE.
              lv_act_depth = lv_act_depth - 1.
              DELETE lt_subq_end.
            ENDIF.
          ENDLOOP.

*       mark beginning of the subqery
          ls_query_depth-position = lv_position.
          ls_query_depth-type     = lv_act_depth.
          APPEND ls_query_depth TO lt_query_depth.

*       find end of the suqery
          READ TABLE mt_paranth INTO ls_aptph
            WITH KEY position = lv_position.

          IF sy-subrc = 0.
*         now ls_aptph-type is the depth of the (
*         find the closing paranthesis - the next with the same depth
            lv_shift = sy-tabix + 1.
            LOOP AT mt_paranth FROM lv_shift INTO ls_aptph
                 WHERE type = ls_aptph-type.
              lv_subq_end = ls_aptph-position.
              INSERT lv_subq_end INTO lt_subq_end INDEX 1.
              EXIT.
            ENDLOOP.
          ENDIF.

*       mark end of subqery -> use negative numbers!!
          ls_query_depth-position = lv_subq_end.
          ls_query_depth-type     = - lv_act_depth.
          APPEND ls_query_depth TO lt_query_depth.
        ENDIF.
      ELSE.
        EXIT.
      ENDIF.

    ENDDO.

    SORT lt_query_depth BY position.

* complete query_depth table
    READ TABLE lt_query_depth INTO ls_depth_old INDEX 1.
    lv_act_depth = 1.

    LOOP AT lt_query_depth INTO ls_query_depth.
*   determine depth
      lv_depth_old = ls_depth_old-type.
      lv_depth_new = ls_query_depth-type.
      IF ABS( lv_depth_old ) = ABS( lv_depth_new ).
        IF lv_depth_old < lv_depth_new.     " between two subquerys on the same level
          lv_act_depth = lv_depth_new - 1.
        ELSE.
          lv_act_depth = lv_depth_old.       " within one subquery
        ENDIF.
      ELSE.
        IF lv_depth_old < lv_depth_new.      " between subquery and new subquery, one level deeper
          lv_act_depth = lv_depth_old.
        ELSEIF lv_depth_old > lv_depth_new.  " between closed subquery and subquery one level higher
          lv_act_depth = - lv_depth_new.
        ENDIF.
      ENDIF.

*   complete missing positions
      lv_position = ls_depth_old-position + 1.
      WHILE ls_query_depth-position > lv_position.
        ls_depth_new-position = lv_position.
        ls_depth_new-type     = lv_act_depth.
        APPEND ls_depth_new TO mt_query_depth.

        lv_position = lv_position + 1.
      ENDWHILE.

      ls_query_depth-type = ABS( ls_query_depth-type ).
      APPEND ls_query_depth TO mt_query_depth.
      ls_depth_old = ls_query_depth.
    ENDLOOP.

  ENDMETHOD.                    "

  METHOD execute_int.
* execute command

    DATA: lt_srccode             TYPE lty_zhtdbt_string_tab,
          lv_line                TYPE string,
          lv_force_insert_report TYPE c,
          lv_program             TYPE programm.


* create source code of the program
    CALL METHOD generate_srccode
      IMPORTING
        et_srccode          = lt_srccode
      EXCEPTIONS
        no_auth_for_columns = 1
        error               = 2
        OTHERS              = 3.

    IF sy-subrc = 1.
      MESSAGE e148 RAISING no_auth_for_columns.
    ELSEIF ( sy-subrc = 2 ) OR ( sy-subrc = 3 ).
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
          iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        RAISE error.
      ENDIF.
    ENDIF.

* program name
    lv_line = mv_prog_id.
    CONCATENATE mc_prog_prefix lv_line INTO lv_program.
    lv_program = lv_program(30).

    IF mv_log_handle IS INITIAL.
      CLEAR lv_force_insert_report.
    ELSE.
      lv_force_insert_report = 'X'.
    ENDIF.

* create program in the repository
    CALL METHOD create_program
      EXPORTING
        iv_program             = lv_program
        it_srccode             = lt_srccode
        iv_force_insert_report = lv_force_insert_report
      EXCEPTIONS
        syntax_error           = 1
        internal_error         = 2
        OTHERS                 = 3.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        IF sy-subrc <> 1.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
            RAISING error.
        ELSE.
*       the syntax check displayed the error already!
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
            RAISING syntax_error.
        ENDIF.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
          iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        IF sy-subrc <> 1.
          RAISE error.
        ELSE.
          RAISE syntax_error.
        ENDIF.
      ENDIF.
    ENDIF.

    IF iv_simulation IS INITIAL.
*   call generated program
      CALL METHOD call_gen_form
        EXPORTING
          iv_program       = lv_program
          iv_bg_proc       = iv_bg_proc
          iv_bg_date       = iv_bg_date
          iv_bg_time       = iv_bg_time
        IMPORTING
          er_result        = er_result
          ev_dbcnt         = ev_dbcnt
          er_lock_argument = er_lock_argument
          er_exc           = er_exc
        EXCEPTIONS
          job_submit_error = 1
          table_locked     = 2
          OTHERS           = 3.

      IF sy-subrc = 1.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING job_submit_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
          RAISE job_submit_error.
        ENDIF.
      ENDIF.

      IF sy-subrc = 2.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING table_locked.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
          RAISE table_locked.
        ENDIF.
      ENDIF.

      IF sy-subrc = 3.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
          RAISE error.
        ENDIF.
      ENDIF.

    ENDIF.

    IF mv_log_handle IS NOT INITIAL.
*   if error occurred, keep the program
      IF ms_s_msg IS INITIAL.
*   delete program from the repository

        CALL FUNCTION 'RS_DELETE_PROGRAM'
          EXPORTING
            program            = lv_program
            suppress_checks    = 'X'
            suppress_popup     = 'X'
            with_includes      = ' '
            with_cua           = ' '
            with_documentation = ' '
            with_dynpro        = ' '
            with_textpool      = ' '
            skip_progress_ind  = 'X'
          EXCEPTIONS
            enqueue_lock       = 1
            object_not_found   = 2
            permission_failure = 3
            reject_deletion    = 4
            OTHERS             = 5.

        IF sy-subrc <> 0.
          IF mv_log_handle IS INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                    RAISING error.
          ELSE.
            CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
            RAISE error.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    et_srccode = lt_srccode.

  ENDMETHOD.                    "


  METHOD create_new.

    DATA: lv_returncode TYPE inri-returncode.


    CLEAR: mv_prog_id.

    mv_command_id = iv_command_id.

*** get program ID from number range
**    CALL FUNCTION 'NUMBER_GET_NEXT'
**      EXPORTING
**        nr_range_nr   = '01'
**        object        = 'ZHTDB_PROG'
**        ignore_buffer = 'X'
**      IMPORTING
**        number        = mv_prog_id
**        returncode    = lv_returncode
**      EXCEPTIONS
**        OTHERS        = 1.

    CALL FUNCTION 'GUID_CREATE'
      IMPORTING
        ev_guid_32 = mv_prog_id.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING no_id.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
          iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        RAISE no_id.
      ENDIF.
    ELSE.
      IF lv_returncode IS NOT INITIAL.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE 'S' NUMBER '116' DISPLAY LIKE 'E'
                  WITH lv_returncode sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING no_id.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '116'
            iv_msgv1 = lv_returncode ).
          RAISE no_id.
        ENDIF.
      ELSE.
        COMMIT WORK.
      ENDIF.
    ENDIF.

* clear attributes
    CLEAR mv_command.
    CLEAR mt_aptph_pos.
    CLEAR mt_paranth.
    CLEAR mt_keywords.
    CLEAR mt_vranges.
    CLEAR mv_parsed.
    CLEAR ms_s_msg.

* take over data
    mv_command    = iv_command.    " Open SQL command
    SHIFT mv_command RIGHT DELETING TRAILING '. '.

    mt_vranges    = it_vranges.    " value ranges for the WHERE clause
    mv_log_handle = iv_log_handle. " Application Log handle. If supplied, no messages given.

* If select commands are loaded from file, some messages are suppressed in add_message
    mv_test_from_file = iv_test_from_file.
* if a message is suppressed, this indicator is set, so no messages are logged from outside (ZSQL)
    CLEAR mv_message_dropped.

  ENDMETHOD.                    "

  METHOD generate_srccode.
* generates a program source code, which includes the command

    DATA: ls_keyword   LIKE LINE OF mt_keywords,
          lv_tabname   TYPE tabname,
          lv_program   TYPE programm,
          lv_line      TYPE string,
          lv_tmp       TYPE string.


*****************************************************************************************
* create source code for the program

* build program name
    lv_tmp = mv_prog_id.
    CONCATENATE mc_prog_prefix lv_tmp INTO lv_program.

    lv_line = 'PROGRAM'.
    CONCATENATE lv_line lv_program '.' INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

    APPEND '  TYPE-POOLS: rsds.' TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* FORM
    APPEND 'FORM exec_command TABLES pt_vranges CHANGING p_locked p_dbcnt.' TO et_srccode.
    APPEND '  DATA: lv_lock_argument(150) TYPE c,'                          TO et_srccode.
    APPEND '        lv_table              TYPE tabname.'                    TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* create value range tables
    IF mt_vranges IS NOT INITIAL.
      generate_vranges( IMPORTING et_srccode = et_srccode ).
    ENDIF.

* insert command
    APPEND mv_command TO et_srccode.
    APPEND '.'        TO et_srccode.

* save SY-DBCNT
    APPEND '  p_dbcnt = sy-dbcnt.' TO et_srccode.
    APPEND 'ENDFORM.'              TO et_srccode.

  ENDMETHOD.                    "

  METHOD generate_vranges.

    DATA: ls_vrange   LIKE LINE OF mt_vranges,
          ls_range    TYPE rsds_range,
          ls_frange   TYPE rsds_frange,
          lv_line     TYPE string,
          lv_index_vr TYPE sy-tabix,
          lv_index_fr TYPE sy-tabix.


    APPEND INITIAL LINE TO et_srccode.

* work area for value range entries
    APPEND '  TYPES: BEGIN OF lty_zhdb_vrange,'        TO et_srccode.
    APPEND '           alias      TYPE tabname,'       TO et_srccode.
    APPEND '           rsds_range TYPE rsds_range,'    TO et_srccode.
    APPEND '  END OF lty_zhdb_vrange.'                 TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.
    APPEND '  TYPES: lty_zhdb_vrange_tab TYPE STANDARD TABLE OF lty_zhdb_vrange.'                 TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.
    APPEND '  DATA: ls_vrange TYPE lty_zhdb_vrange,' TO et_srccode.
    APPEND '        ls_frange TYPE rsds_frange.' TO et_srccode.

    LOOP AT mt_vranges INTO ls_vrange.
      lv_index_vr = sy-tabix.

      LOOP AT ls_vrange-rsds_range-frange_t INTO ls_frange.
        lv_index_fr = sy-tabix.

*     define new value range table
        CONCATENATE '  DATA: r_' ls_vrange-alias '_' ls_frange-fieldname INTO lv_line.
        CONCATENATE lv_line 'TYPE RSDS_SELOPT_T.' INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        lv_line = lv_index_vr.

*     take over content
        CONCATENATE '  READ TABLE pt_vranges INDEX' lv_line 'INTO ls_vrange.' INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        lv_line = lv_index_fr.
        CONCATENATE '  READ TABLE ls_vrange-rsds_range-frange_t INDEX' lv_line 'INTO ls_frange.' INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        CONCATENATE '  r_' ls_vrange-alias '_' ls_frange-fieldname INTO lv_line.
        CONCATENATE lv_line '= ls_frange-selopt_t.' INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        APPEND INITIAL LINE TO et_srccode.

      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.                    "


  METHOD parse_keywords.
* extracts keywords of the command and fills up the MT_KEYWORDS table

    DATA: lv_keyword      TYPE string,
          lv_search_str   TYPE string,
          ls_prev_keyword TYPE gty_keyword,
          ls_next_keyword TYPE gty_keyword,

          lv_length       TYPE i,
          lv_position     TYPE i,
          lv_ends_at      TYPE i,
          lv_lines        TYPE i,
          lv_index        TYPE i,
          lv_shift        TYPE i,
          lv_delta        TYPE i,
          ls_aptph        LIKE LINE OF mt_aptph_pos.

    FIELD-SYMBOLS: <ls_keyword> TYPE gty_keyword.


* determine subquerys
    det_subquery( ).

************************************************************************
* get keywords

    lv_length = STRLEN( mv_command ).

* search for keywords
    LOOP AT mt_keywords ASSIGNING <ls_keyword>.
      lv_keyword = <ls_keyword>-keyword.
      CONCATENATE '.' lv_keyword '.' INTO lv_search_str
        SEPARATED BY space.

      CLEAR lv_position.

      DO.
        lv_shift = lv_position + 1.

        SEARCH mv_command
          FOR lv_search_str
          STARTING AT lv_shift.

        IF sy-subrc EQ 0.
          lv_position = sy-fdpos + lv_shift + 1.
          lv_ends_at  = lv_position + STRLEN( lv_keyword ) - 1.

          READ TABLE mt_aptph_pos INTO ls_aptph
            WITH KEY position = lv_position.

          IF ls_aptph-type = 'O'.  " it's not inside a text

            READ TABLE mt_query_depth INTO ls_aptph
              WITH KEY position = lv_position.

            IF ls_aptph-type = 1.  " top level, not a subquery
*           keyword found
              <ls_keyword>-begins_at = lv_position.
              <ls_keyword>-ends_at   = lv_ends_at.

              IF <ls_keyword>-order_pos = 1 AND
              <ls_keyword>-begins_at <> 2.
                IF mv_log_handle IS INITIAL.
*               Message: Command does not begin with the keyword '&1'
                  MESSAGE e088 WITH lv_keyword
                  RAISING missing_keyword.
                ELSE.
                  CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '088' iv_msgv1 = lv_keyword ).

                  RAISE missing_keyword.
                ENDIF.
              ENDIF.

              EXIT.
            ENDIF.
          ENDIF.
        ELSE.
*       keyword not found at all
          CLEAR lv_position.
          EXIT.
        ENDIF.
      ENDDO.

      IF lv_position IS INITIAL AND
         <ls_keyword>-required = 'X'.    " required keyword

        IF mv_log_handle IS INITIAL.
*       Message: Keyword '&1' is missing
          MESSAGE e006 WITH lv_keyword
            RAISING missing_keyword.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '006' iv_msgv1 = lv_keyword ).

          RAISE missing_keyword.
        ENDIF.

      ENDIF.
    ENDLOOP.


************************************************************************
* check positions

* delete keywords, which are not defined in the current command
    DELETE mt_keywords WHERE begins_at IS INITIAL.

    SORT mt_keywords BY begins_at.

    LOOP AT mt_keywords ASSIGNING <ls_keyword>.
      IF ls_prev_keyword-order_pos > <ls_keyword>-order_pos.
        IF mv_log_handle IS INITIAL.
*       Message: Wrong order of keywords: &1 on wrong position
          MESSAGE e018 WITH <ls_keyword>-keyword
            RAISING wrong_position.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '006' iv_msgv1 = ls_prev_keyword-keyword ).

          RAISE wrong_position.
        ENDIF.

      ENDIF.

      ls_prev_keyword = <ls_keyword>.
    ENDLOOP.

************************************************************************
* get texts

* MOVED before loop above: why loop through obsolete records?
** delete keywords, which are not defined in the current command
*  LOOP AT mt_keywords ASSIGNING <ls_keyword>
*       WHERE begins_at IS INITIAL.
*    DELETE mt_keywords.
*  ENDLOOP.

    DESCRIBE TABLE mt_keywords LINES lv_lines.

* get texts
    LOOP AT mt_keywords ASSIGNING <ls_keyword>.
      lv_index = sy-tabix + 1.

      IF lv_index <= lv_lines.  " til the position of the next keyword
        READ TABLE mt_keywords INTO ls_next_keyword
          INDEX lv_index.

        lv_shift = <ls_keyword>-ends_at + 1.
        lv_delta = ls_next_keyword-begins_at - lv_shift - 1.
      ELSE.                    " til the end of the command
        lv_shift = <ls_keyword>-ends_at + 1.
        lv_delta = lv_length - lv_shift.
      ENDIF.

      MOVE mv_command+lv_shift(lv_delta) TO <ls_keyword>-text.  " trim text

      lv_index = lv_index - 1.
      MODIFY mt_keywords INDEX lv_index FROM <ls_keyword>.
    ENDLOOP.

  ENDMETHOD. "

  METHOD parse_check_dot.
* check that there is no new command after a closing dot

    DATA: lv_strg_lgth  TYPE i,
          lv_char       TYPE c,
          lv_shift      TYPE i,
          lv_end        TYPE c,
          ls_aptph      LIKE LINE OF mt_aptph_pos.


    IF mv_command IS INITIAL.
      RETURN.
    ENDIF.

    lv_strg_lgth = STRLEN( mv_command ).

* check dots
    DO.
      lv_char = mv_command+lv_shift(1).

      IF lv_end  = 'X' AND
         lv_char IS NOT INITIAL.
        IF mv_log_handle IS INITIAL.
*       Message: 'Don''t write any commands after the closing dot'
          MESSAGE e001 RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '001' ).

          RAISE parse_error.
        ENDIF.
      ENDIF.

      IF lv_char = '.'.
*     check that the dot is not inside a text
        READ TABLE mt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_shift.

        IF ls_aptph-type = 'O'.  " outside a text
          lv_end = 'X'.          " the dot closes the command
        ENDIF.
      ENDIF.

      lv_shift = lv_shift + 1.
      IF lv_shift >= lv_strg_lgth.
        EXIT.
      ENDIF.
    ENDDO.

  ENDMETHOD.                    "


  METHOD is_client_spec.

    DATA: ls_keyword LIKE LINE OF mt_keywords.


    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'CLIENT SPECIFIED'.

    IF ls_keyword-begins_at IS NOT INITIAL.
      ev_cspec = 'X'.
    ENDIF.

  ENDMETHOD.                    "

  METHOD split_string.
* splits a string at SPACE, but outside apostrophes only

    DATA: lv_string       TYPE string,
          lt_aptph_pos    LIKE mt_aptph_pos,
          lv_length       TYPE i,
          lv_shift        TYPE i,
          lv_pos          TYPE i,
          lv_char         TYPE c,
          lv_word         TYPE string,
          ls_aptph        LIKE LINE OF mt_aptph_pos.


    lv_string = iv_string.

    lcl_toolbox=>parse_aptph(
                        EXPORTING
                          iv_condense   = space
                        IMPORTING
                          et_aptph_pos = lt_aptph_pos
                        CHANGING
                          cv_string    = lv_string ).
* get words
    lv_shift = -1.
    lv_length = STRLEN( iv_string ).

    DO.
      lv_shift = lv_shift + 1.

      IF lv_shift >= lv_length.
        EXIT.
      ENDIF.

      lv_char = iv_string+lv_shift(1).

      IF lv_char = space.
        lv_pos = lv_shift + 1.

        READ TABLE lt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_pos.

        IF ls_aptph-type = 'O'.

          IF lv_word IS NOT INITIAL.

            APPEND lv_word TO et_words.
            CLEAR lv_word.
          ENDIF.
          CONTINUE.
        ENDIF.
      ENDIF.

      CONCATENATE lv_word lv_char INTO lv_word.
    ENDDO.

* the last word
    IF lv_word IS NOT INITIAL.
      APPEND lv_word TO et_words.
    ENDIF.

  ENDMETHOD.                    "

  METHOD add_message.

    IF     iv_msgid = 'SD'    AND iv_msgno = 94.
      RETURN.
    ELSEIF iv_msgid = 'FL'    AND iv_msgno = 714.
      RETURN.
    ELSEIF iv_msgid = 'VSCAN' AND iv_msgno = 33.
      RETURN.
    ELSEIF iv_msgid = 'E4'    AND iv_msgno = '035'.
      RETURN.
    ENDIF.

    IF mv_test_from_file EQ 'X'.
      IF iv_msgid = 'ZSQL_FREE'.
        IF iv_msgno = 14 OR iv_msgno = 68 OR iv_msgno = 16 OR iv_msgno = 36 OR iv_msgno = 8.
          mv_message_dropped = 'X'.
          RETURN.
        ENDIF.
      ENDIF.
    ENDIF.

    CLEAR ms_s_msg.

    ms_s_msg-msgid = iv_msgid.
    ms_s_msg-msgno = iv_msgno.

    ms_s_msg-msgv1 = iv_msgv1.
    ms_s_msg-msgv2 = iv_msgv2.
    ms_s_msg-msgv3 = iv_msgv3.
    ms_s_msg-msgv4 = iv_msgv4.

    IF ms_s_msg IS INITIAL.
      RETURN.
    ENDIF.

    CONDENSE: ms_s_msg-msgv1, ms_s_msg-msgv2, ms_s_msg-msgv3, ms_s_msg-msgv4.

    ms_s_msg-msgty = iv_msgty.

    CALL FUNCTION 'BAL_LOG_MSG_ADD'
      EXPORTING
        i_log_handle = mv_log_handle
        i_s_msg      = ms_s_msg
      EXCEPTIONS
        OTHERS       = 1.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

  ENDMETHOD.                    "add_message


  METHOD constructor.


  ENDMETHOD.                    "

  METHOD get_id.

    ev_id = mv_prog_id.

  ENDMETHOD.                    "

  METHOD execute.
* execute command

    IF mv_command IS INITIAL.
      RETURN.
    ENDIF.

* parse command if needed
    IF mv_parsed IS INITIAL.
      CALL METHOD parse
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc <> 0.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
          RAISE parse_error.
        ENDIF.

      ENDIF.
    ENDIF.

* execute command
    CALL METHOD execute_int
      EXPORTING
        iv_simulation       = iv_simulation
        iv_bg_proc          = iv_bg_proc
        iv_bg_date          = iv_bg_date
        iv_bg_time          = iv_bg_time
*        it_selscr_fields    = it_selscr_fields
      IMPORTING
        er_result           = er_result
        ev_dbcnt            = ev_dbcnt
        er_lock_argument    = er_lock_argument
        er_exc              = er_exc
        et_srccode          = et_srccode
      EXCEPTIONS
        error               = 1
        syntax_error        = 2
        job_submit_error    = 3
        table_locked        = 4
        no_auth_for_columns = 5
        OTHERS              = 6.

    CASE sy-subrc.
      WHEN 1.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING exec_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
          RAISE exec_error.
        ENDIF.

      WHEN 2.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
          RAISE parse_error.
        ENDIF.

      WHEN 3.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING job_submit_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
          RAISE job_submit_error.
        ENDIF.

      WHEN 4.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING table_locked.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
          RAISE table_locked.
        ENDIF.
      WHEN 5.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING no_auth_for_columns.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
          RAISE no_auth_for_columns.
        ENDIF.
    ENDCASE.

    ev_job_name  = mv_jobname.
    ev_job_count = mv_jobcount.

  ENDMETHOD.                    "

  METHOD parse.
* parse command and execute checks

    IF mv_parsed = 'X'.
      RETURN.
    ELSE.
      mv_parsed = 'X'.
    ENDIF.

* check apostrophes
    CLEAR mt_aptph_pos.
    CALL METHOD lcl_toolbox=>parse_aptph
      EXPORTING
        iv_log_handle  = mv_log_handle
      IMPORTING
        et_aptph_pos   = mt_aptph_pos
        et_paranth     = mt_paranth
      CHANGING
        cv_string      = mv_command
      EXCEPTIONS
        missing_aptph  = 1
        missing_parnth = 2
        OTHERS         = 3.

    CASE sy-subrc.
      WHEN 1.
        IF mv_log_handle IS INITIAL.
*       Message: An ending apostrophe is missing
          MESSAGE e005 RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E'
            iv_msgid = 'ZSQL_FREE'
            iv_msgno = '005' ).
          RAISE parse_error.
        ENDIF.

      WHEN 2.
        IF mv_log_handle IS INITIAL.
*       Message: An closing paranthesis is missing
          MESSAGE e059 RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E'
            iv_msgid = 'ZSQL_FREE'
            iv_msgno = '059' ).
          RAISE parse_error.
        ENDIF.

      WHEN 3.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E'
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
          RAISE parse_error.
        ENDIF.
    ENDCASE.

* if there is a closing dot, check that there is no new command after it
    parse_check_dot( EXCEPTIONS OTHERS = 1 ).

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
          iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

** determine subquerys
*  det_subquery( ).

* extract keywords
    parse_keywords( EXCEPTIONS OTHERS = 1 ).

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
          iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD get_message_dropped.

    ev_message_dropped = mv_message_dropped.

  ENDMETHOD.                    "get_message_dropped

  METHOD get_where.

    CLEAR es_where.

    READ TABLE mt_keywords WITH KEY keyword = 'WHERE'
      INTO es_where.

  ENDMETHOD.                    "get_where

  METHOD get_command.

    ev_command = mv_command.

  ENDMETHOD.                    "get_command

ENDCLASS.                    "lcl_HTDB_CL_COMMAND IMPLEMENTATION



*----------------------------------------------------------------------*
*       CLASS LCL_HTDB_CL_COMMAND_SELECT  DEFINITIO
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command_select DEFINITION
  INHERITING FROM lcl_htdb_cl_command.

*"* public components of class lcl_htdb_cl_command_select
*"* do not include other source files here!!!
  PUBLIC SECTION.

    DATA mt_adt_tables TYPE lty_zhtdb_table_aliases_tt .

    METHODS can_edit
      RETURNING
        value(ev_can_edit) TYPE char1 .
    METHODS get_fieldinfo
      EXPORTING
        !et_fieldinfo TYPE lty_zhtdb_fieldinfo_tt
        !ev_can_edit TYPE flag
        !ev_can_insert TYPE flag .
    METHODS get_program_name
      RETURNING
        value(ev_program_name) TYPE programm .
    METHODS get_table_alias
      EXPORTING
        !et_table_alias TYPE lty_zhtdb_table_aliases_tt .
    METHODS get_texts
      EXPORTING
        !ev_select_text TYPE string
        !ev_from_text TYPE string
        !ev_where_text TYPE string
        !ev_group_by_text TYPE string
        !ev_having_text TYPE string
        !ev_order_by_text TYPE string .

    METHODS create_new
      REDEFINITION .
    METHODS parse
      REDEFINITION .


*"* protected components of class lcl_htdb_cl_command_select
*"* do not include other source files here!!!
  PROTECTED SECTION.

    TYPES:
      BEGIN OF gty_table_field,
             table    TYPE tabname,
             field    TYPE fieldname,
             keyflag  TYPE flag,
             position TYPE tabfdpos,
           END OF gty_table_field .

    DATA mt_fieldinfo TYPE lty_zhtdb_fieldinfo_tt .
    DATA mt_table_alias TYPE lty_zhtdb_table_aliases_tt .
    DATA:
      mt_table_fields TYPE STANDARD TABLE OF gty_table_field .
    DATA mv_sel_single TYPE flag .
    DATA mv_can_edit TYPE flag .
    DATA mv_can_insert TYPE flag .
    DATA mv_has_dupl_fields TYPE flag .
    CONSTANTS mc_type_name_res TYPE string VALUE 'GTY_RES'. "#EC NOTEXT
    CONSTANTS mc_type_name_tech_res TYPE string VALUE 'GTY_RES_TECH'. "#EC NOTEXT
    DATA mv_type_name_tech_res TYPE string .
    DATA mv_prog_id_str TYPE string .
    DATA mv_type_name_res TYPE string .
    DATA mv_program TYPE programm .
    CONSTANTS mc_result_prefix TYPE string VALUE 'GT_RES'.  "#EC NOTEXT
    DATA mv_result_name TYPE string .
    DATA mv_program_upd TYPE programm .
    DATA mt_authorizations TYPE rsec_t_usvalues .
    DATA mv_where_addition TYPE string .
    DATA:
      mt_subqu_where TYPE STANDARD TABLE OF lty_zhtdb_keyword .

    METHODS extend_where_clause
      IMPORTING
        !iv_where_addition TYPE string .
    METHODS add_where_excl_all
      IMPORTING
        !iv_table TYPE tabname
      CHANGING
        !cv_where_addition TYPE string .
    METHODS create_type
      IMPORTING
        !iv_type_name TYPE string
        !it_fieldinfo TYPE lty_zhtdb_fieldinfo_tt
        !iv_with_tech_fields TYPE c
      CHANGING
        !ct_srccode TYPE lty_zhtdbt_string_tab .
    METHODS expand_asterisk
      EXCEPTIONS
        table_not_found .
    METHODS parse_adt_tables
      EXPORTING
        !et_table_alias TYPE lty_zhtdb_table_aliases_tt
      EXCEPTIONS
        parse_error .
    METHODS parse_check_fieldname
      IMPORTING
        !iv_word TYPE string
        !it_keywords TYPE lty_zhtdbt_string_tab OPTIONAL
      RETURNING
        value(rv_valid) TYPE xfeld .
    METHODS parse_check_name
      IMPORTING
        !iv_word TYPE string
        !it_keywords TYPE lty_zhtdbt_string_tab OPTIONAL
      RETURNING
        value(rv_valid) TYPE xfeld .
    METHODS parse_check_value
      IMPORTING
        !iv_word TYPE string
      RETURNING
        value(rv_valid) TYPE xfeld .
    METHODS parse_fields
      EXCEPTIONS
        parse_error
        no_fields_found
        table_not_found
        field_not_found .
    METHODS parse_tables
      EXCEPTIONS
        parse_error
        no_tables_found
        table_not_exist .
    METHODS prepare_from_text
      CHANGING
        !cv_string TYPE string .
    METHODS prepare_sel_text
      CHANGING
        !cv_string TYPE string .
    METHODS rebuild_field_list
      CHANGING
        value(ct_srccode) TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        error
        no_auth_for_columns .
    METHODS remove_duplicates .
    METHODS check_inserted_orgcritdep
      IMPORTING
        !it_inserted TYPE REF TO data
      EXCEPTIONS
        no_auth_for_inserted_records
        assign_error .

    METHODS call_gen_form
      REDEFINITION .
    METHODS generate_srccode
      REDEFINITION .
    METHODS parse_keywords
      REDEFINITION .
ENDCLASS.                    "LCL_HTDB_CL_COMMAND_SELECT  DEFINITIO

*----------------------------------------------------------------------*
*       CLASS lcl_HTDB_CL_COMMAND_SELECT IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command_select IMPLEMENTATION.

  METHOD call_gen_form.

    DATA: lv_timestamp  TYPE timestamp,
          lv_tmp(15)    TYPE c,
          lv_released   TYPE c,
          lv_start_imd  TYPE flag,

          ls_param      TYPE rsparams,
          lt_paramtab   TYPE STANDARD TABLE OF rsparams.


    IF iv_bg_proc = space.   " execute command instantly
      TRY.
          PERFORM exec_command IN PROGRAM (iv_program)
            TABLES mt_vranges          " value ranges
            CHANGING er_result         " result set
                     ev_dbcnt          " sy-dbcnt
                     er_lock_argument  " lock argument
                     er_exc.           " exception object

          IF er_exc IS NOT INITIAL.
            RAISE error.
          ENDIF.

        CATCH cx_root.
          IF mv_log_handle IS INITIAL.
*         Message: Internal error: generated program could not be called
            MESSAGE e003 RAISING error.
          ELSE.
            CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = 003 ).
          ENDIF.
      ENDTRY.
    ENDIF.

  ENDMETHOD.                    "

  METHOD create_new.

    DATA: ls_keyword LIKE LINE OF mt_keywords.


    super->create_new(
      EXPORTING
        iv_command_id     = iv_command_id
        iv_command        = iv_command
        it_vranges        = it_vranges
        iv_log_handle     = iv_log_handle
        iv_test_from_file = iv_test_from_file
      EXCEPTIONS
        no_id             = 1
        OTHERS            = 2 ).

    IF sy-subrc = 1.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING no_id.
    ENDIF.

* clear attributes
    CLEAR mt_fieldinfo.
    CLEAR mt_table_alias.
    CLEAR mt_adt_tables.
    CLEAR mt_table_fields.
    CLEAR mv_has_dupl_fields.
    CLEAR mv_sel_single.
    CLEAR mv_prog_id_str.
    CLEAR mt_query_depth.
    CLEAR mt_subqu_where.

    CLEAR mt_authorizations.

    mv_prog_id_str = mv_prog_id.

    CONCATENATE mc_type_name_tech_res mv_prog_id_str INTO mv_type_name_tech_res.
    mv_type_name_tech_res = mv_type_name_tech_res(30).
    CONCATENATE mc_type_name_res      mv_prog_id_str INTO mv_type_name_res.
    mv_type_name_res = mv_type_name_res(30).
    CONCATENATE mc_result_prefix      mv_prog_id_str INTO mv_result_name.
    mv_result_name = mv_result_name(30).

    CONCATENATE mc_prog_prefix        mv_prog_id_str INTO mv_program.
    mv_program = mv_program(30).

* set to editable as default
    mv_can_edit = 'X'.

* fill up keywords table
    ls_keyword-keyword   = 'SELECT'.
    ls_keyword-required  = 'X'.
    ls_keyword-order_pos = 1.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'FROM'.
    ls_keyword-required  = 'X'.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'CLIENT SPECIFIED'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'BYPASSING BUFFER'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'UP TO'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'WHERE'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 5.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'GROUP BY'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 6.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'HAVING'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 7.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = 'ORDER BY'.
    ls_keyword-required  = ' '.
    ls_keyword-order_pos = 8.
    APPEND ls_keyword TO mt_keywords.

  ENDMETHOD.                    "

  METHOD generate_srccode.

    DATA: lv_program     TYPE programm,
          lv_line        TYPE string,
          ls_keyword     LIKE LINE OF mt_keywords,
          lv_shift       TYPE i.


    CONCATENATE 'PROGRAM' mv_program '.' INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* Type Pools
    APPEND '  TYPE-POOLS: rsds.' TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* create local type for the result set
    create_type(
      EXPORTING
        iv_type_name        = mv_type_name_res
        it_fieldinfo        = mt_fieldinfo
        iv_with_tech_fields = ' '
      CHANGING
        ct_srccode   = et_srccode ).
    APPEND INITIAL LINE TO et_srccode.

* create local type for the result set with technical fields
    create_type(
      EXPORTING
        iv_type_name        = mv_type_name_tech_res
        it_fieldinfo        = mt_fieldinfo
        iv_with_tech_fields = 'X'
      CHANGING
        ct_srccode   = et_srccode ).
    APPEND INITIAL LINE TO et_srccode.

* create result set table
    CONCATENATE 'DATA' mv_result_name 'TYPE STANDARD TABLE OF' mv_type_name_tech_res '.'
      INTO lv_line SEPARATED BY space.
    APPEND lv_line TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.


* create FORM routine
    APPEND 'FORM exec_command TABLES   pt_vranges'                  TO et_srccode.
    APPEND '                  CHANGING p_result'                    TO et_srccode.
    APPEND '                           p_dbcnt'                     TO et_srccode.
    APPEND '                           p_lock_argument'             TO et_srccode.
    APPEND '                           po_exc TYPE REF TO cx_root.' TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* create value range tables
    IF mt_vranges IS NOT INITIAL.
      generate_vranges( IMPORTING et_srccode = et_srccode ).
    ENDIF.

    IF mv_sel_single = 'X'.
*   create result structure
      CONCATENATE '  DATA: ls_result LIKE LINE OF ' mv_result_name '.'
        INTO lv_line SEPARATED BY space.
      APPEND lv_line TO et_srccode.
      APPEND INITIAL LINE TO et_srccode.
    ENDIF.

    APPEND 'TRY.' TO et_srccode.

* create SELECT command
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'SELECT'.

    lv_line = 'SELECT'.
    IF ls_keyword-additions IS NOT INITIAL.
      CONCATENATE lv_line ls_keyword-additions INTO lv_line
        SEPARATED BY space.
    ENDIF.
    APPEND lv_line TO et_srccode.

* build field list (SELECT clause)
    rebuild_field_list(
      CHANGING
        ct_srccode = et_srccode
      EXCEPTIONS
        no_auth_for_columns = 1
        OTHERS              = 2 ).

    IF sy-subrc = 1.
      MESSAGE e148 RAISING no_auth_for_columns.
    ELSEIF sy-subrc = 2.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
          iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        RAISE error.
      ENDIF.
    ENDIF.

* insert addition INTO ...
    IF mv_sel_single = 'X'.
      APPEND '  INTO CORRESPONDING FIELDS OF ls_result' TO et_srccode.
    ELSE.
      CONCATENATE '  INTO CORRESPONDING FIELDS OF TABLE ' mv_result_name INTO lv_line
        SEPARATED BY space.
      APPEND lv_line TO et_srccode.
    ENDIF.

* append the rest: 'FROM ...'
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'FROM'.
    lv_shift = ls_keyword-begins_at - 1.
    CONCATENATE mv_command+lv_shift '.' INTO lv_line.

* split line by 100
    CALL METHOD lcl_toolbox=>split_string
      EXPORTING
        iv_string     = lv_line
        iv_maxlen     = 100
      IMPORTING
        et_string_tab = et_srccode.

* save SY-DBCNT
    lv_line = 'p_dbcnt = sy-dbcnt.'.
    APPEND lv_line TO et_srccode.

    IF mv_sel_single = 'X'.
*   append result structure to result tab
      APPEND ' IF sy-subrc EQ 0.' TO et_srccode.
      CONCATENATE '   APPEND ls_result TO ' mv_result_name '.' INTO lv_line
        SEPARATED BY space.
      APPEND lv_line TO et_srccode.
      APPEND ' ENDIF.' TO et_srccode.
    ENDIF.

* return reference on result set
    CONCATENATE ' GET REFERENCE OF ' mv_result_name 'INTO p_result.' INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO et_srccode.


    APPEND 'CATCH cx_root INTO po_exc.' TO et_srccode.
    APPEND 'ENDTRY.'                    TO et_srccode.

    lv_line = 'ENDFORM.'.
    APPEND lv_line TO et_srccode.

  ENDMETHOD.                    "

  METHOD parse_keywords.
* extracts keywords of the command and fills up the MT_KEYWORDS table

    FIELD-SYMBOLS: <ls_keyword> LIKE LINE OF mt_keywords.


* extract keywords
    super->parse_keywords(
      EXCEPTIONS
        missing_keyword = 1
        wrong_position  = 2 ).

    IF sy-subrc = 1.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING missing_keyword.
    ELSEIF sy-subrc = 2.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING wrong_position.
    ENDIF.

* check the SELECT keyword
    READ TABLE mt_keywords ASSIGNING <ls_keyword>
      WITH KEY keyword = 'SELECT'.

    IF STRLEN( <ls_keyword>-text ) >= 8.
      IF <ls_keyword>-text(8) = 'DISTINCT'.
        SHIFT <ls_keyword>-text LEFT BY 8 PLACES.
        <ls_keyword>-additions = 'DISTINCT'.
*     <ls_keyword>-ends_at   =  <ls_keyword>-ends_at + 8.
      ENDIF.
    ENDIF.

    IF STRLEN( <ls_keyword>-text ) >= 6.
      IF <ls_keyword>-text(6) = 'SINGLE'.
        SHIFT <ls_keyword>-text LEFT BY 6 PLACES.
        <ls_keyword>-additions = 'SINGLE'.
*     <ls_keyword>-ends_at   = <ls_keyword>-ends_at + 6.
        mv_sel_single = 'X'.
      ENDIF.
    ENDIF.

    SEARCH <ls_keyword>-text FOR '. FOR UPDATE .'.
    IF sy-subrc = 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE e068 RAISING wrong_keyword.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'W' iv_msgid = 'ZSQL_FREE' iv_msgno = '068' ).
        RAISE wrong_keyword.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD parse.

    IF mv_parsed = 'X'.
      RETURN.
    ENDIF.

* make search for keywords easier - start and end with SPACE
    SHIFT mv_command RIGHT BY 1 PLACES.
    CONCATENATE mv_command space INTO mv_command
      SEPARATED BY space.

* elemtary check of command (apostrophes, dots, keywords)
    super->parse( EXCEPTIONS OTHERS = 1 ).

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING parse_error.
    ENDIF.

* clear attributes
    CLEAR mt_fieldinfo.
    CLEAR mt_table_alias.
    CLEAR mv_has_dupl_fields.

* set to editable as default
    mv_can_edit = 'X'.

* get tables involved
    CALL METHOD parse_tables
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
          iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

* get field list
    CALL METHOD parse_fields
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
          iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "parse

  METHOD extend_where_clause.

    DATA: lv_where_cauth   TYPE string,
          lv_where_orgcrit TYPE string,

          ls_keywords      LIKE LINE OF mt_keywords,
          lv_tabix         TYPE i,
          lv_len           TYPE i,
          lv_shift         TYPE i,
          lv_tmp           TYPE i.


    IF iv_where_addition IS NOT INITIAL.

      READ TABLE mt_keywords INTO ls_keywords WITH KEY keyword = 'WHERE'.

      IF sy-subrc EQ 0.   " extend WHERE clause

        lv_tabix = sy-tabix.

*     add pre stuff to mv_command
        lv_shift = ls_keywords-begins_at + 4.
        lv_tmp   = lv_shift + 1.
        CONCATENATE mv_command(lv_shift) '(' iv_where_addition ') AND (' mv_command+lv_tmp
          INTO mv_command SEPARATED BY space.

*     add pre stuff to ls_keywords-text
        CONCATENATE '(' iv_where_addition ') AND (' ls_keywords-text
          INTO ls_keywords-text SEPARATED BY space.

        lv_len = STRLEN( ls_keywords-text ) - 1.

        IF ls_keywords-text+lv_len(1) = '.'.
*       add post stuff to mv_command
          lv_shift = ls_keywords-ends_at + STRLEN( ls_keywords-text ) - 1.
          CONCATENATE mv_command(lv_shift) ').' INTO mv_command SEPARATED BY space.
*       add post stuff to ls_keywords-text
          CONCATENATE ls_keywords-text(lv_len) ').' INTO ls_keywords-text SEPARATED BY space.
        ELSE.
*       add post stuff to ls_keywords-text
          CONCATENATE ls_keywords-text ')' INTO ls_keywords-text SEPARATED BY space.

          LOOP AT mt_keywords TRANSPORTING NO FIELDS
               WHERE order_pos > ls_keywords-order_pos.
            lv_shift = ls_keywords-ends_at + lv_len + 1.
            lv_tmp   = lv_shift + 1.
            CONCATENATE mv_command(lv_shift) ')' mv_command+lv_shift
              INTO mv_command SEPARATED BY space.
            EXIT.
          ENDLOOP.

          IF sy-subrc EQ 4.
*         add post stuff to mv_command
            CONCATENATE mv_command ')' INTO mv_command SEPARATED BY space.
          ENDIF.
        ENDIF.

        MODIFY mt_keywords FROM ls_keywords INDEX lv_tabix.

      ELSE.   " create WHERE clause

        LOOP AT mt_keywords INTO ls_keywords WHERE order_pos > 5. " WHERE keyword
          lv_shift = ls_keywords-begins_at - 1.
          CONCATENATE mv_command(lv_shift) 'WHERE' iv_where_addition mv_command+lv_shift
            INTO mv_command SEPARATED BY space.
          EXIT.
        ENDLOOP.

        IF sy-subrc EQ 4.
          CONCATENATE mv_command 'WHERE' iv_where_addition
            INTO mv_command SEPARATED BY space.
        ENDIF.

        ls_keywords-keyword   = 'WHERE'.
        ls_keywords-text      = iv_where_addition.
        ls_keywords-order_pos = 5.
        ls_keywords-begins_at = lv_shift.
        ls_keywords-ends_at   = lv_shift + 4.

        APPEND ls_keywords TO mt_keywords.

      ENDIF.

    ENDIF.

  ENDMETHOD.                    "extend_where_clause

  METHOD add_where_excl_all.

  ENDMETHOD.                    "ADD_WHERE_EXCL_ALL


  METHOD can_edit.

    ev_can_edit = mv_can_edit.

  ENDMETHOD.                    "can_edit

  METHOD create_type.
* create a type for the result set of the command

    DATA: lt_srccode   TYPE STANDARD TABLE OF string,
          lv_line      TYPE string,
          lv_alias     TYPE string,
          ls_fieldinfo LIKE LINE OF it_fieldinfo.


    IF it_fieldinfo IS INITIAL.
      RETURN.
    ENDIF.

    CONCATENATE 'TYPES: BEGIN OF' iv_type_name ',' INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO lt_srccode.

    IF iv_with_tech_fields EQ 'X'.
*   add system fields HTDB_ROWID and HTDB_SELECTED and HTDB_ICON
      lv_line = 'zenith_rowid TYPE i,'.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

      lv_line = 'zenith_selected TYPE c,'.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

*   add style field
      lv_line = 'zenith_style TYPE lvc_t_styl,'.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

*   add coloring field
      lv_line = 'zenith_color TYPE lvc_t_scol,'.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

*   who locked the row?
      lv_line = 'zenith_locked_by TYPE sy-uname,'.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.
    ENDIF.

* for each entry in the field list there will be a field in the structure
    LOOP AT it_fieldinfo INTO ls_fieldinfo.
      TRANSLATE ls_fieldinfo-generated_field TO LOWER CASE.
      TRANSLATE ls_fieldinfo-field_alias     TO LOWER CASE.
      TRANSLATE ls_fieldinfo-orig_field      TO LOWER CASE.
      TRANSLATE ls_fieldinfo-table           TO LOWER CASE.
      TRANSLATE ls_fieldinfo-field           TO LOWER CASE.

      IF ls_fieldinfo-agg_function = 'COUNT'.
        CONCATENATE ls_fieldinfo-generated_field 'TYPE i,'
          INTO lv_line SEPARATED BY space.
*      ELSEIF ls_fieldinfo-agg_function = 'SUM'.
*        CONCATENATE ls_fieldinfo-generated_field 'TYPE f,'
*          INTO lv_line SEPARATED BY space.
      ELSEIF ls_fieldinfo-agg_function = 'AVG'.
        CONCATENATE ls_fieldinfo-generated_field 'TYPE p DECIMALS 4,'
          INTO lv_line SEPARATED BY space.
      ELSE.
        IF ls_fieldinfo-generated_field IS NOT INITIAL.
          CONCATENATE ls_fieldinfo-generated_field 'TYPE' ls_fieldinfo-table
            INTO lv_line SEPARATED BY space.
        ELSEIF ls_fieldinfo-field_alias IS INITIAL.
          CONCATENATE ls_fieldinfo-field_alias 'TYPE' ls_fieldinfo-table
            INTO lv_line SEPARATED BY space.
        ELSE.
          CONCATENATE ls_fieldinfo-orig_field 'TYPE' ls_fieldinfo-table
            INTO lv_line SEPARATED BY space.
        ENDIF.

        CONCATENATE lv_line '-' ls_fieldinfo-field ',' INTO lv_line.
      ENDIF.

      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.
    ENDLOOP.

    CONCATENATE '       END OF' iv_type_name '.' INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO lt_srccode.

    APPEND LINES OF lt_srccode TO ct_srccode.

  ENDMETHOD.                    "

  METHOD expand_asterisk.
* get field list in case of SELECT *

    DATA: lv_lines       TYPE i,
          ls_table_field LIKE LINE OF mt_table_fields,
          ls_table_alias LIKE LINE OF mt_table_alias,
          ls_fieldinfo   LIKE LINE OF mt_fieldinfo.


    CLEAR mt_fieldinfo.

    LOOP AT mt_table_alias INTO ls_table_alias.

      ls_fieldinfo-table = ls_table_alias-table.

*   get table fields
      LOOP AT mt_table_fields INTO ls_table_field
           WHERE TABLE = LS_FIELDINFO-TABLE.

        ls_fieldinfo-orig_field = ls_table_field-field.
        ls_fieldinfo-field      = ls_table_field-field.
        ls_fieldinfo-is_key     = ls_table_field-keyflag.

*      READ TABLE mt_table_alias INTO ls_table_alias
*        WITH KEY table = ls_table_alias-table.

        IF ls_table_alias-alias IS INITIAL.
          ls_fieldinfo-table_alias = ls_table_alias-table.
        ELSE.
          ls_fieldinfo-table_alias = ls_table_alias-alias.
        ENDIF.

        READ TABLE mt_fieldinfo
          WITH KEY orig_field = ls_table_field-field
          TRANSPORTING NO FIELDS.

        IF sy-subrc EQ 0.
          mv_has_dupl_fields = 'X'.
        ENDIF.

        APPEND ls_fieldinfo TO mt_fieldinfo.

      ENDLOOP.

    ENDLOOP.

* result set can be edited, if there is only one table
    DESCRIBE TABLE mt_table_alias LINES lv_lines.
    IF lv_lines NE 1.
      CLEAR mv_can_edit.    " result set can't be edited
      CLEAR mv_can_insert.  " new records can't inserted to the result set
    ENDIF.

* clean field list from duplicates
    remove_duplicates( ).

  ENDMETHOD.                    "


  METHOD get_fieldinfo.
* returns the field list (from the SELECT clause)

    et_fieldinfo  = mt_fieldinfo.
    ev_can_edit   = mv_can_edit.
    ev_can_insert = mv_can_insert.

  ENDMETHOD.                    "

  METHOD get_program_name.

    ev_program_name = mv_program.

  ENDMETHOD.                    "get_program_name

  METHOD get_table_alias.
* returns the table list (from the FROM clause and subquerys)

    CLEAR et_table_alias.

    et_table_alias = mt_table_alias.                   " FROM clause
    APPEND LINES OF mt_adt_tables TO et_table_alias.   " subquerys

  ENDMETHOD.                    "

  METHOD get_texts.
* returns the SELECT, FROM, etc. clauses of the command

    DATA: ls_keyword LIKE LINE OF mt_keywords.


* get SELECT text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'SELECT'.
    ev_select_text = ls_keyword-text.

* get FROM text
    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'FROM'.
    ev_from_text = ls_keyword-text.

* ...
    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'WHERE'.
    ev_where_text = ls_keyword-text.

    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'GROUP BY'.
    ev_group_by_text = ls_keyword-text.

    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'HAVING'.
    ev_having_text = ls_keyword-text.

    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'ORDER BY'.
    ev_order_by_text = ls_keyword-text.

  ENDMETHOD.                    "


  METHOD parse_adt_tables.

    DATA: ls_keyword      LIKE LINE OF mt_keywords,
          lv_where        TYPE string,
          lt_aptph_pos    LIKE mt_aptph_pos,
          lt_paranth      LIKE mt_aptph_pos,
          ls_aptph        LIKE LINE OF mt_aptph_pos,

          lv_search_str   TYPE string,
          lv_offset       TYPE i,
          lv_found        TYPE flag,
          lv_reparse      TYPE flag,

          lv_subquery     TYPE string,
          ls_where        TYPE lty_zhtdb_keyword,
          lv_subq_begin   TYPE i,
          lv_subq_end     TYPE i,
          lv_subq_lgth    TYPE i,
          lv_new_lgth     TYPE i,
          lv_shift        TYPE i,
          lv_left         TYPE i,
          lv_right        TYPE i,

          lo_sel_cmd      TYPE REF TO lcl_htdb_cl_command_select,
          lt_table_alias  LIKE mt_table_alias.


* get WHERE text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'WHERE'.

    IF sy-subrc <> 0.
      EXIT.
    ENDIF.

* WHERE text
    lv_where = ls_keyword-text.
* SPACE as the first character
    SHIFT lv_where RIGHT BY 1 PLACES.

* identify apostrophes and paranthesis
    CALL METHOD lcl_toolbox=>parse_aptph
      EXPORTING
        iv_log_handle = mv_log_handle
      IMPORTING
        et_aptph_pos  = lt_aptph_pos
        et_paranth    = lt_paranth
      CHANGING
        cv_string     = lv_where
      EXCEPTIONS
        OTHERS        = 1.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E'
          iv_msgid = sy-msgid
          iv_msgno = sy-msgno
          iv_msgv1 = sy-msgv1
          iv_msgv2 = sy-msgv2
          iv_msgv3 = sy-msgv3
          iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

* create new instance for the subquery
    CREATE OBJECT lo_sel_cmd.

    DO.
      CLEAR lv_found.
      lv_offset = lv_subq_begin + 1.

*   search for subquerys
      SEARCH lv_where
        FOR '. IN ( SELECT .'
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      < lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 4.
          lv_found = 'X'.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR '. ALL ( SELECT .'
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      < lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 5.
          lv_found = 'X'.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR '. SOME ( SELECT .'
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      < lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 6.
          lv_found = 'X'.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR '. ANY ( SELECT .'
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      < lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 5.
          lv_found = 'X'.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR '. EXISTS ( SELECT .'
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      < lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 8.
          lv_found = 'X'.
        ENDIF.
      ENDIF.

      IF lv_found = 'X'.
        lv_reparse = 'X'.

*     absolute position
        lv_subq_begin = lv_subq_begin + lv_offset.

*     check, whether it's outside of apostrophes
        READ TABLE lt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_subq_begin.

        IF ls_aptph-type = 'O'.  " outside apostrophes
*       identify the depth of the paranthesis in ' ### ( SELECT'
          READ TABLE lt_paranth INTO ls_aptph
            WITH KEY position = lv_subq_begin.

          IF sy-subrc = 0.
*         now ls_aptph-type is the depth of the (
*         find the closing paranthesis - the next with the same depth
            lv_subq_end = sy-tabix + 1.
            LOOP AT lt_paranth FROM lv_subq_end INTO ls_aptph
                 WHERE type = ls_aptph-type.
              lv_subq_end = ls_aptph-position.
              EXIT.
            ENDLOOP.

            IF sy-subrc = 0.
*           extract subquery from string
              lv_subq_lgth = lv_subq_end - lv_subq_begin - 1.
              lv_subquery  = lv_where+lv_subq_begin(lv_subq_lgth).

*           create new subquery
              CALL METHOD lo_sel_cmd->create_new
                EXPORTING
                  iv_command    = lv_subquery
                  iv_log_handle = mv_log_handle.

*           parse subquery
              CALL METHOD lo_sel_cmd->parse
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc <> 0.
                IF mv_log_handle IS INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                          RAISING parse_error.
                ELSE.
                  CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
                    iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
                  RAISE parse_error.
                ENDIF.
              ENDIF.

*           extract tables from subquery
              lo_sel_cmd->get_table_alias( IMPORTING et_table_alias = lt_table_alias ).
              APPEND LINES OF lt_table_alias TO mt_adt_tables.

*           get modified command text
              lo_sel_cmd->get_command( RECEIVING ev_command = lv_subquery ).

*           new length of the subquery
              lv_new_lgth = STRLEN( lv_subquery ).

*           insert modified subquery into the original command
*             position of WHERE + rest of the word 'WHERE' + start of subq '('
              lv_left  = ls_keyword-begins_at + 4 + lv_subq_begin + lv_shift.
*             position of WHERE + rest of the word 'WHERE' + end of subq ')' - 1
              lv_right = ls_keyword-begins_at + 4 + lv_subq_end - 1 + lv_shift.
              CONCATENATE mv_command(lv_left) lv_subquery mv_command+lv_right
                INTO mv_command SEPARATED BY space.

*           offset due to the new length of the subquery
              lv_shift = lv_shift + lv_new_lgth - lv_subq_lgth + 2.

*           continue search on the same level!
              lv_subq_begin = lv_subq_begin + lv_subq_lgth.
            ENDIF.
          ENDIF.
        ELSE.                    " inside apostrophes -> ignore
          CONTINUE.
        ENDIF.

      ELSE.    " no more subquerys found
*     the command could have been changed due to authority checks
        IF lv_reparse = 'X'.
          parse_keywords( ).
        ENDIF.

        EXIT.
      ENDIF.

    ENDDO.

  ENDMETHOD.                    "

  METHOD parse_check_fieldname.
* checks if the string is a valid field name, including ~ for table alias

    CLEAR rv_valid.

    READ TABLE it_keywords WITH KEY table_line = iv_word
      TRANSPORTING NO FIELDS.

    IF sy-subrc = 0.                                       " 1 -> error
      RETURN.
    ELSE.
*    IF iv_word CO 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_~0123456789'.
      rv_valid = 'X'.
*    ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD parse_check_name.
* checks if the string is a valid name for tables, fields or aliases

    rv_valid = 'X'.

*  CLEAR rv_valid.
*
*  READ TABLE it_keywords WITH KEY table_line = iv_word
*    TRANSPORTING NO FIELDS.
*
*  IF sy-subrc = 0.                                       " 1 -> error
*    RETURN.
*  ELSE.
*    IF iv_word CO 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789'.
*      rv_valid = 'X'.
*    ENDIF.
*  ENDIF.

  ENDMETHOD.                    "

  METHOD parse_check_value .
* checks the string if it is between apostrophes;
* the number of apostrophes is correct anyway

    rv_valid = 'X'.

*  DATA: lv_length TYPE i,
*        lv_word   LIKE iv_word.
*
*  CLEAR rv_valid.
*
*  lv_word = iv_word.
*
*  TRANSLATE lv_word TO UPPER CASE.
*
*  IF lv_word IS INITIAL.
*    RETURN.
*  ENDIF.
*
*  IF lv_word = 'SPACE'.
*    rv_valid = 'X'.
*  ENDIF.
*
*  IF lv_word CO '0123456789'.
*    rv_valid = 'X'.
*  ENDIF.
*
*  lv_length = strlen( lv_word ).
*  lv_length = lv_length - 1.
*
*  IF lv_length > 3.
*    IF lv_word(3) = 'SY-'.
*      rv_valid = 'X'.
*    ENDIF.
*  ENDIF.
*
*  IF lv_length > 5.
*    IF lv_word(5) = 'SYST-'.
*      rv_valid = 'X'.
*    ENDIF.
*  ENDIF.
*
*  IF lv_word(1)           = '''' AND
*     lv_word+lv_length(1) = ''''.
*    rv_valid = 'X'.
*  ENDIF.

  ENDMETHOD.                    "


  METHOD parse_fields.
* extracts field names from the SELECT clause
* and fills up the MT_FIELDINFO table

    DATA: lv_state        TYPE i,
          lv_error        TYPE xfeld,
          lv_lines        TYPE i,

          ls_keyword      LIKE LINE OF mt_keywords,
          lt_words        TYPE lty_zhtdbt_string_tab,
          lt_keywords     TYPE lty_zhtdbt_string_tab,
          lv_word         TYPE string,
          ls_fieldinfo    LIKE LINE OF mt_fieldinfo,
          ls_table_alias  LIKE LINE OF mt_table_alias,
          lv_fdpos        TYPE i,
          ls_table_field  LIKE LINE OF mt_table_fields.


* get words of select_text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'SELECT'.

    prepare_sel_text( CHANGING cv_string = ls_keyword-text ).

    CALL METHOD split_string
      EXPORTING
        iv_string = ls_keyword-text
      IMPORTING
        et_words  = lt_words.

* list of possible keywords
    APPEND 'AS'       TO lt_keywords.
    APPEND 'MIN('     TO lt_keywords.
    APPEND 'MAX('     TO lt_keywords.
    APPEND 'AVG('     TO lt_keywords.
    APPEND 'SUM('     TO lt_keywords.
    APPEND 'COUNT('   TO lt_keywords.
    APPEND '*'        TO lt_keywords.
    APPEND 'DISTINCT' TO lt_keywords.
    APPEND ')'        TO lt_keywords.

    IF lt_words IS INITIAL.
      IF mv_log_handle IS INITIAL.
*     Message: Field list is missing
        MESSAGE e017 RAISING no_fields_found.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '017' ).
        RAISE no_fields_found.
      ENDIF.
    ENDIF.

* parse words

* The parser is a simple automat having 10 states defined as follows:

* <field_list>: 1  '*' 4                                                                    |
*               1  {fieldname} 2                                                            |
*               1  'MIN(' | 'MAX(' | 'AVG(' | 'SUM(' 5 ['DISTINCT'] 6 {fieldname } 7  ')' 8 |
*               1  'COUNT(' 9
*
*               2  'AS' 3 {name} 1
*               2  {fieldname} 2                        |
*               2  'MIN(' | 'MAX(' | 'AVG(' | 'SUM(' 5  |
*               2  'COUNT(' 9
*
*               8  'AS' 3 {name} 1                      |
*               8  {fieldname} 2                        |
*               8  'MIN(' | 'MAX(' | 'AVG(' | 'SUM(' 5  |
*               8  'COUNT(' 9
*
*               9  '*' 7         |
*               9  'DISTINCT' 10 |
*               9  {fieldname } 7
*
*               10 '*' 7          |
*               10 {fieldname } 7
*
* 1 is the START state, 2, 4 and 8 are END states.

    lv_state = 1.

    LOOP AT lt_words INTO lv_word
         WHERE table_line IS NOT INITIAL.

      CASE lv_state.

        WHEN 1. "************************************************

*       check wether it's a keyword
          CASE lv_word.
            WHEN '*'.                                       " 1 -> 4
              lv_state = 4.
              CONTINUE.
            WHEN 'MIN(' OR                                  " 1 -> 5
                 'MAX(' OR
                 'AVG(' OR
                 'SUM('.
              lv_state = 5.
              ls_fieldinfo-agg_function = lv_word(3).
              CONTINUE.
            WHEN 'COUNT('.                                  " 1 -> 9
              lv_state = 9.
              ls_fieldinfo-agg_function = lv_word(5).

*           if only one record will be returned
*           -> it's like a SELECT SINGLE
*           depends if there is a group by clause or  not
              READ TABLE mt_keywords TRANSPORTING NO FIELDS
                WITH KEY keyword = 'GROUP BY'.

              IF sy-subrc EQ 0.
                CLEAR mv_sel_single.
              ELSE.
                mv_sel_single = 'X'.
              ENDIF.

              CONTINUE.
          ENDCASE.

*       check wether it's a valid fieldname
          IF parse_check_fieldname(
               iv_word = lv_word
               it_keywords = lt_keywords ) = 'X'.           " 1 -> 2
            lv_state = 2.
            ls_fieldinfo-orig_field = lv_word.
            CONTINUE.
          ELSE.                                               " 1 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 2. "************************************************

          CASE lv_word.
            WHEN 'AS'.                                      " 2 -> 3
              lv_state = 3.
              CONTINUE.
            WHEN 'MIN(' OR                                  " 2 -> 5
                 'MAX(' OR
                 'AVG(' OR
                 'SUM('.
              lv_state = 5.
              APPEND ls_fieldinfo TO mt_fieldinfo.
              CLEAR ls_fieldinfo.
              ls_fieldinfo-agg_function = lv_word(3).
              CONTINUE.
            WHEN 'COUNT('.                                  " 2 -> 9
              lv_state = 9.
              APPEND ls_fieldinfo TO mt_fieldinfo.
              CLEAR ls_fieldinfo.
              ls_fieldinfo-agg_function = lv_word(5).
*           if only one record will be returned
*           -> it's like a SELECT SINGLE
*           depends if there is a group by clause or  not
              READ TABLE mt_keywords TRANSPORTING NO FIELDS
                WITH KEY keyword = 'GROUP BY'.

              IF sy-subrc EQ 0.
                CLEAR mv_sel_single.
              ELSE.
                mv_sel_single = 'X'.
              ENDIF.

              CONTINUE.
          ENDCASE.

          IF parse_check_fieldname(
               iv_word     = lv_word
               it_keywords = lt_keywords ) = 'X'.           " 2 -> 2
            APPEND ls_fieldinfo TO mt_fieldinfo.
            CLEAR ls_fieldinfo.
            ls_fieldinfo-orig_field = lv_word.
            CONTINUE.
          ELSE.                                               " 2 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 3. "************************************************

          IF parse_check_name(
               iv_word     = lv_word
               it_keywords = lt_keywords ) = 'X'.           " 3 -> 1
            lv_state = 1.
            ls_fieldinfo-field_alias = lv_word.
            APPEND ls_fieldinfo TO mt_fieldinfo.
            CLEAR ls_fieldinfo.
            CONTINUE.
          ELSE.                                               " 3 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 4. "************************************************

          IF lv_word IS NOT INITIAL.                          " 4 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 5. "************************************************

          IF lv_word = 'DISTINCT'.                          " 5 -> 6
            ls_fieldinfo-distinctf = 'X'.
            lv_state = 6.
            CONTINUE.
          ENDIF.

          IF parse_check_fieldname(
               iv_word     = lv_word
               it_keywords = lt_keywords ) = 'X'.           " 5 -> 7
            lv_state = 7.
            ls_fieldinfo-orig_field = lv_word.
            CONTINUE.
          ELSE.                                               " 5 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 6. "************************************************

          IF parse_check_fieldname(
               iv_word     = lv_word
               it_keywords = lt_keywords ) = 'X'.           " 6 -> 7
            ls_fieldinfo-orig_field = lv_word.
            lv_state = 7.
            CONTINUE.
          ELSE.                                               " 6 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 7. "************************************************

          IF lv_word = ')'.                                 " 7 -> 8
            lv_state = 8.
            CONTINUE.
          ENDIF.

          lv_error = 'X'.
          EXIT.

        WHEN 8. "************************************************

          CASE lv_word.
            WHEN 'AS'.                                      " 8 -> 3
              lv_state = 3.
              CONTINUE.
            WHEN 'MIN(' OR                                  " 8 -> 5
                 'MAX(' OR
                 'AVG(' OR
                 'SUM('.
              lv_state = 5.
              APPEND ls_fieldinfo TO mt_fieldinfo.
              CLEAR ls_fieldinfo.
              ls_fieldinfo-agg_function = lv_word(3).
              CONTINUE.
            WHEN 'COUNT('.                                  " 8 -> 9
              lv_state = 9.
              APPEND ls_fieldinfo TO mt_fieldinfo.
              CLEAR ls_fieldinfo.
              ls_fieldinfo-agg_function = lv_word(5).

*           if only one record will be returned
*           -> it's like a SELECT SINGLE
*           depends if there is a group by clause or  not
              READ TABLE mt_keywords TRANSPORTING NO FIELDS
                WITH KEY keyword = 'GROUP BY'.

              IF sy-subrc EQ 0.
                CLEAR mv_sel_single.
              ELSE.
                mv_sel_single = 'X'.
              ENDIF.

              CONTINUE.
          ENDCASE.

          IF parse_check_fieldname(
               iv_word     = lv_word
               it_keywords = lt_keywords ) = 'X'.           " 8 -> 2
            lv_state = 2.
            APPEND ls_fieldinfo TO mt_fieldinfo.
            CLEAR ls_fieldinfo.
            ls_fieldinfo-orig_field = lv_word.
            CONTINUE.
          ELSE.                                               " 8 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 9. "************************************************

          CASE lv_word.
            WHEN '*'.                                       " 9 -> 7
              lv_state = 7.
              ls_fieldinfo-orig_field = '*'.
              CONTINUE.
            WHEN 'DISTINCT'.                                " 9 -> 10
              ls_fieldinfo-distinctf = 'X'.
              lv_state = 10.
              CONTINUE.
          ENDCASE.

          IF parse_check_fieldname(
               iv_word     = lv_word
               it_keywords = lt_keywords ) = 'X'.           " 9 -> 7
            lv_state = 7.
*         CLEAR ls_fieldinfo.
            ls_fieldinfo-orig_field = lv_word.
            CONTINUE.
          ELSE.                                               " 9 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 10. "************************************************

          CASE lv_word.
            WHEN '*'.                                       " 10 -> 7
              lv_state = 7.
              ls_fieldinfo-orig_field = '*'.
              CONTINUE.
          ENDCASE.

          IF parse_check_fieldname(
               iv_word     = lv_word
               it_keywords = lt_keywords ) = 'X'.           " 10 -> 7
            lv_state = 7.
*         CLEAR ls_fieldinfo.
            ls_fieldinfo-orig_field = lv_word.
            CONTINUE.
          ELSE.                                               " 10 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

      ENDCASE.

    ENDLOOP.


* check errors
    IF lv_error = 'X'.
      IF mv_log_handle IS INITIAL.
*     Message: '&1' was not expected in the field list
        MESSAGE e010 WITH lv_word
          RAISING parse_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '010' iv_msgv1 = lv_word ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

* check END state
    IF lv_state <> 1 AND
       lv_state <> 2 AND
       lv_state <> 4 AND
       lv_state <> 8.

      IF mv_log_handle IS INITIAL.
*     Message: Field list ended unexpectedly with '&1'
        MESSAGE e011 WITH lv_word
          RAISING parse_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '011' iv_msgv1 = lv_word ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

    IF lv_state = 4.
* SELECT * -> expand *
      expand_asterisk( EXCEPTIONS table_not_found = 1 ).

      IF sy-subrc <> 0.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING table_not_found.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
          RAISE table_not_found.
        ENDIF.
      ENDIF.

      RETURN.
    ENDIF.

    IF ls_fieldinfo IS NOT INITIAL.
*   an END state was reached -> save the last entry
      APPEND ls_fieldinfo TO mt_fieldinfo.
    ENDIF.

************************************************************************
* expand table aliases, fields

    LOOP AT mt_fieldinfo INTO ls_fieldinfo.

      SEARCH ls_fieldinfo-orig_field FOR '~'.

      IF sy-subrc EQ 0.
        lv_fdpos = sy-fdpos.

        MOVE ls_fieldinfo-orig_field(lv_fdpos) TO ls_fieldinfo-table_alias.
        TRANSLATE ls_fieldinfo-table_alias TO UPPER CASE.
        lv_fdpos = lv_fdpos + 1.
        MOVE ls_fieldinfo-orig_field+lv_fdpos TO ls_fieldinfo-field.
        TRANSLATE ls_fieldinfo-field TO UPPER CASE.

        MODIFY mt_fieldinfo FROM ls_fieldinfo.
      ELSE.
        MOVE ls_fieldinfo-orig_field TO ls_fieldinfo-field.
        TRANSLATE ls_fieldinfo-field TO UPPER CASE.
        MODIFY mt_fieldinfo FROM ls_fieldinfo.
      ENDIF.

      IF ls_fieldinfo-field EQ '*'.
        ls_fieldinfo-field = 'ALL'.
      ELSEIF ls_fieldinfo-table_alias IS NOT INITIAL.
        READ TABLE mt_table_alias
          INTO ls_table_alias
          WITH KEY alias = ls_fieldinfo-table_alias.

        IF sy-subrc <> 0.
          READ TABLE mt_table_alias
            INTO ls_table_alias
            WITH KEY table = ls_fieldinfo-table_alias.
        ENDIF.

        IF sy-subrc <> 0.
          IF mv_log_handle IS INITIAL.
*         Message: Field list: can not find table alias &1
            MESSAGE e012 WITH ls_fieldinfo-table_alias
              RAISING table_not_found.
          ELSE.
            CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '012' iv_msgv1 = ls_fieldinfo-table_alias ).
            RAISE table_not_found.
          ENDIF.
        ELSE.
          ls_fieldinfo-table = ls_table_alias-table.

          READ TABLE mt_table_fields INTO ls_table_field
            WITH KEY table = ls_table_alias-table
                     field = ls_fieldinfo-field.

          IF sy-subrc <> 0.
            IF mv_log_handle IS INITIAL.
*           Message: Field '&1' does not belong to tables '&2'
              MESSAGE e036 WITH ls_fieldinfo-field ls_table_alias-table
                RAISING field_not_found.
            ELSE.
              CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '036' iv_msgv1 = ls_fieldinfo-field iv_msgv2 = ls_table_alias-table ).
              RAISE field_not_found.
            ENDIF.
          ELSE.
            ls_fieldinfo-is_key = ls_table_field-keyflag.
          ENDIF.
        ENDIF.
      ELSE.
        READ TABLE mt_table_fields INTO ls_table_field
          WITH KEY field = ls_fieldinfo-field.

        IF sy-subrc <> 0.
          IF mv_log_handle IS INITIAL.
*         Message: Field '&1' does not belong to any of the tables
            MESSAGE e016 WITH ls_fieldinfo-field
              RAISING field_not_found.
          ELSE.
            CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '016' iv_msgv1 = ls_fieldinfo-field ).
            RAISE field_not_found.
          ENDIF.
        ELSE.
          ls_fieldinfo-table  = ls_table_field-table.
          ls_fieldinfo-is_key = ls_table_field-keyflag.
        ENDIF.
      ENDIF.

      MODIFY mt_fieldinfo FROM ls_fieldinfo.

    ENDLOOP.

* tackle with duplicated fields
    remove_duplicates( ).

* result set can be edited, if there is only one table and
* all key fields were selected

    DESCRIBE TABLE mt_table_alias LINES lv_lines.

    IF lv_lines = 1.
      LOOP AT mt_table_fields INTO ls_table_field
           WHERE keyflag = 'X'.
        READ TABLE mt_fieldinfo
          WITH KEY field = ls_table_field-field
          TRANSPORTING NO FIELDS.

        IF sy-subrc <> 0.
          CLEAR mv_can_edit.
          EXIT.
        ENDIF.
      ENDLOOP.
    ELSE.
      CLEAR mv_can_edit.
    ENDIF.

  ENDMETHOD.                    "

  METHOD parse_tables.
* extracts table names from the FROM clause
* and fills up the MT_TABLE_ALIAS table

    DATA: lv_state        TYPE i,
          lv_tabix        TYPE i,
          lv_error        TYPE xfeld,
          lv_viewgrant    TYPE dd25l-viewgrant,

          ls_keyword      LIKE LINE OF mt_keywords,
          lt_from_words   TYPE lty_zhtdbt_string_tab,
          lt_keywords     TYPE lty_zhtdbt_string_tab,
          lt_operators    TYPE lty_zhtdbt_string_tab,
          lv_word         TYPE string,
          ls_table_alias  LIKE LINE OF mt_table_alias.

    FIELD-SYMBOLS: <ls_table_alias> LIKE LINE OF mt_table_alias.


* get words from from_text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = 'FROM'.

    prepare_from_text( CHANGING cv_string = ls_keyword-text ).

    CALL METHOD split_string
      EXPORTING
        iv_string = ls_keyword-text
      IMPORTING
        et_words  = lt_from_words.

    IF lt_from_words IS INITIAL.
      IF mv_log_handle IS INITIAL.
*     Message: No tables were found
        MESSAGE e013 RAISING no_tables_found.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '013' ).
        RAISE no_tables_found.
      ENDIF.
    ENDIF.

* list of possible keywords
    APPEND 'AS'      TO lt_keywords.
    APPEND 'INNER'   TO lt_keywords.
    APPEND 'LEFT'    TO lt_keywords.
    APPEND 'OUTER'   TO lt_keywords.
    APPEND 'JOIN'    TO lt_keywords.
    APPEND 'ON'      TO lt_keywords.
    APPEND 'IS'      TO lt_keywords.
    APPEND 'NOT'     TO lt_keywords.
    APPEND 'NULL'    TO lt_keywords.
    APPEND 'BETWEEN' TO lt_keywords.
    APPEND 'AND'     TO lt_keywords.

* list of possible operators
    APPEND '='       TO lt_operators.
    APPEND '<'       TO lt_operators.
    APPEND '>'       TO lt_operators.
    APPEND '<='      TO lt_operators.
    APPEND '>='      TO lt_operators.
    APPEND '=<'      TO lt_operators.
    APPEND '=>'      TO lt_operators.
    APPEND '<>'      TO lt_operators.
    APPEND '><'      TO lt_operators.
    APPEND 'EQ'      TO lt_operators.
    APPEND 'NE'      TO lt_operators.
    APPEND 'LT'      TO lt_operators.
    APPEND 'GT'      TO lt_operators.
    APPEND 'LE'      TO lt_operators.
    APPEND 'GE'      TO lt_operators.

* parse words

* The parser is a simple automat having 19 states defined as follows:

* <from_text>: 1 {dbtab} 2 [as 3 {alias}] 4 [[inner|[left] 5 outer ] 6 join 7 {dbtab} 8 [as 9 {alias}] 10 ON 11 <join_condition>]
* <join_condition>: {field} 12 (IS 13 NOT 14 NULL) | (BETWEEN 15 {value} 16 AND 17 {value}) | (<comp> 18 {field}) 19 [AND 20 <join_condition>]
* <comp>: =|<|>|<=|>=|EQ|NE|GT|LT|LE|GE

* 1 is the START state, 2, 4 and 19 are END states.

    lv_state = 1.

    LOOP AT lt_from_words INTO lv_word
         WHERE table_line IS NOT INITIAL.

      CASE lv_state.

        WHEN 1. "************************************************

*       check wether it is a valid table name (and no keyword)
          IF parse_check_name(
              iv_word = lv_word
              it_keywords = lt_keywords ) = 'X'.            " 1 -> 2
            lv_state = 2.
            ls_table_alias-table = lv_word.  " store table name
            CONTINUE.
          ELSE.                                               " 1 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 2. "************************************************

*       check wether it is a keyword
          CASE lv_word.
            WHEN 'AS'.                                      " 2 -> 3
              lv_state = 3.
              CONTINUE.
            WHEN 'INNER'.                                   " 2 -> 6
              lv_state = 6.
*           store table
              APPEND ls_table_alias TO mt_table_alias.
              CLEAR ls_table_alias.
              CONTINUE.
            WHEN 'LEFT'.                                    " 2 -> 5
              lv_state = 5.
*           store table
              APPEND ls_table_alias TO mt_table_alias.
              CLEAR ls_table_alias.
              CONTINUE.
            WHEN 'OUTER'.                                   " 2 -> 6
              lv_state = 6.
*           store table
              APPEND ls_table_alias TO mt_table_alias.
              CLEAR ls_table_alias.
              CONTINUE.
            WHEN 'JOIN'.                                    " 2 -> 7
              lv_state = 7.
*           store table
              APPEND ls_table_alias TO mt_table_alias.
              CLEAR ls_table_alias.
              CONTINUE.
          ENDCASE.

*       check wether it is a valid table name (and no keyword)
          IF parse_check_name(
              iv_word = lv_word
              it_keywords = lt_keywords ) = 'X'.            " 2 -> 2
            ls_table_alias-table = lv_word.  " store table name
            CONTINUE.
          ELSE.                                               " 2 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 3. "************************************************

*       check wether it is a valid table name (and no keyword)
          IF parse_check_name(
              iv_word = lv_word
              it_keywords = lt_keywords ) = 'X'.            " 3 -> 4
            lv_state = 4.
            ls_table_alias-alias = lv_word. " store table alias
*         store table
            APPEND ls_table_alias TO mt_table_alias.
            CLEAR ls_table_alias.
            CONTINUE.
          ELSE.                                               " 3 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 4. "************************************************

          CASE lv_word.
            WHEN 'INNER'.                                   " 4 -> 6
              lv_state = 6.
              CONTINUE.
            WHEN 'LEFT'.                                    " 4 -> 5
              lv_state = 5.
              CONTINUE.
            WHEN 'OUTER'.                                   " 4 -> 6
              lv_state = 6.
              CONTINUE.
            WHEN 'JOIN'.                                    " 4 -> 7
              lv_state = 7.
              CONTINUE.
          ENDCASE.

*       check wether it is a valid table name (and no keyword)
          IF parse_check_name(
              iv_word = lv_word
              it_keywords = lt_keywords ) = 'X'.            " 4 -> 2
            lv_state = 2.
            ls_table_alias-table = lv_word.  " store table name
            CONTINUE.
          ELSE.                                               " 4 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 5. "************************************************

          CASE lv_word.
            WHEN 'OUTER'.                                   " 5 -> 6
              lv_state = 6.
              CONTINUE.
            WHEN 'JOIN'.                                    " 5 -> 7
              lv_state = 7.
              CONTINUE.
            WHEN OTHERS.                                      " 5 -> error
              lv_error = 'X'.
              EXIT.
          ENDCASE.

        WHEN 6. "************************************************

          IF lv_word = 'JOIN'.                              " 6 -> 7
            lv_state = 7.
            CONTINUE.
          ELSE.                                               " 6 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 7. "************************************************

*       check wether it is a valid table name (and no keyword)
          IF parse_check_name(
              iv_word = lv_word
              it_keywords = lt_keywords ) = 'X'.            " 7 -> 8
            lv_state = 8.
            ls_table_alias-table = lv_word. " store table name
            CONTINUE.
          ELSE.                                               " 7 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 8. "************************************************

          CASE lv_word.
            WHEN 'AS'.                                      " 8 -> 9
              lv_state = 9.
              CONTINUE.
            WHEN 'ON'.                                      " 8 -> 11
              lv_state = 11.
*           store table
              APPEND ls_table_alias TO mt_table_alias.
              CLEAR ls_table_alias.
              CONTINUE.
          ENDCASE.

          lv_error = 'X'.                                     " 8 -> error
          EXIT.

        WHEN 9. "************************************************

*       check wether it is a valid table name (and no keyword)
          IF parse_check_name(
              iv_word = lv_word
              it_keywords = lt_keywords ) = 'X'.            " 9 -> 10
            lv_state = 10.
            ls_table_alias-alias = lv_word. " store table alias
*         store table
            APPEND ls_table_alias TO mt_table_alias.
            CLEAR ls_table_alias.
            CONTINUE.
          ELSE.                                               " 9 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 10. "***********************************************

          IF lv_word =  'ON'.                               " 10 -> 11
            lv_state = 11.
            CONTINUE.
          ELSE.                                               " 10 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 11. "***********************************************

*       check wether it is a valid field name (and no keyword)
          IF parse_check_fieldname(
              iv_word = lv_word
              it_keywords = lt_keywords ) = 'X'.            " 11 -> 12
            lv_state = 12.
            CONTINUE.
          ELSE.                                               " 11 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 12. "***********************************************

          CASE lv_word.
            WHEN 'IS'.                                      " 12 -> 13
              lv_state = 13.
              CONTINUE.
            WHEN 'BETWEEN'.                                 " 12 -> 15
              lv_state = 15.
              CONTINUE.
          ENDCASE.

*       check wether it is an operator
          READ TABLE lt_operators WITH KEY table_line = lv_word
            TRANSPORTING NO FIELDS.

          IF sy-subrc = 0.                                  " 12 -> 18
            lv_state = 18.
            CONTINUE.
          ELSE.                                               " 12 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 13. "***********************************************

          IF lv_word = 'NOT'.                               " 13 -> 14
            lv_state = 14.
            CONTINUE.
          ELSE.                                               " 13 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 14. "***********************************************

          IF lv_word = 'NULL'.                              " 14 -> 19
            lv_state = 19.
            CONTINUE.
          ELSE.                                               " 14 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 15. "***********************************************

*       check wether it's a valid value
          IF parse_check_value( lv_word ) = 'X'.            " 15 -> 16
            lv_state = 16.
            CONTINUE.
          ELSE.                                               " 15 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 16. "***********************************************

          IF lv_word = 'AND'.                               " 16 -> 17
            lv_state = 17.
            CONTINUE.
          ELSE.                                               " 16 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 17. "***********************************************

*       check wether it's a valid value
          IF parse_check_value( lv_word ) = 'X'.            " 17 -> 19
            lv_state = 19.
            CONTINUE.
          ELSE.                                               " 17 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

        WHEN 18. "***********************************************

*       check wether it is a valid field name (and no keyword)
          IF parse_check_fieldname(
              iv_word = lv_word
              it_keywords = lt_keywords ) = 'X'.            " 18 -> 19
            lv_state = 19.
            CONTINUE.
          ELSE.
*         check wether it's a valid value
            IF parse_check_value( lv_word ) = 'X'.          " 18 -> 19
              lv_state = 19.
              CONTINUE.
            ELSE.                                             " 18 -> error
              lv_error = 'X'.
              EXIT.
            ENDIF.
          ENDIF.

        WHEN 19. "***********************************************

          CASE lv_word.
            WHEN 'AND'.                                     " 19 -> 11
              lv_state = 11.
              CONTINUE.
            WHEN 'INNER'.                                   " 19 -> 6
              lv_state = 6.
              CONTINUE.
            WHEN 'LEFT'.                                    " 19 -> 5
              lv_state = 5.
              CONTINUE.
            WHEN 'OUTER'.                                   " 19 -> 6
              lv_state = 6.
              CONTINUE.
            WHEN 'JOIN'.                                    " 19 -> 7
              lv_state = 7.
              CONTINUE.
          ENDCASE.

*       check wether it is a valid table name (and no keyword)
          IF parse_check_name(
              iv_word = lv_word
              it_keywords = lt_keywords ) = 'X'.            " 19 -> 2
            lv_state = 2.
            ls_table_alias-table = lv_word.  " store table name
            CONTINUE.
          ELSE.                                               " 19 -> error
            lv_error = 'X'.
            EXIT.
          ENDIF.

      ENDCASE.

    ENDLOOP.

* ERROR state
    IF lv_error = 'X'.
      IF mv_log_handle IS INITIAL.
*     Message: '&1' was not expected in the FROM clause
        MESSAGE e008 WITH lv_word
          RAISING parse_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '008' iv_msgv1 = lv_word ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

* check END state
    IF lv_state <> 2  AND
       lv_state <> 4  AND
       lv_state <> 19.   " an END state was not reached

      IF mv_log_handle IS INITIAL.
*     Message: FROM clause ended unexpectedly with '&1'
        MESSAGE e009 WITH lv_word
          RAISING parse_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '009' iv_msgv1 = lv_word ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

    IF ls_table_alias IS NOT INITIAL.
*   an END state was reached -> save last entry
      APPEND ls_table_alias TO mt_table_alias.
    ENDIF.

* get table fields from DDIC
    LOOP AT mt_table_alias INTO ls_table_alias.

      lv_tabix = sy-tabix.

*   check if already processed
      READ TABLE mt_table_fields
        WITH KEY table = ls_table_alias-table
        TRANSPORTING NO FIELDS.

      IF sy-subrc = 0.
        CONTINUE.
      ENDIF.

*   check if it is a transparent table
      SELECT tabname fieldname keyflag position
        FROM dd03vv
        APPENDING TABLE mt_table_fields
        WHERE tabname   = ls_table_alias-table    AND
              tabclass  = 'TRANSP'                AND
              as4local  = 'A'                     AND
              fieldname NOT LIKE '.%'             AND
              fieldname NOT LIKE '*%'             AND
              fieldname NOT LIKE '$_%' ESCAPE '$' AND
              fieldname NOT LIKE '$%%' ESCAPE '$'
        ORDER BY position.

*   not a transparent table
      IF sy-subrc EQ 4.

*     check if it is a view
*     viewfield instead of fieldname, field alias may be defined in a view!
        SELECT viewname AS tabname viewfield keyflag objpos AS position
          FROM dd27s
          APPENDING TABLE mt_table_fields
          WHERE viewname  = ls_table_alias-table AND
                as4local  = 'A' AND
*             possible to define * in views to include all fields from a table, and - to exclude a field
                viewfield <> '*'                    AND
                viewfield <> '-'                    AND
                fieldname NOT LIKE '.%'             AND
                fieldname NOT LIKE '*%'             AND
                fieldname NOT LIKE '$_%' ESCAPE '$' AND
                fieldname NOT LIKE '$%%' ESCAPE '$'
          ORDER BY position.

*     not a view
        IF sy-subrc EQ 4.

*       check if it is a Clustered table
          SELECT tabname fieldname keyflag position
            FROM dd03vv
            APPENDING TABLE mt_table_fields
            WHERE tabname   = ls_table_alias-table    AND
                  tabclass  = 'CLUSTER'               AND
                  as4local  = 'A'                     AND
                  fieldname NOT LIKE '.%'             AND
                  fieldname NOT LIKE '*%'             AND
                  fieldname NOT LIKE '$_%' ESCAPE '$' AND
                  fieldname NOT LIKE '$%%' ESCAPE '$'
            ORDER BY position.

*       not a Clustered table
          IF sy-subrc EQ 4.

*         check if it is a Pooled table
            SELECT tabname fieldname keyflag position
              FROM dd03vv
              APPENDING TABLE mt_table_fields
              WHERE tabname   = ls_table_alias-table    AND
                    tabclass  = 'POOL'                  AND
                    as4local  = 'A'                     AND
                    fieldname NOT LIKE '.%'             AND
                    fieldname NOT LIKE '*%'             AND
                    fieldname NOT LIKE '$_%' ESCAPE '$' AND
                    fieldname NOT LIKE '$%%' ESCAPE '$'
              ORDER BY position.

*         not a Pooled table
            IF sy-subrc EQ 4.
              IF mv_log_handle IS INITIAL.
*             Message: Table '&1' does not exist
                MESSAGE e014 WITH ls_table_alias-table
                  RAISING table_not_exist.
              ELSE.
                CALL METHOD add_message( iv_msgty = 'W' iv_msgid = 'ZSQL_FREE' iv_msgno = '014' iv_msgv1 = ls_table_alias-table ).
                RAISE table_not_exist.
              ENDIF.
*         it is a Pooled table
            ELSE.
              ls_table_alias-type = 'P'.
              CLEAR mv_can_edit.
            ENDIF.

*       it is a Clustered table
          ELSE.
            ls_table_alias-type = 'C'.
            CLEAR mv_can_edit.
          ENDIF.

*     it is a view
        ELSE.

          ls_table_alias-type = 'V'.

          SELECT SINGLE viewgrant FROM dd25l INTO lv_viewgrant
            WHERE viewname = ls_table_alias-table AND
                  as4local = 'A'.

          IF sy-subrc EQ 0.
            IF lv_viewgrant EQ 'R'.
              CLEAR mv_can_edit.
            ENDIF.
          ENDIF.

        ENDIF.

*   it is a transparent table
      ELSE.
        ls_table_alias-type = 'T'.
      ENDIF.

      MODIFY mt_table_alias FROM ls_table_alias INDEX lv_tabix.

    ENDLOOP.

* complete missing table types
    LOOP AT mt_table_alias ASSIGNING <ls_table_alias>
         WHERE TABLE is INITIAL.

*   read the first record with the same table name
      READ TABLE mt_table_alias
        WITH KEY table = <ls_table_alias>-table
        INTO ls_table_alias.

      <ls_table_alias>-type = ls_table_alias-type.
    ENDLOOP.

*  SORT mt_table_fields BY table field.
*  DELETE ADJACENT DUPLICATES FROM mt_table_fields COMPARING table field.

* parse other tables (subqueries in the WHERE clause)
    CALL METHOD parse_adt_tables
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc <> 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
          iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "

  METHOD prepare_from_text.
* remove each '(' and ')'

    DATA: lv_length       TYPE i,
          lv_shift        TYPE i,
          lv_pos          TYPE i,
          lv_char(1)      TYPE c.

    SEARCH cv_string FOR '%_HINT'.

    IF sy-subrc EQ 0.
      lv_pos = sy-fdpos - 1.
      cv_string = cv_string(lv_pos).
    ENDIF.

    lv_shift = -1.
    lv_length = STRLEN( cv_string ).

    DO.
      lv_shift = lv_shift + 1.

      IF lv_shift = lv_length.
        EXIT.
      ENDIF.

      lv_char = cv_string+lv_shift(1).

      IF lv_char = '(' OR
         lv_char = ')'.
        lv_pos = lv_shift + 1.
        CONCATENATE cv_string(lv_shift) cv_string+lv_pos
          INTO cv_string SEPARATED BY space.
      ENDIF.
    ENDDO.

  ENDMETHOD.                    "

  METHOD prepare_sel_text.
* put a SPACE after each '(' and before each ')' so the parser
* can parse the words

    DATA: lv_length       TYPE i,
          lv_shift        TYPE i,
          lv_pos          TYPE i,
          lv_char(1)      TYPE c.


    lv_shift = -1.
    lv_length = STRLEN( cv_string ).

    DO.
      lv_shift = lv_shift + 1.

      IF lv_shift = lv_length.
        EXIT.
      ENDIF.

      lv_char = cv_string+lv_shift(1).

      IF lv_char = '('.
        lv_pos   =  lv_shift + 1.
        CONCATENATE cv_string(lv_pos) cv_string+lv_pos INTO cv_string
          SEPARATED BY space.
        lv_length = lv_length + 1.
        lv_shift = lv_shift + 1.
      ENDIF.

      IF lv_char = ')'.
        CONCATENATE cv_string(lv_shift) cv_string+lv_shift INTO cv_string
          SEPARATED BY space.
        lv_length = lv_length + 1.
        lv_shift = lv_shift + 1.
      ENDIF.
    ENDDO.

  ENDMETHOD.                    "


  METHOD rebuild_field_list.
* builds the field list of the SELECT clause into a string table

    DATA: ls_fieldinfo   LIKE LINE OF mt_fieldinfo,
          lv_string      TYPE string,
          lv_string2     TYPE string,
          lv_tabix       TYPE i,
          ls_table_alias LIKE LINE OF mt_table_alias,
          lv_fieldname   TYPE fieldname.


    IF mt_fieldinfo IS INITIAL.
      MESSAGE e148 RAISING no_auth_for_columns.
    ENDIF.

* check that fields exist
    LOOP AT mt_fieldinfo INTO ls_fieldinfo WHERE orig_field NE '*'.

      READ TABLE mt_table_alias INTO ls_table_alias
        WITH KEY table = ls_fieldinfo-table.

      IF sy-subrc NE 0.
        IF mv_log_handle IS INITIAL.
*       Could not find field &1 in table &2 (type &3)
          MESSAGE s038 DISPLAY LIKE 'E' WITH ls_fieldinfo-field ls_fieldinfo-table '?' RAISING error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '038' iv_msgv1 = ls_fieldinfo-field iv_msgv2 = ls_fieldinfo-table ).
          RAISE error.
        ENDIF.
      ENDIF.

      CASE ls_table_alias-type.

        WHEN 'T'.

          SELECT SINGLE fieldname
          INTO lv_fieldname
          FROM dd03l
          WHERE tabname   = ls_fieldinfo-table AND
                fieldname = ls_fieldinfo-field AND
                as4local  = 'A' AND
                fieldname NOT LIKE '.%' AND
                fieldname NOT LIKE '*%' AND
                fieldname NOT LIKE '$_%' ESCAPE '$' AND
                fieldname NOT LIKE '$%%' ESCAPE '$'.

        WHEN 'V'.

          SELECT SINGLE viewfield
          INTO lv_fieldname
          FROM dd27s
            WHERE viewname  = ls_fieldinfo-table AND
                  viewfield = ls_fieldinfo-field AND
                  as4local  = 'A' AND
                  fieldname NOT LIKE '.%' AND
                  fieldname NOT LIKE '*%' AND
                  fieldname NOT LIKE '$_%' ESCAPE '$' AND
                  fieldname NOT LIKE '$%%' ESCAPE '$'.

*      WHEN 'P'.
*
*        SELECT SINGLE fieldname
*        INTO lv_fieldname
*        FROM dd03vv
*          WHERE tabname   = ls_fieldinfo-table AND
*                fieldname = ls_fieldinfo-field AND
**                in view already
**                AS4LOCAL = 'A' AND
*                fieldname NOT LIKE '.%' AND
*                fieldname NOT LIKE '*%' AND
*                fieldname NOT LIKE '$_%' ESCAPE '$' AND
*                fieldname NOT LIKE '$%%' ESCAPE '$'.

        WHEN 'C' OR 'P'.

*        SELECT SINGLE fieldname
*        INTO lv_fieldname
*        FROM dd16v
*          WHERE sqltab    = ls_fieldinfo-table AND
*                fieldname = ls_fieldinfo-field AND
**                in view already
**                AS4LOCAL = 'A' AND
*                fieldname NOT LIKE '.%' AND
*                fieldname NOT LIKE '*%' AND
*                fieldname NOT LIKE '$_%' ESCAPE '$' AND
*                fieldname NOT LIKE '$%%' ESCAPE '$'.

          SELECT SINGLE fieldname
          INTO lv_fieldname
          FROM dd03l
          WHERE tabname   = ls_fieldinfo-table AND
                fieldname = ls_fieldinfo-field AND
                as4local  = 'A' AND
                fieldname NOT LIKE '.%' AND
                fieldname NOT LIKE '*%' AND
                fieldname NOT LIKE '$_%' ESCAPE '$' AND
                fieldname NOT LIKE '$%%' ESCAPE '$'.


      ENDCASE.

      IF sy-subrc NE 0.
        IF mv_log_handle IS INITIAL.
*       Could not find field &1 in table &2 (type &3)
          MESSAGE s038 DISPLAY LIKE 'E' WITH ls_fieldinfo-field ls_fieldinfo-table ls_table_alias-type RAISING error.
        ELSE.
          CALL METHOD add_message( iv_msgty = 'E' iv_msgid = 'ZSQL_FREE' iv_msgno = '038' iv_msgv1 = ls_fieldinfo-field iv_msgv2 = ls_fieldinfo-table ).
          RAISE error.
        ENDIF.
      ENDIF.

    ENDLOOP.


    LOOP AT mt_fieldinfo INTO ls_fieldinfo.

      CLEAR: lv_string, lv_string2.

      IF ls_fieldinfo-agg_function IS INITIAL.    " aggragate function
        IF ls_fieldinfo-table_alias IS NOT INITIAL.
          CONCATENATE ls_fieldinfo-table_alias '~' ls_fieldinfo-field INTO lv_string2.
        ELSE.
          MOVE ls_fieldinfo-orig_field TO lv_string2.
        ENDIF.

        CONCATENATE lv_string lv_string2 INTO lv_string SEPARATED BY ' '.
      ELSE.
        CONCATENATE ls_fieldinfo-agg_function '(' INTO lv_string.

        IF ls_fieldinfo-distinctf = 'X'.
          CONCATENATE lv_string 'DISTINCT' INTO lv_string
            SEPARATED BY ' '.
        ENDIF.

        IF ls_fieldinfo-field = '*'.
          CONCATENATE lv_string '*' ')' INTO lv_string SEPARATED BY ' '.
        ELSE.
          IF ls_fieldinfo-table_alias IS NOT INITIAL.
            CONCATENATE ls_fieldinfo-table_alias '~' ls_fieldinfo-field INTO lv_string2.
          ELSE.
            MOVE ls_fieldinfo-orig_field TO lv_string2.
          ENDIF.
          CONCATENATE lv_string lv_string2 INTO lv_string SEPARATED BY ' '.
          CONCATENATE lv_string  ')' INTO lv_string SEPARATED BY ' '.
        ENDIF.
      ENDIF.

      CONCATENATE lv_string 'AS' ls_fieldinfo-generated_field INTO lv_string SEPARATED BY ' '.
      SHIFT lv_string RIGHT BY 3 PLACES.
      APPEND lv_string TO ct_srccode.

    ENDLOOP.

  ENDMETHOD.                    "


  METHOD remove_duplicates.
* tackles with duplicates in the field list

    DATA: ls_fieldinfo      LIKE LINE OF mt_fieldinfo,
          ls_fieldinfo_copy LIKE LINE OF mt_fieldinfo,
          lv_same_cnt       TYPE i,
          lv_tabix          TYPE i,
          lv_string         TYPE string,
          lt_fieldinfo_copy LIKE mt_fieldinfo.


    LOOP AT mt_fieldinfo INTO ls_fieldinfo.
      IF ls_fieldinfo-field_alias IS NOT INITIAL.
        ls_fieldinfo-generated_field = ls_fieldinfo-field_alias.
      ELSEIF ls_fieldinfo-agg_function IS NOT INITIAL.
        CONCATENATE ls_fieldinfo-agg_function ls_fieldinfo-field
          INTO ls_fieldinfo-generated_field SEPARATED BY '_'.
      ELSE.
        ls_fieldinfo-generated_field = ls_fieldinfo-field.
      ENDIF.

*   CONNECTION is a reserved word, will cause a syntax error
      IF ls_fieldinfo-generated_field = 'CONNECTION'.
        ls_fieldinfo-generated_field = 'CONNECTION_'.
      ENDIF.

      TRANSLATE ls_fieldinfo-generated_field TO UPPER CASE.
      MODIFY mt_fieldinfo FROM ls_fieldinfo INDEX sy-tabix.
    ENDLOOP.

    lt_fieldinfo_copy[] = mt_fieldinfo[].

    LOOP AT mt_fieldinfo INTO ls_fieldinfo.

      CLEAR lv_same_cnt.
      lv_tabix = sy-tabix.

      LOOP AT lt_fieldinfo_copy INTO ls_fieldinfo_copy
           FROM lv_tabix
           WHERE generated_field = ls_fieldinfo-generated_field.

        IF lv_tabix <> sy-tabix.

          IF ls_fieldinfo_copy-table = ls_fieldinfo-table.
            lv_same_cnt                 = lv_same_cnt + 1.
            ls_fieldinfo_copy-samecount = lv_same_cnt.

            CONCATENATE ls_fieldinfo_copy-table ls_fieldinfo_copy-generated_field
              INTO ls_fieldinfo_copy-generated_field SEPARATED BY '_'.

            lv_string = lv_same_cnt.

            CONCATENATE ls_fieldinfo_copy-generated_field lv_string
              INTO ls_fieldinfo_copy-generated_field SEPARATED BY '_'.

            MODIFY lt_fieldinfo_copy FROM ls_fieldinfo_copy INDEX sy-tabix.
          ENDIF.

          IF ls_fieldinfo_copy-table <> ls_fieldinfo-table.
            IF ls_fieldinfo_copy-field_alias IS NOT INITIAL.
              ls_fieldinfo_copy-generated_field = ls_fieldinfo_copy-field_alias.
            ELSE.
              CONCATENATE ls_fieldinfo_copy-table ls_fieldinfo_copy-generated_field
                INTO lv_string SEPARATED BY '_'.
              ls_fieldinfo_copy-generated_field = lv_string.
            ENDIF.

            MODIFY lt_fieldinfo_copy FROM ls_fieldinfo_copy INDEX sy-tabix.
          ENDIF.

        ENDIF.

      ENDLOOP.

    ENDLOOP.

    mt_fieldinfo[] = lt_fieldinfo_copy[].

  ENDMETHOD.                    "


  METHOD check_inserted_orgcritdep.

    FIELD-SYMBOLS: <lt_inserted> TYPE ANY TABLE,
                   <ls_inserted> TYPE ANY.

    ASSIGN it_inserted->* TO <lt_inserted>.

    IF sy-subrc NE 0.
      RAISE assign_error.
    ENDIF.



*             AUTHORITY-CHECK OBJECT 'S_TABU_LIN'
*             ID 'ORG_CRIT' FIELD ls_orgcrit_tabdep-org_crit
*             ID 'ACTVT' FIELD '02'
*             ID 'ORG_FIELD1' FIELD '__________'
*             ID 'ORG_FIELD2' FIELD '__________'
*             ID 'ORG_FIELD3' FIELD '__________'
*             ID 'ORG_FIELD4' FIELD '__________'
*             ID 'ORG_FIELD5' FIELD '__________'
*             ID 'ORG_FIELD6' FIELD '__________'
*             ID 'ORG_FIELD7' FIELD '__________'
*             ID 'ORG_FIELD8' FIELD '__________'.
*
*
*          IF sy-subrc = 1.
*            RAISE no_auth_for_inserted_records.
*          ENDIF.


  ENDMETHOD.                    "CHECK_INSERTED_ORGCRITDEP


ENDCLASS.                    "lcl_HTDB_CL_COMMAND_SELECT IMPLEMENTATION

*---------------------------------------------------------------------*
*       CLASS LCL_COMMAND DEFINITION
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
CLASS lcl_command DEFINITION ABSTRACT.

  PUBLIC SECTION.

    DATA: mo_pipacs_command      TYPE REF TO lcl_htdb_cl_command,
          mt_srccode             TYPE lty_zhtdbt_string_tab,

          mr_lock_argument       TYPE REF TO data,
          mr_lock_argument_temp  TYPE REF TO data,

          mv_last_display        TYPE lty_last_display_mode,
          mv_grid_modified_toggled TYPE c,
          mv_ref_check           TYPE c,
          mv_grid_modified       TYPE c,

          mv_current_page TYPE i,
          mv_from         TYPE i,
          mv_to           TYPE i,

          mv_colmn_header TYPE c,
          mv_key_colmn_type TYPE c,
          mv_command_type(2) TYPE n.

    METHODS: execute_parsed_sql
               IMPORTING
                 po_grid           TYPE REF TO cl_gui_alv_grid OPTIONAL
                 po_tree           TYPE REF TO cl_gui_alv_tree OPTIONAL
                 iv_simulation     TYPE char1 OPTIONAL
                 iv_bg_proc        TYPE char1 OPTIONAL
                 iv_bg_date        TYPE btcsdate OPTIONAL
                 iv_bg_time        TYPE btcstime OPTIONAL
                 iv_read_from_file TYPE flag OPTIONAL
               EXPORTING
                 er_exception      TYPE REF TO cx_root
                 et_srccode        TYPE lty_zhtdbt_string_tab
               EXCEPTIONS
                 table_not_found
                 parse_error
                 exec_error
                 error_occurred
                 unlock_error
                 arg_to_long
                 foreign_lock
                 foreign_lock_all_clients
                 job_submit_error
                 field_list_changed
                 file_open_error
                 no_auth_for_table,

* sima GET/SET cuccok
             set_commandtext IMPORTING p_commandtext TYPE gty_commandtext,
             get_type EXPORTING value(ep_command_type) TYPE lty_commandtype,

             parse_commandtext
               IMPORTING
                 p_on_load TYPE c OPTIONAL
                 p_bf_test TYPE c OPTIONAL
               EXCEPTIONS
                 error_occurred,

             constructor
               IMPORTING
                 p_copy_from TYPE REF TO lcl_command OPTIONAL.


* VRANGES
**** value range cuccok begin
    DATA:
          it_ranges TYPE lty_zhdb_vrange_tab,
          is_x030l  TYPE x030l.

    DATA: mt_alias_ranges TYPE TABLE OF gty_alias_ranges,
          mt_ranges TYPE TABLE OF gty_ranges.

**** value range cuccok end

* a jobb oldali fa itabja (tablanevek, value rangek) es node_key referencia table
    DATA: mt_outtab_tb TYPE TABLE OF lty_zhtdb_alv_tab,
          mt_tab_node_xref TYPE TABLE OF gty_tab_node_xref.


* command type: select/update/delete/LAWB/script/select fae
    DATA: command_type TYPE lty_commandtype,
          command_id TYPE lty_commandid,
* hany sort erintett a command
          mv_dbcnt TYPE i,
          mv_rowlen TYPE i,
          mv_bytes TYPE i,

* treeben node_key
          node_key TYPE lvc_nkey,
* tree hierarchianban melyik szinten van
          treelevel TYPE i,

* where text kulon
          where_text TYPE gty_commandtext,

* command text mint string
          commandtext TYPE gty_commandtext,
* generalt command text mint string
          gen_commandtext TYPE gty_commandtext,

* generalt text, obsolete lesz
          gen_text TYPE source_table,
* original text, obsolete lesz (?)
          text TYPE source_table,
          table_alias_tb TYPE lty_zhtdb_table_aliases_tt,

*    DATA:  mv_tot_upd TYPE i,
*           mv_tot_ins TYPE i,
*           mv_tot_del TYPE i,
*           mv_upd TYPE i,
*           mv_ins TYPE i,
*           mv_del TYPE i,
* hany byte volt a teljes athozott result set
           mv_filtered TYPE i,
           mv_pos TYPE i.

    DATA:  alv_state TYPE i.

    DATA:  mv_locked  TYPE c,
           mv_cansave TYPE c VALUE 'X',
*           mv_locked_count TYPE i,

           mv_ctext_changed TYPE c.

  PRIVATE SECTION.



ENDCLASS.                    "LCL_COMMAND DEFINITION

CLASS lcl_select_command DEFINITION DEFERRED.

*----------------------------------------------------------------------*
*       CLASS lcl_application DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_application DEFINITION.

  PUBLIC SECTION.

    DATA: mv_cccategory TYPE cccategory.

** brute force testing stuff

    TYPES: BEGIN OF mty_t_type,
       line(255),
*        LINE TYPE string,
     END OF mty_t_type.

    TYPES: mty_tt_type TYPE STANDARD TABLE OF mty_t_type WITH
                 NON-UNIQUE DEFAULT KEY INITIAL SIZE 500.


    DATA:
      mv_log_handle TYPE balloghndl,
      ms_s_log      TYPE bal_s_log,
      ms_s_msg      TYPE bal_s_msg,


      mt_replace_message          TYPE bal_t_rplv,
      mt_replace_context          TYPE bal_t_rplc,

      ms_object                   TYPE bal_s_obj,
      ms_extnumber                TYPE bal_s_extn,
      ms_log_filter               TYPE bal_s_lfil,
      mt_log_header               TYPE balhdr_t.

** brute force test end


    DATA: dragdrop_tree TYPE REF TO cl_dragdrop,
          g_dropeffect TYPE i,
          g_handle_tree TYPE i,
          mv_la_fs_was_result TYPE c VALUE 'X'.


    DATA: mt_permitted_commandtypes TYPE TABLE OF rsrange,

          mv_tree_tb_width TYPE i,
          mv_result_height TYPE i,

          mv_result_already_unlocked TYPE c.


    METHODS:

            remove_gen_programs,
            insert_stringtab_to_pos
              IMPORTING
                it_stringtab TYPE lty_zhtdbt_string_tab,

            check_s_tabu_dis
              IMPORTING
                iv_for_editing TYPE char1
                iv_tabname     TYPE tabname
              EXPORTING
                ev_auth        TYPE char1,

             issue_message
               IMPORTING
                 iv_msgty        TYPE symsgty
                 iv_msgno        TYPE symsgno
                 iv_to_log       TYPE char1 DEFAULT ' '
                 iv_msgid        TYPE symsgid DEFAULT sy-msgid
                 iv_display_like TYPE char1 OPTIONAL
                 iv_msgv1        TYPE any OPTIONAL
                 iv_msgv2        TYPE any OPTIONAL
                 iv_msgv3        TYPE any OPTIONAL
                 iv_msgv4        TYPE any OPTIONAL,

            constructor,

            get_selected_word
              EXPORTING
                ep_word TYPE string,

            show_abap_docu,
            show_syntax_diagram,

             read_checktables
               IMPORTING
                 sender TYPE c
                 i_ucomm TYPE sy-ucomm,

             create_txt_toolbar,

            handle_lq_ctx_sel
              IMPORTING
                sender TYPE c
                e_ucomm TYPE sy-ucomm,

            handle_context_menu
                 FOR EVENT context_menu OF cl_gui_abapedit "cl_gui_textedit
                   IMPORTING menu sender,

             handle_f1_textedit
                 FOR EVENT f1 OF cl_gui_abapedit, "cl_gui_textedit,


             handle_context_menu_selected
                 FOR EVENT context_menu_selected OF cl_gui_abapedit "cl_gui_textedit
                     IMPORTING fcode,

             handle_node_ctx_menu_sel_lq
                 FOR EVENT node_context_menu_selected OF cl_gui_alv_tree
                     IMPORTING fcode,

             handle_context_menu_tree_tb_n
                 FOR EVENT node_context_menu_request OF cl_gui_alv_tree
                     IMPORTING menu,

             handle_lq_context_menu
                     IMPORTING
                       sender TYPE c
                       e_object TYPE REF TO cl_ctmenu,


* tables tree
             handle_node_double_click
               FOR EVENT node_double_click OF cl_gui_alv_tree
                 IMPORTING node_key,

*new*
             handle_dropdown_clicked
               FOR EVENT dropdown_clicked OF cl_gui_toolbar
                 IMPORTING fcode posx posy.

    METHODS: refresh_status_indicators,
             display_table_grid,
             create_tb_tree_toolbar.

    METHODS:

      handle_function_selected
          FOR EVENT function_selected OF cl_gui_toolbar
              IMPORTING fcode,

      handle_function_selected_txt
          FOR EVENT function_selected OF cl_gui_toolbar
              IMPORTING fcode.
    METHODS:

         handle_context_menu_alv
             FOR EVENT context_menu_request OF cl_gui_alv_grid
                 IMPORTING e_object sender,

         handle_menu_button
            FOR EVENT menu_button OF cl_gui_alv_grid
                IMPORTING e_object e_ucomm,

         handle_toolbar
            FOR EVENT toolbar OF cl_gui_alv_grid
                IMPORTING e_object e_interactive sender,

         handle_user_command
            FOR EVENT user_command OF cl_gui_alv_grid
                IMPORTING e_ucomm sender,

         handle_double_click
            FOR EVENT double_click OF cl_gui_alv_grid
                IMPORTING e_column e_row sender,

         handle_after_refresh
            FOR EVENT data_changed OF cl_gui_alv_grid.

    METHODS:
             set_column_settings IMPORTING p_mode TYPE sy-ucomm,
             set_key_field_settings IMPORTING p_mode TYPE sy-ucomm,
             set_column_headings,
             set_key_display_attributes,
             refresh_display.


ENDCLASS.                    "lcl_application DEFINITION

*---------------------------------------------------------------------*
*       CLASS LCL_COMMANDS DEFINITION
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
CLASS lcl_commands DEFINITION.

  PUBLIC SECTION.

    CONSTANTS: gc_initial_mark TYPE string VALUE ' ',
               gc_initial_mark_xref TYPE string VALUE 'ZENITH_INITIAL_VALUE',
               gc_initial_mark_display TYPE string VALUE 'N/A'.

    TYPES: BEGIN OF gty_commands,
             seq_no TYPE i,
             command_id TYPE lty_commandid,
             treelevel TYPE i,
             command TYPE REF TO lcl_command,
           END OF gty_commands.


    TYPES: BEGIN OF mty_ctypes_exclude,
            fcode TYPE rsmpe-func,
          END OF mty_ctypes_exclude.

    DATA: mt_ctypes_exclude TYPE TABLE OF mty_ctypes_exclude,
          mv_create_auth_checked TYPE c.

    METHODS:
             transfer_text_to_command,

             generate_structure
               EXCEPTIONS
                 empty_fieldinfo_tb
                 command_is_not_select
                 field_not_found,

             display
               IMPORTING
                 po_grid TYPE REF TO cl_gui_alv_grid OPTIONAL
                 po_tree TYPE REF TO cl_gui_alv_tree OPTIONAL,

             create_new_command
               IMPORTING
                 p_command_type TYPE lty_commandtype
                 reference(p_copy_from) TYPE REF TO lcl_command OPTIONAL,
*                 p_during_initial_load TYPE c OPTIONAL,

             execute_command
               IMPORTING
                 iv_mode           TYPE sy-ucomm
                 iv_bg_proc        TYPE char1 OPTIONAL
                 iv_bg_date        TYPE btcsdate OPTIONAL
                 iv_bg_time        TYPE btcstime OPTIONAL
                 iv_read_from_file TYPE flag OPTIONAL,

             parse_only_command
               IMPORTING
                 p_on_load TYPE c OPTIONAL
               EXCEPTIONS
                 no_id
                 create_error
                 no_parent
                 parse_error,

             display_command,
             write_status_message.

    DATA:  command_count TYPE i VALUE 0.

    DATA:  command_list TYPE TABLE OF gty_commands,
           current_command TYPE REF TO lcl_command,
           prev_command TYPE REF TO lcl_command.


ENDCLASS.                    "LCL_COMMANDS DEFINITION





*---------------------------------------------------------------------*
*       CLASS LCL_SELECT_COMMAND DEFINITION
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
CLASS lcl_select_command DEFINITION INHERITING FROM lcl_command.

  PUBLIC SECTION.

* backup tablebol select
    DATA:    mo_parent_command TYPE REF TO lcl_select_command.

    DATA: mo_pipacs_select TYPE REF TO lcl_htdb_cl_command_select.

    METHODS: execute_parsed_sql REDEFINITION,

             parse_commandtext REDEFINITION.

    METHODS:

             calculate_mv_rowlen,

             constructor
               IMPORTING
                 p_copy_from TYPE REF TO lcl_select_command OPTIONAL.

    METHODS:
             assign_field_symbols.

    METHODS: assign_field_symbol
                IMPORTING p_fs TYPE c
                CHANGING value(p_table) TYPE REF TO data.


    DATA:  layo TYPE TABLE OF lvc_s_layo,
           fcat TYPE lvc_t_fcat,
           prev_fcat TYPE lvc_t_fcat,
           fieldinfo_tb TYPE TABLE OF gty_fieldinfo,
           ddic_references TYPE TABLE OF gty_ddicref,
           can_edit TYPE c,
           mv_key_fields_missing TYPE string,
           mv_tree_heading TYPE tv_heading,

*           lock_results TYPE c,
           has_table_alias TYPE c,
           has_duplicate_fields TYPE c,
           selected_node TYPE lvc_nkey,
           selected_rows TYPE lvc_t_row,
           selected_rows2 TYPE lvc_t_roid.


    DATA: select_text TYPE gty_commandtext,
          all_fields_selected TYPE c,
          from_text TYPE gty_commandtext,
          group_by_text TYPE gty_commandtext,
          having_text TYPE gty_commandtext,
          order_by_text TYPE gty_commandtext.
*          sort_text TYPE gty_commandtext.

    DATA: result_table TYPE REF TO data,
          display_table TYPE REF TO data,
          deleted_table TYPE REF TO data,
          updated_table TYPE REF TO data,
          inserted_table TYPE REF TO data,
          tree_table TYPE REF TO data,
          returned_table TYPE REF TO data,
          temp_table TYPE REF TO data,
          undo_table TYPE REF TO data,
          lawb_table TYPE REF TO data,
          selfae_table TYPE REF TO data,
          result_structure  TYPE REF TO data,
          updated_structure  TYPE REF TO data,
          deleted_structure  TYPE REF TO data,
          inserted_structure  TYPE REF TO data,
          temp_structure  TYPE REF TO data,
          undo_structure  TYPE REF TO data,
          lawb_structure  TYPE REF TO data,
          selfae_structure  TYPE REF TO data.

    DATA: show_all TYPE c.


    DATA: mv_fdpos_select TYPE i,
          mv_fdpos_from TYPE i,
          mv_fdpos_where TYPE i,
          mv_fdpos_gb TYPE i,
          mv_fdpos_having TYPE i,
          mv_fdpos_ob TYPE i,
          mv_fdpos_sb TYPE i.

    DATA: mv_read_from_file TYPE c.

*  PRIVATE SECTION.


ENDCLASS.                    "LCL_SELECT_COMMAND DEFINITION


DATA: g_application          TYPE REF TO lcl_application,
      g_commands             TYPE REF TO lcl_commands.

DATA: gv_max_rowid           TYPE i,
      status1(132)           TYPE c,
      status2(132)           TYPE c.

DATA: gt_dynpread            TYPE TABLE OF dynpread,
      gs_dynpread            TYPE dynpread.

DATA: w_okcode                    TYPE sy-ucomm.

DATA: gv_starttime                TYPE i,
      gv_endtime                  TYPE i,
      gv_deltatime                TYPE i.

DATA: g_cx_dynamic_check          TYPE REF TO cx_dynamic_check,
      g_root_exception            TYPE REF TO cx_root.

DATA: gv_node_count               TYPE i.

DATA: gv_copy_commandid           TYPE i,
      gv_copy_folderid            TYPE i.

DATA: gr_command_clipboard        TYPE REF TO lcl_command,
      gv_folder_clipboard         TYPE lvc_nkey,
      gr_clipboard_mode           TYPE c.

DATA: go_splitter_outer           TYPE REF TO cl_gui_splitter_container,
      go_splitter_inner           TYPE REF TO cl_gui_splitter_container,
      go_container_alv_tb         TYPE REF TO cl_gui_container,
      go_container_reklam         TYPE REF TO cl_gui_container,
      go_container_alv            TYPE REF TO cl_gui_container,
      go_container_navtree        TYPE REF TO cl_gui_container,
      go_container_textedit       TYPE REF TO cl_gui_container,
      go_container_for_inner_sp   TYPE REF TO cl_gui_container,
      go_container_main           TYPE REF TO cl_gui_custom_container,
      go_container_field_select   TYPE REF TO cl_gui_custom_container,
      go_container_selscr_field   TYPE REF TO cl_gui_custom_container.

DATA: g_comm_longtext             TYPE REF TO cl_gui_textedit,
      g_container_textedit        TYPE REF TO cl_gui_custom_container,
      gt_text_orig                TYPE TABLE OF ty_notes,
      gt_lines_comm_longtext      TYPE TABLE OF tline,
      g_comm_longtext_read        TYPE c,
      g_html_viewer               TYPE REF TO cl_gui_html_viewer.


DATA: g_visible TYPE c.

DATA: gt_selfae_jointext          TYPE source_table.
DATA: gt_result_select_text       TYPE source_table.


DATA: gc_nodekey_my_repository    TYPE lvc_nkey,
      gc_nodekey_current_commands TYPE lvc_nkey,
      gc_nodekey_appl_hier        TYPE lvc_nkey.

DATA: gv_toolbar_extended         TYPE c,
      gv_nodekey                  TYPE lvc_nkey.

DATA: gv_data_changed_finished    TYPE c,
      gv_undo_pressed             TYPE c.

DATA: g_selected_nodekey          TYPE lvc_nkey,
      gv_check_button             TYPE c.

DATA: gv_step_counter             TYPE i,
      gc_test_step_cnt            TYPE i VALUE 50,
      gt_testscript               TYPE TABLE OF sy-ucomm,
      gv_autotest                 TYPE c,
      gt_testselects              TYPE TABLE OF mty_tt_type,
      gv_testselect_cnt           TYPE i.

DATA: gt_outtab_tb                TYPE TABLE OF lty_zhtdb_alv_tab.

DATA: gv_app_hier_counter         TYPE i, " used to generate unique node keys for the tree
      gv_app_hier_parent_cnt      TYPE i. " used to generate unique node keys for the tree

CONSTANTS: gc_max_nodetext_length TYPE i VALUE 128.

DATA: g_folder_b                  TYPE REF TO cl_dragdrop,
      g_command_b                 TYPE REF TO cl_dragdrop.

DATA: gv_lawb_test_finished       TYPE c,
      gv_lawb_test_success        TYPE c.

DATA: gv_version                  TYPE c VALUE 'B'.

DATA: gv_parent_result_tx         TYPE string.

DATA: gv_sel_changed_load         TYPE c.

* changing the node style in the navtree
* tolnatej requirement
* must be global (in automation call)
DATA: gv_top_node_key             TYPE lvc_nkey,
      gt_nodes                    TYPE lvc_t_nkey.



*----------------------------------------------------------------------*
***INCLUDE ZHTDB_STATUS_0100O01 .
*----------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Module  STATUS_0100  OUTPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_0100 OUTPUT.

  PERFORM status_0100.

ENDMODULE.                 " STATUS_0100  OUTPUT

*&---------------------------------------------------------------------*
*&      Form  STATUS_0100
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM status_0100.

  DATA: l_hierarchy_header_new TYPE treev_hhdr,
        lt_events_new          TYPE cntl_simple_events,
        ls_events_new          TYPE cntl_simple_event,

        node                   TYPE lvc_s_layn,
        l_new_node_key         TYPE lvc_nkey,

        l_hierarchy_header     TYPE treev_hhdr,
        lt_events              TYPE cntl_simple_events,
        ls_events              TYPE cntl_simple_event,

        events                 TYPE cntl_simple_events,
        event                  TYPE cntl_simple_event.


  IF gv_0100_first_run = 'X'.  " first call of the screen

    SET PF-STATUS '100_MAIN'.
    SET TITLEBAR  '100_TITLE' WITH 'Hovitaga OpenSQL Editor Free Edition - Upgrade at www.hovitaga.com'.

    gv_def_col_hdr = 'T'.
    gv_def_keycol_type = 'F'.

  ENDIF.

  IF g_application IS INITIAL.

    CREATE OBJECT g_application.

    CALL METHOD g_application->remove_gen_programs.

  ENDIF.


  IF go_splitter_outer IS INITIAL.

    g_application->mv_tree_tb_width = 25.
    g_application->mv_result_height = 50.



    CREATE OBJECT go_splitter_outer
      EXPORTING
        parent  = cl_gui_container=>default_screen " cl_gui_custom_container=>screen0 "go_container_main
        rows    = 2
        columns = 1.

    CALL METHOD go_splitter_outer->get_container
      EXPORTING
        row       = 1
        column    = 1
      RECEIVING
        container = go_container_for_inner_sp
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_outer->get_container
      EXPORTING
        row       = 2
        column    = 1
      RECEIVING
        container = go_container_alv
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CREATE OBJECT go_splitter_inner
      EXPORTING
        parent  = go_container_for_inner_sp
        rows    = 1
        columns = 3.

    CALL METHOD go_splitter_inner->get_container
      EXPORTING
        row       = 1
        column    = 1
      RECEIVING
        container = go_container_textedit
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_inner->get_container
      EXPORTING
        row       = 1
        column    = 2
      RECEIVING
        container = go_container_alv_tb
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


    CALL METHOD go_splitter_inner->get_container
      EXPORTING
        row       = 1
        column    = 3
      RECEIVING
        container = go_container_reklam
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_inner->set_column_width
      EXPORTING
        id    = 3
        width = 30.

    go_splitter_inner->set_row_mode( mode = go_splitter_inner->mode_absolute ).

    CALL METHOD go_splitter_inner->set_column_sash
         EXPORTING
           id                = 2
           type              = cl_gui_splitter_container=>type_movable
           value             = cl_gui_splitter_container=>false
*         IMPORTING
*           RESULT            =
          EXCEPTIONS
            cntl_error        = 1
            cntl_system_error = 2
            OTHERS            = 3.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_refresh.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_view_excel.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

*   gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_sum.
*   APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_check.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_undo.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_append_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_insert_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_delete_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_cut.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_paste_new_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_paste.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_loc_copy_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

*   gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_subtot.
*   APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_info.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=>mc_fc_help.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_layo-edit       = 'X'.
    gs_layo-zebra      = 'X'.
    gs_layo-stylefname = 'ZENITH_STYLE'.
    gs_layo-cwidth_opt = 'X'.
    gs_layo-ctab_fname = 'ZENITH_COLOR'.
    gs_layo-sel_mode   = 'D'.
    gs_layo-no_rowmove = 'X'.
    gs_layo-no_rowins  = 'X'.
    gs_layo-no_keyfix  = 'X'.
    gs_layo-smalltitle = 'X'.

    CREATE OBJECT g_alv
      EXPORTING
        i_parent = go_container_alv.

    CALL METHOD g_alv->set_ready_for_input
      EXPORTING
        i_ready_for_input = 0
      EXCEPTIONS
        OTHERS            = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    SET HANDLER g_application->handle_toolbar               FOR ALL INSTANCES.
    SET HANDLER g_application->handle_user_command          FOR ALL INSTANCES.
    SET HANDLER g_application->handle_menu_button           FOR g_alv.
*    SET HANDLER g_application->handle_data_changed          FOR g_alv.
*    SET HANDLER g_application->handle_data_changed_finished FOR g_alv.
    SET HANDLER g_application->handle_double_click          FOR g_alv.
    SET HANDLER g_application->handle_context_menu_alv      FOR g_alv.

    gs_layo_tb-edit       = ' '.
    gs_layo_tb-cwidth_opt = 'X'.
    gs_layo_tb-sel_mode   = 'B'.

    CREATE OBJECT g_tree_tb
      EXPORTING
        parent                      = go_container_alv_tb
        node_selection_mode         = cl_gui_column_tree=>node_sel_mode_single
        item_selection              = ' '
        no_html_header              = 'X'
        no_toolbar                  = ''
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        illegal_node_selection_mode = 5
        failed                      = 6
        illegal_column_name         = 7.

    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_tree_tb->set_screen_update
      EXPORTING
        i_update = ' '.


    DATA: ls_fcat_tb TYPE lvc_s_fcat.

    ls_fcat_tb-fieldname = 'DDTEXT'.
    ls_fcat_tb-inttype = 'C'.
    ls_fcat_tb-intlen  = '255'.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    ls_fcat_tb-fieldname = 'TABLENAME'.
    ls_fcat_tb-rollname  = 'TABNAME'.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    ls_fcat_tb-fieldname = 'FIELDNAME'.
    ls_fcat_tb-rollname  = 'FIELDNAME'.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    ls_fcat_tb-fieldname = 'ALIAS'.
    ls_fcat_tb-rollname  = 'TABNAME'.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    LOOP AT gt_fcat_tb INTO gs_fcat_tb.
      IF gs_fcat_tb-fieldname = 'TABLENAME' OR
         gs_fcat_tb-fieldname = 'FIELDNAME' OR
         gs_fcat_tb-fieldname = 'ALIAS'.
        gs_fcat_tb-tech   = 'X'.
        gs_fcat_tb-no_out = 'X'.
      ENDIF.

      IF gs_fcat_tb-fieldname = 'DDTEXT'.
        gs_fcat_tb-coltext   = text-145.
        gs_fcat_tb-tooltip   = text-145.
        gs_fcat_tb-reptext   = text-145.
        gs_fcat_tb-outputlen = 255.
        CLEAR: gs_fcat_tb-tech, gs_fcat_tb-no_out.
      ENDIF.

      MODIFY gt_fcat_tb FROM gs_fcat_tb.
    ENDLOOP.

    l_hierarchy_header-heading   = text-137.
    l_hierarchy_header-width     = 40.
    l_hierarchy_header-width_pix = ''.

    CALL METHOD g_tree_tb->set_table_for_first_display
      EXPORTING
        is_hierarchy_header = l_hierarchy_header
      CHANGING
        it_fieldcatalog     = gt_fcat_tb
        it_outtab           = gt_outtab_tb
      EXCEPTIONS
        OTHERS              = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_tree_tb->get_registered_events
      IMPORTING
        events     = lt_events
      EXCEPTIONS
        cntl_error = 1
        OTHERS     = 2.

    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    ls_events-appl_event = ' '.
    ls_events-eventid = cl_gui_column_tree=>eventid_node_context_menu_req.
    APPEND ls_events TO lt_events.
*
*   ls_events-eventid = cl_gui_column_tree=>eventid_item_context_menu_req.
*   APPEND ls_events TO lt_events.

    ls_events-eventid = cl_gui_column_tree=>eventid_node_double_click.
    APPEND ls_events TO lt_events.

    CALL METHOD g_tree_tb->set_registered_events
      EXPORTING
        events                    = lt_events
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3
        OTHERS                    = 4.

    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

*   SET HANDLER g_application->handle_function_selected      FOR g_toolbar_tb_tree.
    SET HANDLER g_application->handle_node_double_click      FOR g_tree_tb.
    SET HANDLER g_application->handle_node_ctx_menu_sel_lq   FOR g_tree_tb.
    SET HANDLER g_application->handle_context_menu_tree_tb_n FOR g_tree_tb.

    CREATE OBJECT g_html_viewer
      EXPORTING
        parent = go_container_reklam.

    DATA: lv_url(255) TYPE c.

    CONCATENATE 'http://www.hovitaga.com/'
    'oe_free_edition_reklam_tidy_20111028.php?h='
    gc_hash
    INTO lv_url.

    CONDENSE lv_url NO-GAPS.

    g_html_viewer->show_url( url = lv_url ).

  ENDIF.

  IF g_textedit IS INITIAL.

    CREATE OBJECT g_textedit
      EXPORTING
        parent = go_container_textedit.

    SET HANDLER g_application->handle_context_menu FOR g_textedit.
    SET HANDLER g_application->handle_context_menu_selected FOR g_textedit.
    SET HANDLER g_application->handle_f1_textedit FOR g_textedit.

    event-eventid = cl_gui_textedit=>event_f1.
    APPEND event TO events.

    event-eventid = cl_gui_textedit=>event_context_menu_selected.
    APPEND event TO events.

    event-eventid = cl_gui_textedit=>event_context_menu.
    APPEND event TO events.

*REGISTER_EVENT_F1 ?

    CALL METHOD g_textedit->set_registered_events
      EXPORTING
        events                    = events
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3.

    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDIF.

* ZMI?
**  IF gt_dynpread IS NOT INITIAL.
**
**    CALL FUNCTION 'DYNP_UPDATE_FIELDS'
**      EXPORTING
**        dyname               = sy-repid
**        dynumb               = '0100'
**        request              = 'A'
**      TABLES
**        dynpfields           = gt_dynpread
**      EXCEPTIONS
**        invalid_abapworkarea = 1
**        invalid_dynprofield  = 2
**        invalid_dynproname   = 3
**        invalid_dynpronummer = 4
**        invalid_request      = 5
**        no_fielddescription  = 6
**        undefind_error       = 7
**        OTHERS               = 8.
**
**    IF sy-subrc <> 0.
**      IF sy-msgno IS NOT INITIAL.
**        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
**                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
**      ENDIF.
**    ENDIF.
**
**    CLEAR gt_dynpread.
**
**  ENDIF.

  IF gv_data_changed_finished EQ 'X'.

    CLEAR gv_data_changed_finished.

    CALL METHOD g_alv->set_focus
      EXPORTING
        control = g_alv
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ELSE.

    CALL METHOD g_textedit->set_focus
      EXPORTING
        control = g_textedit
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDIF.

  IF g_commands IS INITIAL.

    CREATE OBJECT g_commands.

    CALL METHOD g_application->create_tb_tree_toolbar.

    CALL METHOD g_commands->create_new_command
      EXPORTING
        p_command_type = 1.


  ENDIF.


ENDFORM.                    " STATUS_0100


*----------------------------------------------------------------------*
***INCLUDE ZHTDB_USER_COMMAND_0100I01 .
*----------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0100  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*

MODULE user_command_0100 INPUT.

  PERFORM user_command_0100.

  CLEAR gv_0100_first_run.

ENDMODULE.                 " USER_COMMAND_0100  INPUT
*&---------------------------------------------------------------------*
*&      Form  USER_COMMAND_0100
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM user_command_0100.

  DATA: l_type TYPE i.

  DATA: l_s_c_100 TYPE REF TO lcl_select_command,
        lv_ucomm  LIKE LINE OF gt_testscript.

  CASE ok_code.


    WHEN 'SYNTAXD'.

*      PERFORM LOAD_DYNPRO USING '0100' sy-repid.
      CALL METHOD g_application->show_syntax_diagram.

    WHEN 'ABAPDOCU'.

      CALL METHOD g_application->show_abap_docu.

    WHEN 'EXEC' OR 'SIMULATE' OR 'EXEC_BG'.

      IF g_commands->current_command IS NOT INITIAL.


        DATA: lv_bg TYPE c.

        CLEAR autotrace.
        CALL METHOD g_commands->execute_command
          EXPORTING
            iv_mode = ok_code.

      ELSE.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'I'
            iv_msgno        = '061'
            iv_display_like = 'E'.
*          message i061 DISPLAY LIKE 'E'.
      ENDIF.

  ENDCASE.

  CLEAR ok_code.

ENDFORM.                    " USER_COMMAND

*----------------------------------------------------------------------*
***INCLUDE ZHTDB_USER_COMMAND_0100_EXITI1 .
*----------------------------------------------------------------------*
*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0100_EXIT  INPUT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_0100_exit INPUT.

  PERFORM user_command_0100_exit.

ENDMODULE.                 " USER_COMMAND_0100_EXIT  INPUT
*&---------------------------------------------------------------------*
*&      Form  USER_COMMAND_0100_EXIT
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM user_command_0100_exit .

  CASE ok_code.

    WHEN 'BACK' OR 'CANCEL' OR 'EXIT'.

      LEAVE TO SCREEN 0.

  ENDCASE.

ENDFORM.                    " USER_COMMAND_0100_EXIT



*&---------------------------------------------------------------------*
*&  Include           ZHTDB_LCLAPPLICATION_I                           *
*&---------------------------------------------------------------------*


CLASS lcl_application IMPLEMENTATION.

  METHOD remove_gen_programs.

    DATA: lt_reports TYPE TABLE OF reposrc-progname,
          lv_report  TYPE reposrc-progname.

    SELECT progname
      INTO TABLE lt_reports
      FROM reposrc
      WHERE progname LIKE 'ZENITH_GEN%'.

    LOOP AT lt_reports INTO lv_report.

      CALL FUNCTION 'ENQUEUE_ES_PROG'
        EXPORTING
          mode_trdir     = 'E'
          name           = lv_report
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.

      IF sy-subrc EQ 0.

*     delete program from the repository
        CALL FUNCTION 'RS_DELETE_PROGRAM'
          EXPORTING
            program            = lv_report
            suppress_checks    = 'X'
            suppress_popup     = 'X'
            with_includes      = ' '
            with_cua           = ' '
            with_documentation = ' '
            with_dynpro        = ' '
            with_textpool      = ' '
            skip_progress_ind  = 'X'
          EXCEPTIONS
            enqueue_lock       = 1
            object_not_found   = 2
            permission_failure = 3
            reject_deletion    = 4
            OTHERS             = 5.


        IF sy-subrc <> 0.

          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty        = 'S'
              iv_display_like = 'W'
              iv_msgno        = sy-msgno
              iv_msgid        = sy-msgid.

        ELSE.

          CALL FUNCTION 'DEQUEUE_ES_PROG'
            EXPORTING
              mode_trdir = 'E'
              name       = lv_report.

        ENDIF.

      ENDIF.

    ENDLOOP.


  ENDMETHOD.                    "remove_gen_programs



  METHOD issue_message.

    IF iv_msgid IS INITIAL.
      ms_s_msg-msgid = 'ZSQL_FREE'.
    ELSE.
      ms_s_msg-msgid = iv_msgid.
    ENDIF.

    IF iv_to_log EQ 'X' OR gv_autotest = 'X'.

      CLEAR ms_s_msg.

      IF iv_msgno IS INITIAL.
        RETURN.
      ENDIF.

      IF     iv_msgid = 'SD' AND iv_msgno = 94.
        RETURN.
      ELSEIF iv_msgid = 'FL' AND iv_msgno = 714.
        RETURN.
      ENDIF.

      ms_s_msg-msgno = iv_msgno.

      ms_s_msg-msgv1 = iv_msgv1.
      ms_s_msg-msgv2 = iv_msgv2.
      ms_s_msg-msgv3 = iv_msgv3.
      ms_s_msg-msgv4 = iv_msgv4.

      IF ms_s_msg-msgid IS INITIAL.
        ms_s_msg-msgid = 'ZSQL_FREE'.
      ENDIF.

      CONDENSE: ms_s_msg-msgv1, ms_s_msg-msgv2, ms_s_msg-msgv3, ms_s_msg-msgv4.

      ms_s_msg-msgty = iv_msgty.
*      ms_s_msg-probclass = iv_probclass.

*      CALL FUNCTION 'BAL_LOG_MSG_CUMULATE'
*       EXPORTING
*         I_LOG_HANDLE               = mv_log_handle
*         I_S_MSG                    = ms_s_msg
*  *       I_COMPARE_ATTRIBUTES       = ' '
*  *       I_COMPARE_CONTEXT          = ' '
*  *       I_COMPARE_PARAMETERS       = ' '
*  *     IMPORTING
*  *       E_S_MSG_HANDLE             =
*  *       E_MSG_WAS_LOGGED           =
*  *       E_MSG_WAS_DISPLAYED        =
*       EXCEPTIONS
*         LOG_NOT_FOUND              = 1
*         MSG_INCONSISTENT           = 2
*         LOG_IS_FULL                = 3
*         OTHERS                     = 4
*                .
*      IF sy-subrc <> 0.
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*               WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
*      ENDIF.
*

      CALL FUNCTION 'BAL_LOG_MSG_ADD'
        EXPORTING
          i_log_handle = mv_log_handle
          i_s_msg      = ms_s_msg
        EXCEPTIONS
          OTHERS       = 1.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                 WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.

    ELSE.

      IF iv_msgno IS NOT INITIAL.
        MESSAGE ID     ms_s_msg-msgid
          TYPE         'S'
          NUMBER       iv_msgno
          DISPLAY LIKE iv_msgty " iv_display_like
          WITH         iv_msgv1 iv_msgv2 iv_msgv3 iv_msgv4 .
      ENDIF.

    ENDIF.

  ENDMETHOD.                    "issue_message




  METHOD get_selected_word.

    DATA: l_from      TYPE i,
          l_to        TYPE i,
          l_from_new  TYPE i,
          l_to_new    TYPE i,
          l_from_line TYPE i,
          l_to_line   TYPE i,
          l_len       TYPE i,
          lt_text     TYPE source_table,
          l_text      LIKE LINE OF lt_text,
          lstr        TYPE string.
*          l_area      TYPE thead-tdname,


    CALL METHOD g_textedit->get_selection_pos
      IMPORTING
        from_line              = l_from_line
        from_pos               = l_from
        to_line                = l_to_line
        to_pos                 = l_to
      EXCEPTIONS
        error_cntl_call_method = 1
        OTHERS                 = 2.

    IF sy-subrc <> 0.

      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.

    ENDIF.

*abaped    CALL METHOD g_textedit->get_text_as_r3table
    CALL METHOD g_textedit->get_text
      IMPORTING
        table               = lt_text
      EXCEPTIONS
*abaped        potential_data_loss = 1.
        OTHERS = 1.

    IF sy-subrc = 1.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'I'
          iv_msgno = '025'.
*      MESSAGE i025.
    ENDIF.

    READ TABLE lt_text INTO l_text INDEX l_from_line.

    lstr = l_text.

    CALL METHOD lcl_toolbox=>get_word_at_pos
      EXPORTING
        iv_string   = lstr
        iv_position = l_from
      IMPORTING
        ev_word     = ep_word.

  ENDMETHOD.                    "get_selected_word

  METHOD show_abap_docu.

    DATA: l_word      TYPE string.

    CALL METHOD get_selected_word
      IMPORTING
        ep_word = l_word.

    CHECK l_word IS NOT INITIAL.

    TRANSLATE l_word TO UPPER CASE.

    DATA: lt_search_results TYPE docu_search_abap,
          ls_search_results LIKE LINE OF lt_search_results.

    CALL FUNCTION 'ABAP_DOCU_SEARCH'
      EXPORTING
        keyword_or_text = l_word
      IMPORTING
        RESULT          = lt_search_results.

    IF lt_search_results IS NOT INITIAL.

      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'S'
          iv_msgno = '062'
          iv_msgv1 = l_word.
*      MESSAGE s062 WITH l_word.

      DATA: l_name      TYPE thead-tdname.

      READ TABLE lt_search_results INTO ls_search_results INDEX 1.
      l_name = ls_search_results-object.

      CALL FUNCTION 'ABAP_DOCU_SHOW'
        EXPORTING
          area  = l_name(4)
          name  = l_name+4
          langu = sy-langu.

    ELSE.
*      MESSAGE w063 WITH l_word.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'W'
          iv_msgno = '063'
          iv_msgv1 = l_word.
    ENDIF.

  ENDMETHOD.                    "show_abap_docu


  METHOD show_syntax_diagram.


    DATA: l_word      TYPE string.

    CALL METHOD get_selected_word
      IMPORTING
        ep_word = l_word.

    CHECK l_word IS NOT INITIAL.

    TRANSLATE l_word TO UPPER CASE.

    DATA: l_keyword TYPE sy-repid.

    l_keyword = l_word.

    CALL FUNCTION 'RS_DISPLAY_SYNTAX_DIAGRAM'
      EXPORTING
        keyword = l_keyword.


  ENDMETHOD.                    "show_syntax_diagram




  METHOD constructor.


  ENDMETHOD.                    "lcl_application



  METHOD set_key_field_settings.

    DATA:           l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands->current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.


    CHECK l_select_command IS NOT INITIAL.

    IF p_mode = 'KEY_FIX'.
      l_select_command->mv_key_colmn_type = 'F'.
    ELSE.
      l_select_command->mv_key_colmn_type = 'N'.
    ENDIF.

  ENDMETHOD.                    "set_key_field_settings

  METHOD set_column_settings.

    DATA:
          l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands->current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.


    CHECK l_select_command IS NOT INITIAL.

    CASE p_mode.
      WHEN 'TXT_SHTXT'.
        l_select_command->mv_colmn_header = 'S'.
      WHEN 'TXT_GENFLD'.
        l_select_command->mv_colmn_header = 'G'.
      WHEN 'TXT_ALIAS'.
        l_select_command->mv_colmn_header = 'A'.
      WHEN 'TXT_FLD'.
        l_select_command->mv_colmn_header = 'T'.
    ENDCASE.

  ENDMETHOD.                    "set_column_settings

  METHOD handle_f1_textedit.

    CALL METHOD show_abap_docu.

  ENDMETHOD.                    "lcl_application



  METHOD handle_context_menu.

    CALL METHOD menu->add_function
      EXPORTING
        fcode  = 'PRETTY'
        text   = text-023
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD menu->add_function
      EXPORTING
        fcode  = 'ABAPDOCU'
        text   = text-116
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD menu->add_function
      EXPORTING
        fcode  = 'SYNTAXD'
        text   = text-117
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


  ENDMETHOD.                    "lcl_application

  METHOD handle_context_menu_selected.

    CASE fcode.
      WHEN 'ABAPDOCU'.

        CALL METHOD show_abap_docu.

      WHEN 'SYNTAXD'.

        CALL METHOD show_syntax_diagram.

      WHEN 'PRETTY'.

        DATA: "l_text TYPE source_table,
              l_text TYPE rswsourcet.

*abaped    CALL METHOD g_textedit->get_text_as_r3table
        CALL METHOD g_textedit->get_text
          IMPORTING
            table               = l_text
          EXCEPTIONS
*abaped            potential_data_loss = 1.
            OTHERS = 1.

        IF sy-subrc = 1.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty = 'E'
              iv_msgno = '025'.
*          MESSAGE e025.
        ENDIF.

        IF l_text[] IS NOT INITIAL.


          CALL FUNCTION 'CREATE_PRETTY_PRINT_FORMAT'
            EXPORTING
              mode          = 'HIKEY'
            TABLES
              SOURCE        = l_text
            EXCEPTIONS
              syntax_errors = 1
              OTHERS        = 2.

          IF sy-subrc <> 0.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.


*abaped    CALL METHOD g_textedit->set_text_as_r3table
          CALL METHOD g_textedit->set_text
            EXPORTING
              table  = l_text[]
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

        ENDIF.

    ENDCASE.

  ENDMETHOD.                    "lcl_application

  METHOD handle_context_menu_alv.


  ENDMETHOD.                    "lcl_application


  METHOD handle_node_ctx_menu_sel_lq.

    CALL METHOD handle_lq_ctx_sel
      EXPORTING
        sender  = 'T'
        e_ucomm = fcode
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "lcl_application

  METHOD handle_context_menu_tree_tb_n.

    CALL METHOD handle_lq_context_menu
      EXPORTING
        sender   = 'T'
        e_object = menu
      EXCEPTIONS
        OTHERS   = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "lcl_application

  METHOD handle_lq_context_menu.

    DATA: lq_menu_inner TYPE REF TO cl_ctmenu,
          lq_menu_outer TYPE REF TO cl_ctmenu,
          lq_menu_selfae TYPE REF TO cl_ctmenu,
          lq_menu_subquery TYPE REF TO cl_ctmenu,
          lq_menu_table_i TYPE REF TO cl_ctmenu,
          lq_menu_table_o TYPE REF TO cl_ctmenu,
          lq_menu_table_selfae TYPE REF TO cl_ctmenu,
          lq_menu_table_subquery TYPE REF TO cl_ctmenu,
          lq_menu_table_i_prev TYPE REF TO cl_ctmenu,
          lq_menu_table_o_prev TYPE REF TO cl_ctmenu,
          lq_menu_table_selfae_prev TYPE REF TO cl_ctmenu,
          lq_menu_table_subquery_prev TYPE REF TO cl_ctmenu,
          ls_dd08l TYPE dd08l,
          l_fcode TYPE ui_func,
          lt_dd08l TYPE TABLE OF dd08l,
          ls_table_alias LIKE LINE OF g_commands->current_command->table_alias_tb,
          lstr(40) TYPE c,
          lstr4(40) TYPE c,
          lstr2 TYPE string,
          lstr3 TYPE string,
          lstr5 TYPE string,
          lint TYPE i,
          ls_prev_linkedquery LIKE gs_linkedquery,
          ls_linkedquery LIKE gs_linkedquery,
          lt_linkedquery LIKE gt_linkedquery,
*          l_prev_checktable TYPE dd08l-checktable,
*          l_prev_table TYPE dd08l-checktable,
*          l_prev_ddtext TYPE dd02t-ddtext,
*          l_prev_primpos TYPE dd05m-primpos,
          l_ddtext TYPE dd02t-ddtext,
          l_text(40) TYPE c,
          l_comp_text(40) TYPE c.

    DATA: dd08v_ia TYPE TABLE OF dd08v,
          dd05m_ia TYPE TABLE OF dd05m,
          wa_dd08v_ia TYPE dd08v,
          wa_dd05m_ia TYPE dd05m,
          state(1),
          l_tabname TYPE dd08l-tabname.

*    CHECK g_commands->current_command->mv_locked IS INITIAL.

    CLEAR gt_linkedquery.
    CLEAR lint.

    CALL METHOD e_object->add_separator
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CHECK g_commands->current_command->command_type EQ gc_ctype_select OR
          g_commands->current_command->command_type EQ gc_ctype_selfae.

    LOOP AT g_commands->current_command->table_alias_tb INTO ls_table_alias.

      CLEAR lt_dd08l.

      l_tabname = ls_table_alias-table.

      CALL FUNCTION 'DD_TBFK_GET'
           EXPORTING
*                FIELDNAME     = INCLFIELD
                get_state     = 'A'
                tabl_name     = l_tabname
                withtext      = 'X'
           IMPORTING
                got_state     = state
           TABLES
                dd05m_tab_a   = dd05m_ia
*                DD05M_TAB_N   = FK1_DD05M
                dd08v_tab_a   = dd08v_ia
*                DD08V_TAB_N   = FK1_DD08V
           EXCEPTIONS
                illegal_value = 01.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.

      ENDIF.

      LOOP AT dd05m_ia INTO wa_dd05m_ia WHERE checkfield NE 'MANDT' OR checktable EQ 'T000'.

        lint = lint + 1.

        SELECT SINGLE ddtext
        INTO l_ddtext
        FROM dd02t
        WHERE as4local = 'A'
              AND tabname = wa_dd05m_ia-checktable
              AND ddlanguage = sy-langu.

        IF sy-subrc NE 0.

          SELECT SINGLE ddtext
          INTO l_ddtext
          FROM dd02t
          WHERE as4local = 'A'
                AND tabname = wa_dd05m_ia-checktable.

          IF sy-subrc NE 0.
*            message 'ZENITH:sdfgdsf' type 'E'.
          ENDIF.

        ENDIF.

        CONCATENATE ls_table_alias-alias '~' wa_dd05m_ia-forkey INTO lstr2.
        CONDENSE lstr2 NO-GAPS.
        CONCATENATE wa_dd05m_ia-checktable '~' wa_dd05m_ia-checkfield INTO lstr3.
        CONDENSE lstr3 NO-GAPS.
        CONCATENATE 'ON' lstr3 '=' lstr2 INTO lstr2 SEPARATED BY ' '.

        MOVE lstr2 TO lstr.

        lstr2 = lint.
        CONCATENATE 'LA_' lstr2 INTO l_fcode.
        CONDENSE l_fcode NO-GAPS.

        CLEAR gs_linkedquery.
        gs_linkedquery-fcode       = l_fcode.
        gs_linkedquery-tabname     = ls_table_alias-alias.
        gs_linkedquery-checktable  = wa_dd05m_ia-checktable.
        gs_linkedquery-fieldname   = wa_dd05m_ia-forkey.
        gs_linkedquery-checkfield  = wa_dd05m_ia-checkfield.
        gs_linkedquery-primpos     = wa_dd05m_ia-primpos.
        gs_linkedquery-text        = lstr.
        gs_linkedquery-longtext    = lstr.
        gs_linkedquery-ddtext      = l_ddtext.

        APPEND gs_linkedquery TO gt_linkedquery.

      ENDLOOP.

    ENDLOOP.


    DATA: l_comp_count TYPE i,
          lt_primpos TYPE TABLE OF gty_linkedquery-primpos,
          l_primpos TYPE gty_linkedquery-primpos.

    CLEAR gt_linkedquery_comp.


    IF g_commands->current_command->mv_locked IS INITIAL.
      CREATE OBJECT lq_menu_inner.
      CREATE OBJECT lq_menu_outer.
      CREATE OBJECT lq_menu_subquery.
    ENDIF.

    CREATE OBJECT lq_menu_selfae.

    SORT gt_linkedquery BY checktable tabname primpos.

    LOOP AT gt_linkedquery INTO gs_linkedquery.

      IF ls_prev_linkedquery-checktable NE gs_linkedquery-checktable OR
           ls_prev_linkedquery-tabname NE gs_linkedquery-tabname.

        CLEAR: l_comp_count.
        CLEAR lt_primpos.
        CLEAR lstr2.

        lstr4 = '* ON'.

        LOOP AT gt_linkedquery INTO ls_linkedquery
          WHERE tabname         = ls_prev_linkedquery-tabname
                AND checktable  = ls_prev_linkedquery-checktable.
*                AND join_type   = ls_prev_linkedquery-join_type.


          READ TABLE lt_primpos TRANSPORTING NO FIELDS
            WITH KEY table_line = ls_linkedquery-primpos.

          IF sy-subrc EQ 4.

            CONCATENATE ls_linkedquery-tabname '~' ls_linkedquery-fieldname INTO lstr5.
            CONDENSE lstr5  NO-GAPS.

            CONCATENATE ls_linkedquery-checktable '~' ls_linkedquery-checkfield INTO lstr3.
            CONDENSE lstr3 NO-GAPS.

            CONCATENATE lstr4 lstr3 INTO lstr4 SEPARATED BY space.

            IF lstr2 IS INITIAL.
              CONCATENATE 'ON' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
            ELSE.
              CONCATENATE lstr2 'AND' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
            ENDIF.

*              CONCATENATE ls_linkedquery-table '~' ls_linkedquery-field INTO lstr5.
*              CONDENSE lstr5  NO-GAPS.
*              CONCATENATE lstr4 lstr5 INTO lstr4 SEPARATED BY SPACE.
*
*              CONCATENATE ls_linkedquery-checktable '~' ls_linkedquery-checkfield INTO lstr3.
*              CONDENSE lstr3 NO-GAPS.
*
*              if lstr2 IS INITIAL.
*                CONCATENATE 'ON' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
*              else.
*                CONCATENATE lstr2 'AND' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
*              endif.

            APPEND ls_linkedquery-primpos TO lt_primpos.

            l_comp_count = l_comp_count + 1.

          ENDIF.

        ENDLOOP.

        IF l_comp_count GT 1.

          READ TABLE gt_linkedquery_comp TRANSPORTING NO FIELDS
            WITH KEY tabname  = ls_linkedquery-tabname
                     checktable = ls_linkedquery-checktable
                     text   = lstr4.
*                     longtext   = lstr2.

          IF sy-subrc EQ 4.

            CONCATENATE gs_linkedquery-fcode '_COMP' INTO l_fcode.
*            CONCATENATE 'I_' gs_linkedquery-fcode '_COMP' INTO l_fcode.
***            l_fcode = gs_linkedquery-fcode.

            gs_linkedquery_comp-fcode      = l_fcode.
            gs_linkedquery_comp-tabname    = ls_linkedquery-tabname.
            gs_linkedquery_comp-checktable = ls_linkedquery-checktable.
            gs_linkedquery_comp-text       = lstr4.
            gs_linkedquery_comp-longtext   = lstr2.
            gs_linkedquery_comp-join_type  = ls_linkedquery-join_type.
            gs_linkedquery_comp-ddtext     = ls_linkedquery-ddtext.

            APPEND gs_linkedquery_comp TO gt_linkedquery_comp.

            CONCATENATE 'I_' gs_linkedquery-fcode '_COMP' INTO l_fcode.

            IF lq_menu_table_i_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_i_prev->add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CONCATENATE 'O_' gs_linkedquery-fcode '_COMP' INTO l_fcode.

            IF lq_menu_table_o_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_o_prev->add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CONCATENATE 'S_' gs_linkedquery-fcode '_COMP' INTO l_fcode.

            IF lq_menu_table_selfae_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_selfae_prev->add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CONCATENATE 'Q_' gs_linkedquery-fcode '_COMP' INTO l_fcode.

            IF lq_menu_table_subquery_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_subquery_prev->add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CLEAR l_fcode.

          ENDIF.

        ENDIF.

      ENDIF.

      IF ls_prev_linkedquery-checktable NE gs_linkedquery-checktable.

        IF g_commands->current_command->mv_locked IS INITIAL.
          CREATE OBJECT lq_menu_table_i.
          CREATE OBJECT lq_menu_table_o.
          CREATE OBJECT lq_menu_table_subquery.
        ENDIF.

        CREATE OBJECT lq_menu_table_selfae.

        CONCATENATE '(' gs_linkedquery-ddtext ')' INTO l_ddtext.
        CONCATENATE gs_linkedquery-checktable l_ddtext INTO lstr SEPARATED BY ' '.

        IF g_commands->current_command->mv_locked IS INITIAL.

          CALL METHOD lq_menu_inner->add_submenu
            EXPORTING
              menu   = lq_menu_table_i
              text   = lstr
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

          CALL METHOD lq_menu_outer->add_submenu
            EXPORTING
              menu   = lq_menu_table_o
              text   = lstr
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

          CALL METHOD lq_menu_subquery->add_submenu
            EXPORTING
              menu   = lq_menu_table_subquery
              text   = lstr
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

        ENDIF.

        CALL METHOD lq_menu_selfae->add_submenu
          EXPORTING
            menu   = lq_menu_table_selfae
            text   = lstr
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      ENDIF.

      IF g_commands->current_command->mv_locked IS INITIAL.

        CONCATENATE 'I_' gs_linkedquery-fcode INTO l_fcode.

        CALL METHOD lq_menu_table_i->add_function
          EXPORTING
            fcode  = l_fcode
            text   = gs_linkedquery-text
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CONCATENATE 'O_' gs_linkedquery-fcode INTO l_fcode.

        CALL METHOD lq_menu_table_o->add_function
          EXPORTING
            fcode  = l_fcode
            text   = gs_linkedquery-text
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CONCATENATE 'Q_' gs_linkedquery-fcode INTO l_fcode.

        CALL METHOD lq_menu_table_subquery->add_function
          EXPORTING
            fcode  = l_fcode
            text   = gs_linkedquery-text
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      ENDIF.

      CONCATENATE 'S_' gs_linkedquery-fcode INTO l_fcode.

      CALL METHOD lq_menu_table_selfae->add_function
        EXPORTING
          fcode  = l_fcode
          text   = gs_linkedquery-text
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      ls_prev_linkedquery = gs_linkedquery.

      IF g_commands->current_command->mv_locked IS INITIAL.
        lq_menu_table_i_prev        = lq_menu_table_i.
        lq_menu_table_o_prev        = lq_menu_table_o.
        lq_menu_table_subquery_prev = lq_menu_table_subquery.
      ENDIF.

      lq_menu_table_selfae_prev   = lq_menu_table_selfae.

    ENDLOOP.

    IF sender = 'T'.

      IF g_commands->current_command->mv_locked IS INITIAL.

        CALL METHOD lq_menu_inner->add_function
          EXPORTING
            fcode  = 'RELAT_I'
            text   = text-028
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CALL METHOD lq_menu_outer->add_function
          EXPORTING
            fcode  = 'RELAT_O'
            text   = text-028
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CALL METHOD lq_menu_subquery->add_function
          EXPORTING
            fcode  = 'RELAT_Q'
            text   = text-028
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      ENDIF.

      CALL METHOD lq_menu_selfae->add_function
        EXPORTING
          fcode  = 'RELAT_S'
          text   = text-028
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.
    lstr = text-024.

    IF g_commands->current_command->mv_locked IS INITIAL.

      CALL METHOD e_object->add_submenu
        EXPORTING
          menu   = lq_menu_inner
          text   = lstr
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      lstr = text-025.

      CALL METHOD e_object->add_submenu
        EXPORTING
          menu   = lq_menu_outer
          text   = lstr
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      lstr = text-149.

      CALL METHOD e_object->add_submenu
        EXPORTING
          menu   = lq_menu_subquery
          text   = lstr
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    "lcl_application


  METHOD handle_function_selected_txt.

    CASE fcode.

      WHEN 'PRETTY'.

        IF g_commands->current_command->text IS NOT INITIAL.

**          CALL METHOD LCL_TOOLBOX=>pretty_printer
**            CHANGING
**              ct_source = g_commands->current_command->text.

          CALL FUNCTION 'PRETTY_PRINTER'
            EXPORTING
              inctoo             = ' '
            TABLES
              ntext              = g_commands->current_command->text
              otext              = g_commands->current_command->text
            EXCEPTIONS
              enqueue_table_full = 1
              include_enqueued   = 2
              include_readerror  = 3
              include_writeerror = 4
              OTHERS             = 5.
          IF sy-subrc <> 0.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.

        ENDIF.

    ENDCASE.

  ENDMETHOD.                    "lcl_application


  METHOD handle_double_click.

    DATA: l_s_c TYPE REF TO lcl_select_command,
          l_lawb TYPE REF TO lcl_lawb,
          ls_fcat TYPE lvc_s_fcat,
          lv_uname LIKE sy-uname.

    FIELD-SYMBOLS: <lv_icon> TYPE ANY.


    TRY.
        l_s_c ?= g_commands->current_command.

      CATCH cx_sy_move_cast_error.

    ENDTRY.

    READ TABLE l_s_c->fcat INTO ls_fcat
    WITH KEY fieldname = e_column.

    IF sy-subrc NE 0.
      EXIT.
    ENDIF.

    IF ls_fcat-rollname IS NOT INITIAL.
      CALL DIALOG 'RS_DD_DTEL_EDIT'
        EXPORTING
          MODE    from 'S'
          objname FROM ls_fcat-rollname.
    ELSE.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty        = 'S'
          iv_msgno        = '115'
          iv_display_like = 'W'.
    ENDIF.

  ENDMETHOD.                    "lcl_application

*new*
  METHOD handle_dropdown_clicked.

    DATA: menu_dynamic TYPE REF TO cl_ctmenu.

    CREATE OBJECT menu_dynamic.

    CALL METHOD handle_lq_context_menu
      EXPORTING
        sender   = 'T'
        e_object = menu_dynamic.

    CALL METHOD g_toolbar_tb_tree->track_context_menu
      EXPORTING
        context_menu = menu_dynamic
        posx         = posx
        posy         = posy.

  ENDMETHOD.                    "lcl_my_event_handler

  METHOD handle_node_double_click.

    DATA: lstr TYPE string,
          l_text TYPE source_table,
          ls_table_alias TYPE lty_zhtdb_table_aliases.

    CALL METHOD g_tree_tb->get_outtab_line
      EXPORTING
        i_node_key     = node_key
      IMPORTING
        e_outtab_line  = gs_outtab_tb
      EXCEPTIONS
        node_not_found = 1
        OTHERS         = 2.

    IF sy-subrc EQ 0.
      IF gs_outtab_tb-fieldname IS INITIAL.
        EXIT.
      ENDIF.
    ELSE.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.

    ENDIF.

    READ TABLE g_commands->current_command->mt_ranges INTO gs_ranges
      WITH KEY table_alias = gs_outtab_tb-alias
               fieldname   = gs_outtab_tb-fieldname.

    IF sy-subrc NE 0.
*      MESSAGE e027.
      RETURN.
    ENDIF.

    CONCATENATE gs_ranges-fieldname 'IN' gs_ranges-node_text INTO lstr SEPARATED BY ' '.

    READ TABLE g_commands->current_command->table_alias_tb INTO ls_table_alias
      WITH KEY alias = gs_ranges-table_alias.

    IF sy-subrc EQ 0.
      IF ls_table_alias-alias IS NOT INITIAL.
        CONCATENATE ls_table_alias-alias '~' lstr INTO lstr.
      ENDIF.
    ELSE.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'E'
          iv_msgno = '027'.
*      MESSAGE e027.
    ENDIF.


    DATA: lt_vrange_text TYPE lty_zhtdbt_string_tab.

**    IF g_commands->current_command->where_text IS INITIAL.
**      CONCATENATE 'WHERE' lstr INTO lstr SEPARATED BY ' '.
**    ELSE.
**      CONCATENATE 'and' lstr INTO lstr SEPARATED BY ' '.
**    ENDIF.

    APPEND lstr TO lt_vrange_text.

    CALL METHOD insert_stringtab_to_pos
      EXPORTING
        it_stringtab = lt_vrange_text.

**    APPEND lstr TO l_text.

*abaped    CALL METHOD g_textedit->set_text_as_r3table
    CALL METHOD g_textedit->set_text
      EXPORTING
        table  = g_commands->current_command->text
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


**
**    CALL METHOD cl_gui_cfw=>dispatch
**      EXCEPTIONS
**        OTHERS = 1.
**
**    IF sy-subrc NE 0.
**      IF sy-msgno IS NOT INITIAL.
**        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
**WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
**      ENDIF.
**    ENDIF.

  ENDMETHOD.                    "lcl_application


  METHOD insert_stringtab_to_pos.

    DATA: l_from            TYPE i,
          l_to              TYPE i,
          l_from_new        TYPE i,
          l_to_new          TYPE i,
          l_from_line       TYPE i,
          l_to_line         TYPE i,
          l_len             TYPE i,
          lv_lines          TYPE i,
          lv_middle_string  TYPE string,
          lt_text           TYPE source_table,
          lt_text_temp      TYPE source_table,
          l_text            LIKE LINE OF lt_text_temp,
          lstr              TYPE string,
          lstr2             TYPE string,
          lt_text_split     TYPE TABLE OF string,
          ls_sel_field_list TYPE string,
          lv_from_copy      TYPE i.

    CALL METHOD g_textedit->get_selection_pos
      IMPORTING
        from_line              = l_from_line
        from_pos               = l_from
        to_line                = l_to_line
        to_pos                 = l_to
      EXCEPTIONS
        error_cntl_call_method = 1
        OTHERS                 = 2.

    IF sy-subrc <> 0.

      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.

    ENDIF.

*abaped    CALL METHOD g_textedit->get_text_as_r3table
    CALL METHOD g_textedit->get_text
      IMPORTING
        table               = lt_text
      EXCEPTIONS
*abaped        potential_data_loss = 1.
        OTHERS = 1.

    IF sy-subrc = 1.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'I'
          iv_msgno = '025'.
*      MESSAGE i025.
    ENDIF.

    DESCRIBE TABLE it_stringtab LINES lv_lines.
    READ TABLE lt_text INTO l_text INDEX l_from_line.
    READ TABLE it_stringtab INTO ls_sel_field_list INDEX 1.

    l_from = l_from - 1.

    IF l_from EQ 0.
      lstr2 = l_text.
      CLEAR lstr.
    ELSE.
      lstr  = l_text(l_from).
    ENDIF.

    l_text = l_text+l_from.
    lstr2  = l_text.

    IF lv_lines = 1.
      CONCATENATE lstr ls_sel_field_list lstr2 INTO lv_middle_string SEPARATED BY space.
    ELSE.
      CONCATENATE lstr ls_sel_field_list INTO lv_middle_string SEPARATED BY space.
    ENDIF.

    IF l_from_line > 1.
      lv_from_copy = l_from_line - 1.

      LOOP AT lt_text INTO lstr FROM 1 TO lv_from_copy.
        l_text = lstr.
        APPEND l_text TO lt_text_temp.
      ENDLOOP.
    ENDIF.

    CALL METHOD lcl_toolbox=>split_string
      EXPORTING
        iv_string     = lv_middle_string
        iv_maxlen     = gc_line_length
      IMPORTING
        et_string_tab = lt_text_split.

    LOOP AT lt_text_split INTO lstr.
      l_text = lstr.
      APPEND l_text TO lt_text_temp.
    ENDLOOP.

    LOOP AT it_stringtab INTO ls_sel_field_list FROM 2.

      CLEAR lt_text_split.

      IF sy-tabix = lv_lines.
        CONCATENATE ls_sel_field_list lstr2 INTO ls_sel_field_list
          SEPARATED BY space.
      ENDIF.

      CALL METHOD lcl_toolbox=>split_string
        EXPORTING
          iv_string     = ls_sel_field_list
          iv_maxlen     = gc_line_length
        IMPORTING
          et_string_tab = lt_text_split.

      LOOP AT lt_text_split INTO lstr.
        l_text = lstr.
        APPEND l_text TO lt_text_temp.
      ENDLOOP.

    ENDLOOP.

    lv_from_copy = l_from_line + 1.

    LOOP AT lt_text INTO lstr FROM lv_from_copy.
      l_text = lstr.
      APPEND l_text TO lt_text_temp.
    ENDLOOP.

    g_commands->current_command->text[] = lt_text_temp[].


  ENDMETHOD.                    "insert_stringtab_to_pos

  METHOD create_tb_tree_toolbar.

    DATA: lv_auth_ok TYPE c.

    CALL METHOD g_tree_tb->get_toolbar_object
      IMPORTING
        er_toolbar = g_toolbar_tb_tree
      EXCEPTIONS
        OTHERS     = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CHECK NOT g_toolbar_tb_tree IS INITIAL.

*new*
    SET HANDLER g_application->handle_dropdown_clicked  FOR g_toolbar_tb_tree.
    SET HANDLER g_application->handle_function_selected FOR g_toolbar_tb_tree.

    IF g_commands IS NOT INITIAL AND g_commands->current_command IS NOT INITIAL.

      lv_auth_ok = 'X'.

    ENDIF.


    CALL METHOD g_toolbar_tb_tree->delete_all_buttons
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


***    IF g_commands IS NOT INITIAL AND g_commands->current_command IS NOT INITIAL.
***      CHECK g_commands->current_command->mv_locked IS INITIAL.
***    ENDIF.

    DATA: lv_icontext TYPE iconquick.

    IF lv_auth_ok = 'X' AND ( g_commands->current_command->mv_locked = ' ' ).

      lv_icontext = text-147.
      CALL METHOD g_toolbar_tb_tree->add_button
        EXPORTING
          fcode     = 'GET_TABLES'
          icon      = '@42@'
          butn_type = cntb_btype_button
          text      = ''
          quickinfo = lv_icontext
        EXCEPTIONS
          OTHERS    = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.

    lv_icontext = text-050.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'DISPLAY'
        icon      = '@B_DISP@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = text-051.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'INDEXES'
        icon      = '@USEREL@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = text-052.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'TECH'
        icon      = '@B_DETL@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = text-053.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'GRAPH'
        icon      = '@56@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = text-054.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'TEXTTAB'
        icon      = '@B_TXDP@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = text-055.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'RUNTIMEOBJ'
        icon      = '@OBJELI@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = text-056.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'WHERE'
        icon      = '@B_BOOK@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = text-057.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'CONTENTS'
        icon      = '@B_LIST@'
        butn_type = cntb_btype_button
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    IF lv_auth_ok = 'X' AND ( g_commands->current_command->mv_locked = ' ' ).
      lv_icontext = text-058.
      CALL METHOD g_toolbar_tb_tree->add_button
        EXPORTING
          fcode     = 'VRANGES'
          icon      = '@BGMORE@'
          butn_type = cntb_btype_button
          text      = ''
          quickinfo = lv_icontext
        EXCEPTIONS
          OTHERS    = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.
    ENDIF.

*new*

    lv_icontext = text-169.
    CALL METHOD g_toolbar_tb_tree->add_button
      EXPORTING
        fcode     = 'LQA'
        icon      = '@B_TREE@'
        butn_type = cntb_btype_dropdown
        text      = ''
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


  ENDMETHOD.                    "lcl_application

  METHOD create_txt_toolbar.

* nincs ilyen vaze

  ENDMETHOD.                    "lcl_application



  METHOD display_table_grid.

    DATA: ls_tb_alias_tb TYPE gty_table_aliases,
          l_command      TYPE REF TO lcl_command,
          ls_table       TYPE lty_zhtdb_alv_tab,
          l_node_text    TYPE lvc_value,
          l_new_node_key TYPE lvc_nkey,
          ls_node_style  TYPE lvc_s_layn,
          ls_rangename   TYPE lvc_value,
          ls_alias_range LIKE LINE OF l_command->mt_alias_ranges,
          ls_dd25l       TYPE dd25l.


    l_command = g_commands->current_command.

*   CHECK l_command->mt_tab_node_xref IS INITIAL.
*   CLEAR l_command->mt_outtab_tb.

*   miert a where feltetel??
    DELETE l_command->mt_outtab_tb
      WHERE fieldname IS INITIAL.

*   CLEAR l_command->mt_outtab_tb.
    CLEAR l_command->mt_tab_node_xref.

    IF g_tree_tb IS INITIAL.
      RETURN.
    ENDIF.

    CALL METHOD g_tree_tb->delete_all_nodes
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    LOOP AT l_command->table_alias_tb INTO ls_tb_alias_tb.

      CLEAR ls_table.

      SELECT SINGLE ddtext
        INTO ls_table-ddtext
        FROM dd02t
        WHERE as4local   = 'A'                  AND
              tabname    = ls_tb_alias_tb-table AND
              ddlanguage = sy-langu.

      IF sy-subrc EQ 4.

        SELECT SINGLE ddtext
          INTO ls_table-ddtext
          FROM dd02t
          WHERE as4local = 'A'      AND
                tabname = ls_tb_alias_tb-table.

      ENDIF.

      IF ls_tb_alias_tb-alias IS NOT INITIAL.
        ls_table-alias     = ls_tb_alias_tb-alias.
      ELSE.
        ls_table-alias     = ls_tb_alias_tb-table.
      ENDIF.

      ls_table-tablename = ls_tb_alias_tb-table.

      APPEND ls_table TO l_command->mt_outtab_tb.

      READ TABLE l_command->mt_alias_ranges
      WITH KEY table_alias = ls_table-alias
      TRANSPORTING NO FIELDS.

      IF sy-subrc NE 0.
        CLEAR ls_alias_range.
        ls_alias_range-table_alias = ls_table-alias.

        APPEND ls_alias_range TO l_command->mt_alias_ranges.
      ENDIF.

    ENDLOOP.

*   add tables to tree
    LOOP AT l_command->mt_outtab_tb INTO gs_outtab_tb
         WHERE fieldname IS INITIAL.

      READ TABLE l_command->table_alias_tb INTO ls_tb_alias_tb
        WITH KEY alias = gs_outtab_tb-alias.

      IF ls_tb_alias_tb-table NE ls_tb_alias_tb-alias.
        CONCATENATE ls_tb_alias_tb-table 'as' ls_tb_alias_tb-alias INTO l_node_text SEPARATED BY ' '.
      ELSE.
        l_node_text = ls_tb_alias_tb-table.
      ENDIF.

*      SELECT SINGLE viewname
*      FROM dd25l
*      INTO ls_dd25l-viewname
*      WHERE AS4LOCAL = 'A'
*            and viewname = ls_tb_alias_tb-table.

      CASE ls_tb_alias_tb-type.
        WHEN 'T'.
          ls_node_style-exp_image = '@PO@'.
          ls_node_style-n_image = '@PO@'.
        WHEN 'V'.
          ls_node_style-exp_image = '@A2@'.
          ls_node_style-n_image = '@A2@'.
        WHEN 'C'.
          ls_node_style-exp_image = '@AP@'.
          ls_node_style-n_image = '@AP@'.
        WHEN 'P'.
          ls_node_style-n_image = '@AQ@'.
          ls_node_style-exp_image = '@AQ@'.
      ENDCASE.

      CALL METHOD g_tree_tb->add_node
        EXPORTING
          i_relat_node_key = ''
          i_relationship   = cl_gui_column_tree=>relat_last_child
          is_outtab_line   = gs_outtab_tb
          i_node_text      = l_node_text
          is_node_layout   = ls_node_style
        IMPORTING
          e_new_node_key   = l_new_node_key
        EXCEPTIONS
          OTHERS           = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      gs_tab_node_xref-tablename = gs_outtab_tb-tablename.
      gs_tab_node_xref-alias     = gs_outtab_tb-alias.
      gs_tab_node_xref-node_key  = l_new_node_key.
      APPEND gs_tab_node_xref TO l_command->mt_tab_node_xref.

    ENDLOOP.

    ls_node_style-n_image = '@1E@'.

*   add fields
    LOOP AT l_command->mt_outtab_tb INTO gs_outtab_tb
         WHERE fieldname IS NOT INITIAL.

      READ TABLE l_command->mt_tab_node_xref
        INTO gs_tab_node_xref
        WITH KEY alias = gs_outtab_tb-alias.
*      WITH KEY tablename = gs_outtab_tb-tablename.

      IF sy-subrc NE 0.
*        MESSAGE i027.
        CONTINUE.
      ENDIF.

      IF gs_outtab_tb-tablename NE gs_outtab_tb-alias.
        CONCATENATE 'R_' gs_outtab_tb-alias '_' gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY ''.
      ELSE.
        CONCATENATE 'R_' gs_outtab_tb-tablename '_' gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY ''.
      ENDIF.

*      CONCATENATE 'R_' gs_outtab_tb-tablename '_' gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY ''.
      REPLACE ' ' WITH '' INTO ls_rangename.
      CONDENSE ls_rangename NO-GAPS.

      CALL METHOD g_tree_tb->add_node
        EXPORTING
          i_relat_node_key = gs_tab_node_xref-node_key
          i_relationship   = cl_gui_column_tree=>relat_last_child
          is_outtab_line   = gs_outtab_tb
          i_node_text      = ls_rangename
          is_node_layout   = ls_node_style
        IMPORTING
          e_new_node_key   = l_new_node_key
        EXCEPTIONS
          OTHERS           = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD g_tree_tb->expand_node
        EXPORTING
          i_node_key = gs_tab_node_xref-node_key
        EXCEPTIONS
          OTHERS     = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDLOOP.

    CALL METHOD g_tree_tb->frontend_update
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "lcl_application

  METHOD refresh_status_indicators.

    DATA: lstr TYPE string,
*            l_s_c TYPE REF TO lcl_select_command,
          lstr2 TYPE string,
          l_command_type TYPE lty_commandtype,
          l_int TYPE i.

*      try.
*        l_s_c ?= g_commands->current_command.
*
*      catch cx_sy_move_cast_error.
*        EXIT.
*      endtry.

    CALL METHOD g_commands->current_command->get_type
      IMPORTING
        ep_command_type = l_command_type
      EXCEPTIONS
        OTHERS          = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CASE l_command_type.
      WHEN gc_ctype_select OR
           gc_ctype_selfae OR
           gc_ctype_lawb.

      WHEN OTHERS.
        EXIT.
    ENDCASE.

    CLEAR gt_dynpread.

*      CLEAR: lstr, lstr2.
*
*      lstr2 = g_commands->current_command->mv_dbcnt.
*      CONCATENATE lstr 'Rows fetched:' lstr2 INTO lstr SEPARATED BY ' '.

    DATA: lv_cnt_fetched TYPE i,
          lv_cnt_updated TYPE i,
          lv_cnt_inserted TYPE i,
          lv_cnt_deleted TYPE i.

    MESSAGE i030 WITH g_commands->current_command->mv_dbcnt lv_cnt_updated lv_cnt_inserted lv_cnt_deleted INTO lstr.

****    MESSAGE i137 WITH lstr g_commands->current_command->mv_from g_commands->current_command->mv_to INTO lstr.

*new*
    DATA: lv_title TYPE lvc_title.

    lv_title = lstr.

    CALL METHOD g_alv->set_gridtitle
      EXPORTING
        i_gridtitle = lv_title.

*    gs_dynpread-fieldname = 'STATUS1'.
*    gs_dynpread-fieldvalue = lstr.
*    APPEND gs_dynpread TO gt_dynpread.
*
*    IF g_alv IS NOT INITIAL AND g_commands->current_command->mv_grid_modified IS NOT INITIAL.
*      CALL METHOD g_alv->set_toolbar_interactive
*        EXCEPTIONS
*          OTHERS = 1.
*
*      IF sy-subrc NE 0.
*        IF sy-msgno IS NOT INITIAL.
*          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
*                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*        ENDIF.
*      ENDIF.
*    ENDIF.
*
*    CALL METHOD cl_gui_cfw=>set_new_ok_code
*      EXPORTING
*        new_code = 'ENT'
*      IMPORTING
*        rc       = l_int
*      EXCEPTIONS
*        OTHERS   = 1.
*
*    IF sy-subrc NE 0.
*      IF sy-msgno IS NOT INITIAL.
*        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
*                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*      ENDIF.
*    ENDIF.

  ENDMETHOD.                    "lcl_application


  METHOD handle_after_refresh.

  ENDMETHOD.                    "lcl_application

  METHOD check_s_tabu_dis.

    DATA: x030l_wa        TYPE x030l,
          activity(2)     TYPE c,
          client_indep    TYPE c,
          lv_tddat        TYPE tddat,
          lv_tabname      TYPE tabname.

    CLEAR client_indep.

    lv_tabname = iv_tabname.
    TRANSLATE lv_tabname TO UPPER CASE.

*   determine activity
    IF iv_for_editing IS INITIAL.
      activity = '03'.
    ELSE.
      activity = '02'.
    ENDIF.

*   client independent?
    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = lv_tabname
      IMPORTING
        x030l_wa       = x030l_wa
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
         WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    IF x030l_wa-clpos = 0.
      client_indep = 'X'.
    ENDIF.

*   check normal table maintenace authority
    SELECT SINGLE * FROM tddat INTO lv_tddat
                    WHERE tabname = lv_tabname.

    IF sy-subrc <> 0  OR lv_tddat-cclass IS INITIAL.
      lv_tddat-cclass = '&NC&'.        " 'non classified table'
    ENDIF.

    ev_auth = 'X'.

    AUTHORITY-CHECK OBJECT 'S_TABU_DIS'
                    ID     'ACTVT'      FIELD activity
                    ID     'DICBERCLS'  FIELD lv_tddat-cclass.

    IF sy-subrc <> 0.
      CLEAR ev_auth.
    ENDIF.

*   check authority for client independent changes
    IF client_indep   = 'X' AND
       iv_for_editing = 'X'.

      AUTHORITY-CHECK OBJECT 'S_TABU_CLI'
                      ID     'CLIIDMAINT' FIELD 'X'.

      IF sy-subrc <> 0.
        CLEAR ev_auth.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    " check_s_tabu_dis


  METHOD handle_toolbar.

    DATA: ls_toolbar           TYPE stb_button,
          lv_not_modified      TYPE c,
          lv_display_only      TYPE c,
          lv_hide_undo         TYPE c,
          lv_undo_not_empty    TYPE c,
          lv_auth_change_res   TYPE c,
          lv_read_from_file    TYPE c,
          l_lawb               TYPE REF TO lcl_lawb,
          lv_tabname           TYPE tabname,
          l_select             TYPE REF TO lcl_select_command,
          lv_add_save_btn      TYPE c.


    IF sender NE g_alv.
      EXIT.
    ENDIF.

    TRY.
        l_select ?= g_commands->current_command.

        lv_read_from_file = l_select->mv_read_from_file.

        IF l_select->alv_state EQ 0.
          lv_display_only = 'X'.
        ELSE.
          lv_display_only = ' '.
        ENDIF.

      CATCH cx_sy_move_cast_error.
*      message 'ZENITH:Casting error5' TYPE 'E'.
    ENDTRY.

    IF <gt_undo> IS ASSIGNED AND <gt_undo> IS NOT INITIAL.
      lv_undo_not_empty = 'X'.
    ENDIF.

    IF g_commands->current_command->mv_grid_modified EQ 'X'.
      lv_not_modified = ' '.
    ELSE.
      lv_not_modified = 'X'.
    ENDIF.

    CLEAR ls_toolbar.
    MOVE 3 TO ls_toolbar-butn_type.
    INSERT ls_toolbar INTO e_object->mt_toolbar INDEX 1.

    CLEAR ls_toolbar.
    MOVE cl_gui_alv_grid=>mc_fc_select_all TO ls_toolbar-function.
    MOVE icon_select_all TO ls_toolbar-icon.
    MOVE text-061 TO ls_toolbar-quickinfo.
    APPEND ls_toolbar TO e_object->mt_toolbar.

    CLEAR ls_toolbar.
    MOVE cl_gui_alv_grid=>mc_fc_deselect_all TO ls_toolbar-function.
    MOVE icon_deselect_all TO ls_toolbar-icon.
    MOVE text-062 TO ls_toolbar-quickinfo.
    APPEND ls_toolbar TO e_object->mt_toolbar.

    CLEAR ls_toolbar.
    MOVE 3 TO ls_toolbar-butn_type.
    APPEND ls_toolbar TO e_object->mt_toolbar.

    CLEAR ls_toolbar.
    MOVE 'TXT_MENU' TO ls_toolbar-function.
    MOVE icon_display_text TO ls_toolbar-icon.
    MOVE text-063 TO ls_toolbar-quickinfo.
    MOVE 2 TO ls_toolbar-butn_type.
    MOVE space TO ls_toolbar-disabled.
    APPEND ls_toolbar TO e_object->mt_toolbar.

    CLEAR ls_toolbar.
    MOVE 3 TO ls_toolbar-butn_type.
    APPEND ls_toolbar TO e_object->mt_toolbar.



  ENDMETHOD.                    "lcl_application


  METHOD handle_function_selected.

    DATA: l_tabname         TYPE tabname,
          l_aliasname       TYPE string,
          l_texttabname     TYPE dd08v-tabname,
          lstr              TYPE string,
          fpopup            TYPE c,
          l_ok_code         TYPE sy-ucomm,
          l_selected_node   TYPE lvc_nkey,
          l_fieldname       TYPE lvc_fname,
          ls_selected_nodes TYPE lvc_s_nkey,
          lt_selected_nodes TYPE lvc_t_nkey,
          l_node_key        TYPE lvc_nkey,
          l_new_node_key    TYPE lvc_nkey,
          l_nodetext        TYPE lvc_value,
          l_command         TYPE REF TO lcl_command,
          ls_table_alias_tb LIKE LINE OF l_command->table_alias_tb.


    CHECK g_commands->current_command IS NOT INITIAL.

*new*
    IF fcode+2(3) EQ 'LA_' OR fcode(5) EQ 'RELAT'.

      CALL METHOD handle_lq_ctx_sel
        EXPORTING
          sender  = 'T'
          e_ucomm = fcode
        EXCEPTIONS
          OTHERS  = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ELSEIF fcode = 'GET_TABLES'.

      CALL METHOD g_commands->parse_only_command
        EXCEPTIONS
          no_id        = 1
          create_error = 2
          no_parent    = 3
          parse_error  = 4
          OTHERS       = 5.

      CASE sy-subrc.
        WHEN 1.
*          message s077 DISPLAY LIKE 'E'.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty        = 'S'
              iv_msgno        = '077'
              iv_display_like = 'E'.
          RETURN.
        WHEN 2.
*          message s076 DISPLAY LIKE 'E'.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty        = 'S'
              iv_msgno        = '076'
              iv_display_like = 'E'.
          RETURN.
        WHEN 3.
*          MESSAGE s050 DISPLAY LIKE 'E'.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty        = 'S'
              iv_msgno        = '050'
              iv_display_like = 'E'.
          RETURN.
        WHEN 4.
*  this would override detailed information
*          message s079 DISPLAY LIKE 'E'.
          RETURN.
        WHEN 5.
          RETURN.

      ENDCASE.

      RETURN.

    ENDIF.

    CALL METHOD g_tree_tb->get_selected_nodes
      CHANGING
        ct_selected_nodes = lt_selected_nodes
      EXCEPTIONS
        cntl_system_error = 1
        dp_error          = 2
        failed            = 3
        OTHERS            = 4.

    IF sy-subrc <> 0.
      CALL METHOD g_application->issue_message
        EXPORTING
          iv_msgty = 'E'
          iv_msgno = '031'.
*      MESSAGE e031.
    ENDIF.

    READ TABLE lt_selected_nodes INTO ls_selected_nodes INDEX 1.

    IF sy-subrc EQ 0.

      l_node_key = ls_selected_nodes-node_key.

      CLEAR gs_outtab_tb.

      CALL METHOD g_tree_tb->get_outtab_line
        EXPORTING
          i_node_key     = l_node_key
        IMPORTING
*         E_NODE_TEXT    = l_nodetext
          e_outtab_line  = gs_outtab_tb
        EXCEPTIONS
          node_not_found = 1
          OTHERS         = 2.

      IF sy-subrc <> 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      IF gs_outtab_tb IS INITIAL AND fcode NE 'VRANGES'.
        EXIT.
      ENDIF.

*     MOVE gs_outtab_tb-tablename TO l_aliasname.
*     MOVE ls_table_alias_tb-alias TO l_aliasname.
      MOVE gs_outtab_tb-alias TO l_aliasname.

      l_command = g_commands->current_command.

      READ TABLE l_command->table_alias_tb INTO ls_table_alias_tb
        WITH KEY alias = l_aliasname.

      IF sy-subrc NE 0.
        RETURN.
      ENDIF.

      IF fcode = 'VRANGES'             AND
         ls_table_alias_tb-type NE 'T' AND
         ls_table_alias_tb-type NE 'V'.
        MESSAGE i121 DISPLAY LIKE 'W' WITH ls_table_alias_tb-table.
        RETURN.
      ENDIF.

      MOVE ls_table_alias_tb-table TO l_tabname.

*      IF l_aliasname IS INITIAL AND fcode EQ 'VRANGES'.
*        EXIT.
*      ENDIF.

    ELSE.
      RETURN.
    ENDIF.

    CASE fcode.

      WHEN 'GRAPH'.

        TYPE-POOLS: sdg1.
        DATA: obj_tab TYPE sdg1_obj,
              obj_def TYPE sdg1_obj1.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        obj_def-obj_name = l_tabname.
        obj_def-type     = 'TABL'.
        CLEAR obj_tab.
        APPEND obj_def TO obj_tab.

        CLEAR sy-msgno.
        CALL FUNCTION 'REPOSITORY_STRUCTURE_GRAPH'
          EXPORTING
            type    = 'TABL'
          TABLES
            OBJECTS = obj_tab
          EXCEPTIONS
            OTHERS  = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      WHEN 'DISPLAY'.

        DATA: lv_type TYPE string.

        CASE ls_table_alias_tb-type.

          WHEN 'T'.
            lv_type = 'TABL'.

          WHEN 'V'.
            lv_type = 'VIEW'.

          WHEN 'C'.
            lv_type = 'SQLT'.

          WHEN 'P'.
            lv_type = 'SQLT'.

        ENDCASE.

        CALL FUNCTION 'RS_TOOL_ACCESS'
          EXPORTING
            operation                 = 'SHOW'
            object_name               = l_tabname
            object_type               = lv_type
*           ENCLOSING_OBJECT          =
*           POSITION                  = ' '
*           DEVCLASS                  =
*           INCLUDE                   =
*           VERSION                   = ' '
*           MONITOR_ACTIVATION        = 'X'
*           WB_MANAGER                =
*           IN_NEW_WINDOW             =
*           WITH_OBJECTLIST           = ' '
*           WITH_WORKLIST             = ' '
*         IMPORTING
*           NEW_NAME                  =
*           WB_TODO_REQUEST           =
*         TABLES
*           OBJLIST                   =
         EXCEPTIONS
           not_executed              = 1
           invalid_object_type       = 2
           OTHERS                    = 3
                  .
        IF sy-subrc <> 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.


      WHEN 'TECH'.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        PERFORM mem_export.
        SET PARAMETER ID 'DTB' FIELD l_tabname.
        CALL TRANSACTION 'SE13' AND SKIP FIRST SCREEN.

      WHEN 'INDEXES'.

*       if ddxx-tabclass ne 'TRANSP'.
*         Indexpflege nur fr transparente Tabellen mglich
*         message s807.
*       else.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION 'DD_LIST_INDEX'
          EXPORTING
            objname = l_tabname
          IMPORTING
            fcode   = l_ok_code.


      WHEN 'RUNTIMEOBJ'.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        SUBMIT rutdbdsp AND RETURN WITH objname EQ l_tabname
                                   WITH display EQ 2.

*        SUBMIT rutntchk AND RETURN WITH tabname EQ l_tabname
*                                   WITH ttype   EQ 'TABL'
*                                   WITH status  EQ 'A'
*                                   WITH showonly EQ 'X'.

      WHEN 'TEXTTAB'.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION 'DDUT_TEXTTABLE_GET'
          EXPORTING
            tabname   = l_tabname
          IMPORTING
            texttable = l_texttabname.

        IF l_texttabname IS INITIAL.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty = 'I'
              iv_msgno = '032'
              iv_msgv1 = l_tabname.
*          MESSAGE i032 WITH l_tabname.
        ELSE.
          CLEAR fpopup.
          CALL DIALOG 'RS_DD_FIEL_SHOW'
            EXPORTING
              objname FROM l_texttabname.
        ENDIF.


      WHEN 'CONTENTS'.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION 'RS_NAVIGATION_BREAK'.

        CLEAR sy-msgno.
        CALL FUNCTION 'RS_TOOL_ACCESS'
             EXPORTING
                  operation   = 'TAB_CONT'
                  object_name = l_tabname
                  object_type = 'TABL'
             EXCEPTIONS
                  not_executed.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.

        ENDIF.

        CALL FUNCTION 'RS_NAVIGATION_BREAK_RESET'.


      WHEN 'WHERE'.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION 'RS_NAVIGATION_BREAK'.

        CLEAR sy-msgno.
        CALL FUNCTION 'RS_TOOL_ACCESS'
          EXPORTING
            operation          = 'CROSSREF'
            object_name        = l_tabname
            object_type        = 'DT'
            monitor_activation = 'X'
          EXCEPTIONS
            OTHERS             = 01.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CALL FUNCTION 'RS_NAVIGATION_BREAK_RESET'.
* VRANGES
      WHEN 'VRANGES'.

        DATA: it_fdiff       TYPE TABLE OF field_dif,
              it_dfies       TYPE TABLE OF dfies,
              is_dfies       TYPE dfies,
              is_fdiff       TYPE field_dif,
              lt_tables      TYPE TABLE OF rsdstabs,
              is_tables      TYPE rsdstabs,
              lt_ranges      TYPE rsds_trange,
              ls_range2      LIKE LINE OF lt_ranges, " TYPE rsds_range, "lty_zhdb_vrange-rsds_range,
              it_ranges2     TYPE rsds_trange,
              is_ranges2     LIKE LINE OF it_ranges2,
              is_ranges      LIKE LINE OF l_command->it_ranges,
              l_tabix        TYPE i,
              it_frange      TYPE rsds_frange_t,
              is_frange      LIKE LINE OF it_frange,
              ls_frange2     LIKE LINE OF it_frange,
              it_where       TYPE rsds_twhere,
              is_where       TYPE rsds_where,
              l_where_text   TYPE string,
              ls_alias_range LIKE LINE OF l_command->mt_alias_ranges,
              ls_rangename   TYPE lvc_value,
              lt_where       TYPE rsds_twhere,
              ls_where       TYPE rsds_where,
              ls_range       LIKE LINE OF l_command->mt_ranges,
              l_line         LIKE LINE OF ls_where-where_tab,
              ls_node_style  TYPE lvc_s_layn,

              lt_field_desc  TYPE TABLE OF fldconvert,
              ls_field_desc  TYPE fldconvert,

              lt_fields      TYPE TABLE OF rsdsfields,
              ls_fields      TYPE rsdsfields.

        CLEAR lt_tables.

        CHECK l_command IS NOT INITIAL.

        READ TABLE l_command->mt_alias_ranges INTO ls_alias_range
          WITH KEY table_alias = l_aliasname.

        IF sy-subrc EQ 0.

*          if ls_table_alias_tb-type = 'C' or ls_table_alias_tb-type = 'P'.
*
*            LOOP AT l
*
*          endif.

          l_tabix = sy-tabix.

          READ TABLE l_command->it_ranges INTO is_ranges
          WITH KEY alias = l_aliasname.

          IF sy-subrc EQ 0.

            CLEAR lt_ranges.

            APPEND is_ranges-rsds_range TO lt_ranges.

            CALL FUNCTION 'FREE_SELECTIONS_RANGE_2_EX'
              EXPORTING
                field_ranges = lt_ranges
              IMPORTING
                expressions  = ls_alias_range-expr.

            LOOP AT lt_ranges INTO is_ranges2.

              LOOP AT is_ranges2-frange_t INTO is_frange.

                ls_fields-tablename = l_tabname.
                ls_fields-fieldname = is_frange-fieldname.

                APPEND ls_fields TO lt_fields.

              ENDLOOP.

            ENDLOOP.

          ENDIF.

        ENDIF.

        REFRESH: it_fdiff.
        is_fdiff-tabname = l_tabname.

        CLEAR it_dfies.
        CLEAR sy-msgno.

        CALL FUNCTION 'DDIF_NAMETAB_GET'
          EXPORTING
            tabname   = l_tabname
          IMPORTING
            x030l_wa  = l_command->is_x030l
          TABLES
            dfies_tab = it_dfies
          EXCEPTIONS
            OTHERS    = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        IF l_command->is_x030l IS INITIAL.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty = 'E'
              iv_msgno = '033'
              iv_msgv1 = l_tabname.
*          MESSAGE e033 WITH l_tabname.
*       ELSEIF l_command->is_x030l-tabtype NE 'T'.
*         message 'ZENITH:is not selectable' TYPE 'E'.
*       ELSEIF l_command->is_x030l-align NE 0.
*         message 'ZENITH:has alignment - cannot continue' TYPE 'E'.
        ENDIF.

        is_tables-prim_tab = ls_table_alias_tb-table.
        APPEND is_tables TO lt_tables.

        IF ls_alias_range-sel_id IS INITIAL.
*         Init free selection dialog
          CLEAR sy-msgno.
          CALL FUNCTION 'FREE_SELECTIONS_INIT'
            EXPORTING
              expressions  = ls_alias_range-expr
            IMPORTING
              selection_id = ls_alias_range-sel_id
              expressions  = ls_alias_range-expr
            TABLES
              tables_tab   = lt_tables
              fields_tab   = lt_fields
              field_desc   = lt_field_desc
            EXCEPTIONS
              OTHERS       = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.
        ENDIF.

*       Display free selection dialog
        CLEAR sy-msgno.
        CALL FUNCTION 'FREE_SELECTIONS_DIALOG'
          EXPORTING
            selection_id            = ls_alias_range-sel_id
            title                   = text-077
            as_window               = 'X'
          IMPORTING
            expressions             = ls_alias_range-expr
            field_ranges            = lt_ranges
            number_of_active_fields = ls_alias_range-active
          TABLES
            fields_tab              = ls_alias_range-fields
          EXCEPTIONS
            OTHERS                  = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
          EXIT.
        ENDIF.

        LOOP AT lt_ranges INTO ls_range2.
          DELETE l_command->it_ranges WHERE alias = l_aliasname.

          is_ranges-alias      = l_aliasname.
          is_ranges-rsds_range = ls_range2.
          APPEND is_ranges TO l_command->it_ranges.
        ENDLOOP.

        IF sy-subrc EQ 4.
          CLEAR l_command->it_ranges.
        ENDIF.

        ls_node_style-n_image = '@1E@'.

        MODIFY l_command->mt_alias_ranges FROM ls_alias_range INDEX l_tabix.

        READ TABLE lt_ranges INTO ls_range2 INDEX 1.

        it_frange = ls_range2-frange_t.

        LOOP AT l_command->mt_outtab_tb INTO gs_outtab_tb
             WHERE alias = l_aliasname    AND
                   fieldname IS NOT INITIAL.

          READ TABLE it_frange INTO is_frange
            WITH KEY fieldname = gs_outtab_tb-fieldname.

          IF sy-subrc NE 0.
            DELETE l_command->mt_outtab_tb
              WHERE alias     = l_aliasname              AND
                    fieldname = gs_outtab_tb-fieldname.

            DELETE l_command->mt_ranges
              WHERE table_alias = l_aliasname            AND
                    fieldname   = gs_outtab_tb-fieldname.
          ENDIF.

        ENDLOOP.

        LOOP AT it_frange INTO is_frange.

          CLEAR: it_ranges2, is_ranges2.
          is_ranges2-tablename = is_ranges-rsds_range-tablename.
          CLEAR ls_frange2.
          APPEND is_frange TO is_ranges2-frange_t.
          APPEND is_ranges2 TO it_ranges2.

          CALL FUNCTION 'FREE_SELECTIONS_RANGE_2_WHERE'
            EXPORTING
              field_ranges  = it_ranges2
            IMPORTING
              where_clauses = lt_where.

          READ TABLE lt_where INTO ls_where INDEX 1.

          CLEAR l_where_text.
          LOOP AT ls_where-where_tab INTO l_line.
            CONCATENATE l_where_text l_line-line INTO l_where_text SEPARATED BY ' '.
          ENDLOOP.

          CONDENSE l_where_text.

          IF l_where_text IS INITIAL.
            DELETE l_command->mt_outtab_tb
              WHERE alias       = l_aliasname AND
                    fieldname   = is_frange-fieldname.

            DELETE l_command->mt_ranges
              WHERE table_alias = l_aliasname AND
                    fieldname   = is_frange-fieldname.

            EXIT.
          ENDIF.

          READ TABLE l_command->mt_outtab_tb INTO gs_outtab_tb
            WITH KEY tablename = l_tabname
                     fieldname = is_frange-fieldname.

          IF sy-subrc NE 0.

            MOVE l_where_text TO gs_outtab_tb-ddtext.
*           CLEAR gs_outtab_tb-ddtext.
            gs_outtab_tb-alias     = l_aliasname.
            gs_outtab_tb-fieldname = is_frange-fieldname.

            CONCATENATE 'R_' l_aliasname '_' gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY ''.
            REPLACE ' ' WITH '' INTO ls_rangename.
            CONDENSE ls_rangename NO-GAPS.

            APPEND gs_outtab_tb TO l_command->mt_outtab_tb.

            READ TABLE l_command->mt_tab_node_xref INTO gs_tab_node_xref
              WITH KEY alias = l_aliasname.
*              WITH KEY tablename = l_tabname.

            CLEAR l_new_node_key.
            CALL METHOD g_tree_tb->add_node
              EXPORTING
                i_relat_node_key = gs_tab_node_xref-node_key
                i_relationship   = cl_gui_column_tree=>relat_last_child
                is_outtab_line   = gs_outtab_tb
                i_node_text      = ls_rangename
                is_node_layout   = ls_node_style
              IMPORTING
                e_new_node_key   = l_new_node_key
              EXCEPTIONS
                OTHERS           = 1.

            IF sy-subrc NE 0.
              IF sy-msgno IS NOT INITIAL.
                MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
              ENDIF.
            ENDIF.

*          READ TABLE l_command->mt_ranges INTO gs_ranges
*          WITH KEY tablename = is_ranges-tablename fieldname = is_frange-fieldname.
**            gs_ranges-node_text = ls_rangename.
*          MODIFY l_command->mt_ranges FROM gs_ranges INDEX sy-tabix.

*          CALL METHOD g_tree_tb->EXPAND_NODE
*            EXPORTING
*              I_NODE_KEY = gs_tab_node_xref-node_key.

          ELSE.
            MOVE l_where_text TO gs_outtab_tb-ddtext.
            MODIFY l_command->mt_outtab_tb FROM gs_outtab_tb INDEX sy-tabix.
          ENDIF.

          READ TABLE l_command->mt_ranges INTO gs_ranges
            WITH KEY table_alias = l_aliasname
                     fieldname   = is_frange-fieldname.

          IF sy-subrc EQ 0.
            gs_ranges-where_text = l_where_text.
            gs_ranges-range      = is_frange-selopt_t.

            MODIFY l_command->mt_ranges FROM gs_ranges INDEX sy-tabix.
          ELSE.
            CLEAR gs_ranges.
*           gs_ranges-node_key    = l_new_node_key.
            gs_ranges-table_alias = l_aliasname.
            gs_ranges-fieldname   = is_frange-fieldname.
            gs_ranges-where_text  = l_where_text.
            gs_ranges-node_text   = ls_rangename.
            gs_ranges-range       = is_frange-selopt_t.

            APPEND gs_ranges TO l_command->mt_ranges.
          ENDIF.

        ENDLOOP.

        CLEAR sy-msgno.
        CALL METHOD g_tree_tb->frontend_update
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CLEAR sy-msgno.
        CALL METHOD cl_gui_cfw=>dispatch
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ENDIF.

        CLEAR sy-msgno.
        CALL METHOD display_table_grid
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ENDIF.

    ENDCASE.

  ENDMETHOD.                    "lcl_application



  METHOD handle_user_command.

    DATA: lt_rows          TYPE lvc_t_row,
          l_select_command TYPE REF TO lcl_select_command,
          lv_valid         TYPE c,
          lv_bool          TYPE c,
          l_lines          TYPE i,
          lt_index_rows    TYPE lvc_t_row,
          ls_index_rows    TYPE lvc_s_row,
          l_index          TYPE i,

          l_s_c            TYPE REF TO lcl_select_command,
          l_lawb           TYPE REF TO lcl_lawb,
          l_select         TYPE REF TO lcl_select_command,

          ls_celltab       TYPE lvc_s_styl,
          lt_cells         TYPE lvc_t_cell,

          ls_row           TYPE lvc_s_row,
          ls_column_id     TYPE lvc_s_col,
          ls_row_no        TYPE lvc_s_roid,

          lv_from          TYPE i,
          lv_to            TYPE i,
          lv_mod           TYPE i,
          lv_max_page      TYPE i,

          lt_col           TYPE lvc_t_col,
          ls_col           TYPE lvc_s_col,
          lv_lines         TYPE i,
          ls_fcat          TYPE lvc_s_fcat,
          lv_tabix         TYPE i,

          ls_fieldinfo_tb  LIKE LINE OF l_s_c->fieldinfo_tb,

          lv_tabname       TYPE tabname,
          l_ans            TYPE c,

          lv_subrc         TYPE i,

          ls_fieldinfo     TYPE lty_zhtdb_fieldinfo,
          lt_fieldinfo     TYPE TABLE OF lty_zhtdb_fieldinfo,

          ls_table_alias   LIKE LINE OF l_select->table_alias_tb.

    FIELD-SYMBOLS: <lt_style> TYPE lvc_t_styl,
                   <lt_icon> TYPE ANY.


    TRY.
        l_select_command ?= g_commands->current_command.
      CATCH cx_sy_move_cast_error.
*      message 'ZENITH:Casting error33' TYPE 'E'.
    ENDTRY.

    CALL METHOD g_alv->get_selected_cells
      IMPORTING
        et_cell = lt_cells
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_alv->get_current_cell
      IMPORTING
        es_row_id = ls_row
        es_col_id = ls_column_id
        es_row_no = ls_row_no
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CASE e_ucomm.

      WHEN 'TXT_SHTXT'  OR
           'TXT_GENFLD' OR
           'TXT_ALIAS'  OR
           'TXT_FLD'.

        CALL METHOD me->set_column_settings
          EXPORTING
            p_mode = e_ucomm.

        CALL METHOD me->set_column_headings.
        CALL METHOD me->refresh_display.

      WHEN 'KEY_NONE' OR
           'KEY_FIX'.

        CALL METHOD me->set_key_field_settings
          EXPORTING
            p_mode = e_ucomm.

        CALL METHOD me->set_key_display_attributes.
        CALL METHOD me->refresh_display.

    ENDCASE.

    TRY.
        l_select ?= g_commands->current_command.

        IF l_select->mv_last_display EQ 'G'.
          CALL METHOD g_alv->set_selected_cells
            EXPORTING
              it_cells = lt_cells
            EXCEPTIONS
              OTHERS   = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

          CALL METHOD g_alv->set_current_cell_via_id
            EXPORTING
              is_row_id    = ls_row
              is_column_id = ls_column_id
              is_row_no    = ls_row_no
            EXCEPTIONS
              OTHERS       = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

        ENDIF.

      CATCH cx_sy_move_cast_error.
    ENDTRY.

  ENDMETHOD.                    "lcl_application



  METHOD read_checktables.


    DATA: dd08v_ia TYPE TABLE OF dd08v,
          dd05m_ia TYPE TABLE OF dd05m,
          wa_dd08v_ia TYPE dd08v,
          wa_dd05m_ia TYPE dd05m,
          state(1),
          l_tabname TYPE dd08l-tabname,

          ls_dd08l TYPE dd08l,
          lt_dd08l TYPE TABLE OF dd08l,
          ls_table_alias LIKE LINE OF g_commands->current_command->table_alias_tb,
          lstr(40) TYPE c,
          lstr4(40) TYPE c,
          lstr2 TYPE string,
          lstr3 TYPE string,
          lstr5 TYPE string,
          lint TYPE i,
          ls_prev_linkedquery LIKE gs_linkedquery,
          ls_linkedquery LIKE gs_linkedquery,
          lt_linkedquery LIKE gt_linkedquery,
          l_ddtext TYPE dd02t-ddtext,
          l_text(40) TYPE c,
          l_comp_text(40) TYPE c.


    DATA: ls_info_tablf TYPE lty_zhtdb_checktable_struc,
          lt_info_tablf TYPE TABLE OF lty_zhtdb_checktable_struc,

          ls_info_tablf_out TYPE lty_zhtdb_checktable_struc_alv,
          lt_info_tablf_out TYPE TABLE OF lty_zhtdb_checktable_struc_alv,

          ls_selected_nodes TYPE lvc_s_nkey,
          lt_selected_nodes TYPE lvc_t_nkey,
          l_node_key TYPE lvc_nkey,
          l_new_node_key TYPE lvc_nkey,
          l_nodetext TYPE lvc_value,

          l_command TYPE REF TO lcl_command,
          ls_table_alias_tb LIKE LINE OF l_command->table_alias_tb.


    IF sender = 'T'.

      CALL METHOD g_tree_tb->get_selected_nodes
        CHANGING
          ct_selected_nodes = lt_selected_nodes
        EXCEPTIONS
          cntl_system_error = 1
          dp_error          = 2
          failed            = 3
          OTHERS            = 4.
      IF sy-subrc <> 0.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty = 'E'
            iv_msgno = '031'.
*        MESSAGE e031.
      ENDIF.


      READ TABLE lt_selected_nodes INTO ls_selected_nodes INDEX 1.

      l_node_key = ls_selected_nodes-node_key.

      CALL METHOD g_tree_tb->get_outtab_line
        EXPORTING
          i_node_key     = l_node_key
        IMPORTING
*          E_NODE_TEXT    = l_nodetext
          e_outtab_line  = gs_outtab_tb
        EXCEPTIONS
          node_not_found = 1
          OTHERS         = 2.

      l_tabname = gs_outtab_tb-tablename.

    ELSEIF sender = 'G'.
* obsolete
      RETURN.
    ENDIF.

    CLEAR gt_linkedquery.
    CLEAR lint.

    CLEAR lt_dd08l.

    READ TABLE g_commands->current_command->table_alias_tb INTO ls_table_alias
    WITH KEY table = l_tabname.

    SELECT info_tablf~tabname info_tablf~fieldname info_tablf~forkey info_tablf~primpos
    INTO CORRESPONDING FIELDS OF TABLE lt_info_tablf
    FROM info_tablf INNER JOIN dd02l ON info_tablf~tabname = dd02l~tabname
    WHERE info_tablf~checktable = l_tabname AND dd02l~tabclass = 'TRANSP'.

    LOOP AT lt_info_tablf INTO ls_info_tablf.

      CLEAR: dd05m_ia, dd08v_ia.

      CALL FUNCTION 'DD_TBFK_GET'
           EXPORTING
                fieldname     = '*'
                get_state     = 'A'
                tabl_name     = ls_info_tablf-tabname
                withtext      = 'X'
           IMPORTING
                got_state     = state
           TABLES
                dd05m_tab_a   = dd05m_ia
*                DD05M_TAB_N   = FK1_DD05M
                dd08v_tab_a   = dd08v_ia
*                DD08V_TAB_N   = FK1_DD08V
           EXCEPTIONS
                illegal_value = 01.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      LOOP AT dd05m_ia INTO wa_dd05m_ia WHERE checktable = l_tabname.

        lint = lint + 1.

        SELECT SINGLE ddtext
        INTO l_ddtext
        FROM dd02t
        WHERE tabname = wa_dd05m_ia-tabname
              AND ddlanguage = sy-langu.

        IF sy-subrc NE 0.

          SELECT SINGLE ddtext
          INTO l_ddtext
          FROM dd02t
          WHERE as4local = 'A'
                AND tabname = wa_dd05m_ia-tabname.

          IF sy-subrc NE 0.
*            message 'ZENITH:sdfgdsf' type 'E'.
          ENDIF.

        ENDIF.

        CONCATENATE wa_dd05m_ia-tabname '~' wa_dd05m_ia-checkfield INTO lstr2.
        CONDENSE lstr2 NO-GAPS.
        CONCATENATE ls_table_alias-alias '~' wa_dd05m_ia-forkey INTO lstr3.
        CONDENSE lstr3 NO-GAPS.
        CONCATENATE 'ON' lstr3 '=' lstr2 INTO lstr2 SEPARATED BY ' '.

        MOVE lstr2 TO lstr.

        lstr2 = lint.

        CLEAR gs_linkedquery.
        gs_linkedquery-tabname     = ls_table_alias-alias.
        gs_linkedquery-checktable  = wa_dd05m_ia-tabname.
        gs_linkedquery-fieldname   = wa_dd05m_ia-forkey.
        gs_linkedquery-checkfield  = wa_dd05m_ia-checkfield.
        gs_linkedquery-primpos     = wa_dd05m_ia-primpos.
        gs_linkedquery-text        = lstr.
        gs_linkedquery-longtext    = lstr.
        gs_linkedquery-ddtext      = l_ddtext.

        APPEND gs_linkedquery TO gt_linkedquery.

      ENDLOOP.

    ENDLOOP.


    DATA: l_comp_count TYPE i,
          lt_primpos TYPE TABLE OF gty_linkedquery-primpos,
          l_primpos TYPE gty_linkedquery-primpos.

    CLEAR gt_linkedquery_comp.

    SORT gt_linkedquery BY checktable tabname primpos fieldname checkfield .
    DELETE ADJACENT DUPLICATES FROM gt_linkedquery COMPARING checktable tabname primpos fieldname checkfield.

    LOOP AT gt_linkedquery INTO gs_linkedquery.

*      if ls_prev_linkedquery-checktable NE gs_linkedquery-checktable OR
*           ls_prev_linkedquery-tabname NE gs_linkedquery-tabname.

      AT END OF checktable.

        CLEAR: l_comp_count.
        CLEAR lt_primpos.
        CLEAR lstr2.

        lstr4 = '* ON'.

        LOOP AT gt_linkedquery INTO ls_linkedquery
          WHERE tabname         = ls_prev_linkedquery-tabname
                AND checktable  = ls_prev_linkedquery-checktable.
*                AND join_type   = ls_prev_linkedquery-join_type.


          READ TABLE lt_primpos TRANSPORTING NO FIELDS
            WITH KEY table_line = ls_linkedquery-primpos.

          IF sy-subrc EQ 4.

            CONCATENATE ls_linkedquery-tabname '~' ls_linkedquery-checkfield INTO lstr5.
            CONDENSE lstr5  NO-GAPS.

            CONCATENATE ls_linkedquery-checktable '~' ls_linkedquery-fieldname INTO lstr3.
            CONDENSE lstr3 NO-GAPS.

            CONCATENATE lstr4 lstr3 INTO lstr4 SEPARATED BY space.

            IF lstr2 IS INITIAL.
              CONCATENATE 'ON' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
            ELSE.
              CONCATENATE lstr2 'AND' lstr3 '=' lstr5 INTO lstr2 SEPARATED BY ' '.
            ENDIF.

            APPEND ls_linkedquery-primpos TO lt_primpos.

            l_comp_count = l_comp_count + 1.

          ENDIF.

        ENDLOOP.

        IF l_comp_count GT 0.

          READ TABLE gt_linkedquery_comp TRANSPORTING NO FIELDS
            WITH KEY tabname    = ls_linkedquery-tabname
                     checktable = ls_linkedquery-checktable
                     text   = lstr4.
*                     longtext   = lstr2.

          IF sy-subrc EQ 4.

            gs_linkedquery_comp-tabname    = ls_linkedquery-tabname.
            gs_linkedquery_comp-checktable = ls_linkedquery-checktable.
            gs_linkedquery_comp-text       = lstr4.
            gs_linkedquery_comp-longtext   = lstr2.
            gs_linkedquery_comp-join_type  = ls_linkedquery-join_type.
            gs_linkedquery_comp-ddtext     = ls_linkedquery-ddtext.

            APPEND gs_linkedquery_comp TO gt_linkedquery_comp.

          ENDIF.

        ENDIF.

      ENDAT.

      ls_prev_linkedquery = gs_linkedquery.

*      if ls_prev_linkedquery-checktable NE gs_linkedquery-checktable.
*
*        CONCATENATE '(' gs_linkedquery-ddtext ')' INTO l_ddtext.
*        CONCATENATE gs_linkedquery-checktable l_ddtext INTO lstr SEPARATED BY ' '.
*
*      endif.

    ENDLOOP.


    LOOP AT gt_linkedquery_comp INTO gs_linkedquery_comp.

      CLEAR ls_info_tablf_out.

      MOVE-CORRESPONDING gs_linkedquery_comp TO ls_info_tablf_out.

      ls_info_tablf_out-tabname = gs_linkedquery_comp-checktable.

      APPEND ls_info_tablf_out TO lt_info_tablf_out.

    ENDLOOP.

*    CONCATENATE 'Checktable Relationships for ' l_tabname INTO lstr SEPARATED BY ' '.
    MESSAGE i037 WITH l_tabname INTO lstr.

    DELETE lt_info_tablf_out WHERE tabname = l_tabname.

    DATA: ls_selfield TYPE slis_selfield,
          lt_fcat_slis TYPE slis_t_fieldcat_alv,
          ls_fcat_slis TYPE slis_fieldcat_alv.

    ls_fcat_slis-col_pos       = 1.
    ls_fcat_slis-fieldname     = 'TABNAME'.
    ls_fcat_slis-rollname      = 'AS4TAB'.
    ls_fcat_slis-reptext_ddic  = 'Table name'.
    ls_fcat_slis-outputlen = 20.
    APPEND ls_fcat_slis TO lt_fcat_slis.

    ls_fcat_slis-col_pos       = 2.
    ls_fcat_slis-fieldname     = 'DDTEXT'.
    ls_fcat_slis-rollname      = 'AS4TEXT'.
    ls_fcat_slis-reptext_ddic  = 'Short text'.
    ls_fcat_slis-outputlen = 50.
    APPEND ls_fcat_slis TO lt_fcat_slis.

    ls_fcat_slis-col_pos       = 3.
    ls_fcat_slis-fieldname     = 'LONGTEXT'.
    ls_fcat_slis-rollname      = 'CHAR_512'.
    ls_fcat_slis-reptext_ddic  = 'Join condition'.
    ls_fcat_slis-outputlen = 512.
    APPEND ls_fcat_slis TO lt_fcat_slis.


    CALL FUNCTION 'REUSE_ALV_POPUP_TO_SELECT'
      EXPORTING
       i_title                       = lstr
*       I_SELECTION                   = 'X'
*       I_ALLOW_NO_SELECTION          =
       i_zebra                       = ' '
       i_screen_start_column         = 3
       i_screen_start_line           = 2
       i_screen_end_column           = 200
       i_screen_end_line             = 30
*       I_CHECKBOX_FIELDNAME          =
*       I_LINEMARK_FIELDNAME          =
*       I_SCROLL_TO_SEL_LINE          = 'X'
       it_fieldcat                   = lt_fcat_slis
       i_tabname                     = 'L+FASY'
*       IT_EXCLUDING                  =
*       I_CALLBACK_PROGRAM            =
*       I_CALLBACK_USER_COMMAND       =
*       IS_PRIVATE                    =
     IMPORTING
       es_selfield                   = ls_selfield
*       E_EXIT                        =
      TABLES
        t_outtab                      = lt_info_tablf_out
     EXCEPTIONS
       program_error                 = 1
       OTHERS                        = 2
              .
    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    IF ls_selfield-tabindex IS NOT INITIAL.

      DATA:
            l_len TYPE i,
            l_jointext TYPE string,
            lt_jointext TYPE lty_zhtdbt_string_tab,
*            lt_jointext TYPE source_table,
            l_tablename TYPE gty_linkedquery-checktable,
            l_alias TYPE gty_linkedquery-checktable,
            l_jointype TYPE c,
            l_select TYPE REF TO lcl_select_command,
            l_selfae TYPE REF TO lcl_select_fae_command,
            l_from_text TYPE string,
            l_where_text TYPE string,
            l_gb_text TYPE string,
            l_ob_text TYPE string,
            l_new_from_text TYPE string,
            l_fdpos TYPE i,
            l_tabix TYPE i,
            l_ucomm TYPE sy-ucomm,
            l_selfae_alias TYPE string,
            ls_linkedquery_comp LIKE gs_linkedquery_comp.


      READ TABLE lt_info_tablf_out INTO ls_info_tablf_out
      INDEX ls_selfield-tabindex.

      IF sy-subrc NE 0.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty = 'I'
            iv_msgno = '027'.
*        MESSAGE i027.
      ENDIF.

      READ TABLE gt_linkedquery_comp INTO ls_linkedquery_comp
      WITH KEY checktable = ls_info_tablf_out-tabname.

      IF sy-subrc NE 0.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty = 'I'
            iv_msgno = '027'.
*        MESSAGE i027.
      ELSE.
        l_tablename    = ls_linkedquery_comp-checktable.
        l_jointext     = ls_linkedquery_comp-longtext.
        l_selfae_alias = ls_linkedquery_comp-tabname.
      ENDIF.

      TRY.

          l_select ?= g_commands->current_command.

          l_from_text   = l_select->from_text.
          l_gb_text     = l_select->group_by_text.
          l_ob_text     = l_select->order_by_text.
          l_where_text  = l_select->where_text.

        CATCH cx_sy_move_cast_error.

      ENDTRY.

      CHECK l_from_text IS NOT INITIAL.

      IF l_where_text IS NOT INITIAL.

        SEARCH g_commands->current_command->text FOR l_where_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_gb_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands->current_command->text FOR l_gb_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_ob_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands->current_command->text FOR l_ob_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ENDIF.

*      LOOP AT g_commands->current_command->table_alias_tb INTO ls_table_alias_tb WHERE TABLE = L_TABLENAME.
*
*      ENDLOOP.
      READ TABLE g_commands->current_command->table_alias_tb TRANSPORTING NO FIELDS
      WITH KEY table = l_tablename.

      IF sy-subrc EQ 4.
        l_alias = l_tablename.
      ELSE.
        lstr = sy-tabix + 1.
        CONCATENATE l_tablename lstr INTO l_alias.

        CONCATENATE l_tablename '~' INTO lstr.
        CONCATENATE l_alias '~' INTO lstr2.
        REPLACE ALL OCCURRENCES OF lstr IN l_jointext WITH lstr2.
      ENDIF.

      CASE i_ucomm.

        WHEN 'RELAT_I'.
          CONCATENATE 'INNER JOIN' l_tablename 'AS' l_alias l_jointext INTO l_jointext SEPARATED BY ' '.

        WHEN 'RELAT_O'.
          CONCATENATE 'LEFT OUTER JOIN' l_tablename 'AS' l_alias l_jointext INTO l_jointext SEPARATED BY ' '.

        WHEN 'RELAT_Q'.
          CONCATENATE '( SELECT' l_tablename 'AS' l_alias l_jointext ')' INTO l_jointext SEPARATED BY ' '.

        WHEN 'RELAT_S'.

          MOVE l_jointext+3 TO l_jointext.

          CONCATENATE l_selfae_alias '~' INTO l_selfae_alias.
          CONDENSE l_selfae_alias NO-GAPS.

          REPLACE ALL OCCURRENCES OF l_selfae_alias IN l_jointext WITH 'ZSQL_OUTER_TABLE-' IGNORING CASE.

          CONCATENATE 'SELECT * FROM' l_tablename INTO lstr2 SEPARATED BY ' '.
          APPEND lstr2 TO lt_jointext.

          lstr2 = 'FOR ALL ENTRIES IN ZSQL_OUTER_TABLE'.
          APPEND lstr2 TO lt_jointext.

          DATA: lt_jointext_temp LIKE lt_jointext.

          CONCATENATE 'WHERE' l_jointext INTO lstr2 SEPARATED BY ' '.

          CALL METHOD lcl_toolbox=>split_string
            EXPORTING
              iv_string     = lstr2
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext_temp.

*          CALL METHOD split_string_to_itab
*            EXPORTING
*              p_string = lstr2
*            IMPORTING
*              p_itab   = lt_jointext_temp.
*
          APPEND LINES OF lt_jointext_temp TO lt_jointext.

      ENDCASE.


      IF i_ucomm EQ 'RELAT_S'.

        CALL METHOD cl_gui_cfw=>set_new_ok_code
          EXPORTING
            new_code = 'NEWSELFOR'
          EXCEPTIONS
            OTHERS   = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        gt_selfae_jointext[] = lt_jointext[].

        RETURN.

      ELSE.

        IF STRLEN( l_jointext ) < gc_line_length.
          APPEND l_jointext TO lt_jointext.
        ELSE.

          CALL METHOD lcl_toolbox=>split_string
            EXPORTING
              iv_string     = l_jointext
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext.

*          CALL METHOD split_string_to_itab
*            EXPORTING
*              p_string = l_jointext
*            IMPORTING
*              p_itab   = lt_jointext.
*
        ENDIF.

      ENDIF.

*      IF l_fdpos IS NOT INITIAL.
*
*        INSERT LINES OF lt_jointext INTO g_commands->current_command->text INDEX l_tabix.
*
*      ELSE.
*
*        APPEND LINES OF lt_jointext TO g_commands->current_command->text.
*
*      ENDIF.

      CALL METHOD insert_stringtab_to_pos
        EXPORTING
          it_stringtab = lt_jointext.

      CALL METHOD g_commands->display_command.

    ENDIF.



  ENDMETHOD.                    "lcl_application


  METHOD handle_lq_ctx_sel.

    CALL METHOD g_commands->transfer_text_to_command.

    IF e_ucomm(5) EQ 'RELAT'.

      CALL METHOD read_checktables
        EXPORTING
          sender  = sender
          i_ucomm = e_ucomm.


    ENDIF.

    IF e_ucomm+2(3) EQ 'LA_'.

      DATA: lstr TYPE string,
            lstr2 TYPE string,
            lstr3 TYPE string,
            l_len TYPE i,
            l_jointext TYPE string,
            lt_jointext TYPE lty_zhtdbt_string_tab,
*            lt_jointext TYPE source_table,
            l_tablename TYPE gty_linkedquery-checktable,
            l_alias TYPE gty_linkedquery-checktable,
            l_jointype(3) TYPE c,
            l_select TYPE REF TO lcl_select_command,
            l_selfae TYPE REF TO lcl_select_fae_command,
            l_from_text TYPE string,
            l_where_text TYPE string,
            l_gb_text TYPE string,
            l_ob_text TYPE string,
            l_new_from_text TYPE string,
            l_fdpos TYPE i,
            l_tabix TYPE i,
            l_ucomm TYPE sy-ucomm,
            l_selfae_alias TYPE string,
            ls_linkedquery_comp LIKE gs_linkedquery_comp,
            ls_linkedquery LIKE gs_linkedquery,
            ls_table_alias_tb LIKE LINE OF g_commands->current_command->table_alias_tb.


      l_ucomm = e_ucomm.

**      SEARCH l_ucomm FOR '_COMP'.
**
**      IF sy-fdpos EQ 0.

      REPLACE ALL OCCURRENCES OF 'I_' IN l_ucomm WITH ''.
      IF sy-subrc EQ 0.
        l_jointype = 'I'.
      ENDIF.

      REPLACE ALL OCCURRENCES OF 'O_' IN l_ucomm WITH ''.
      IF sy-subrc EQ 0.
        l_jointype = 'O'.
      ENDIF.

      REPLACE ALL OCCURRENCES OF 'S_' IN l_ucomm WITH ''.
      IF sy-subrc EQ 0.
        l_jointype = 'S'.
      ENDIF.

      REPLACE ALL OCCURRENCES OF 'Q_' IN l_ucomm WITH ''.
      IF sy-subrc EQ 0.
        l_jointype = 'Q'.
      ENDIF.

      SEARCH l_ucomm FOR '_COMP'.

      IF sy-fdpos EQ 0.

        READ TABLE gt_linkedquery INTO ls_linkedquery
        WITH KEY fcode = l_ucomm.

        IF sy-subrc NE 0.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty = 'I'
              iv_msgno = '027'.
*            MESSAGE i027.
        ELSE.
          l_tablename    = ls_linkedquery-checktable.
          l_jointext     = ls_linkedquery-longtext.
          l_selfae_alias = ls_linkedquery-tabname.
        ENDIF.

      ELSE.

        READ TABLE gt_linkedquery_comp INTO ls_linkedquery_comp
        WITH KEY fcode = l_ucomm.

        IF sy-subrc NE 0.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty = 'I'
              iv_msgno = '027'.
*            MESSAGE i027.
        ELSE.
          l_tablename    = ls_linkedquery_comp-checktable.
          l_jointext     = ls_linkedquery_comp-longtext.
          l_selfae_alias = ls_linkedquery_comp-tabname.
        ENDIF.

      ENDIF.


      LOOP AT g_commands->current_command->table_alias_tb INTO ls_table_alias_tb WHERE TABLE = L_TABLENAME.

      ENDLOOP.

      IF sy-subrc EQ 4.
        l_alias = l_tablename.
      ELSE.
        lstr = sy-tabix + 1.
        CONCATENATE l_tablename lstr INTO l_alias.

        CONCATENATE l_tablename '~' INTO lstr.
        CONCATENATE l_alias '~' INTO lstr2.
        REPLACE ALL OCCURRENCES OF lstr IN l_jointext WITH lstr2.
      ENDIF.

      TRY.

          l_select ?= g_commands->current_command.

          l_from_text   = l_select->from_text.
          l_gb_text     = l_select->group_by_text.
          l_ob_text     = l_select->order_by_text.
          l_where_text  = l_select->where_text.

        CATCH cx_sy_move_cast_error.

      ENDTRY.

      CHECK l_from_text IS NOT INITIAL.

      IF l_where_text IS NOT INITIAL.

        SEARCH g_commands->current_command->text FOR l_where_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_gb_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands->current_command->text FOR l_gb_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_ob_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands->current_command->text FOR l_ob_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ENDIF.

      CASE l_jointype.

        WHEN 'I'.
          CONCATENATE 'INNER JOIN' l_tablename 'AS' l_alias l_jointext INTO l_jointext SEPARATED BY ' '.

        WHEN 'O'.
          CONCATENATE 'LEFT OUTER JOIN' l_tablename 'AS' l_alias l_jointext INTO l_jointext SEPARATED BY ' '.

        WHEN 'S'.

          MOVE l_jointext+3 TO l_jointext.

          CONCATENATE l_selfae_alias '~' INTO l_selfae_alias.
          CONDENSE l_selfae_alias NO-GAPS.

          REPLACE ALL OCCURRENCES OF l_selfae_alias IN l_jointext WITH 'ZSQL_OUTER_TABLE-' IGNORING CASE.

          CONCATENATE 'SELECT * FROM' l_tablename INTO lstr2 SEPARATED BY ' '.
          APPEND lstr2 TO lt_jointext.

          lstr2 = 'FOR ALL ENTRIES IN ZSQL_OUTER_TABLE'.
          APPEND lstr2 TO lt_jointext.

          DATA: lt_jointext_temp LIKE lt_jointext.

          CONCATENATE 'WHERE' l_jointext INTO lstr2 SEPARATED BY ' '.

          CALL METHOD lcl_toolbox=>split_string
            EXPORTING
              iv_string     = lstr2
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext_temp.

*          CALL METHOD split_string_to_itab
*            EXPORTING
*              p_string = lstr2
*            IMPORTING
*              p_itab   = lt_jointext_temp.
*
          APPEND LINES OF lt_jointext_temp TO lt_jointext.

        WHEN 'Q'.

          MOVE l_jointext+3 TO l_jointext.

*          CONCATENATE l_selfae_alias '~' INTO l_selfae_alias.
*          CONDENSE l_selfae_alias NO-GAPS.
*
*          REPLACE ALL OCCURRENCES OF l_selfae_alias IN l_jointext WITH l_tablename IGNORING CASE.

          CONCATENATE '( SELECT * FROM' l_tablename 'WHERE' l_jointext ')' INTO l_jointext SEPARATED BY ' '.

      ENDCASE.

      IF l_jointype NE 'S'.

        IF STRLEN( l_jointext ) < gc_line_length.
          APPEND l_jointext TO lt_jointext.
        ELSE.

          CALL METHOD lcl_toolbox=>split_string
            EXPORTING
              iv_string     = l_jointext
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext.

        ENDIF.

      ELSE.

        CALL METHOD cl_gui_cfw=>set_new_ok_code
          EXPORTING
            new_code = 'NEWSELFOR'
          EXCEPTIONS
            OTHERS   = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        gt_selfae_jointext[] = lt_jointext[].

        RETURN.

      ENDIF.

      CALL METHOD insert_stringtab_to_pos
        EXPORTING
          it_stringtab = lt_jointext.

      CALL METHOD g_commands->display_command.

    ENDIF.

  ENDMETHOD.                    "lcl_application


  METHOD refresh_display.

    DATA: ls_fcat          TYPE lvc_s_fcat,
          lt_fcat          TYPE lvc_t_fcat,
          ls_fieldinfo     TYPE gty_fieldinfo,
          l_lawb           TYPE REF TO lcl_lawb,
          lv_tabix         TYPE i,
          l_selfae         TYPE REF TO lcl_select_fae_command,
          l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands->current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.

    CHECK l_select_command IS NOT INITIAL.
    CHECK <gt_result> IS ASSIGNED.

    CALL METHOD g_alv->set_frontend_fieldcatalog
      EXPORTING
        it_fieldcatalog = l_select_command->fcat
      EXCEPTIONS
        OTHERS          = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_alv->refresh_table_display
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "refresh_display


  METHOD set_column_headings.

    DATA: ls_fcat          TYPE lvc_s_fcat,
          lt_fcat          TYPE lvc_t_fcat,
          ls_fieldinfo     TYPE gty_fieldinfo,
          l_lawb           TYPE REF TO lcl_lawb,
          lv_tabix         TYPE i,
          l_selfae         TYPE REF TO lcl_select_fae_command,
          l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands->current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.

    CHECK l_select_command IS NOT INITIAL.
    CHECK <gt_result> IS ASSIGNED.

    TRY.
        LOOP AT l_select_command->fcat INTO ls_fcat
             WHERE fieldname <> 'ZENITH_ROWID'    AND
                   fieldname <> 'ZENITH_SELECTED' AND
                   fieldname <> 'ZENITH_STYLE'    AND
                   fieldname <> 'ZENITH_COLOR'    AND
                   fieldname <> 'ZENITH_LOCKED_BY'.

          lv_tabix = sy-tabix.

          READ TABLE l_select_command->fieldinfo_tb INTO ls_fieldinfo
            WITH KEY generated_field = ls_fcat-fieldname.

          IF sy-subrc NE 0.
            CALL METHOD g_application->issue_message
              EXPORTING
                iv_msgty = 'E'
                iv_msgno = '027'.
          ENDIF.

          CASE l_select_command->mv_colmn_header.
            WHEN 'S'.

              IF l_select_command->mv_last_display = 'G'.
                CLEAR: ls_fcat-coltext,
                       ls_fcat-scrtext_l,
                       ls_fcat-scrtext_m,
                       ls_fcat-scrtext_s,
                       ls_fcat-reptext.
              ELSE.
                ls_fcat-coltext   = ls_fcat-reptext.
                ls_fcat-scrtext_l = ls_fcat-reptext.
                ls_fcat-scrtext_m = ls_fcat-reptext.
                ls_fcat-scrtext_s = ls_fcat-reptext.
                ls_fcat-reptext   = ls_fcat-reptext.
              ENDIF.

            WHEN 'G'.
              ls_fcat-coltext = ls_fieldinfo-generated_field.

            WHEN 'A'.

              IF ls_fieldinfo-field_alias IS NOT INITIAL.
                ls_fcat-coltext = ls_fieldinfo-field_alias.
              ELSE.
                ls_fcat-coltext = ls_fieldinfo-generated_field.
              ENDIF.

            WHEN 'T'.
              ls_fcat-coltext = ls_fieldinfo-orig_field.

          ENDCASE.

          MODIFY l_select_command->fcat FROM ls_fcat INDEX lv_tabix.
        ENDLOOP.


      CATCH cx_sy_move_cast_error.

    ENDTRY.

  ENDMETHOD.                    "lcl_application


  METHOD set_key_display_attributes.

    DATA: ls_fcat          TYPE lvc_s_fcat,
          l_char           TYPE c,
          l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands->current_command.

      CATCH cx_sy_move_cast_error.
        RETURN.
    ENDTRY.

    CHECK l_select_command IS NOT INITIAL.
    CHECK <gt_result> IS ASSIGNED.
    CHECK l_select_command->mv_last_display = 'G'.

*   set this property so it can be saved with the command

*   modify field catalog
    LOOP AT l_select_command->fcat INTO ls_fcat WHERE key_sel EQ 'X'.
      CASE l_select_command->mv_key_colmn_type.
        WHEN 'N'.
          CLEAR ls_fcat-key.
        WHEN 'F'.
          ls_fcat-key = 'X'.
      ENDCASE.

      MODIFY l_select_command->fcat FROM ls_fcat.
    ENDLOOP.

    gs_layo-no_keyfix = 'X'.

    CALL METHOD g_alv->set_frontend_layout
      EXPORTING
        is_layout = gs_layo
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    " set_key_display_attributes


  METHOD handle_menu_button.

    DATA: lv_display_only TYPE c.


    IF g_alv->is_ready_for_input( ) EQ 0.
      lv_display_only = 'X'.
    ELSE.
      lv_display_only = ' '.
    ENDIF.


    IF e_ucomm = 'TXT_MENU'.
      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'TXT_ALIAS'
          text   = text-081
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'TXT_FLD'
          text   = text-090
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'TXT_GENFLD'
          text   = text-091
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'TXT_SHTXT'
          text   = text-092
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object->add_separator
        EXCEPTIONS
          OTHERS = 1.

      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'KEY_FIX'
          text   = text-089
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object->add_function
        EXPORTING
          fcode  = 'KEY_NONE'
          text   = text-078
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    "lcl_application

ENDCLASS.                    "lcl_application IMPLEMENTATION

*&---------------------------------------------------------------------*
*&  Include           ZHTDB_LCLCOMMAND_I                               *
*&---------------------------------------------------------------------*


CLASS lcl_command IMPLEMENTATION.



  METHOD constructor.

    IF p_copy_from IS NOT INITIAL.

      it_ranges        = p_copy_from->it_ranges.
      is_x030l         = p_copy_from->is_x030l.

      mt_alias_ranges  = p_copy_from->mt_alias_ranges.
      mt_ranges        = p_copy_from->mt_ranges.
      mt_outtab_tb     = p_copy_from->mt_outtab_tb.
      mt_tab_node_xref = p_copy_from->mt_tab_node_xref.

      command_type     = p_copy_from->command_type.
      where_text       = p_copy_from->where_text.
      mv_dbcnt         = p_copy_from->mv_dbcnt.
      mv_bytes         = p_copy_from->mv_bytes.

      commandtext      = p_copy_from->commandtext.
      gen_commandtext  = p_copy_from->gen_commandtext.
      gen_text         = p_copy_from->gen_text.
      text             = p_copy_from->text.
      table_alias_tb   = p_copy_from->table_alias_tb.

    ENDIF.

  ENDMETHOD.                    "LCL_COMMAND



  METHOD execute_parsed_sql.

  ENDMETHOD.                    "LCL_COMMAND


  METHOD get_type.
    ep_command_type = me->command_type.
  ENDMETHOD.                    "LCL_COMMAND


  METHOD parse_commandtext.

  ENDMETHOD.                    "LCL_COMMAND


  METHOD set_commandtext.

    me->commandtext = p_commandtext.
    CONDENSE me->commandtext.
    CONCATENATE '' me->commandtext INTO me->commandtext SEPARATED BY ' '.

  ENDMETHOD.                    "LCL_COMMAND

ENDCLASS.                    "LCL_COMMAND IMPLEMENTATION



*&---------------------------------------------------------------------*
*&  Include           ZHTDB_LCLSELECT_I                                *
*&---------------------------------------------------------------------*


CLASS lcl_select_command IMPLEMENTATION.


  METHOD calculate_mv_rowlen.

    DATA: ls_fcat TYPE lvc_s_fcat.

    CLEAR mv_rowlen.

    LOOP AT fcat INTO ls_fcat
         WHERE fieldname NE 'ZENITH_ROWID'    AND
               fieldname NE 'ZENITH_SELECTED' AND
               fieldname NE 'ZENITH_STYLE'    AND
               fieldname NE 'ZENITH_COLOR'    AND
               fieldname NE 'ZENITH_LOCKED_BY'.
      mv_rowlen = mv_rowlen + ls_fcat-intlen.
    ENDLOOP.

  ENDMETHOD.                    " calculate_mv_rowlen


  METHOD constructor.

    CALL METHOD super->constructor
      EXPORTING
        p_copy_from = p_copy_from.

    CREATE OBJECT mo_pipacs_select.
    mo_pipacs_command = mo_pipacs_select.

    IF p_copy_from IS NOT INITIAL.

      select_text = p_copy_from->select_text.
      from_text = p_copy_from->from_text.
      group_by_text = p_copy_from->group_by_text.
      having_text = p_copy_from->having_text.
      order_by_text = p_copy_from->order_by_text.

      can_edit = p_copy_from->can_edit.

      has_table_alias = p_copy_from->has_table_alias.
      group_by_text = p_copy_from->group_by_text.
      alv_state = p_copy_from->alv_state.
      has_duplicate_fields = p_copy_from->has_duplicate_fields.

      ddic_references = p_copy_from->ddic_references.
      fieldinfo_tb = p_copy_from->fieldinfo_tb.
      prev_fcat = p_copy_from->prev_fcat.
      fcat = p_copy_from->fcat.

    ENDIF.

  ENDMETHOD.                    " constructor



  METHOD assign_field_symbols.

    UNASSIGN: <gt_result>,
              <gt_temp>,
              <gt_undo>,

              <gs_result>,
              <gs_temp>,
              <gs_undo>.

    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'R'
      CHANGING
        p_table = me->result_table.
****    CALL METHOD me->assign_field_symbol
****      EXPORTING
****        p_fs    = 'X'
****      CHANGING
****        p_table = me->display_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'D'
      CHANGING
        p_table = me->deleted_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'I'
      CHANGING
        p_table = me->inserted_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'U'
      CHANGING
        p_table = me->updated_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'T'
      CHANGING
        p_table = me->temp_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'N'
      CHANGING
        p_table = me->undo_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'L'
      CHANGING
        p_table = me->lawb_table.
    CALL METHOD me->assign_field_symbol
      EXPORTING
        p_fs    = 'S'
      CHANGING
        p_table = me->selfae_table.

  ENDMETHOD.                    " assign_field_symbols


  METHOD assign_field_symbol.

    CASE p_fs.
****      WHEN 'X'.
****        ASSIGN p_table->* TO <gt_display>.
*****        ASSIGN me->deleted_structure->* TO <gs_deleted>.

      WHEN 'R'.
        ASSIGN p_table->* TO <gt_result>.
        ASSIGN me->result_structure->* TO <gs_result>.

      WHEN 'T'.
        ASSIGN p_table->* TO <gt_temp>.
        ASSIGN me->temp_structure->* TO <gs_temp>.

      WHEN 'N'.
        ASSIGN p_table->* TO <gt_undo>.
        ASSIGN me->undo_structure->* TO <gs_undo>.

    ENDCASE.

  ENDMETHOD.                    " assign_field_symbol


  METHOD parse_commandtext.

    DATA: ls_table_alias LIKE LINE OF me->table_alias_tb,
          lv_idx TYPE string.


    CALL METHOD super->parse_commandtext
      EXPORTING
        p_on_load      = p_on_load
      EXCEPTIONS
        error_occurred = 1
        OTHERS         = 2.

    CASE sy-subrc.
      WHEN 1.
        RAISE error_occurred.
      WHEN 2.
        RAISE error_occurred.
    ENDCASE.

    CLEAR table_alias_tb.

    CALL METHOD mo_pipacs_command->parse
      EXCEPTIONS
        parse_error = 1
        OTHERS      = 2.

    IF sy-subrc <> 0.
      IF sy-msgno IS NOT INITIAL AND p_on_load IS INITIAL.
        IF p_bf_test IS INITIAL.
          MESSAGE ID sy-msgid TYPE 'S' NUMBER sy-msgno DISPLAY LIKE 'E'
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ELSE.
*          CALL METHOD g_application->add_message( iv_msgty = 'E' iv_msgid = sy-msgid iv_msgno = sy-msgno
*            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        ENDIF.

        RAISE error_occurred.
      ELSE.
        RAISE error_occurred.
      ENDIF.

    ENDIF.

    CALL METHOD mo_pipacs_select->get_texts
      IMPORTING
        ev_select_text   = select_text
        ev_from_text     = from_text
        ev_where_text    = where_text
        ev_group_by_text = group_by_text
        ev_having_text   = having_text
        ev_order_by_text = order_by_text.

    CALL METHOD mo_pipacs_select->get_fieldinfo
      IMPORTING
        et_fieldinfo = me->fieldinfo_tb.

    CALL METHOD mo_pipacs_select->get_table_alias
      IMPORTING
        et_table_alias = me->table_alias_tb.

    SORT me->table_alias_tb BY table alias.

    DELETE ADJACENT DUPLICATES FROM me->table_alias_tb COMPARING TABLE alias.

    can_edit = mo_pipacs_select->can_edit( ).

    LOOP AT me->table_alias_tb INTO ls_table_alias.
      IF ls_table_alias-alias IS INITIAL.
        ls_table_alias-alias = ls_table_alias-table.

        MODIFY me->table_alias_tb FROM ls_table_alias INDEX sy-tabix.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    " parse_commandtext



  METHOD execute_parsed_sql.

    DATA: l_root_exception               TYPE REF TO cx_root,
          lstr                           TYPE string,
          lstr3(10)                      TYPE c,
          lv_job_name                    TYPE btcjob,
          lv_job_count                   TYPE btcjobcnt,
          g_cx_dynamic_check             TYPE REF TO cx_dynamic_check,
          g_cx_sy_sql_error              TYPE REF TO cx_sy_sql_error,
          g_cx_sy_open_sql_error         TYPE REF TO cx_sy_open_sql_error,
          g_cx_sy_open_sql_db            TYPE REF TO cx_sy_open_sql_db,
          g_cx_sy_dynamic_osql_error     TYPE REF TO cx_sy_dynamic_osql_error,
          g_cx_sy_dynamic_osql_syntax    TYPE REF TO cx_sy_dynamic_osql_syntax,
          g_cx_sy_dynamic_osql_semantics TYPE REF TO cx_sy_dynamic_osql_semantics,
          l_bool                         TYPE c,
          l_sfae                         TYPE REF TO lcl_select_fae_command,
          lx_root                        TYPE REF TO cx_root,
          lv_message                     TYPE string,
          lt_fieldinfo                   TYPE lty_zhtdb_fieldinfo_tt,
          lt_data                        TYPE REF TO data,
          ls_celltab                     TYPE lvc_s_styl,
          ls_fcat                        TYPE lvc_s_fcat.

    FIELD-SYMBOLS: <lt_style> TYPE lvc_t_styl.

    CALL METHOD super->execute_parsed_sql
      EXPORTING
        iv_simulation    = iv_simulation
        iv_bg_proc       = iv_bg_proc
        iv_bg_date       = iv_bg_date
        iv_bg_time       = iv_bg_time
      EXCEPTIONS
        table_not_found  = 1
        parse_error      = 2
        exec_error       = 3
        error_occurred   = 4
        unlock_error     = 5
        arg_to_long      = 6
        foreign_lock     = 7
        job_submit_error = 8
        OTHERS           = 9.

    CASE sy-subrc.
      WHEN 1.
        RAISE table_not_found.
      WHEN 2.
        RAISE parse_error.
      WHEN 3.
        RAISE exec_error.
      WHEN 4.
        RAISE error_occurred.
      WHEN 5.
        RAISE unlock_error.
      WHEN 6.
        RAISE arg_to_long.
      WHEN 7.
        RAISE foreign_lock.
      WHEN 8.
        RAISE job_submit_error.
      WHEN 9.
        RAISE error_occurred.
    ENDCASE.

    CALL METHOD mo_pipacs_command->execute
      EXPORTING
        iv_simulation    = iv_simulation
        iv_bg_proc       = iv_bg_proc
        iv_bg_date       = iv_bg_date
        iv_bg_time       = iv_bg_time
      IMPORTING
        er_result        = returned_table
        ev_dbcnt         = mv_dbcnt
        er_lock_argument = mr_lock_argument_temp
        er_exc           = lx_root
        ev_job_name      = lv_job_name
        ev_job_count     = lv_job_count
        et_srccode       = et_srccode
      EXCEPTIONS
        parse_error      = 1
        exec_error       = 2
        job_submit_error = 3
        OTHERS           = 4.

    CASE sy-subrc.
      WHEN 1.
        RAISE parse_error.
      WHEN 3.
        RAISE job_submit_error.
      WHEN 2 OR 4.
        er_exception = lx_root.
        RAISE exec_error.
    ENDCASE.

    IF iv_simulation IS INITIAL AND
       iv_bg_proc    IS INITIAL.

      FIELD-SYMBOLS: <lt_returned> TYPE ANY TABLE, <ls_lock_arg> TYPE ANY.

      ASSIGN mr_lock_argument_temp->* TO <ls_lock_arg>.

      IF sy-subrc EQ 0.
        CREATE DATA me->mr_lock_argument LIKE <ls_lock_arg>.
      ENDIF.

      ASSIGN returned_table->* TO <lt_returned>.

      CREATE DATA me->result_table LIKE <lt_returned>.
      ASSIGN result_table->* TO <gt_result>.

      <gt_result>[] = <lt_returned>[].

      CREATE DATA me->display_table LIKE <gt_result>.
      ASSIGN display_table->* TO <gt_display>.

      CREATE DATA me->temp_table LIKE <gt_result>.
      ASSIGN temp_table->* TO <gt_temp>.

      CREATE DATA me->temp_table LIKE <gt_result>.
      ASSIGN temp_table->* TO <gt_temp>.

      CREATE DATA me->undo_table LIKE <gt_result>.
      ASSIGN undo_table->* TO <gt_undo>.

      CREATE DATA me->tree_table LIKE <gt_result>.
      ASSIGN tree_table->* TO <gt_tree>.


      CREATE DATA me->result_structure LIKE LINE OF <gt_result>.
      ASSIGN me->result_structure->* TO <gs_result>.

      CREATE DATA me->temp_structure LIKE LINE OF <gt_temp>.
      ASSIGN me->temp_structure->* TO <gs_temp>.

      CREATE DATA me->undo_structure LIKE LINE OF <gt_undo>.
      ASSIGN me->undo_structure->* TO <gs_undo>.

      ls_celltab-style = cl_gui_alv_grid=>mc_style_disabled.

      LOOP AT <gt_result> ASSIGNING <gs_result>.
        ASSIGN COMPONENT 'ZENITH_ROWID' OF STRUCTURE <gs_result> TO <gf_result>.
        <gf_result> = sy-tabix.

        ASSIGN COMPONENT 'ZENITH_STYLE' OF STRUCTURE <gs_result> TO <lt_style>.
        CLEAR <lt_style>.

        LOOP AT me->fcat INTO ls_fcat
             WHERE fieldname <> 'ZENITH_ROWID'    AND
                   fieldname <> 'ZENITH_SELECTED' AND
                   fieldname <> 'ZENITH_STYLE'    AND
                   fieldname <> 'ZENITH_COLOR'    AND
                   fieldname <> 'ZENITH_LOCKED_BY'.
          ls_celltab-fieldname = ls_fcat-fieldname.
          INSERT ls_celltab INTO TABLE <lt_style>.
        ENDLOOP.

        MODIFY <gt_result> FROM <gs_result>.
        gv_max_rowid = sy-tabix.
      ENDLOOP.

      CALL METHOD calculate_mv_rowlen.

      mv_bytes = mv_rowlen * mv_dbcnt.
    ENDIF.

  ENDMETHOD.                    " execute_parsed_sql

ENDCLASS.                    "LCL_SELECT_COMMAND IMPLEMENTATION




*&---------------------------------------------------------------------*
*&  Include           ZHTDB_LCLCOMMANDS_I                              *
*&---------------------------------------------------------------------*


CLASS lcl_commands IMPLEMENTATION.


  METHOD generate_structure.

    DATA: ls_fcat           TYPE lvc_s_fcat,
          ls_fieldinfo      TYPE lty_zhtdb_fieldinfo,
          lt_fieldinfo      TYPE lty_zhtdb_fieldinfo_tt,
*         ls_fieldinfo_copy LIKE LINE OF me->fieldinfo_tb,
*         lt_fieldinfo_copy LIKE me->fieldinfo_tb,
          lt_comp           TYPE abap_compdescr_tab,
          ls_comp           TYPE abap_compdescr,
          l_edescr          TYPE REF TO cl_abap_elemdescr,
          l_tdescr          TYPE REF TO cl_abap_typedescr,
          l_select          TYPE REF TO lcl_select_command,
          lstr              TYPE string,
          lstr2             TYPE string,
          length            TYPE i,
          oref              TYPE REF TO cx_root,
          ls_ref            TYPE gty_ddicref,
          ls_table_alias_tb LIKE LINE OF l_select->table_alias_tb,
          descr_struc_ref   TYPE REF TO cl_abap_structdescr.

    TRY.
        l_select ?= current_command.

        CLEAR l_select->fcat.
        CLEAR l_select->ddic_references.

*       build fieldcatalog

*      CALL METHOD l_select->mo_pipacs->get_fieldinfo
*        IMPORTING
*          et_fieldinfo = l_select->fieldinfo_tb.
*
        LOOP AT l_select->fieldinfo_tb INTO ls_fieldinfo.

          READ TABLE l_select->table_alias_tb INTO ls_table_alias_tb
            WITH KEY table = ls_fieldinfo-table.

          CLEAR ls_fcat.

          ls_fcat-col_opt = 'X'.

          IF ls_fieldinfo-agg_function IS NOT INITIAL.

            IF ls_fieldinfo-agg_function EQ 'COUNT'.
              ls_fcat-rollname = 'INT4'.
            ELSEIF ls_fieldinfo-agg_function EQ 'AVG'.
              ls_fcat-rollname = 'FLTP'.
            ENDIF.

            ls_fcat-fieldname = ls_fieldinfo-generated_field.
            TRANSLATE ls_fcat-fieldname TO UPPER CASE.

            IF ls_fieldinfo-field_alias IS NOT INITIAL.

              length = STRLEN( ls_fieldinfo-field_alias ) - 1.

              IF ls_fieldinfo-field_alias(1) = '''' AND ls_fieldinfo-field_alias+length = ''''.
                length = length - 1.
                MOVE ls_fieldinfo-field_alias+1(length) TO ls_fieldinfo-field_alias.
                MODIFY l_select->fieldinfo_tb FROM ls_fieldinfo INDEX sy-tabix.
              ENDIF.

              lstr = ls_fieldinfo-field_alias.
            ELSE.
              lstr = ls_fieldinfo-generated_field.
            ENDIF.

            TRANSLATE ls_fieldinfo-agg_function TO UPPER CASE.

            TRANSLATE ls_fieldinfo-field TO UPPER CASE.
            TRANSLATE ls_fieldinfo-table TO UPPER CASE.

            ls_fcat-ref_table = ls_fieldinfo-table.
            ls_fcat-ref_field = ls_fieldinfo-field.

          ELSE.    " agg_function is not initial

            ls_fcat-fieldname = ls_fieldinfo-generated_field.
            TRANSLATE ls_fcat-fieldname TO UPPER CASE.

            IF ls_fieldinfo-field_alias IS NOT INITIAL.

              length = STRLEN( ls_fieldinfo-field_alias ) - 1.

              IF ls_fieldinfo-field_alias(1) = '''' AND ls_fieldinfo-field_alias+length = ''''.
                length = length - 1.
                MOVE ls_fieldinfo-field_alias+1(length) TO ls_fieldinfo-field_alias.
                MODIFY l_select->fieldinfo_tb FROM ls_fieldinfo INDEX sy-tabix.
              ENDIF.

              lstr = ls_fieldinfo-field_alias.
            ELSE.
              lstr = ls_fieldinfo-generated_field.
            ENDIF.

            TRANSLATE ls_fieldinfo-field TO UPPER CASE.
            TRANSLATE ls_fieldinfo-table TO UPPER CASE.

            ls_fcat-ref_field = ls_fieldinfo-field.
            ls_fcat-ref_table = ls_fieldinfo-table.
*           ls_fcat-f4availabl = 'X'.

          ENDIF.   " agg_function is not initial

          CASE l_select->mv_colmn_header.
            WHEN 'S'.
              CLEAR: ls_fcat-coltext, ls_fcat-scrtext_l, ls_fcat-scrtext_m, ls_fcat-scrtext_s, ls_fcat-reptext.
            WHEN 'G'.
              ls_fcat-coltext = ls_fieldinfo-generated_field.
            WHEN 'A'.
              IF ls_fieldinfo-field_alias IS NOT INITIAL.
                ls_fcat-coltext = ls_fieldinfo-field_alias.
              ELSE.
                ls_fcat-coltext = ls_fieldinfo-generated_field.
              ENDIF.
            WHEN 'T'.
              ls_fcat-coltext = ls_fieldinfo-orig_field.
          ENDCASE.

          IF ls_fcat-ref_field IS NOT INITIAL AND
             ls_fcat-ref_table IS NOT INITIAL.

            CASE ls_table_alias_tb-type.

              WHEN 'T'.

                SELECT SINGLE keyflag AS fix_column keyflag AS key datatype intlen inttype domname rollname
                  INTO CORRESPONDING FIELDS OF ls_fcat
                  FROM dd03l
                  WHERE tabname   = ls_fcat-ref_table AND
                        fieldname = ls_fcat-ref_field AND
                        as4local  = 'A'.

              WHEN 'V'.

                SELECT SINGLE rollname keyflag AS fix_column keyflag AS key
                  INTO CORRESPONDING FIELDS OF ls_fcat
                  FROM dd27s
                    WHERE viewname  = ls_fcat-ref_table AND
                          viewfield = ls_fcat-ref_field AND
                          as4local  = 'A'.
*                          fieldname NOT LIKE '.%' AND
*                          fieldname NOT LIKE '*%' AND
*                          fieldname NOT LIKE '$_%' ESCAPE '$' AND
*                          fieldname NOT LIKE '$%%' ESCAPE '$'

              WHEN 'C' OR 'P'.

*                SELECT SINGLE keyflag AS fix_column keyflag AS key datatype intlen inttype
*                INTO CORRESPONDING FIELDS OF ls_fcat
*                FROM dd16v
*                  WHERE sqltab    = ls_fcat-ref_table AND
*                        fieldname = ls_fcat-ref_field.

                SELECT SINGLE keyflag AS fix_column keyflag AS key datatype intlen inttype domname rollname
                  INTO CORRESPONDING FIELDS OF ls_fcat
                  FROM dd03l
                  WHERE tabname   = ls_fcat-ref_table AND
                        fieldname = ls_fcat-ref_field AND
                        as4local  = 'A'.

*                        in view already
*                        AS4LOCAL = 'A' AND
*                        fieldname NOT LIKE '.%' AND
*                        fieldname NOT LIKE '*%' AND
*                        fieldname NOT LIKE '$_%' ESCAPE '$' AND
*                        fieldname NOT LIKE '$%%' ESCAPE '$'

            ENDCASE.

            IF sy-subrc NE 0.
              MESSAGE s038 DISPLAY LIKE 'E' WITH ls_fcat-ref_field ls_fcat-ref_table ls_table_alias_tb-type RAISING field_not_found.
            ENDIF.

            CONCATENATE text-143 ls_fcat-domname text-144 ls_fcat-intlen INTO lstr
              SEPARATED BY space.

            ls_fcat-tooltip = lstr.

            CLEAR ls_fcat-fix_column.

            ls_ref-fieldname  = ls_fcat-fieldname.
            ls_ref-checktable = ls_fcat-checktable.
            ls_ref-ref_table  = ls_fcat-ref_table.
            ls_ref-ref_field  = ls_fcat-ref_field.
            ls_ref-key        = ls_fcat-key.

            APPEND ls_ref TO l_select->ddic_references.

            DATA: ls_dfies TYPE dfies,
                  lt_dfies TYPE TABLE OF dfies.

            CALL FUNCTION 'DDIF_FIELDINFO_GET'
              EXPORTING
                tabname        = ls_fcat-ref_table
                fieldname      = ls_fcat-ref_field
                langu          = sy-langu
              TABLES
                dfies_tab      = lt_dfies
              EXCEPTIONS
                not_found      = 1
                internal_error = 2
                OTHERS         = 3.

            IF sy-subrc <> 0.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              READ TABLE lt_dfies INTO ls_dfies INDEX 1.

              IF sy-subrc EQ 0.
                MOVE ls_dfies-convexit TO ls_fcat-convexit.
                MOVE ls_dfies-scrtext_m TO ls_fcat-coltext.
                MOVE ls_dfies-scrtext_l TO  ls_fcat-scrtext_l.
                MOVE ls_dfies-scrtext_m TO  ls_fcat-scrtext_m.
                MOVE ls_dfies-scrtext_s TO  ls_fcat-scrtext_s.
                MOVE ls_dfies-reptext TO ls_fcat-reptext.
              ENDIF.

            ENDIF.

          ENDIF.

*        ls_fcat-no_convext = 'X'.

          IF ls_fcat-key EQ 'X'.
            ls_fcat-key_sel = 'X'.
            ls_fcat-edit = ' '.
          ENDIF.

          APPEND ls_fcat TO l_select->fcat.

        ENDLOOP.

        IF sy-subrc EQ 4.
          RAISE empty_fieldinfo_tb.
        ENDIF.

      CATCH cx_sy_move_cast_error.
        RAISE command_is_not_select.
    ENDTRY.

  ENDMETHOD.                    " generate_structure



  METHOD display.

    DATA: l_select         TYPE REF TO lcl_select_command,
          lv_show_grid     TYPE c,
          lo_result_tree   TYPE REF TO cl_gui_alv_tree,
          lt_fcat          TYPE lvc_t_fcat,
          ls_fcat          TYPE lvc_s_fcat,
          lo_alv           TYPE REF TO cl_gui_alv_grid.


    TRY.
        l_select ?= current_command.

      CATCH cx_sy_move_cast_error.
        RETURN.
    ENDTRY.

    IF po_grid IS INITIAL AND
       po_tree IS INITIAL.
      IF l_select->mv_last_display = 'T'.
        lv_show_grid = ' '.
      ELSE.
        lv_show_grid = 'X'.
      ENDIF.
    ELSE.
      IF po_grid IS INITIAL.
        lv_show_grid = ' '.
      ELSE.
        lv_show_grid = 'X'.
      ENDIF.
    ENDIF.

    IF po_grid IS SUPPLIED.
      lo_alv = po_grid.
    ELSE.
      lo_alv = g_alv.
    ENDIF.

    IF <gt_result> IS ASSIGNED.

      CALL METHOD g_application->set_column_headings.
      CALL METHOD g_application->set_key_display_attributes.

      CALL METHOD lo_alv->set_table_for_first_display
        EXPORTING
          is_layout            = gs_layo
          it_toolbar_excluding = gt_toolbar_exclude
        CHANGING
          it_outtab            = <gt_result>
          it_fieldcatalog      = l_select->fcat
        EXCEPTIONS
          OTHERS               = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      ENDIF.
    ENDIF.

    IF lo_result_tree IS NOT INITIAL.
      CALL METHOD lo_result_tree->set_visible
        EXPORTING
          visible = ' '
        EXCEPTIONS
          OTHERS  = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      ENDIF.
    ENDIF.

    CALL METHOD lo_alv->set_ready_for_input
      EXPORTING
        i_ready_for_input = l_select->alv_state
      EXCEPTIONS
        OTHERS            = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CALL METHOD lo_alv->set_selected_rows
      EXPORTING
        it_index_rows = l_select->selected_rows
        it_row_no     = l_select->selected_rows2
      EXCEPTIONS
        OTHERS        = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "LCL_COMMANDS


  METHOD display_command.

    DATA: l_command_type TYPE lty_commandtype,
          l_prev_select_command TYPE REF TO lcl_select_command,
          l_selfae TYPE REF TO lcl_select_fae_command,
          l_lawb TYPE REF TO lcl_lawb,
          l_select_command TYPE REF TO lcl_select_command,
          lv_tree_tb_width TYPE i,
          lv_result_height TYPE i,
          lv_tree_tb_visible TYPE c,
          lv_done TYPE c.


    CHECK current_command IS NOT INITIAL.

    CALL METHOD current_command->get_type
      IMPORTING
        ep_command_type = l_command_type.


    IF l_command_type EQ gc_ctype_lawb.

      lv_tree_tb_width = 0.
      lv_result_height = g_application->mv_result_height.

      lv_tree_tb_visible = ' '.

    ELSEIF l_command_type EQ gc_ctype_select OR l_command_type EQ gc_ctype_selfae.

      lv_tree_tb_width = g_application->mv_tree_tb_width.
      lv_result_height = g_application->mv_result_height.

      lv_tree_tb_visible = 'X'.

    ENDIF.

    CALL METHOD go_splitter_inner->set_column_width
      EXPORTING
        id     = 2
        width  = lv_tree_tb_width
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_outer->set_row_height
      EXPORTING
        id     = 2
        height = lv_result_height
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_tree_tb->set_visible
      EXPORTING
        visible = lv_tree_tb_visible.

*abaped    CALL METHOD g_textedit->set_text_as_r3table
    CALL METHOD g_textedit->set_text
      EXPORTING
        table  = current_command->text[]
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


    IF lv_done IS INITIAL.
      TRY.
          l_select_command ?= current_command.

          CALL METHOD l_select_command->assign_field_symbols.

          IF l_select_command->fcat[] IS NOT INITIAL AND <gt_result> IS ASSIGNED.

            CALL METHOD g_alv->set_visible
              EXPORTING
                visible = 'X'
              EXCEPTIONS
                OTHERS  = 1.

            IF sy-subrc NE 0.
              IF sy-msgno IS NOT INITIAL.
                MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
              ENDIF.
            ENDIF.

            IF <gt_result> IS ASSIGNED.
              CALL METHOD me->display.
            ENDIF.

          ELSE.

            IF command_count NE 1.

              CALL METHOD g_alv->set_visible
                EXPORTING
                  visible = ' '
                EXCEPTIONS
                  OTHERS  = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

          ENDIF.

        CATCH cx_sy_move_cast_error.
*        CALL METHOD l_select_command->display.
      ENDTRY.

    ENDIF.

    IF l_command_type NE gc_ctype_lawb AND l_command_type NE gc_ctype_script.
      CALL METHOD g_application->display_table_grid.
    ENDIF.

    CALL METHOD cl_gui_cfw=>set_new_ok_code
      EXPORTING
        new_code = 'KAMU'
      EXCEPTIONS
        OTHERS   = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE 'I'
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "LCL_COMMANDS


  METHOD create_new_command.

    DATA: l_update          TYPE REF TO lcl_update_command,
          l_select          TYPE REF TO lcl_select_command,
          lsc               TYPE REF TO lcl_select_command,
          l_delete          TYPE REF TO lcl_delete_command,
          l_selfae          TYPE REF TO lcl_select_fae_command,
          l_lawb            TYPE REF TO lcl_lawb,
          ls_text           LIKE LINE OF l_select->text,
          ls_commands       TYPE gty_commands,
          l_int             TYPE i,
          lstr              TYPE string,
          l_nodekey         TYPE lvc_nkey,
          l_subitem         TYPE c,

          lt_selected_nodes TYPE lvc_t_nkey,

          l_copy_sc         TYPE REF TO lcl_select_command,
          l_copy_uc         TYPE REF TO lcl_update_command,
          l_copy_dc         TYPE REF TO lcl_delete_command,

          l_copy_lawb       TYPE REF TO lcl_lawb,
          l_command_id      TYPE lty_commandid,
          lv_random         TYPE i,

          lv_command_id_str(10) TYPE n.

    IF sy-subrc NE 0.
      g_selected_nodekey = gc_nodekey_current_commands.
    ENDIF.

    CASE p_command_type.

      WHEN gc_ctype_select.

        TRY.

            l_copy_sc ?= p_copy_from.

            CREATE OBJECT l_select
              EXPORTING
                p_copy_from = l_copy_sc.

          CATCH cx_sy_move_cast_error.
            CREATE OBJECT l_select.
        ENDTRY.

        l_select->command_type = p_command_type.
        ls_commands-command = l_select.

        CLEAR g_selected_nodekey.

        ls_text =  'SELECT *'.
        APPEND ls_text TO l_select->text.
        ls_text =  'FROM '.
        APPEND ls_text TO l_select->text.
        ls_text =  'UP TO 200 ROWS'.
        APPEND ls_text TO l_select->text.


        l_select->mv_colmn_header   = gv_def_col_hdr.
        l_select->mv_key_colmn_type = gv_def_keycol_type.

        l_select->mv_last_display = 'G'.
        current_command = l_select.

        l_select->mv_command_type = l_select->command_type.


    ENDCASE.

    CALL METHOD g_textedit->set_readonly_mode
      EXPORTING
        readonly_mode = '0'.

    current_command->command_id = l_command_id.
    ls_commands-command_id = l_command_id.

    command_count = command_count + 1.
    ls_commands-seq_no = command_count.
    ls_commands-treelevel = current_command->treelevel.
    APPEND ls_commands TO command_list.

    IF command_count EQ 1.

      CLEAR prev_command.
    ENDIF.

    CALL METHOD g_commands->display_command.
**    CALL METHOD g_application->refresh_status_indicators.

    CALL METHOD g_application->create_tb_tree_toolbar.

    lv_command_id_str = current_command->command_id.

  ENDMETHOD.                    "LCL_COMMANDS


  METHOD execute_command.

    DATA: l_text                TYPE source_table,
          l_owm                 TYPE i VALUE 1,
          ls_text               LIKE LINE OF l_text,
          l_str                 TYPE string,
          l_str2                TYPE string,
          l_update_command      TYPE REF TO lcl_update_command,
          l_delete_command      TYPE REF TO lcl_delete_command,
          l_select_command      TYPE REF TO lcl_select_command,
          l_selfae              TYPE REF TO lcl_select_fae_command,
          l_lawb                TYPE REF TO lcl_lawb,
          l_prev_select_command TYPE REF TO lcl_select_command,
          l_c_type              TYPE lty_commandtype,
          l_lines               TYPE i,

          lo_tree               TYPE REF TO cl_gui_alv_tree,
          lx_root               TYPE REF TO cx_root,

          lv_message            TYPE string,
          lv_read_auth          TYPE c,
          ls_table_alias_tb     LIKE LINE OF current_command->table_alias_tb,

          stracsum_tab          TYPE stracsumtab,
          sqlstatful_tab        TYPE TABLE OF sqlstatful,
          ls_stracsum_tab       TYPE stracsum,
          ls_sqlstatful         TYPE sqlstatful,
          lstr                  TYPE string,
          l_gen_text            LIKE LINE OF l_select_command->gen_text.


    GET RUN TIME FIELD gv_starttime.

    IF sy-tcode = 'ZSQL_TEST'.
      IF current_command->command_type NE gc_ctype_select.
        RETURN.
      ENDIF.
    ENDIF.

    CALL METHOD transfer_text_to_command.

    TRY.
        l_select_command ?= current_command.

*          message 'ZENITH:Casting error3' TYPE 'E'.

        DATA: lv_log_handle LIKE g_application->mv_log_handle.

        IF gv_autotest = 'X'.
          lv_log_handle = g_application->mv_log_handle.
        ENDIF.

*CALL METHOD l_select_command->assign_field_symbols.

        CALL METHOD l_select_command->mo_pipacs_select->create_new
          EXPORTING
            iv_command_id = current_command->command_id
            iv_command    = current_command->commandtext
            it_vranges    = current_command->it_ranges
            iv_log_handle = lv_log_handle
          EXCEPTIONS
            no_id         = 1
            OTHERS        = 2.

        CASE sy-subrc.

          WHEN 1.
            CALL METHOD g_application->issue_message
              EXPORTING
                iv_msgty        = 'S'
                iv_msgno        = '077'
                iv_display_like = 'E'.
*                message s077 DISPLAY LIKE 'E'.
            RETURN.
          WHEN 2.
            CALL METHOD g_application->issue_message
              EXPORTING
                iv_msgty        = 'S'
                iv_msgno        = '076'
                iv_display_like = 'E'.
*                message s076 DISPLAY LIKE 'E'.
            RETURN.

        ENDCASE.

        l_select_command->mo_pipacs_command = l_select_command->mo_pipacs_select.


      CATCH cx_sy_move_cast_error.
*        message 'ZENITH:Casting error3' TYPE 'E'.
    ENDTRY.

    CALL METHOD current_command->parse_commandtext
      EXCEPTIONS
        error_occurred = 1
        OTHERS         = 2.

    CASE sy-subrc.

      WHEN 1.
*        message s079 DISPLAY LIKE 'E'.
        RETURN.
      WHEN 2.
*        message s079 DISPLAY LIKE 'E'.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'S'
            iv_msgno        = '079'
            iv_display_like = 'E'.
        RETURN.

    ENDCASE.


    TRY.
        l_select_command ?= current_command.

        CALL METHOD l_select_command->assign_field_symbols.

        CALL METHOD me->generate_structure
          EXCEPTIONS
            empty_fieldinfo_tb    = 1
            command_is_not_select = 2
            OTHERS                = 3.

        CASE sy-subrc.
          WHEN 1.
            CALL METHOD g_application->issue_message
              EXPORTING
                iv_msgty        = 'S'
                iv_msgno        = '078'
                iv_display_like = 'E'.
*            message s078 DISPLAY LIKE 'E'.
            RETURN.

          WHEN 2.
            CALL METHOD g_application->issue_message
              EXPORTING
                iv_msgty        = 'S'
                iv_msgno        = '080'
                iv_display_like = 'E'.
*            message s080 DISPLAY LIKE 'E'.
            RETURN.

          WHEN 3.
            CALL METHOD g_application->issue_message
              EXPORTING
                iv_msgty        = 'S'
                iv_msgno        = '081'
                iv_display_like = 'E'.
*            message s081 DISPLAY LIKE 'E'.
            RETURN.
        ENDCASE.

        CLEAR:

          l_select_command->mv_dbcnt,
          l_select_command->mv_bytes,
          l_select_command->mv_filtered,
          l_select_command->mv_pos,
          l_select_command->alv_state.

      CATCH cx_sy_move_cast_error.
    ENDTRY.

    LOOP AT current_command->table_alias_tb INTO ls_table_alias_tb.

      CALL METHOD g_application->check_s_tabu_dis
        EXPORTING
          iv_for_editing = ' '
          iv_tabname     = ls_table_alias_tb-table
        IMPORTING
          ev_auth        = lv_read_auth.

      IF lv_read_auth IS INITIAL.
        MESSAGE s125 DISPLAY LIKE 'E' WITH ls_table_alias_tb-table.
        RETURN.
      ENDIF.

    ENDLOOP.

    DATA: lv_simulation TYPE c.

    IF iv_mode = 'SIMULATE'.
      lv_simulation = 'X'.
    ELSE.
      CLEAR lv_simulation.
    ENDIF.



    CALL METHOD current_command->execute_parsed_sql
      EXPORTING
        po_grid                  = g_alv
        po_tree                  = lo_tree
        iv_simulation            = lv_simulation
        iv_bg_proc               = iv_bg_proc
        iv_bg_date               = iv_bg_date
        iv_bg_time               = iv_bg_time
        iv_read_from_file        = iv_read_from_file
      IMPORTING
        er_exception             = lx_root
        et_srccode               = current_command->mt_srccode
      EXCEPTIONS
        table_not_found          = 1
        parse_error              = 2
        exec_error               = 3
        error_occurred           = 4
        unlock_error             = 5
        arg_to_long              = 6
        foreign_lock             = 7
        foreign_lock_all_clients = 8
        job_submit_error         = 9
        field_list_changed       = 10
        file_open_error          = 11
        no_auth_for_table        = 12
        OTHERS                   = 13.

    CASE sy-subrc.
      WHEN 0.

      WHEN 1.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'S'
            iv_msgno        = '082'
            iv_display_like = 'E'.
*          message s082 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 2.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'S'
            iv_msgno        = '079'
            iv_display_like = 'E'.
*          message s079 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 3.
        IF lx_root IS INITIAL.
          CALL METHOD g_application->issue_message
            EXPORTING
              iv_msgty        = 'S'
              iv_msgno        = '083'
              iv_display_like = 'E'.
        ELSE.
          CALL METHOD lx_root->if_message~get_longtext
            RECEIVING
              result = lv_message.
          MESSAGE lv_message TYPE 'S' DISPLAY LIKE 'E'.
        ENDIF.

        RETURN.

      WHEN 4.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'S'
            iv_msgno        = '083'
            iv_display_like = 'E'.
*          message s083 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 5.
        MESSAGE i073 DISPLAY LIKE 'W' WITH sy-msgv1.
        RETURN.

      WHEN 6.
        MESSAGE i069 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 7.
        MESSAGE i071 DISPLAY LIKE 'E' WITH sy-msgv1 sy-msgv2 sy-msgv3.
        RETURN.

      WHEN 8.
        MESSAGE i070 DISPLAY LIKE 'E' WITH sy-msgv1 sy-msgv2.
        RETURN.

      WHEN 9.
        MESSAGE i134 DISPLAY LIKE 'E'. " WITH sy-msgv1 sy-msgv2.
        RETURN.

      WHEN 10.
        MESSAGE i144 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 11.
        MESSAGE i145 DISPLAY LIKE 'E'.
        RETURN.

      WHEN 12.
        MESSAGE s125 DISPLAY LIKE 'E' WITH sy-msgv1.
        RETURN.

      WHEN 13.
        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty        = 'S'
            iv_msgno        = '084'
            iv_display_like = 'W'.
*          message s084 DISPLAY LIKE 'W'.
    ENDCASE.

    TRY.
        l_select_command ?= current_command.

        IF lv_simulation IS INITIAL AND
           iv_bg_proc    IS INITIAL.
          CALL METHOD me->display.
        ENDIF.

        l_select_command->mv_read_from_file = iv_read_from_file.

        IF iv_read_from_file EQ 'X'.
          CALL METHOD g_alv->set_toolbar_interactive.
        ENDIF.

        current_command->mv_grid_modified = ' '.

        IF lv_simulation IS INITIAL.
          CALL METHOD g_application->refresh_status_indicators.
        ENDIF.

        IF lv_simulation = 'X'.
          CLEAR l_select_command->fcat.
        ELSE.
          l_select_command->prev_fcat = l_select_command->fcat.
        ENDIF.

      CATCH cx_sy_move_cast_error.
*      message 'ZENITH:Casting error4' TYPE 'E'.
    ENDTRY.

    CALL METHOD current_command->get_type
      IMPORTING
        ep_command_type = l_c_type.

    IF l_c_type NE gc_ctype_lawb.
      CALL METHOD g_application->display_table_grid.
    ENDIF.

    IF iv_bg_proc IS INITIAL.
      IF lv_simulation = 'X'.
        MESSAGE s120.
      ELSE.
        CALL METHOD me->write_status_message.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "LCL_COMMANDS


  METHOD write_status_message.

    DATA: lstr             TYPE string,
          lstr2            TYPE string,
          lstr3(20)        TYPE c,
          lv_float         TYPE f,
          lv_p             TYPE p DECIMALS 3,
          l_bytes          TYPE i,
          l_select_command TYPE REF TO lcl_select_command,
          l_update_command TYPE REF TO lcl_update_command,
          l_delete_command TYPE REF TO lcl_delete_command,
          l_lawb           TYPE REF TO lcl_lawb.


    GET RUN TIME FIELD gv_endtime.
    gv_deltatime = ( gv_endtime - gv_starttime ) DIV 1000.

    lv_float = gv_deltatime / 1000.

    lv_p = lv_float.
    MOVE lv_p TO lstr2.

    TRY.
        l_select_command ?= current_command.

        CALL METHOD g_application->issue_message
          EXPORTING
            iv_msgty = 'S'
            iv_msgno = '047'
            iv_msgv1 = l_select_command->mv_dbcnt
            iv_msgv2 = lstr2
            iv_msgv3 = l_select_command->mv_bytes.

      CATCH cx_sy_move_cast_error.
    ENDTRY.

  ENDMETHOD.                    " write_status_message


  METHOD transfer_text_to_command.

    DATA: l_text TYPE source_table,
          ls_text LIKE LINE OF l_text,
          l_str TYPE string.

    IF sy-tcode = 'ZSQL_TEST'.
      l_text[] = current_command->text[].
    ELSE.
      CALL METHOD g_textedit->get_text
        IMPORTING
          table  = l_text[]
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc = 1.
*        MESSAGE i025.
      ENDIF.
    ENDIF.

    IF current_command->text[] NE l_text[].
      IF current_command->mv_ctext_changed IS INITIAL.
        current_command->mv_ctext_changed = 'X'.
      ENDIF.
    ENDIF.

    current_command->text[] = l_text[].

    IF l_text IS NOT INITIAL.
      CALL METHOD lcl_toolbox=>pretty_printer
        CHANGING
          ct_source = l_text.

      LOOP AT l_text INTO ls_text.
        IF ls_text(1) NE '*'.
          CONCATENATE l_str ls_text INTO l_str SEPARATED BY ' '.
        ENDIF.
      ENDLOOP.

      CALL METHOD current_command->set_commandtext
        EXPORTING
          p_commandtext = l_str.
    ENDIF.

  ENDMETHOD.                    "transfer_text_to_command

  METHOD parse_only_command.

    DATA: l_update_command TYPE REF TO lcl_update_command,
          l_delete_command TYPE REF TO lcl_delete_command,
          l_select_command TYPE REF TO lcl_select_command,
          l_lawb           TYPE REF TO lcl_lawb,
          l_selfae         TYPE REF TO lcl_select_fae_command,
          l_parent_selfae  TYPE REF TO lcl_select_fae_command.

    IF p_on_load EQ ' '.
      CALL METHOD transfer_text_to_command.
    ENDIF.
    TRY.
        l_select_command ?= current_command.

        DATA: lv_log_handle LIKE g_application->mv_log_handle.

        IF gv_autotest = 'X'.
          lv_log_handle = g_application->mv_log_handle.
        ENDIF.

        CALL METHOD l_select_command->mo_pipacs_select->create_new
          EXPORTING
            iv_command_id = current_command->command_id
            iv_command    = current_command->commandtext
            it_vranges    = current_command->it_ranges
            iv_log_handle = lv_log_handle
          EXCEPTIONS
            no_id         = 1
            OTHERS        = 2.

        CASE sy-subrc.
          WHEN 1.
            RAISE no_id.
          WHEN 2.
            RAISE create_error.
        ENDCASE.

        l_select_command->mo_pipacs_command = l_select_command->mo_pipacs_select.


      CATCH cx_sy_move_cast_error.

    ENDTRY.

    IF p_on_load EQ ' '.
****      CALL METHOD g_application->refresh_curr_tree_node_caption.
    ENDIF.

    CALL METHOD current_command->parse_commandtext
      EXPORTING
        p_on_load      = p_on_load
      EXCEPTIONS
        error_occurred = 1
        OTHERS         = 2.

    CASE sy-subrc.
      WHEN 1.
        RAISE parse_error.
      WHEN 2.
        RAISE parse_error.
    ENDCASE.

    IF p_on_load EQ ' '.
      CALL METHOD g_application->display_table_grid.
    ENDIF.

  ENDMETHOD.                    " parse_only_command

ENDCLASS.                    "LCL_COMMANDS IMPLEMENTATION

*&---------------------------------------------------------------------*
*&      Form  mem_export
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM mem_export .

  DATA: BEGIN OF mode,                 " Schnittstelle fr SE13
         show(1),
         edit(1),
         END OF mode.

  mode-show = 'X'.
  mode-edit = ' '.
  EXPORT mode TO MEMORY ID 'MOD'.


ENDFORM.                    " mem_export
*&---------------------------------------------------------------------*
*&      Form  INSTALL
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  -->  p1        text
*  <--  p2        text
*----------------------------------------------------------------------*
FORM install .

  DATA: lt_eg TYPE dyn_flowlist,
        lt_fg TYPE TABLE OF d021s,
        lt_mg TYPE TABLE OF d023s,
        lt_htext TYPE TABLE OF d023s,
        ls_fg TYPE d021s,
        ls_htext TYPE d023s,
        ls_d020s TYPE d020s,
        lstr TYPE string.

  SELECT SINGLE *
    FROM d020s
    INTO ls_d020s
    WHERE prog = sy-repid.

  IF sy-subrc <> 0.

    CALL FUNCTION 'ENQUEUE_ES_PROG'
      EXPORTING
        mode_trdir     = 'E'
        name           = sy-repid
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.

    IF sy-subrc <> 0.

      CONCATENATE 'Report' sy-repid 'cannot be locked for installation. Please do not edit it.' INTO lstr SEPARATED BY space.

      MESSAGE i085 WITH lstr.

      LEAVE PROGRAM.
    ENDIF.

    CALL FUNCTION 'DEQUEUE_ES_PROG'
      EXPORTING
        name = sy-repid.

    APPEND 'PROCESS BEFORE OUTPUT.' TO lt_eg.
    APPEND 'MODULE status_0100.' TO lt_eg.
    APPEND INITIAL LINE TO lt_eg.
    APPEND 'PROCESS AFTER INPUT.' TO lt_eg.
    APPEND 'MODULE user_command_0100_exit.' TO lt_eg.
    APPEND 'MODULE user_command_0100.' TO lt_eg.


    ls_fg-fnam =  'OK_CODE'.
    ls_fg-flg1 =  '80'.
    ls_fg-flg2 =  '10'.
    ls_fg-leng =  '14'.
    ls_fg-line =  'FF'.
    ls_fg-coln =  '01'.
    ls_fg-ltyp =  'O'.
    ls_fg-type =  'CHAR'.
    ls_fg-stxt = '____________________'.
    APPEND ls_fg TO lt_fg.

*    ls_htext-PROG = sy-repid.
*    ls_htext-DYNR = '0100'.
*    ls_htext-LANG = sy-langu.
*    ls_htext-DTXT = 'Main screen'.
*    APPEND ls_htext TO lt_htext.

*    CALL FUNCTION 'RS_SCREEN_CREATE'

    ls_d020s-prog =  sy-repid.
    ls_d020s-dnum =  '0100'.
    ls_d020s-fnum =  '0100'.
    ls_d020s-bzmx =  '0'.
    ls_d020s-bzbr =  '0'.
    ls_d020s-mili =  '192'.
    ls_d020s-mico =  '37'.
    ls_d020s-mali =  '0'.
    ls_d020s-maco =  '0'.
    ls_d020s-noli =  '27'.
    ls_d020s-noco =  '120'.
    ls_d020s-valp =  '0'.
    ls_d020s-cuan =  'G'.
    ls_d020s-spra =  sy-langu.
    ls_d020s-dgen =  sy-datum.
    ls_d020s-tgen =  sy-uzeit.

    CALL FUNCTION 'RS_SCREEN_EXPORT'
      EXPORTING
        dynnr                 = '0100'
        progname              = sy-repid
        h_export              = ls_d020s
        save_without_question = 'X'
        without_corr_insert   = 'X'
      TABLES
        e_g                   = lt_eg
        f_g                   = lt_fg
        m_g                   = lt_mg
      EXCEPTIONS
        already_exists        = 1
        not_executed          = 2
        OTHERS                = 3.

    IF sy-subrc <> 0.
*      ???
    ENDIF.

    TABLES trkey.

    TYPES: BEGIN OF ty_tit,
            code TYPE rsoldleng-title,
            text TYPE title-text_line,
           END OF ty_tit.

    DATA: tit    TYPE STANDARD TABLE OF ty_tit.
*     Release ab  4.6
    DATA: fun4   TYPE STANDARD TABLE OF rsmpe_funt WITH HEADER LINE.
    DATA: ctx4   TYPE STANDARD TABLE OF rsmpe_ctx WITH HEADER LINE.
    DATA: mtx4   TYPE STANDARD TABLE OF rsmpe_mnlt WITH HEADER LINE.
    DATA: men4   TYPE STANDARD TABLE OF rsmpe_men WITH HEADER LINE.
    DATA: act4   TYPE STANDARD TABLE OF rsmpe_act WITH HEADER LINE.
    DATA: doc4   TYPE STANDARD TABLE OF rsmpe_atrt WITH HEADER LINE.
    DATA: sta4   TYPE STANDARD TABLE OF rsmpe_stat WITH HEADER LINE.
    DATA: set4   TYPE STANDARD TABLE OF rsmpe_staf WITH HEADER LINE.
    DATA: pfk4   TYPE STANDARD TABLE OF rsmpe_pfk WITH HEADER LINE.
    DATA: but4   TYPE STANDARD TABLE OF rsmpe_but WITH HEADER LINE.
    DATA: tit4   TYPE STANDARD TABLE OF rsmpe_titt WITH HEADER LINE.
    DATA: stx4   TYPE STANDARD TABLE OF rsmptexts WITH HEADER LINE.
    DATA: adm4   TYPE rsmpe_adm.
*     Release ab  4.6c
    DATA: biv46c TYPE STANDARD TABLE OF rsmpe_buts.

    DATA: i_adm4 TYPE STANDARD TABLE OF rsmpe_adm.

*    trkey-devclass = '$TMP'.
    trkey-obj_type = 'PROG'.
    trkey-obj_name = sy-repid.
    trkey-sub_type = 'CUAD'.
    trkey-sub_name = sy-repid.

    adm4-actcode = '000003'.
    adm4-pfkcode = '000003'.

    sta4-code     = '100_MAIN'.
    sta4-modal    = 'D'.
    sta4-actcode  = '000001'.
    sta4-pfkcode  = '000001'.
    sta4-butcode  = '0001'.
    sta4-int_note = 'MAIN'.

    APPEND sta4.

    fun4-code      = 'BACK'.
    fun4-textno    = '001'.
    fun4-text_type = 'S'.
    fun4-fun_text  = 'BACK'.

    APPEND fun4.
    fun4-code      = 'CANCEL'.
    APPEND fun4.
    fun4-code      = 'EXIT'.
    APPEND fun4.
    fun4-code      = 'EXEC'.
    fun4-text_name = 'ICON_EXECUTE_OBJECT'.
    fun4-fun_text  = 'Execute'.
    fun4-info_text = 'Execute'.
    fun4-icon_id   = '@15@'.

    APPEND fun4.
    fun4-code      = 'SIMULATE'.
    fun4-text_name = 'ICON_SIMULATE'.
    fun4-fun_text  = 'Simulate'.
    fun4-info_text = 'Simulate'.
    fun4-icon_id   = '@8Z@'.
    APPEND fun4.

    but4-pfk_code = '000001'.
    but4-code     = '0001'.
    but4-no       = '01'.
    but4-pfno     = '08'.

    APPEND but4.

    but4-no       = '02'.
    but4-pfno     = '20'.
    APPEND but4.

    pfk4-code    = '000001'.
    pfk4-pfno    = '03'.
    pfk4-funcode = 'BACK'.
    pfk4-funno   = '001'.

    APPEND pfk4.

    pfk4-pfno    = '08'.
    pfk4-funcode = 'EXEC'.
    APPEND pfk4.

    pfk4-pfno    = '12'.
    pfk4-funcode = 'CANCEL'.
    APPEND pfk4.

    pfk4-pfno    = '15'.
    pfk4-funcode = 'EXIT'.
    APPEND pfk4.

    pfk4-pfno    = '20'.
    pfk4-funcode = 'SIMULATE'.
    APPEND pfk4.

    set4-status   = '100_MAIN'.
    set4-function = 'BACK'.

    APPEND set4.

    set4-function = 'CANCEL'.
    APPEND set4.

    set4-function = 'EXIT'.
    APPEND set4.

    set4-function = 'SIMULATE'.
    APPEND set4.

    set4-function = 'EXEC'.
    APPEND set4.

    doc4-obj_type = 'A'.
    doc4-obj_code = '000001'.
    doc4-modal    = 'D'.
    doc4-int_note = 'MAIN'.

    APPEND doc4.

    doc4-obj_type = 'P'.
    doc4-obj_code = '000001'.
    doc4-modal    = 'D'.
    doc4-int_note = 'MAIN'.

    APPEND doc4.

    doc4-obj_type = 'B'.
    doc4-obj_code = '000001'.
    doc4-modal    = 'D'.
    doc4-norm     = '0001'.
    doc4-int_note = 'MAIN'.

    APPEND doc4.

    tit4-code = '100_TITLE'.
    tit4-text = '&'.

    APPEND tit4.

    CALL FUNCTION 'RS_CUA_INTERNAL_WRITE'
      EXPORTING
        program   = sy-repid
        language  = sy-langu
        tr_key    = trkey
        adm       = adm4
        state     = 'I'
      TABLES
        sta       = sta4
        fun       = fun4
        men       = men4
        mtx       = mtx4
        act       = act4
        but       = but4
        pfk       = pfk4
        set       = set4
        doc       = doc4
        tit       = tit4
        biv       = biv46c
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.


    DATA: lt_text TYPE TABLE OF textpool,
          ls_text TYPE textpool.

    ls_text-id = 'I'.

    ls_text-entry = 'Domain Definitions'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Data Element Definitions'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Lock Object Definitions'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Indexes'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Table Definitions'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Table Technical Attriibutes'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Table Type definitions'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Text Component Table Type definitions'. APPEND ls_text TO lt_text.
    ls_text-entry = 'View definitions'. APPEND ls_text TO lt_text.
    ls_text-entry = 'View Technical Attributes'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Domains'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Domain definitions'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Data Elements'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Lock Objects'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Logical Databases'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Number Ranges'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Tables'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Table Contents'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Table Types'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Data Models'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Entity Types'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Views'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Pretty Printer'. APPEND ls_text TO lt_text.
    ls_text-entry = '(...) INNER JOIN Checktable'. APPEND ls_text TO lt_text.
    ls_text-entry = '(...) LEFT OUTER JOIN Checktable'. APPEND ls_text TO lt_text.
    ls_text-entry = '(...) SELECT FOR ALL ENTRIES Checktable'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Delete Folder'. APPEND ls_text TO lt_text.
    ls_text-entry = '(...) Foreign Key Relations'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Delete All'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Create New Folder'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Paste'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Rename Folder'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Create New Folder'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Cut'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Paste'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Delete All Commands'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Delete'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Properties'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Execute'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Do you want to move the commands in the Repository'. APPEND ls_text TO lt_text.
    ls_text-entry = 'to the Current commands after emptying the Repository?'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Confirm deletion'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Do you really want to delete all current commands?'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Do you want to move the commands in the selected folder'. APPEND ls_text TO lt_text.
    ls_text-entry = 'to the Current commands after Deleting the Folder?'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Enter Folder Name'. APPEND ls_text TO lt_text.
    ls_text-entry = 'and all of its subcommands'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Do you really want to delete the command'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display table definition'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display indexes'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display technical settings'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display foreign key relations'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display text table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display runtime object'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Where Used List'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display contents'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Use Value Ranges'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Toggle Display/Change mode'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display Tree'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Select All Rows'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Deselect All Rows'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Column display settings'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Toggle automatic check'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Append row'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Insert row'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Delete row'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Copy row'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Updated/Inserted/Deleted rows'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Update DB table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Insert lines to DB table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Modify DB table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Delete visible lines from DB'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Delete deleted lines from DB'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Undo all changes'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Enter Table Name'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Dynamic Selection'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Key fields as normal'. APPEND ls_text TO lt_text.
    ls_text-entry = 'To edit the result sets, key fields &1 have to be included in the field list.'. APPEND ls_text TO lt_text.
*     GAP HANDLED IN LOOP
    ls_text-entry = 'Display alias'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Modify source table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Modify other table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Insert into source table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Insert into other table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Create table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Update source table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Update other table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Fix key columns'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display original field name'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display generated field name'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Diaplay short text'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display All records'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display Updated records'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display Inserted records'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display Deleted records'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Total'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Structure'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Script'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Select for All Entries'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Loop-at Workbench'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Delete SQL'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Update SQL'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Select SQL'. APPEND ls_text TO lt_text.
    ls_text-entry = '* field symbols for the work area and for a specific field'. APPEND ls_text TO lt_text.
    ls_text-entry = '* the table name MUST be p_itab'. APPEND ls_text TO lt_text.
    ls_text-entry = '* replace XYZ with the field name in UPPERCASE'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Create table and insert'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Refresh'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display Options'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Display Grid'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Data has changed'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Do you really want to quit without saving?'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Yes'. APPEND ls_text TO lt_text.
    ls_text-entry = 'No'. APPEND ls_text TO lt_text.
    ls_text-entry = 'ABAP Documentation'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Syntax Diagram'. APPEND ls_text TO lt_text.
    ls_text-entry = 'You have unsaved modifications of the result list.'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Do you really want to cancel editing?'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Warning'. APPEND ls_text TO lt_text.
    ls_text-entry = 'You have unsaved modifications of the result list of a command'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Do you really want to exit?'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Exif from the application'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Lock records'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Unlock records'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Deleted records'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Updated records'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Inserted records'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Simulate'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Move Result Set'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Update other table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Insert into other table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Modify other table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Current Commands'. APPEND ls_text TO lt_text.
    ls_text-entry = 'My Repository'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Application Components'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Table/Value range'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Select'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Update'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Delete'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Loop at Workbench'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Select for all entries...'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Domain:'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Length:'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Description'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Navigation Tree'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Recognize tables'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Advanced Paste'. APPEND ls_text TO lt_text.
    ls_text-entry = '(...) SUBQUERY for Checktable'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Field Selector'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Check'. APPEND ls_text TO lt_text.
    ls_text-entry = '* Original command text:'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Delete backup table'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Column options'. APPEND ls_text TO lt_text.
    ls_text-entry = 'First page'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Previous page'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Next page'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Last page'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Do you really wanto to display all records?'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Show all records'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Confirmation'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Report generated by Hovitaga Report Generator'. APPEND ls_text TO lt_text.
    ls_text-entry = 'at'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Report title:'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Created by:'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Created on:'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Fields for the selection screen'. APPEND ls_text TO lt_text.
    ls_text-entry = 'You have unsaved modifications of a command text'. APPEND ls_text TO lt_text.
    ls_text-entry = 'Linked Query Assistant'. APPEND ls_text TO lt_text.

    ls_text-id = 'R'.
    ls_text-entry = 'Hovitaga OpenSQL Editor free edition'. APPEND ls_text TO lt_text.

    LOOP AT lt_text INTO ls_text.

      IF sy-tabix > 79.
        ls_text-key    = sy-tabix + 1.
      ELSE.
        ls_text-key    = sy-tabix.
      ENDIF.

      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
        EXPORTING
          input  = ls_text-key
        IMPORTING
          output = ls_text-key.

      ls_text-key = ls_text-key+5(3).

      ls_text-length = STRLEN( ls_text-entry ).

      MODIFY lt_text FROM ls_text INDEX sy-tabix.

    ENDLOOP.

    INSERT textpool sy-repid FROM lt_text LANGUAGE sy-langu.

    DATA: lv_transaction TYPE sy-tcode.

    lv_transaction = sy-repid.

    CALL FUNCTION 'RPY_TRANSACTION_INSERT'
      EXPORTING
        transaction                   = lv_transaction
        program                       = sy-repid
        dynpro                        = '0100'
        shorttext                     = 'Hovitaga OpenSQL Editor Free Edition'
        easy_web_transaction          = ' '
        professionel_user_transaction = 'X'
        html_enabled                  = 'X'
        java_enabled                  = 'X'
        wingui_enabled                = 'X'
        genflag                       = 'X'
        suppress_authority_check      = 'X'
        suppress_corr_insert          = 'X'
      EXCEPTIONS
        cancelled                     = 1
        already_exist                 = 2
        permission_error              = 3
        name_not_allowed              = 4
        name_conflict                 = 5
        illegal_type                  = 6
        object_inconsistent           = 7
        db_access_error               = 8
        OTHERS                        = 9.

    IF sy-subrc <> 0.
    ENDIF.


    DATA: ls_t100a TYPE t100a,
          lt_t100a TYPE TABLE OF t100a,
          lv_msgclass TYPE t100a-arbgb.

    lv_msgclass = 'ZSQL_FREE'.

    SELECT SINGLE arbgb FROM t100a
      INTO ls_t100a-arbgb
      WHERE arbgb = lv_msgclass.

    IF sy-subrc EQ 4.

      ls_t100a-arbgb      = lv_msgclass.
      ls_t100a-masterlang = sy-langu.
*      ls_t100a-APPLCLASS
      ls_t100a-respuser = sy-uname.
      ls_t100a-lastuser = sy-uname.
      ls_t100a-ldate    = sy-datum.
      ls_t100a-ltime    = sy-uzeit.
      ls_t100a-stext    = 'Hovitaga OpenSQL Editor Free Edition'.

      INSERT t100a FROM ls_t100a.

      DATA: ls_t100t TYPE t100t,
            lt_t100t TYPE TABLE OF t100t.

      ls_t100t-arbgb      = lv_msgclass.
      ls_t100t-sprsl      = sy-langu.
      ls_t100t-stext    = 'Hovitaga OpenSQL Editor Free Edition'.

      INSERT t100t FROM ls_t100t.

      DATA: ls_t100 TYPE t100,
            lt_t100 TYPE TABLE OF t100.

      ls_t100-arbgb = lv_msgclass.
      ls_t100-sprsl = sy-langu.

      ls_t100-text = '    *** Core Classes ***'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Don''t write any commands after the closing dot'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Internal error during syntax check'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Internal error: generated program could not be called'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'The command cannot be interpreted'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'An ending quotation mark is missing'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Keyword ''&1'' is missing'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Field ''&1'' not found in table ''&2'''. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '''&1'' was not expected in the FROM clause'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'FROM clause ended unexpectedly with ''&1'''. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '''&1'' was not expected in the field list'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Field list ended unexpectedly with ''&1'''. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Field list: can not find table alias &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'No tables were found'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Table ''&1'' does not exist or is not active'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '''&1'' is not a table'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Field ''&1'' does not belong to any of the tables'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Field list is missing'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Wrong order of keywords: &1 on wrong position'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'A syntax error occured'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'The command must have the FOR ALL ENTRIES clause'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'The command must have the WHERE clause'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Not an update command'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Not a delete command'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Only one table name can be entered for a DELETE/UPDATE command'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Zenith: textedit get_text Potential data loss'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Zenith: node xref not found'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Please adopt changes to the command by pressing the Simulate button'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Command copied to Clipboard'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Folder copied to Clipboard'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Rows fetched: &1 Updated: &2 Inserted: &3 Deleted: &4'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Zenith: tree get node error'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'No text table for &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Table &1 does not exist or is not active'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'No errors were found'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'To edit the result set, key fields &1 must be included in the field list'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Field ''&1'' does not belong to tables ''&2'''. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Checktable Relationships for &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Could not find field &1 in table &2 (type &3)'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Domain: &1  Length: &2'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Empty fieldcatalog'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Copy of Table &1 for ZSQL Command &2'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'ZENITH Generated Table for Command &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Transparent table succesfully created and activated'. APPEND ls_t100 TO lt_t100.
*     GAP HANDLED IN LOOP
      ls_t100-text = 'First execute the parent command'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'At least one record was not found in the DB with the primary key'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 records fetched in &2 seconds &3 bytes transferred'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 records updated in &2 seconds'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 records deleted in &2 seconds'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Parent command not found'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 records inserted'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'At least one record was not inserted'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'At least one record was not deleted'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'All lines were successfully inserted or updated'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'One or more lines could not be inserted or updated'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Key incomplete, update not allowed'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Table &1 already exists'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Maximum records must be at least 1'. APPEND ls_t100 TO lt_t100.
*     GAP HANDLED IN LOOP
      ls_t100-text = 'Command cannot be displayed'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'You don''t have the authority to execute this command type'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'ABAP documentation launched for keyword &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Nothing found in the ABAP documentation for keyword &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Command is locked by &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error when locking the selected command'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 records updated &2 inserted &3 deleted in &4 seconds'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error while updating table'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Do not use the ''FOR UPDATE'' addition'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Lock argument too long'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Table &1 locked by &2'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Table &1 client &2 locked by &3'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error when locking table &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error when unlocking table &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Some inserted rows were locked, update cancelled'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Record locked by &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Unable to create command'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Cannot assign a command ID'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Field list empty'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error parsing the command'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Command is not a select command'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error generating the structure for the result list'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Table list empty'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error executing the command'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error unlocking the table'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 &2 &3 &4 &5 &6'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Nothing to display'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Some records cannot be written to the database'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Command does not beging with the keyword ''&1'''. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Record not found or action resulted in duplicate primary keys'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Field &1 missing from result set, please adjust tree settings'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 records updated in table &2'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 records inserted into table &2'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 records modified in table &2'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 reports being processed'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Loop-at Workbench executed in &1 seconds'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'CALL METHOD lo_select->mo_pipacs_select->create_new: NO_ID exception'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'CALL METHOD lo_select->mo_pipacs_select->create_new: OTHERS exception'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Parsing statement in program &1 at line &2 resulted in errors'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'General Error'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 statements processed'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Executing statement in program &1 at line &2 resulted in errors'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Could not remove previously generated programs'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Updating result of statement in program &1 at line &2 resulted in errors'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Generated program name: &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error generating structure for statement in program &1 at line &2'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Editing result sets is not allowed. See longtext for further help'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error unlocking table &1 in generated program &2'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Argument too long when locking table &1 in generated program &2'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error when locking table &1 in generated program &2'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Error generating lock argument for table &1 in &2, generated program &3'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Unable to get lock argument in &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Could not find field &2 in table &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Test entry already locked for table &1 in &2, generated program &3'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Unable to create lock argument in &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Unable to display data element'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'NUMBER_GET_NEXT returncode = &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Synchronize the Loop-at Workbench with its parent command first'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Table structures are different. Possible field type mismatch.'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Table &1 already exists'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'No syntax errors found'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Value Ranges are not available for Pooled and Clustered tables'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'You don''t have authorization to use keyword CLIENT SPECIFIED'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Aggregate functions in the field list are not supported'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'At least one key field must be included in the field list'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'You have no authorization to access data in table &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'All records must be locked before executing a Loop-at Workbench'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'The command must be executed first'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '* Results from command &1 executed at &2 &3'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '* &1 records saved, &2 bytes transferred'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'No table exists for the selected command'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Really delete the command and the underlying backup table &1?'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Backup table &1 successfully deleted'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Exactly one column must be selected to invoke the Column Options dialog'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Background job could not be started'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Background job &1 successfully started'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Output file &1 could not be created'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 Displaying records from &2 to &3'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'There result contains &1 records'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'The query returned &1 record(s)'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Output file &1 successfully created'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 records successfully updated/deleted'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Cannot open file &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Result set could not be imported from file &1'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Field list has changed, cannot display the results'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Unable to open file on the application server'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Table could not be locked'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'No records were updated/deleted'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'You have no authorization to display any of the selected fields'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'Report succesfully generated'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'The command must be parsed successfully before generating a report'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = 'You have no authorization to create records with the specified keys'. APPEND ls_t100 TO lt_t100.
      ls_t100-text = '&1 records read from the database'. APPEND ls_t100 TO lt_t100.

      LOOP AT lt_t100 INTO ls_t100.

        IF sy-tabix < 45.
          ls_t100-msgnr = sy-tabix - 1.
        ELSEIF ( sy-tabix > 44 ) AND ( sy-tabix < 59 ).
          ls_t100-msgnr = sy-tabix.
        ELSEIF sy-tabix > 58.
          ls_t100-msgnr = sy-tabix + 1.
        ENDIF.

        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
          EXPORTING
            input  = ls_t100-msgnr
          IMPORTING
            output = ls_t100-msgnr.

        MODIFY lt_t100 FROM ls_t100 INDEX sy-tabix.

      ENDLOOP.

      INSERT t100 FROM TABLE lt_t100.

      DATA: ls_t100u TYPE t100u,
            ls_tadir TYPE tadir.

      LOOP AT lt_t100 INTO ls_t100.

        ls_t100u-arbgb   = lv_msgclass.
        ls_t100u-msgnr   = ls_t100-msgnr.
        ls_t100u-name    = sy-uname.
        ls_t100u-datum   = sy-datum.
        ls_t100u-selfdef = '3'.

        INSERT t100u FROM ls_t100u.

      ENDLOOP.

      ls_tadir-pgmid      = 'R3TR'.
      ls_tadir-object     = 'MSAG'.
      ls_tadir-devclass   = '$TMP'.
      ls_tadir-obj_name   = lv_msgclass.
      ls_tadir-cproject   = ' L'.
      ls_tadir-srcsystem  = sy-sysid.
      ls_tadir-author     = sy-uname.
      ls_tadir-masterlang = sy-langu.

      INSERT tadir FROM ls_tadir.

    ENDIF.

    CALL FUNCTION 'RS_TOOL_ACCESS'
      EXPORTING
        operation       = 'ACTIVATE'
        object_name     = sy-repid
        object_type     = 'PROG'
        with_objectlist = 'X'
        with_worklist   = 'X'
      EXCEPTIONS
        OTHERS          = 1.

    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    DATA: lv_str TYPE string.

    CONCATENATE 'Now you can use transaction ' sy-repid '.' INTO lv_str SEPARATED BY ''.

    CALL FUNCTION 'POPUP_TO_INFORM'
      EXPORTING
        titel = 'Installation completed'
        txt1  = lv_str
        txt2  = 'If you like this application, please share it with your '
        txt3  = 'friends on social networks, forums and blogs.'
        txt4  = 'Thank you! This message will not pop up again.'.

    LEAVE PROGRAM.

  ENDIF.

ENDFORM.                    " INSTALL

*&---------------------------------------------------------------------*
*&      Form  update
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM update.

  DATA: uri              TYPE saeuri,
        content_txt      TYPE  soli_tab,
        lv_latestversion LIKE LINE OF content_txt,
        lv_latestver_int TYPE i.

  uri = 'http://www.hovitaga.com/files/oe_latestversion_700.txt'.
  PERFORM get_file USING uri CHANGING content_txt.

  CHECK content_txt IS NOT INITIAL.

  READ TABLE content_txt INTO lv_latestversion INDEX 1.

  IF sy-subrc EQ 0.

    lv_latestver_int = lv_latestversion.

    IF lv_latestversion GT gc_version.

      DATA: lv_current TYPE string,
            lv_latest  TYPE string,
            lv_answer  TYPE c.

      DATA: lv_url(255) TYPE c.
      DATA: content_bin_255 TYPE  solix_tab.

      CONCATENATE 'Current version:' gc_version INTO lv_current SEPARATED BY space.
      CONCATENATE 'Latest version:' lv_latestversion INTO lv_latest SEPARATED BY space.

      CALL FUNCTION 'POPUP_TO_DECIDE'
        EXPORTING
*         DEFAULTOPTION           = '1'
          textline1               = 'An newer version is available.'
          textline2               = lv_current
          textline3               = lv_latest
          text_option1            = 'Update'
          text_option2            = 'No thanks'
*         ICON_TEXT_OPTION1       = ' '
*         ICON_TEXT_OPTION2       = ' '
          titel                   = 'Update forund'
*         START_COLUMN            = 25
*         START_ROW               = 6
          CANCEL_DISPLAY          = ' '
        IMPORTING
          answer                  = lv_answer.

      IF lv_answer EQ '1'.

        uri = 'http://www.hovitaga.com/files/oe_source_700.txt'.
        PERFORM get_file USING uri CHANGING content_txt.

        DATA: lv_msg      TYPE string,
              lv_line     TYPE n,
              lv_word     TYPE char50,
              lv_replace  TYPE string.

        CONCATENATE 'gc_hash(32) TYPE c VALUE ''' gc_hash '''' INTO lv_replace.
        REPLACE ALL OCCURRENCES OF 'gc_hash(32) TYPE c VALUE ''e130d57ba1c629c83107bce22ae5f594''' IN TABLE content_txt WITH lv_replace.

        SYNTAX-CHECK FOR content_txt
          MESSAGE lv_msg
          LINE lv_line
          WORD lv_word
          PROGRAM sy-repid.

        IF sy-subrc NE 0.
          MESSAGE 'Syntax check failed. Please download the update manually from hovitaga.com' TYPE 'I'.

          CONCATENATE 'http://www.hovitaga.com/'
          'updated.php?h='
          gc_hash
          '&oldversion='
          gc_version
          '&newversion='
          lv_latestversion
          '&statuscode=SyntaxCheckFailed'
          INTO lv_url.

          CONDENSE lv_url NO-GAPS.

          CALL FUNCTION 'DP_GET_STREAM_FROM_URL'
            EXPORTING
              url            = lv_url
            TABLES
              data           = content_bin_255
            EXCEPTIONS
              dp_fail        = 1
              dp_failed_init = 2
              OTHERS         = 3.

          IF sy-subrc <> 0.
*            RETURN.
          ENDIF.

          RETURN.
        ENDIF.

        INSERT REPORT sy-repid FROM content_txt.

        IF sy-subrc EQ 0.

          CONCATENATE 'http://www.hovitaga.com/'
          'updated.php?h='
          gc_hash
          '&oldversion='
          gc_version
          '&newversion='
          lv_latestversion
          '&statuscode=Success'
          INTO lv_url.

          CONDENSE lv_url NO-GAPS.

          CALL FUNCTION 'DP_GET_STREAM_FROM_URL'
            EXPORTING
              url            = lv_url
            TABLES
              data           = content_bin_255
            EXCEPTIONS
              dp_fail        = 1
              dp_failed_init = 2
              OTHERS         = 3.

          IF sy-subrc <> 0.
*            RETURN.
          ENDIF.

          CALL FUNCTION 'POPUP_TO_DECIDE'
            EXPORTING
*             DEFAULTOPTION           = '1'
              textline1               = 'In order to make the changes effective,'
              textline2               = 'the program has to be restarted.'
              text_option1            = 'Exit'
              text_option2            = 'Show changelog'
*             ICON_TEXT_OPTION1       = ' '
*             ICON_TEXT_OPTION2       = ' '
              titel                   = 'Update successful'
*             START_COLUMN            = 25
*             START_ROW               = 6
              CANCEL_DISPLAY          = ' '
            IMPORTING
              answer                  = lv_answer.

          IF lv_answer EQ '2'.

            DATA: lv_string TYPE string.

            lv_string = 'http://www.hovitaga.com/files/oe_changelog_700.txt'.

            CALL METHOD CL_GUI_FRONTEND_SERVICES=>EXECUTE
              EXPORTING
                document = lv_string.

          ENDIF.

          LEAVE PROGRAM.
        ELSE.
          MESSAGE 'Update failed (INSERT REPORT subrc NE 0)' TYPE 'I'.

          CONCATENATE 'http://www.hovitaga.com/'
          'updated.php?h='
          gc_hash
          '&oldversion='
          gc_version
          '&newversion='
          lv_latestversion
          '&statuscode=InsertReportFailed'
          INTO lv_url.

          CONDENSE lv_url NO-GAPS.

          CALL FUNCTION 'DP_GET_STREAM_FROM_URL'
            EXPORTING
              url            = lv_url
            TABLES
              data           = content_bin_255
            EXCEPTIONS
              dp_fail        = 1
              dp_failed_init = 2
              OTHERS         = 3.

          IF sy-subrc <> 0.
*            RETURN.
          ENDIF.

        ENDIF.

      ELSE.
        RETURN.
      ENDIF.

    ENDIF.

  ENDIF.

ENDFORM.                    "update

*&---------------------------------------------------------------------*
*&      Form  get_file
*&---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      -->URL        text
*      -->CONTENT    text
*----------------------------------------------------------------------*
FORM get_file USING url TYPE saeuri CHANGING content TYPE soli_tab.

  DATA: content_bin_255 TYPE  solix_tab.

  CALL FUNCTION 'DP_GET_STREAM_FROM_URL'
    EXPORTING
      url            = url
    TABLES
      data           = content_bin_255
    EXCEPTIONS
      dp_fail        = 1
      dp_failed_init = 2
      OTHERS         = 3.

  IF sy-subrc <> 0.
    RETURN.
  ENDIF.

  CHECK content_bin_255 IS NOT INITIAL.

  DATA: lv_string TYPE string.

  CALL FUNCTION 'SCMS_BINARY_TO_STRING'
    EXPORTING
      input_length  = 999999999
    IMPORTING
      text_buffer   = lv_string
*      output_length = lv_len_out
    TABLES
      binary_tab    = content_bin_255.

  CLEAR content.
  SPLIT lv_string AT cl_abap_char_utilities=>cr_lf INTO TABLE content.


ENDFORM.                    "get_file

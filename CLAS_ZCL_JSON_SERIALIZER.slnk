<?xml version="1.0" encoding="utf-8"?>
<CLAS CLSNAME="ZCL_JSON_SERIALIZER" VERSION="1" LANGU="E" DESCRIPT="Serialize ABAP data into JSON format" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 ">
 <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes

class lcl_test implementation .
  method setup .
  endmethod .
  method teardown .
    clear serializer .
  endmethod .
  method test_struct .
    data l_struct type t_struct .

    l_struct-c1 = &apos;comp1&apos; .
    l_struct-c2 = &apos;comp2&apos; .

    create object serializer exporting data = l_struct .
    serializer-&gt;serialize( ) .

    result = serializer-&gt;get_data( ) .
    assert_equals(
        exp = &apos;{c1: &quot;comp1&quot;, c2: &quot;comp2&quot;}&apos;
        act = result ) .
  endmethod .
  method test_itab .
    data l_itab type standard table of string .

    append &apos;line1&apos; to l_itab .
    append &apos;line2&apos; to l_itab .

    create object serializer exporting data = l_itab .
    serializer-&gt;serialize( ) .

    result = serializer-&gt;get_data( ) .
    assert_equals(
        exp = &apos;[&quot;line1&quot;, &quot;line2&quot;]&apos;
        act = result ) .
  endmethod .
  method test_deep .
    data:
      begin of l_deep ,
        itab1 type standard table of t_struct ,
        itab2 type standard table of t_struct ,
      end of l_deep ,
      l_row type t_struct .

    l_row-c1 = &apos;comp1&apos; .
    l_row-c2 = &apos;comp2&apos; .
    append l_row to l_deep-itab1 .
    append l_row to l_deep-itab1 .
    append l_row to l_deep-itab2 .
    append l_row to l_deep-itab2 .

    create object serializer exporting data = l_deep .
    serializer-&gt;serialize( ) .

    result = serializer-&gt;get_data( ) .

    constants c_exp_comp type string value &apos;{c1: &quot;comp1&quot;, c2: &quot;comp2&quot;}&apos; .
    data l_expected type string value
          &apos;{itab1: [&amp;comp, &amp;comp], itab2: [&amp;comp, &amp;comp]}&apos; .
    replace all occurrences of &apos;&amp;comp&apos; in l_expected with c_exp_comp .

    assert_equals(
        exp = l_expected
        act = result ) .
  endmethod .
endclass .</localImplementation>
 <localTypes>*&quot;* use this source file for any type declarations (class
*&quot;* definitions, interfaces or data types) you need for method
*&quot;* implementation or private method&apos;s signature

class lcl_test definition
    for testing &quot;#AU Risk_Level Harmless
    inheriting from cl_aunit_assert .
  private section .
    methods:
      setup ,
      teardown ,
      test_struct for testing ,
      test_itab for testing ,
      test_deep for testing .
    types:
      begin of t_struct ,
        c1 type string ,
        c2 type string ,
      end of t_struct .
    data:
      serializer type ref to cl_trex_json_serializer ,
      result type string .
endclass .</localTypes>
 <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
 <attribute CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="C_COLON" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="C_COMMA" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="DATA_REF" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="DATA" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="FRAGMENTS" VERSION="1" LANGU="E" DESCRIPT="Table of STRINGs" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="TREXT_STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <method CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="CLASS_CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CLASS_CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <source>method CLASS_CONSTRUCTOR.
  cl_abap_string_utilities=&gt;c2str_preserving_blanks(
      exporting source = &apos;: &apos;
      importing dest   = c_colon ) .
  cl_abap_string_utilities=&gt;c2str_preserving_blanks(
      exporting source = &apos;, &apos;
      importing dest   = c_comma ) .
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="CONSTRUCTOR" VERSION="1" LANGU="E" DESCRIPT="CONSTRUCTOR" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="2" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="CONSTRUCTOR" SCONAME="DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="2" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <source>method CONSTRUCTOR.
  get reference of data into me-&gt;data_ref .
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="GET_DATA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="GET_DATA" SCONAME="RVAL" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>method GET_DATA.
  concatenate lines of me-&gt;fragments into rval .
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="RECURSE" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="RECURSE" SCONAME="DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="DATA"/>
  <source>method RECURSE.
*  data:
*    l_type  type c ,
*    l_comps type i ,
*    l_lines type i ,
*    l_index type i ,
*    l_value type string .
*  field-symbols:
*    &lt;itab&gt; type any table ,
*    &lt;comp&gt; type any .
*
*  describe field data type l_type components l_comps .
*
*  if l_type = cl_abap_typedescr=&gt;typekind_table .
**   itab -&gt; array
*    append &apos;[&apos; to me-&gt;fragments .
*    assign data to &lt;itab&gt; .
*    l_lines = lines( &lt;itab&gt; ) .
*    loop at &lt;itab&gt; assigning &lt;comp&gt; .
*      add 1 to l_index .
*      recurse( &lt;comp&gt; ) .
*      if l_index &lt; l_lines .
*        append c_comma to me-&gt;fragments .
*      endif .
*    endloop .
*    append &apos;]&apos; to fragments .
*  else .
*    if l_comps is initial .
**     field -&gt; scalar
**     todo: format
*      l_value = data .
*      replace all occurrences of &apos;\&apos; in l_value with &apos;\\&apos; .
*      replace all occurrences of &apos;&quot;&apos; in l_value with &apos;\&quot;&apos; .
*      replace all occurrences of &apos;&apos;&apos;&apos; in l_value with &apos;\&apos;&apos;&apos; .
*      concatenate &apos;&quot;&apos; l_value &apos;&quot;&apos; into l_value .
*      append l_value to me-&gt;fragments .
*    else .
**     structure -&gt; object
*      data l_typedescr type ref to cl_abap_structdescr .
*      field-symbols &lt;abapcomp&gt; type abap_compdescr .
*
*      append &apos;{&apos; to me-&gt;fragments .
*      l_typedescr ?= cl_abap_typedescr=&gt;describe_by_data( data ) .
*      loop at l_typedescr-&gt;components assigning &lt;abapcomp&gt; .
*        l_index = sy-tabix .
*        concatenate &lt;abapcomp&gt;-name c_colon into l_value .
*        translate l_value to lower case .
*        append l_value to me-&gt;fragments .
*        assign component &lt;abapcomp&gt;-name of structure data to &lt;comp&gt; .
*        recurse( &lt;comp&gt; ) .
*        if l_index &lt; l_comps .
*          append c_comma to me-&gt;fragments .
*
*        endif .
*      endloop .
*      append &apos;}&apos; to me-&gt;fragments .
*    endif .
*  endif .

   data:
     l_type  type c ,
     l_comps type i ,
     l_lines type i ,
     l_index type i ,
     l_value type string .
   field-symbols:
     &lt;itab&gt; type any table ,
     &lt;comp&gt; type any .

   describe field data type l_type components l_comps .

   if l_type = cl_abap_typedescr=&gt;typekind_table .
*   itab -&gt; array
     append &apos;[&apos; to me-&gt;fragments .
     assign data to &lt;itab&gt; .
     l_lines = lines( &lt;itab&gt; ) .
     loop at &lt;itab&gt; assigning &lt;comp&gt; .
       add 1 to l_index .
       recurse( &lt;comp&gt; ) .
       if l_index &lt; l_lines .
         append c_comma to me-&gt;fragments .
       endif .
     endloop .
     append &apos;]&apos; to fragments .
   else .
     if l_comps is initial .
*     field -&gt; scalar
*     todo: format
       l_value = data .
       replace all occurrences of &apos;\&apos; in l_value with &apos;\\&apos; .
       replace all occurrences of &apos;&apos;&apos;&apos; in l_value with &apos;\&apos;&apos;&apos; .
       replace all occurrences of &apos;&quot;&apos; in l_value with &apos;\&quot;&apos; .
       replace all occurrences of &apos;&amp;&apos; in l_value with &apos;\&amp;&apos; .
       replace all occurrences of cl_abap_char_utilities=&gt;cr_lf in l_value with &apos;\r\n&apos; .
       replace all occurrences of cl_abap_char_utilities=&gt;newline in l_value with &apos;\n&apos; .
       replace all occurrences of cl_abap_char_utilities=&gt;horizontal_tab in l_value with &apos;\t&apos; .
       replace all occurrences of cl_abap_char_utilities=&gt;backspace in l_value with &apos;\b&apos; .
       replace all occurrences of cl_abap_char_utilities=&gt;form_feed in l_value with &apos;\f&apos; .
*     space at the end of numbers
       CONDENSE l_value.
       concatenate &apos;&quot;&apos; l_value &apos;&quot;&apos; into l_value .
       append l_value to me-&gt;fragments .
     else .
*     structure -&gt; object
       data l_typedescr type ref to cl_abap_structdescr .
       field-symbols &lt;abapcomp&gt; type abap_compdescr .

       append &apos;{&apos; to me-&gt;fragments .
       l_typedescr ?= cl_abap_typedescr=&gt;describe_by_data( data ) .
       loop at l_typedescr-&gt;components assigning &lt;abapcomp&gt; .
         l_index = sy-tabix .
*         concatenate &lt;abapcomp&gt;-name c_colon into l_value .
         CONCATENATE &apos;&quot;&apos; &lt;abapcomp&gt;-name &apos;&quot;&apos; c_colon INTO l_value .
         translate l_value to lower case .
         append l_value to me-&gt;fragments .
         assign component &lt;abapcomp&gt;-name of structure data to &lt;comp&gt; .
         recurse( &lt;comp&gt; ) .
         if l_index &lt; l_comps .
           append c_comma to me-&gt;fragments .
         endif .
       endloop .
       append &apos;}&apos; to me-&gt;fragments .
     endif .
   endif .
endmethod.</source>
 </method>
 <method CLSNAME="ZCL_JSON_SERIALIZER" CMPNAME="SERIALIZE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>method SERIALIZE.
  field-symbols &lt;data&gt; type data .

  assign me-&gt;data_ref-&gt;* to &lt;data&gt; .
  recurse( &lt;data&gt; ) .
endmethod.</source>
 </method>
</CLAS>

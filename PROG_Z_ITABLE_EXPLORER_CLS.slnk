<?xml version="1.0" encoding="utf-8"?>
<PROG NAME="Z_ITABLE_EXPLORER_CLS" VARCL="X" SUBC="I" RMAND="100" RLOAD="E" UCCHECK="X">
 <textPool>
  <language SPRAS="E">
   <textElement ID="R" ENTRY="Include Z_ITABLE_EXPLORER_CLS" LENGTH="29 "/>
  </language>
 </textPool>
 <source>CLASS lcl_data_receiver DEFINITION DEFERRED.
CLASS lcl_data_transmitter DEFINITION DEFERRED.
CLASS lcl_rtti_tree DEFINITION DEFERRED.
CLASS lcl_window DEFINITION DEFERRED.
CLASS lcl_table_viewer DEFINITION DEFERRED.

CLASS lcl_box_handler DEFINITION.&quot;for memory clearing
  PUBLIC SECTION.
    METHODS: on_box_close FOR EVENT close OF cl_gui_dialogbox_container IMPORTING sender.
ENDCLASS.


CLASS lcl_appl DEFINITION.
  PUBLIC SECTION.
    TYPES: BEGIN OF sign_option_icon_s,
             sign          TYPE tvarv_sign,
             option        TYPE tvarv_opti,
             icon_name(64) TYPE c,
             icon          TYPE aqadh_type_of_icon,
           END OF sign_option_icon_s,

           BEGIN OF var_table,
             step    TYPE i,
             stack   TYPE i,
             first   TYPE xfeld,
             leaf    TYPE string,
             name    TYPE string,
             short   TYPE string,
             key     TYPE salv_de_node_key,
             cl_leaf TYPE int4,
             ref     TYPE REF TO data,
             tree    TYPE REF TO lcl_rtti_tree,
             class   TYPE string,
           END OF var_table,

           BEGIN OF var_table_h,
             step    TYPE i,
             leaf    TYPE string,
             name    TYPE string,
             short   TYPE string,
             cl_leaf TYPE int4,
             ref     TYPE REF TO data,
             tree    TYPE REF TO lcl_rtti_tree,
           END OF var_table_h,


           BEGIN OF var_table_temp,
             step  TYPE i,
             stack TYPE i,
             first TYPE xfeld,
             leaf  TYPE string,
             name  TYPE string,
             short TYPE string,
             class TYPE string,
           END OF var_table_temp,

           BEGIN OF t_obj,
             name       TYPE string,
             alv_viewer TYPE REF TO lcl_table_viewer,
           END OF t_obj,

           BEGIN OF t_classes_types,
             name TYPE string,
             full TYPE string,
             type TYPE char1,
             key  TYPE salv_de_node_key,
           END OF t_classes_types,

           BEGIN OF t_lang,
             spras(4),
             sptxt    TYPE sptxt,
           END OF t_lang  ,
           BEGIN OF t_stack,
             stackpointer TYPE tpda_stack_pointer,
             stacklevel   TYPE tpda_stack_level,
             program      TYPE tpda_program,
             include      TYPE tpda_include,
             line         TYPE tpda_sc_line,
             eventtype    TYPE tpda_event_type,
             eventname    TYPE tpda_event,
           END OF t_stack,

           BEGIN OF t_step_counter,
             step       TYPE i,
             stacklevel TYPE tpda_stack_level,
             program    TYPE tpda_program,
             include    TYPE tpda_include,
             line       TYPE tpda_sc_line,
             eventtype  TYPE tpda_event_type,
             eventname  TYPE tpda_event,
           END OF t_step_counter.

    CLASS-DATA: m_option_icons     TYPE TABLE OF sign_option_icon_s,
                mt_lang            TYPE TABLE OF t_lang,
                mt_obj             TYPE TABLE OF t_obj, &quot;main object table
                m_ctrl_box_handler TYPE REF TO lcl_box_handler,
                c_dragdropalv      TYPE REF TO cl_dragdrop.

    CLASS-METHODS:
      init_icons_table,
      init_lang,
      open_int_table IMPORTING it_tab  TYPE ANY TABLE OPTIONAL
                               it_ref  TYPE REF TO data OPTIONAL
                               iv_name TYPE string
                               iv_dummy type xfeld OPTIONAL
                               iv_show  type xfeld OPTIONAL
                               i_tname TYPE string OPTIONAL.
ENDCLASS.

CLASS lcl_popup DEFINITION.
  PUBLIC SECTION.
    CLASS-DATA m_counter              TYPE i.
    DATA: m_additional_name      TYPE string,
          mo_box                 TYPE REF TO cl_gui_dialogbox_container,
          mo_splitter            TYPE REF TO cl_gui_splitter_container,
          mo_variables_container TYPE REF TO cl_gui_container.

    METHODS: constructor IMPORTING i_additional_name TYPE string OPTIONAL,
      create IMPORTING i_width       TYPE i
                       i_hight       TYPE i
                       i_name        TYPE text100 OPTIONAL
             RETURNING VALUE(ro_box) TYPE REF TO cl_gui_dialogbox_container,

      on_box_close FOR EVENT close OF cl_gui_dialogbox_container IMPORTING sender.
ENDCLASS.

CLASS lcl_popup IMPLEMENTATION.

  METHOD constructor.
    m_additional_name = i_additional_name.
  ENDMETHOD.

  METHOD create.
    DATA: l_top  TYPE i,
          l_left TYPE i.

    ADD 1 TO m_counter.
    l_top  = l_left = 5 + 5 * ( m_counter DIV 5 ) +  ( m_counter MOD 5 ) * 50.

    CREATE OBJECT ro_box
      EXPORTING
        width                       = i_width
        height                      = i_hight
        top                         = l_top
        left                        = l_left
        caption                     = i_name
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        lifetime_dynpro_dynpro_link = 5
        event_already_registered    = 6
        error_regist_event          = 7
        OTHERS                      = 8.
    IF sy-subrc &lt;&gt; 0.
      RETURN.
    ENDIF.
  ENDMETHOD.

  METHOD on_box_close.
    sender-&gt;free( ).
  ENDMETHOD.

ENDCLASS.

CLASS lcl_ddic DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: get_text_table IMPORTING i_tname TYPE tabname
                                  EXPORTING e_tab   TYPE tabname.
ENDCLASS.

CLASS lcl_ddic IMPLEMENTATION.
  METHOD get_text_table.
    CALL FUNCTION &apos;DDUT_TEXTTABLE_GET&apos;
      EXPORTING
        tabname   = i_tname
      IMPORTING
        texttable = e_tab.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_dd_data DEFINITION.&quot;drag&amp;drop data
  PUBLIC  SECTION.
    DATA: m_row    TYPE i,
          m_column TYPE lvc_s_col.
ENDCLASS.

CLASS lcl_dragdrop DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      drag FOR EVENT ondrag OF cl_gui_alv_grid IMPORTING e_dragdropobj e_row e_column ,
      drop FOR EVENT ondrop OF cl_gui_alv_grid IMPORTING e_dragdropobj e_row.
ENDCLASS.

CLASS lcl_sql DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      read_any_table IMPORTING i_tabname   TYPE tabname
                               i_where     TYPE string
                               i_row_count TYPE i OPTIONAL
                     CHANGING  cr_tab      TYPE REF TO data
                               c_count     TYPE i,
      exist_table IMPORTING i_tab TYPE tabname RETURNING VALUE(e_subrc) LIKE sy-subrc,
      exist_view  IMPORTING i_tab TYPE tabname RETURNING VALUE(e_subrc) LIKE sy-subrc,
      exist_cds   IMPORTING i_tab TYPE tabname RETURNING VALUE(e_subrc) LIKE sy-subrc  .
ENDCLASS.

CLASS lcl_sql IMPLEMENTATION.
  METHOD read_any_table.
    FIELD-SYMBOLS: &lt;f_tab&gt; TYPE ANY TABLE.

    ASSIGN cr_tab-&gt;* TO &lt;f_tab&gt;.
    c_count = lines( &lt;f_tab&gt; ).
    CHECK lcl_sql=&gt;exist_table( i_tabname ) = 1.
    IF i_where IS NOT INITIAL.
      TRY.
          SELECT * FROM (i_tabname) INTO CORRESPONDING FIELDS OF  TABLE &lt;f_tab&gt; WHERE (i_where) ORDER BY PRIMARY KEY
           .
        CATCH cx_sy_dynamic_osql_semantics.             &quot;#EC NO_HANDLER
        CATCH cx_sy_dynamic_osql_syntax.                &quot;#EC NO_HANDLER
        CATCH cx_sy_conversion_no_number.               &quot;#EC NO_HANDLER
      ENDTRY.
    ELSE.
      IF i_row_count IS NOT SUPPLIED.
        SELECT * FROM (i_tabname) INTO CORRESPONDING FIELDS OF TABLE &lt;f_tab&gt; ORDER BY PRIMARY KEY.
      ELSE.
        SELECT * FROM (i_tabname) INTO CORRESPONDING FIELDS OF TABLE &lt;f_tab&gt; UP TO i_row_count ROWS ORDER BY PRIMARY KEY..
      ENDIF.
    ENDIF.
    c_count = sy-dbcnt.
  ENDMETHOD.

  METHOD exist_table.
    SELECT COUNT( * ) FROM dd02l
     WHERE tabname = i_tab
       AND ( tabclass = &apos;TRANSP&apos; OR tabclass = &apos;CLUSTER&apos; ).
    e_subrc = sy-dbcnt.
  ENDMETHOD.

  METHOD exist_view.
    SELECT COUNT( * ) FROM dd02l
     WHERE tabname = i_tab
       AND tabclass = &apos;VIEW&apos;.
    e_subrc = sy-dbcnt.
  ENDMETHOD.

  METHOD exist_cds.
    SELECT COUNT( * ) FROM dd02l
     WHERE tabname = i_tab
       AND tabclass = &apos;VIEW&apos;
       AND applclass = &apos;SDGV&apos;.
    e_subrc = sy-dbcnt.
  ENDMETHOD.
ENDCLASS.


CLASS lcl_alv_common DEFINITION.
  PUBLIC SECTION.
    CONSTANTS: c_white(4) TYPE x VALUE &apos;00000001&apos;, &quot;white background
               c_grey(4)  TYPE x VALUE &apos;00000003&apos;, &quot;gray background
               c_green(4) TYPE x VALUE &apos;00000216&apos;, &quot;green +underline
               c_blue(4)  TYPE x VALUE &apos;00000209&apos;, &quot; blue font +underline
               c_bold(4)  TYPE x VALUE &apos;00000020&apos;.

    TYPES: BEGIN OF t_tabfields.
             INCLUDE TYPE   dfies.
             TYPES: empty   TYPE xfeld,
             is_text TYPE xfeld,
           END OF t_tabfields.

    CLASS-DATA: mt_tabfields TYPE HASHED TABLE OF t_tabfields WITH UNIQUE KEY tabname fieldname.


    CLASS-METHODS:
      refresh IMPORTING i_obj TYPE REF TO cl_gui_alv_grid i_layout TYPE lvc_s_layo OPTIONAL i_soft TYPE char01 OPTIONAL,
      translate_field IMPORTING i_lang TYPE ddlanguage OPTIONAL CHANGING c_fld TYPE lvc_s_fcat,
      get_selected IMPORTING i_obj TYPE REF TO cl_gui_alv_grid RETURNING VALUE(e_index) TYPE i.
ENDCLASS.

CLASS lcl_alv_common IMPLEMENTATION.
  METHOD refresh.
    DATA l_stable TYPE lvc_s_stbl.
    l_stable = &apos;XX&apos;.
    IF i_layout IS SUPPLIED.
      i_obj-&gt;set_frontend_layout( i_layout ) .
    ENDIF.
    i_obj-&gt;refresh_table_display( EXPORTING is_stable = l_stable i_soft_refresh = i_soft  ).
  ENDMETHOD.

  METHOD translate_field.
    DATA: lt_field_info TYPE TABLE OF dfies.

    CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
      EXPORTING
        tabname        = c_fld-tabname
        fieldname      = c_fld-fieldname
        langu          = i_lang
      TABLES
        dfies_tab      = lt_field_info
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.

    IF sy-subrc = 0.
      READ TABLE lt_field_info INDEX 1 INTO DATA(l_info).
      IF l_info-scrtext_l IS INITIAL AND l_info-scrtext_m IS INITIAL AND l_info-scrtext_s IS INITIAL.
        IF l_info-fieldtext IS NOT INITIAL.
          MOVE l_info-fieldtext TO: c_fld-reptext, c_fld-scrtext_l, c_fld-scrtext_m, c_fld-scrtext_s .
        ELSE.
          MOVE l_info-fieldname TO: c_fld-reptext, c_fld-scrtext_l, c_fld-scrtext_m, c_fld-scrtext_s .
        ENDIF.
      ELSE.
        c_fld-scrtext_l = l_info-scrtext_l.
        c_fld-scrtext_m = l_info-scrtext_m.
        c_fld-scrtext_s = l_info-scrtext_s.
        IF l_info-reptext IS NOT INITIAL.
          c_fld-reptext   = l_info-reptext.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDMETHOD.

  METHOD get_selected.
    i_obj-&gt;get_selected_cells( IMPORTING et_cell = DATA(lt_sel_cells) ).
    IF lines( lt_sel_cells ) &gt; 0.
      e_index = lt_sel_cells[ 1 ]-row_id.
    ELSE.
      i_obj-&gt;get_selected_rows( IMPORTING et_index_rows = DATA(lt_sel_rows) ).
      IF lines( lt_sel_rows ) &gt; 0.
        e_index = lt_sel_rows[ 1 ]-index.
      ENDIF.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_rtti DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      create_table_by_name IMPORTING i_tname TYPE tabname
                           CHANGING  c_table TYPE REF TO data,

      create_struc_handle IMPORTING i_tname  TYPE tabname
                          EXPORTING e_t_comp TYPE abap_component_tab
                                    e_handle TYPE REF TO cl_abap_structdescr.
ENDCLASS.

CLASS lcl_rtti_tree DEFINITION FINAL INHERITING FROM lcl_popup.
  PUBLIC SECTION.

    TYPES: BEGIN OF t_classes_leaf,
             name TYPE string,
             type TYPE char1,
             key  TYPE salv_de_node_key,
           END OF t_classes_leaf.

    TYPES: BEGIN OF ts_table,
             ref      TYPE REF TO data,
             kind(1),
             value    TYPE string,
             typename TYPE abap_abstypename,
             fullname TYPE string,
           END OF ts_table.

    TYPES tt_table TYPE STANDARD TABLE OF ts_table
          WITH NON-UNIQUE DEFAULT KEY.

    DATA: main_node_key   TYPE salv_de_node_key,
          m_leaf          TYPE string,
          m_variable      TYPE REF TO data,
          m_object        TYPE REF TO object,
          m_hide          TYPE x,
          m_globals       TYPE x,
          m_class_data    TYPE x,
          m_ldb           TYPE x,
          m_changed       TYPE x,
          m_locals_key    TYPE salv_de_node_key,
          m_globals_key   TYPE salv_de_node_key,
          m_class_key     TYPE salv_de_node_key,
          m_ldb_key       TYPE salv_de_node_key,
          m_debug_key     TYPE salv_de_node_key,
          m_icon          TYPE salv_de_tree_image,
          mt_vars         TYPE STANDARD TABLE OF lcl_appl=&gt;var_table,
          mt_state        TYPE STANDARD TABLE OF lcl_appl=&gt;var_table,
          mt_classes_leaf TYPE TABLE OF t_classes_leaf,
          m_new_node      TYPE salv_de_node_key,
          m_no_refresh    TYPE xfeld,
          m_prg_info      TYPE tpda_scr_prg_info,
          tree            TYPE REF TO cl_salv_tree.

    METHODS constructor IMPORTING i_header   TYPE clike DEFAULT &apos;View&apos;.
    METHODS create_popup.

    METHODS add_variable
      IMPORTING
        iv_root_name TYPE string
        iv_full_name TYPE string OPTIONAL
        iv_key       TYPE salv_de_node_key OPTIONAL
        i_icon       TYPE salv_de_tree_image OPTIONAL
        i_cl_leaf    TYPE int4 OPTIONAL
      CHANGING
        io_var       TYPE any  .

    METHODS clear.

    METHODS add_buttons.
    METHODS add_node
      IMPORTING
        iv_name TYPE string
        iv_icon TYPE salv_de_tree_image OPTIONAL.

    METHODS add_obj_var
      IMPORTING
                iv_name       TYPE lvc_value
                iv_full       TYPE string OPTIONAL
                iv_value      TYPE string OPTIONAL
                iv_key        TYPE salv_de_node_key OPTIONAL
                iv_icon       TYPE  salv_de_tree_image OPTIONAL
      RETURNING VALUE(er_key) TYPE salv_de_node_key.

    METHODS delete_node IMPORTING iv_key TYPE salv_de_node_key.
    METHODS display.

  PRIVATE SECTION.
    CONSTANTS: BEGIN OF c_kind,
                 struct LIKE cl_abap_typedescr=&gt;kind_struct VALUE cl_abap_typedescr=&gt;kind_struct,
                 table  LIKE cl_abap_typedescr=&gt;kind_table VALUE cl_abap_typedescr=&gt;kind_table,
                 elem   LIKE cl_abap_typedescr=&gt;kind_elem VALUE cl_abap_typedescr=&gt;kind_elem,
                 class  LIKE cl_abap_typedescr=&gt;kind_class VALUE cl_abap_typedescr=&gt;kind_class,
                 intf   LIKE cl_abap_typedescr=&gt;kind_intf VALUE cl_abap_typedescr=&gt;kind_intf,
                 ref    LIKE cl_abap_typedescr=&gt;kind_ref VALUE cl_abap_typedescr=&gt;kind_ref,
               END OF c_kind.

    DATA: tree_table TYPE tt_table.

    METHODS traverse
      IMPORTING
                io_type_descr     TYPE REF TO cl_abap_typedescr
                iv_parent_key     TYPE salv_de_node_key
                iv_rel            TYPE salv_de_node_relation
                iv_name           TYPE clike
                iv_fullname       TYPE string OPTIONAL
                ir_up             TYPE REF TO data OPTIONAL
                iv_parent_name    TYPE string OPTIONAL
                i_cl_leaf         TYPE int4 OPTIONAL
      RETURNING VALUE(e_root_key) TYPE salv_de_node_key.

    METHODS traverse_struct
      IMPORTING
                io_type_descr     TYPE REF TO cl_abap_typedescr
                iv_parent_key     TYPE salv_de_node_key
                iv_rel            TYPE salv_de_node_relation
                iv_name           TYPE clike
                iv_fullname       TYPE string OPTIONAL
                ir_up             TYPE REF TO data OPTIONAL
                iv_parent_name    TYPE string OPTIONAL
                i_cl_leaf         TYPE int4 OPTIONAL
      RETURNING VALUE(e_root_key) TYPE salv_de_node_key.

    METHODS traverse_elem
      IMPORTING
                io_type_descr     TYPE REF TO cl_abap_typedescr
                iv_parent_key     TYPE salv_de_node_key
                iv_rel            TYPE salv_de_node_relation
                iv_name           TYPE clike
                iv_fullname       TYPE string OPTIONAL
                iv_value          TYPE any OPTIONAL
                ir_up             TYPE REF TO data OPTIONAL
                iv_parent_name    TYPE string OPTIONAL
                i_cl_leaf         TYPE int4 OPTIONAL
      RETURNING VALUE(e_root_key) TYPE salv_de_node_key.

    METHODS traverse_table
      IMPORTING
                io_type_descr     TYPE REF TO cl_abap_typedescr
                iv_parent_key     TYPE salv_de_node_key
                iv_rel            TYPE salv_de_node_relation
                iv_name           TYPE clike
                iv_fullname       TYPE string OPTIONAL
                ir_up             TYPE REF TO data OPTIONAL
                iv_parent_name    TYPE string OPTIONAL
                i_cl_leaf         TYPE int4 OPTIONAL
      RETURNING VALUE(e_root_key) TYPE salv_de_node_key.

    METHODS: hndl_double_click FOR EVENT double_click OF cl_salv_events_tree IMPORTING node_key,
      hndl_user_command FOR EVENT added_function OF cl_salv_events IMPORTING e_salv_function,
      check_change.
ENDCLASS.

CLASS lcl_window DEFINITION INHERITING FROM lcl_popup.
  PUBLIC SECTION.

    TYPES: BEGIN OF ts_table,
             ref      TYPE REF TO data,
             kind(1),
             value    TYPE string,
             typename TYPE abap_abstypename,
             fullname TYPE string,
           END OF ts_table.

    TYPES tt_table TYPE STANDARD TABLE OF ts_table
          WITH NON-UNIQUE DEFAULT KEY.

    DATA: m_history              TYPE x,
          m_visualization        TYPE x,
          m_zcode                TYPE x,
          m_prg                  TYPE tpda_scr_prg_info,
          m_debug_button         LIKE sy-ucomm,
          m_show_step            TYPE xfeld,
          m_update_tree          TYPE xfeld,
          mo_splitter_code       TYPE REF TO cl_gui_splitter_container,
          mo_splitter_var        TYPE REF TO cl_gui_splitter_container,
          mo_toolbar_container   TYPE REF TO cl_gui_container,
          mo_importing_container TYPE REF TO cl_gui_container,
          mo_locals_container    TYPE REF TO cl_gui_container,
          mo_exporting_container TYPE REF TO cl_gui_container,
          mo_code_container      TYPE REF TO cl_gui_container,
          mo_editor_container    TYPE REF TO cl_gui_container,
          mo_stack_container     TYPE REF TO cl_gui_container,
          mo_code_viewer         TYPE REF TO cl_gui_abapedit,
          mt_stack               TYPE TABLE OF lcl_appl=&gt;t_stack,
          mo_toolbar             TYPE REF TO cl_gui_toolbar,
          mo_salv_stack          TYPE REF TO cl_salv_table,
          mt_tree_imp            TYPE tt_table,
          mt_tree_loc            TYPE tt_table,
          mt_tree_exp            TYPE tt_table,
          mo_tree_imp            TYPE REF TO cl_salv_tree,
          mo_tree_loc            TYPE REF TO cl_salv_tree,
          mo_tree_exp            TYPE REF TO cl_salv_tree,
          mt_breaks              TYPE tpda_bp_persistent_it.

    METHODS: constructor IMPORTING i_additional_name TYPE string OPTIONAL,
      add_toolbar_buttons,
      hnd_toolbar FOR EVENT function_selected OF cl_gui_toolbar IMPORTING fcode,
      set_program IMPORTING iv_program TYPE program.

    METHODS set_program_line IMPORTING iv_line LIKE sy-index.
    METHODS create_code_viewer.
    METHODS show_stack.
ENDCLASS.


CLASS lcl_types DEFINITION ABSTRACT.
  PUBLIC SECTION.
    TYPES:
      BEGIN OF selection_display_s,
        ind         TYPE i,
        field_label TYPE lvc_fname,
        int_type(1),
        inherited   TYPE aqadh_type_of_icon,
        emitter     TYPE aqadh_type_of_icon,
        sign        TYPE tvarv_sign,
        opti        TYPE tvarv_opti,
        option_icon TYPE aqadh_type_of_icon,
        low         TYPE string,
        high        TYPE string,
        more_icon   TYPE aqadh_type_of_icon,
        range       TYPE aqadh_t_ranges,
        name        TYPE reptext,
        element     TYPE text60,
        domain      TYPE text60,
        datatype    TYPE string,
        length      TYPE i,
        transmitter TYPE REF TO lcl_data_transmitter,
        receiver    TYPE REF TO lcl_data_receiver,
        color       TYPE lvc_t_scol,
        style       TYPE lvc_t_styl,
      END OF selection_display_s,

      BEGIN OF t_sel_row,
        sign        TYPE tvarv_sign,
        opti        TYPE tvarv_opti,
        option_icon TYPE aqadh_type_of_icon,
        low         TYPE string,
        high        TYPE string,
        more_icon   TYPE aqadh_type_of_icon,
        range       TYPE aqadh_t_ranges,
      END OF t_sel_row.

    CLASS-DATA: mt_sel TYPE TABLE OF lcl_types=&gt;selection_display_s.
ENDCLASS.


CLASS lcl_window IMPLEMENTATION.

  METHOD constructor.
    super-&gt;constructor( ).
    m_history = &apos;01&apos;.
    m_zcode = &apos;01&apos;.

    mo_box = create( i_name = &apos;SDDE Simple Debugger Data Explorer beta v. 0.2&apos; i_width = 1200 i_hight = 400 ).
    CREATE OBJECT mo_splitter ##FM_SUBRC_OK
      EXPORTING
        parent  = mo_box
        rows    = 3
        columns = 1
      EXCEPTIONS
        OTHERS  = 1.

    mo_splitter-&gt;get_container(
     EXPORTING
       row       = 2
       column    = 1
     RECEIVING
       container = mo_code_container ).

    mo_splitter-&gt;get_container(
      EXPORTING
        row       = 1
        column    = 1
      RECEIVING
        container = mo_toolbar_container ).

    mo_splitter-&gt;set_row_height( id = 1  height = &apos;3&apos; ).

    mo_splitter-&gt;set_row_sash( id    = 1 type  = 0 value = 0 ).

    mo_splitter-&gt;get_container(
      EXPORTING
        row       = 3
        column    = 1
      RECEIVING
        container = mo_variables_container ).

    CREATE OBJECT mo_splitter_code ##FM_SUBRC_OK
      EXPORTING
        parent  = mo_code_container
        rows    = 1
        columns = 2
      EXCEPTIONS
        OTHERS  = 1.

    mo_splitter_code-&gt;get_container(
         EXPORTING
           row       = 1
           column    = 1
         RECEIVING
           container = mo_editor_container ).

    mo_splitter_code-&gt;get_container(
         EXPORTING
           row       = 1
           column    = 2
         RECEIVING
           container = mo_stack_container ).

    mo_splitter_code-&gt;set_column_width( EXPORTING id = 1 width = &apos;67&apos; ).

    CREATE OBJECT mo_splitter_var ##FM_SUBRC_OK
      EXPORTING
        parent  = mo_variables_container
        rows    = 1
        columns = 3
      EXCEPTIONS
        OTHERS  = 1.

    mo_splitter_var-&gt;set_column_width( EXPORTING id = 1 width = &apos;25&apos; ).
    mo_splitter_var-&gt;set_column_width( EXPORTING id = 2 width = &apos;50&apos; ).
    mo_splitter_var-&gt;set_column_width( EXPORTING id = 3 width = &apos;25&apos; ).

    mo_splitter_var-&gt;get_container(
             EXPORTING
               row       = 1
               column    = 1
             RECEIVING
               container = mo_importing_container ).

    mo_splitter_var-&gt;get_container(
         EXPORTING
           row       = 1
           column    = 2
         RECEIVING
           container = mo_locals_container ).

    mo_splitter_var-&gt;get_container(
             EXPORTING
               row       = 1
               column    = 3
             RECEIVING
               container = mo_exporting_container ).

    SET HANDLER on_box_close FOR mo_box.

    CREATE OBJECT mo_toolbar EXPORTING parent = mo_toolbar_container.
    mo_toolbar-&gt;set_visible( &apos;X&apos; ).
    add_toolbar_buttons( ).
    create_code_viewer( ).

  ENDMETHOD.

  METHOD add_toolbar_buttons.
    DATA: lt_button TYPE ttb_button,
          ls_button LIKE LINE OF lt_button,
          lt_events TYPE cntl_simple_events,
          ls_events LIKE LINE OF lt_events.

    CLEAR ls_button.
    ls_button-function = &apos;HIST&apos;.
    ls_button-icon = CONV #( icon_graduate ).
    ls_button-quickinfo = &apos;History On&apos;.
    ls_button-text = &apos;History On&apos;.
    ls_button-butn_type = 0.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-function = &apos;VIS&apos;.
    ls_button-icon = CONV #( icon_flight ).
    ls_button-quickinfo = &apos;Visualization Off&apos;.
    ls_button-text = &apos;Visualization Off&apos;.
    ls_button-butn_type = 0.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-function = &apos;CODE&apos;.
    ls_button-icon = CONV #( icon_customer_warehouse ).
    ls_button-quickinfo = &apos;Only Z&apos;.
    ls_button-text = &apos;Only Z&apos;.
    ls_button-butn_type = 0.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-butn_type = 3.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-function = &apos;F5&apos;.
    ls_button-icon = CONV #( icon_debugger_step_into ).
    ls_button-quickinfo = &apos;Step into&apos;.
    ls_button-text = &apos;Step into&apos;.
    ls_button-butn_type = 0.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-function = &apos;F6BEG&apos;.
    ls_button-icon = CONV #( icon_release ).
    ls_button-quickinfo = &apos;Start of block&apos;.
    ls_button-text = &apos;Start of block&apos;.
    ls_button-butn_type = 0.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-function = &apos;F7END&apos;.
    ls_button-icon = CONV #( icon_outgoing_org_unit ).
    ls_button-quickinfo = &apos;End of block&apos;.
    ls_button-text = &apos;End of block &apos;.
    ls_button-butn_type = 0.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-function = &apos;F6&apos;.
    ls_button-icon = CONV #( icon_debugger_step_over ).
    ls_button-quickinfo = &apos;Step over&apos;.
    ls_button-text = &apos;Step over&apos;.
    ls_button-butn_type = 0.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-function = &apos;F7&apos;.
    ls_button-icon = CONV #( icon_debugger_step_out ).
    ls_button-quickinfo = &apos;Step out&apos;.
    ls_button-text = &apos;Step out&apos;.
    ls_button-butn_type = 0.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-function = &apos;F8&apos;.
    ls_button-icon = CONV #( icon_debugger_continue ).
    ls_button-quickinfo = &apos;Continue&apos;.
    ls_button-text = &apos;Continue&apos;.
    ls_button-butn_type = 0.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-butn_type = 3.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-function = &apos;BACK&apos;.
    ls_button-icon = CONV #( icon_column_left ).
    ls_button-quickinfo = &apos;Step Back&apos;.
    ls_button-text = &apos;Step Back&apos;.
    ls_button-butn_type = 0.
    APPEND ls_button TO lt_button.

    CLEAR ls_button.
    ls_button-function = &apos;FORW&apos;.
    ls_button-icon = CONV #( icon_column_right ).
    ls_button-quickinfo = &apos;Step forward&apos;.
    ls_button-text = &apos;Forward&apos;.
    ls_button-butn_type = 0.
    APPEND ls_button TO lt_button.

    mo_toolbar-&gt;add_button_group( lt_button ).

* Register events
    ls_events-eventid = cl_gui_toolbar=&gt;m_id_function_selected.
    ls_events-appl_event = space.
    APPEND ls_events TO lt_events.

    mo_toolbar-&gt;set_registered_events( events = lt_events ).
    SET HANDLER me-&gt;hnd_toolbar FOR mo_toolbar.
  ENDMETHOD.

  METHOD set_program.
    DATA gr_scan TYPE REF TO cl_ci_scan.
    DATA(gr_source) = cl_ci_source_include=&gt;create( p_name = iv_program ).

    CREATE OBJECT gr_scan EXPORTING p_include = gr_source .
    mo_code_viewer-&gt;set_text( table = gr_source-&gt;lines  ).
  ENDMETHOD.

  METHOD set_program_line.
    TYPES: lntab TYPE STANDARD TABLE OF i.
    DATA lt_lines TYPE lntab.

    APPEND INITIAL LINE TO lt_lines ASSIGNING FIELD-SYMBOL(&lt;line&gt;).
    &lt;line&gt; = iv_line.
    mo_code_viewer-&gt;set_marker( EXPORTING marker_number = 7  marker_lines = lt_lines ).

    CLEAR lt_lines.

    LOOP AT mt_breaks INTO DATA(ls_break) WHERE inclnamesrc = m_prg-include.
      APPEND INITIAL LINE TO lt_lines ASSIGNING &lt;line&gt;.
      &lt;line&gt; = ls_break-linesrc.
    ENDLOOP.
    mo_code_viewer-&gt;set_marker( EXPORTING marker_number = 9  marker_lines = lt_lines ).
    mo_code_viewer-&gt;select_lines( EXPORTING from_line = iv_line to_line = iv_line ).
  ENDMETHOD.

  METHOD create_code_viewer.
    CHECK mo_code_viewer IS INITIAL.

    CREATE OBJECT mo_code_viewer
      EXPORTING
        parent           = mo_editor_container
        max_number_chars = 100.

    mo_code_viewer-&gt;init_completer( ).
    mo_code_viewer-&gt;upload_properties(
           EXCEPTIONS
             dp_error_create  = 1
             dp_error_general = 2
             dp_error_send    = 3
             OTHERS           = 4 ).

    mo_code_viewer-&gt;set_statusbar_mode( statusbar_mode = cl_gui_abapedit=&gt;true ).
    mo_code_viewer-&gt;create_document( ).
    mo_code_viewer-&gt;set_readonly_mode( 1 ).
  ENDMETHOD.

  METHOD show_stack.
    IF mo_salv_stack IS INITIAL.
      cl_salv_table=&gt;factory(
  EXPORTING
    r_container = mo_stack_container
  IMPORTING
  r_salv_table = mo_salv_stack
  CHANGING
  t_table = mt_stack ).

      DATA:  lo_column  TYPE REF TO cl_salv_column.

      DATA(lo_columns) = mo_salv_stack-&gt;get_columns( ).
      lo_columns-&gt;set_optimize( &apos;X&apos; ).

      lo_column ?= lo_columns-&gt;get_column( &apos;STACKPOINTER&apos; ).
      lo_column-&gt;set_output_length( &apos;5&apos; ).

      lo_column ?= lo_columns-&gt;get_column( &apos;STACKLEVEL&apos; ).
      lo_column-&gt;set_output_length( &apos;5&apos; ).
      mo_salv_stack-&gt;display( ).
    ELSE.
      mo_salv_stack-&gt;refresh( ).
    ENDIF.
  ENDMETHOD.

  METHOD hnd_toolbar.
    CONSTANTS: c_mask TYPE x VALUE &apos;01&apos;.
    &quot;m_debug_button = fcode.

  ENDMETHOD.

ENDCLASS.

CLASS lcl_sel_opt DEFINITION DEFERRED.

CLASS lcl_rtti IMPLEMENTATION.
  METHOD create_struc_handle.
    cl_abap_typedescr=&gt;describe_by_name( EXPORTING p_name          = i_tname
                                         RECEIVING p_descr_ref     = DATA(lo_descr)
                                         EXCEPTIONS type_not_found = 1 ).
    IF sy-subrc = 0.
      e_handle ?= lo_descr.
    ELSE.
      RETURN.
    ENDIF.
  ENDMETHOD.

  METHOD create_table_by_name.
    DATA: lo_new_tab  TYPE REF TO cl_abap_tabledescr,
          lo_new_type TYPE REF TO cl_abap_structdescr.

    create_struc_handle( EXPORTING i_tname = i_tname IMPORTING e_handle = lo_new_type ).
    lo_new_tab = cl_abap_tabledescr=&gt;create(
                    p_line_type  = lo_new_type
                    p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
                    p_unique     = abap_false ).
    CREATE DATA c_table TYPE HANDLE lo_new_tab.  &quot;Create a New table type
  ENDMETHOD.
ENDCLASS.

CLASS lcl_data_transmitter DEFINITION.
  PUBLIC SECTION.
    EVENTS: data_changed EXPORTING VALUE(e_row) TYPE lcl_types=&gt;t_sel_row,
             col_changed EXPORTING VALUE(e_column) TYPE lvc_fname.
    METHODS: emit IMPORTING e_row TYPE lcl_types=&gt;t_sel_row,
      emit_col IMPORTING e_column TYPE lvc_fname.
ENDCLASS.

CLASS lcl_data_transmitter IMPLEMENTATION.
  METHOD  emit.
    RAISE EVENT data_changed EXPORTING e_row = e_row.
  ENDMETHOD.

  METHOD emit_col.
    RAISE EVENT col_changed EXPORTING e_column = e_column.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_data_receiver DEFINITION.
  PUBLIC SECTION.
    DATA: mo_transmitter TYPE REF TO lcl_data_transmitter,
          lo_tab_from    TYPE REF TO lcl_table_viewer,
          lo_sel_to      TYPE REF TO lcl_sel_opt,
          m_from_field   TYPE lvc_fname,
          m_to_field     TYPE lvc_fname.
    METHODS: constructor
      IMPORTING io_transmitter TYPE REF TO lcl_data_transmitter OPTIONAL
                io_tab_from    TYPE REF TO lcl_table_viewer OPTIONAL
                io_sel_to      TYPE REF TO lcl_sel_opt OPTIONAL
                i_from_field   TYPE lvc_fname OPTIONAL
                i_to_field     TYPE lvc_fname OPTIONAL,
      shut_down,
      update FOR EVENT data_changed OF lcl_data_transmitter IMPORTING e_row,
      update_col FOR EVENT col_changed OF lcl_data_transmitter IMPORTING e_column,
      on_grid_button_click
          FOR EVENT button_click OF cl_gui_alv_grid
        IMPORTING
          es_col_id
          es_row_no.
ENDCLASS.

CLASS lcl_sel_opt DEFINITION.
  PUBLIC SECTION.
    DATA: mo_viewer  TYPE REF TO lcl_table_viewer,
          mo_sel_alv TYPE REF TO cl_gui_alv_grid,
          mt_fcat    TYPE lvc_t_fcat,
          mt_sel_tab TYPE TABLE OF lcl_types=&gt;selection_display_s,
          ms_layout  TYPE lvc_s_layo.

    EVENTS: selection_done.
    METHODS:
      constructor IMPORTING io_viewer TYPE REF TO lcl_table_viewer io_container TYPE REF TO cl_gui_container,
      raise_selection_done,
      update_sel_tab,
      set_value IMPORTING  i_field TYPE any i_low TYPE any OPTIONAL i_high TYPE any OPTIONAL i_clear TYPE xfeld DEFAULT abap_true ,
      update_sel_row CHANGING c_sel_row TYPE lcl_types=&gt;selection_display_s.

  PRIVATE SECTION.
    METHODS:
      init_fcat IMPORTING i_dd_handle TYPE i,
      handle_sel_toolbar FOR EVENT toolbar OF cl_gui_alv_grid IMPORTING e_object,
      on_f4 FOR EVENT onf4 OF cl_gui_alv_grid IMPORTING e_fieldname es_row_no er_event_data,
      on_grid_button_click FOR EVENT button_click OF cl_gui_alv_grid
        IMPORTING
          es_col_id
          es_row_no,
      on_data_changed FOR EVENT data_changed OF cl_gui_alv_grid IMPORTING  er_data_changed,
      on_data_changed_finished FOR EVENT data_changed_finished OF cl_gui_alv_grid IMPORTING e_modified,
      handle_user_command FOR EVENT user_command OF cl_gui_alv_grid IMPORTING e_ucomm,
      handle_doubleclick FOR EVENT double_click OF cl_gui_alv_grid IMPORTING e_column es_row_no,
      handle_context_menu_request FOR EVENT context_menu_request OF cl_gui_alv_grid IMPORTING e_object.
ENDCLASS.

CLASS lcl_table_viewer DEFINITION INHERITING FROM lcl_popup.
  PUBLIC SECTION.
    TYPES: BEGIN OF t_column_emitter,
             column  TYPE lvc_fname,
             emitter TYPE REF TO lcl_data_transmitter,
           END OF t_column_emitter,
           BEGIN OF t_elem,
             field TYPE fieldname,
             elem  TYPE ddobjname,
           END OF t_elem.

    DATA: m_lang             TYPE ddlanguage,
          m_tabname          TYPE tabname,
          m_texttabname      TYPE tabname,
          m_count            TYPE i,
          mo_alv             TYPE REF TO cl_gui_alv_grid,
          mo_sel             TYPE REF TO lcl_sel_opt,
          mr_table           TYPE REF TO data,
          mr_text_table      TYPE REF TO data,
          mo_sel_parent      TYPE REF TO cl_gui_container,
          mo_alv_parent      TYPE REF TO cl_gui_container,
          mt_alv_catalog     TYPE lvc_t_fcat,
          mt_text_components TYPE abap_component_tab,

          mt_fields          TYPE TABLE OF t_elem,
          mo_column_emitters TYPE TABLE OF t_column_emitter,
          mo_sel_width       TYPE i,
          m_visible,
          m_std_tbar         TYPE x,
          m_show_empty       TYPE i.

    METHODS:
      constructor IMPORTING i_tname           TYPE any OPTIONAL
                            i_additional_name TYPE string OPTIONAL
                            ir_tab            TYPE REF TO data OPTIONAL,
      refresh_table FOR EVENT selection_done OF lcl_sel_opt.

  PRIVATE SECTION.
    METHODS:
      create_popup,
      create_alv,
      create_sel_alv,
      set_header,
      read_text_table,
      update_texts,
      get_where RETURNING VALUE(c_where) TYPE string,

      create_field_cat IMPORTING i_tname           TYPE tabname
                       RETURNING VALUE(et_catalog) TYPE lvc_t_fcat,
      translate_field IMPORTING i_lang TYPE ddlanguage CHANGING c_fld TYPE lvc_s_fcat,
      handle_tab_toolbar  FOR EVENT toolbar OF cl_gui_alv_grid  IMPORTING e_object,
      before_user_command FOR EVENT before_user_command OF cl_gui_alv_grid IMPORTING e_ucomm,
      handle_user_command FOR EVENT user_command OF cl_gui_alv_grid IMPORTING e_ucomm,
      get_field_info IMPORTING i_tab TYPE tabname,
      handle_doubleclick FOR EVENT double_click OF cl_gui_alv_grid IMPORTING e_column es_row_no.
ENDCLASS.

CLASS lcl_text_viewer DEFINITION FINAL INHERITING FROM lcl_popup.
  PUBLIC SECTION.
    DATA: mo_text     TYPE REF TO cl_gui_textedit.
    METHODS: constructor IMPORTING ir_str TYPE REF TO data.
ENDCLASS.

CLASS lcl_text_viewer IMPLEMENTATION.
  METHOD constructor.
    super-&gt;constructor( ).
    mo_box = create( i_name = &apos;text&apos; i_width = 200 i_hight = 100 ).
    CREATE OBJECT mo_splitter ##FM_SUBRC_OK
      EXPORTING
        parent  = mo_box
        rows    = 1
        columns = 1
      EXCEPTIONS
        OTHERS  = 1.

    mo_splitter-&gt;get_container(
     EXPORTING
       row       = 1
       column    = 1
     RECEIVING
       container = mo_variables_container ).

    SET HANDLER on_box_close FOR mo_box.

    CREATE OBJECT mo_text
      EXPORTING
        parent                 = mo_variables_container
      EXCEPTIONS
        error_cntl_create      = 1
        error_cntl_init        = 2
        error_cntl_link        = 3
        error_dp_create        = 4
        gui_type_not_supported = 5
        OTHERS                 = 6.
    IF sy-subrc &lt;&gt; 0.
      on_box_close( mo_box ).
    ENDIF.

    mo_text-&gt;set_readonly_mode( ).

    FIELD-SYMBOLS &lt;str&gt; TYPE string.
    ASSIGN ir_str-&gt;* TO &lt;str&gt;.
    DATA lt_string TYPE TABLE OF char255.
    WHILE strlen( &lt;str&gt; ) &gt; 255.
      APPEND &lt;str&gt;+0(255) TO lt_string.
      SHIFT &lt;str&gt; LEFT BY 255 PLACES.
    ENDWHILE.
    APPEND &lt;str&gt; TO lt_string.
    mo_text-&gt;set_text_as_r3table( lt_string ).
    CALL METHOD cl_gui_cfw=&gt;flush.
    mo_text-&gt;set_focus( mo_box ).
  ENDMETHOD.
ENDCLASS.

CLASS lcl_plugins DEFINITION.
  PUBLIC SECTION.
    TYPES: BEGIN OF t_field_links,
             tab        TYPE tablename,
             field      TYPE fieldname,
             method(30),
             rtab       TYPE tablename,
             rfield     TYPE fieldname,
             const      TYPE string, &quot;aqadh_range_value,
           END OF t_field_links,
           BEGIN OF t_el_links,
             element TYPE tablename,
             rtab    TYPE tablename,
             rfield  TYPE fieldname,
             plugin  TYPE tcode,
           END OF t_el_links.

    CLASS-DATA: mt_field_links TYPE  TABLE OF t_field_links,
                mt_el_links    TYPE  TABLE OF t_el_links,
                mr_cluster     TYPE REF TO data.
    CLASS-METHODS: init,
      link IMPORTING i_str     TYPE any
                     io_viewer TYPE REF TO lcl_table_viewer
                     i_column  TYPE any,
      run_pa20 IMPORTING io_viewer TYPE REF TO lcl_table_viewer,
      run_pp01 IMPORTING io_viewer TYPE REF TO lcl_table_viewer,
      run_text IMPORTING io_viewer TYPE REF TO lcl_table_viewer,
      run_subty IMPORTING io_viewer TYPE REF TO lcl_table_viewer,
      run_py_cluster IMPORTING io_viewer TYPE REF TO lcl_table_viewer,
      run_dictionary_key IMPORTING i_str     TYPE any
                                   io_viewer TYPE REF TO lcl_table_viewer
                                   i_column  TYPE any,
      run_data_element IMPORTING i_str          TYPE any
                                 io_viewer      TYPE REF TO lcl_table_viewer
                                 i_column       TYPE any
                       RETURNING VALUE(is_done) TYPE xfeld,
      run_field_2_field IMPORTING i_str          TYPE any
                                  io_viewer      TYPE REF TO lcl_table_viewer
                                  i_column       TYPE any
                        RETURNING VALUE(is_done) TYPE xfeld,
      run_field_2_plugin IMPORTING &quot;i_str          TYPE any
                                   io_viewer      TYPE REF TO lcl_table_viewer
                                   i_column       TYPE any
                         RETURNING VALUE(is_done) TYPE xfeld,

      run_hrp1001_adatanr IMPORTING i_str          TYPE any
                                    io_viewer      TYPE REF TO lcl_table_viewer
                                    i_column       TYPE any
                          RETURNING VALUE(is_done) TYPE xfeld,
      run_hrpy_rgdir IMPORTING i_str          TYPE any.
ENDCLASS.

CLASS lcl_plugins IMPLEMENTATION.
  METHOD init.
    &quot;data elements links
    mt_el_links = VALUE #(
      ( element = &apos;PERSNO&apos;   plugin = &apos;PA20&apos; )
      ( element = &apos;HROBJID&apos;  plugin = &apos;PP01&apos; )
      ( element = &apos;LGART&apos;    rtab = &apos;T512W&apos;   rfield = &apos;LGART&apos; )
      ( element = &apos;ITXEX&apos;    plugin = &apos;SHOW_TEXT&apos; )
      ( element = &apos;SUBTY&apos;    plugin = &apos;SUBTY&apos; ) ).

    &quot;field to field links
    mt_field_links = VALUE #(
      ( tab = &apos;PA0001&apos;     field = &apos;PLANS&apos; rtab = &apos;HRP1000&apos; rfield = &apos;OTYPE&apos; const = &apos;S&apos; )
      ( tab = &apos;PA0001&apos;     field = &apos;PLANS&apos; rtab = &apos;HRP1000&apos; rfield = &apos;OBJID&apos; )
      ( tab = &apos;PA0001&apos;     field = &apos;ORGEH&apos; rtab = &apos;HRP1000&apos; rfield = &apos;OTYPE&apos; const = &apos;O&apos; )
      ( tab = &apos;PA0001&apos;     field = &apos;ORGEH&apos; rtab = &apos;HRP1000&apos; rfield = &apos;OBJID&apos; )
      ( tab = &apos;PA0001&apos;     field = &apos;STELL&apos; rtab = &apos;HRP1000&apos; rfield = &apos;OBJID&apos; const = &apos;C&apos; )
      ( tab = &apos;PA0001&apos;     field = &apos;STELL&apos; rtab = &apos;HRP1000&apos; rfield = &apos;OBJID&apos; )
      ( tab = &apos;HRP1001&apos;    field = &apos;SCLAS&apos; rfield = &apos;OTYPE&apos; )
      ( tab = &apos;HRP1001&apos;    field = &apos;SOBID&apos; rfield = &apos;OBJID&apos; )
      ( tab = &apos;HRP1002&apos;    field = &apos;TABNR&apos; rtab = &apos;HRT1002&apos;  rfield = &apos;TABNR&apos; )
      ( tab = &apos;HRP1035&apos;    field = &apos;TABNR&apos; rtab = &apos;HRT1035&apos;  rfield = &apos;TABNR&apos; )
      ( tab = &apos;HRP1222&apos;    field = &apos;TABNR&apos; rtab = &apos;HRT1222&apos;  rfield = &apos;TABNR&apos; )
      ( tab = &apos;PA2006&apos;     field = &apos;QUONR&apos; rtab = &apos;PTQUODED&apos; rfield = &apos;QUONR&apos; )
      ( tab = &apos;PTQUODED&apos;   field = &apos;QUONR&apos; rtab = &apos;PA2006&apos;   rfield = &apos;QUONR&apos; )
      ( tab = &apos;PTQUODED&apos;   field = &apos;DOCNR&apos; rtab = &apos;PA2001&apos;   rfield = &apos;DOCNR&apos; )
      ( tab = &apos;HRPY_RGDIR&apos; field = &apos;SEQNR&apos; method = &apos;RUN_PY_CLUSTER&apos; ) ).
  ENDMETHOD.

  METHOD link.
    CHECK run_field_2_field( EXPORTING io_viewer = io_viewer i_column = i_column i_str = i_str ) = abap_false.
    CHECK run_field_2_plugin( EXPORTING io_viewer = io_viewer i_column = i_column ) = abap_false.

    CHECK run_data_element(  EXPORTING io_viewer = io_viewer i_column = i_column i_str = i_str ) = abap_false.
    CHECK run_hrp1001_adatanr( EXPORTING io_viewer = io_viewer i_column = i_column i_str = i_str ) = abap_false.
    run_dictionary_key( EXPORTING io_viewer = io_viewer i_column = i_column i_str = i_str ).

    LOOP AT lcl_plugins=&gt;mt_field_links INTO DATA(ls_link) WHERE tab = io_viewer-&gt;m_tabname AND field = i_column AND method IS NOT INITIAL.
      CASE ls_link-method.
        WHEN &apos;RUN_PY_CLUSTER&apos;.
          ASSIGN COMPONENT &apos;PERNR&apos; OF STRUCTURE i_str TO FIELD-SYMBOL(&lt;pernr&gt;).
          ASSIGN COMPONENT ls_link-field OF STRUCTURE i_str TO FIELD-SYMBOL(&lt;field&gt;).
      ENDCASE.
    ENDLOOP.
  ENDMETHOD.

  METHOD run_pa20.
    DATA: l_infty    TYPE infty,
          l_temp(10) TYPE c.

    FIELD-SYMBOLS: &lt;f_tab&gt; TYPE STANDARD  TABLE.
    DATA(l_row) = lcl_alv_common=&gt;get_selected( io_viewer-&gt;mo_alv ).

    ASSIGN io_viewer-&gt;mr_table-&gt;* TO  &lt;f_tab&gt;.
    READ TABLE &lt;f_tab&gt; INDEX l_row ASSIGNING FIELD-SYMBOL(&lt;tab&gt;).

    SELECT SINGLE infty INTO l_infty FROM t777d WHERE dbtab = io_viewer-&gt;m_tabname.
    ASSIGN COMPONENT &apos;PERNR&apos; OF STRUCTURE &lt;tab&gt; TO FIELD-SYMBOL(&lt;field&gt;).
    l_temp = &lt;field&gt;.
    SET PARAMETER ID &apos;PER&apos; FIELD l_temp.
    SET PARAMETER ID &apos;FCD&apos; FIELD &apos;DIS&apos;.
    SET PARAMETER ID &apos;ITP&apos; FIELD l_infty.
    ASSIGN COMPONENT &apos;SUBTY&apos; OF STRUCTURE &lt;tab&gt; TO &lt;field&gt;.
    l_temp = &lt;field&gt;.
    SET PARAMETER ID &apos;SUB&apos; FIELD l_temp.
    ASSIGN COMPONENT &apos;BEGDA&apos; OF STRUCTURE &lt;tab&gt; TO &lt;field&gt;.
    l_temp = &lt;field&gt;.
    SET PARAMETER ID &apos;BEG&apos; FIELD &lt;field&gt;.
    ASSIGN COMPONENT &apos;ENDDA&apos; OF STRUCTURE &lt;tab&gt; TO &lt;field&gt;.
    l_temp = &lt;field&gt;.
    SET PARAMETER ID &apos;END&apos; FIELD &lt;field&gt;.
    CALL TRANSACTION &apos;PA20&apos; AND SKIP FIRST SCREEN.
  ENDMETHOD.

  METHOD run_pp01.
    DATA: it_bdcdata    TYPE TABLE OF  bdcdata,
          save_plvar(2),
          save_otype(2),
          save_objid(8),
          l_infty(4),
          l_subty(4),
          l_temp(10).

    FIELD-SYMBOLS: &lt;f_tab&gt; TYPE STANDARD  TABLE.
    DATA(l_row) = lcl_alv_common=&gt;get_selected( io_viewer-&gt;mo_alv ).

    ASSIGN io_viewer-&gt;mr_table-&gt;* TO  &lt;f_tab&gt;.
    READ TABLE &lt;f_tab&gt; INDEX l_row ASSIGNING FIELD-SYMBOL(&lt;tab&gt;).

    SELECT SINGLE infty INTO l_infty FROM t777d WHERE dbtab = io_viewer-&gt;m_tabname.

    GET PARAMETER ID &apos;POP&apos; FIELD save_plvar.
    GET PARAMETER ID &apos;POT&apos; FIELD save_otype.
    GET PARAMETER ID &apos;PON&apos; FIELD save_objid.

    ASSIGN COMPONENT &apos;PLVAR&apos; OF STRUCTURE &lt;tab&gt; TO FIELD-SYMBOL(&lt;plvar&gt;).
    SET PARAMETER ID &apos;POP&apos; FIELD &lt;plvar&gt;.                   &quot;RITPP01

    ASSIGN COMPONENT &apos;OBJID&apos; OF STRUCTURE &lt;tab&gt; TO FIELD-SYMBOL(&lt;field&gt;).
    l_temp = &lt;field&gt;.
    SET PARAMETER ID &apos;PON&apos; FIELD l_temp.

    ASSIGN COMPONENT &apos;OTYPE&apos; OF STRUCTURE &lt;tab&gt; TO &lt;field&gt;.
    l_temp = &lt;field&gt;.
    SET PARAMETER ID &apos;POT&apos; FIELD l_temp.

    ASSIGN COMPONENT &apos;ISTAT&apos; OF STRUCTURE &lt;tab&gt; TO FIELD-SYMBOL(&lt;istat&gt;).
    l_temp = &lt;istat&gt;.

    ASSIGN COMPONENT &apos;SUBTY&apos; OF STRUCTURE &lt;tab&gt; TO &lt;field&gt;.
    IF sy-subrc = 0.
      l_subty = &lt;field&gt;.
    ELSE.
      CLEAR l_subty.
    ENDIF.

    ASSIGN COMPONENT &apos;BEGDA&apos; OF STRUCTURE &lt;tab&gt; TO FIELD-SYMBOL(&lt;date&gt;).
    SET PARAMETER ID &apos;BEG&apos; FIELD &lt;date&gt;.

    ASSIGN COMPONENT &apos;ENDDA&apos; OF STRUCTURE &lt;tab&gt; TO &lt;date&gt;.
    SET PARAMETER ID &apos;END&apos; FIELD &lt;date&gt;.
    ASSIGN COMPONENT &apos;SUBTY&apos; OF STRUCTURE &lt;tab&gt; TO &lt;field&gt;.

    it_bdcdata = VALUE #(
      ( program = &apos;SAPMH5A0&apos; dynpro = &apos;1000&apos; dynbegin = abap_true )
      ( fnam = &apos;PPHDR-INFTY&apos; fval = l_infty )
      ( fnam = &apos;PPHDR-SUBTY&apos; fval = l_subty )
      ( fnam = &apos;PPHDR-ISTAT&apos; fval = l_temp )
      ( fnam = &apos;BDC_OKCODE&apos; fval = &apos;DISP&apos; )
      ).
    CALL TRANSACTION &apos;PP02&apos; USING it_bdcdata MODE &apos;E&apos;.
  ENDMETHOD.

  METHOD run_text.
    &quot;NEW lcl_text_viewer( io_viewer ).
  ENDMETHOD.

  METHOD run_hrpy_rgdir.
    APPEND INITIAL LINE TO lcl_appl=&gt;mt_obj ASSIGNING FIELD-SYMBOL(&lt;obj&gt;).
    CREATE OBJECT &lt;obj&gt;-alv_viewer EXPORTING i_tname = &apos;HRPY_RGDIR&apos;.
    ASSIGN COMPONENT &apos;PERNR&apos; OF STRUCTURE i_str TO FIELD-SYMBOL(&lt;pernr&gt;).
    &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;set_value( i_field = &apos;PERNR&apos; i_low = &lt;pernr&gt;  ).
    &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;raise_selection_done( ).
  ENDMETHOD.

  METHOD run_hrp1001_adatanr.
    IF i_column = &apos;ADATANR&apos; AND io_viewer-&gt;m_tabname = &apos;HRP1001&apos;.
      ASSIGN COMPONENT &apos;ADATANR&apos; OF STRUCTURE i_str TO FIELD-SYMBOL(&lt;datanr&gt;).
      ASSIGN COMPONENT &apos;RELAT&apos; OF STRUCTURE i_str TO FIELD-SYMBOL(&lt;relat&gt;).
      &quot;SELECT SINGLE pasub INTO @DATA(lv_struc) FROM t77ar WHERE relat = @&lt;relat&gt;.
      &quot;SELECT SINGLE dbtab INTO @DATA(lv_dbtab) FROM t77ad WHERE pasub = @lv_struc.

*      IF sy-subrc = 0.
*        APPEND INITIAL LINE TO lcl_appl=&gt;mt_obj ASSIGNING FIELD-SYMBOL(&lt;obj&gt;).
*        CREATE OBJECT &lt;obj&gt;-alv_viewer EXPORTING i_tname = lv_dbtab.
*        &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;set_value( i_field = &apos;ADATANR&apos; i_low = &lt;datanr&gt;  ).
*        &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;raise_selection_done( ).
*        is_done = abap_true.
*      ENDIF.
    ENDIF.
  ENDMETHOD.

  METHOD run_subty.
    FIELD-SYMBOLS: &lt;f_tab&gt; TYPE STANDARD  TABLE.
    DATA(l_row) = lcl_alv_common=&gt;get_selected( io_viewer-&gt;mo_alv ).
    ASSIGN io_viewer-&gt;mr_table-&gt;* TO  &lt;f_tab&gt;.
    READ TABLE &lt;f_tab&gt; INDEX l_row ASSIGNING FIELD-SYMBOL(&lt;str&gt;).

    SELECT SINGLE stypt, namst INTO @DATA(l_result)   FROM t777d WHERE dbtab = @io_viewer-&gt;m_tabname.
    ASSIGN COMPONENT &apos;SUBTY&apos; OF STRUCTURE &lt;str&gt; TO FIELD-SYMBOL(&lt;subty&gt;).
    DATA(l_infty) = io_viewer-&gt;m_tabname+2(4).
    APPEND INITIAL LINE TO lcl_appl=&gt;mt_obj ASSIGNING FIELD-SYMBOL(&lt;obj&gt;).
    CREATE OBJECT &lt;obj&gt;-alv_viewer EXPORTING i_tname = l_result-stypt.
    &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;set_value( i_field = l_result-namst i_low = &lt;subty&gt; ).
    &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;set_value( i_field = &apos;SUBTY&apos; i_low = &lt;subty&gt; ).
    &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;set_value( i_field = &apos;INFTY&apos; i_low = l_infty ).
    &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;raise_selection_done( ).
  ENDMETHOD.

  METHOD run_py_cluster.
    DATA: lo_handle TYPE REF TO cl_abap_complexdescr,
          l_name    TYPE string.
    FIELD-SYMBOLS: &lt;f_tab&gt; TYPE STANDARD  TABLE.

    DATA(l_row) = lcl_alv_common=&gt;get_selected( io_viewer-&gt;mo_alv ).
    ASSIGN io_viewer-&gt;mr_table-&gt;* TO  &lt;f_tab&gt;.
    READ TABLE &lt;f_tab&gt; INDEX l_row ASSIGNING FIELD-SYMBOL(&lt;str&gt;).

    ASSIGN COMPONENT &apos;PERNR&apos; OF STRUCTURE &lt;str&gt; TO FIELD-SYMBOL(&lt;pernr&gt;).
    ASSIGN COMPONENT &apos;SEQNR&apos; OF STRUCTURE &lt;str&gt; TO FIELD-SYMBOL(&lt;seqnr&gt;).


    FIELD-SYMBOLS: &lt;cluster&gt; TYPE any.

    lo_handle ?= cl_abap_typedescr=&gt;describe_by_name( &apos;PAYRU_RESULT&apos; ).
    CREATE DATA mr_cluster TYPE HANDLE lo_handle.
    ASSIGN mr_cluster-&gt;* TO &lt;cluster&gt;.

    CALL FUNCTION &apos;PYXX_READ_PAYROLL_RESULT&apos;
      EXPORTING
        employeenumber               = &lt;pernr&gt;
        sequencenumber               = &lt;seqnr&gt;
      CHANGING
        payroll_result               = &lt;cluster&gt;
      EXCEPTIONS
        illegal_isocode_or_clusterid = 1
        error_generating_import      = 2
        import_mismatch_error        = 3
        subpool_dir_full             = 4
        no_read_authority            = 5
        no_record_found              = 6
        versions_do_not_match        = 7
        error_reading_archive        = 8
        error_reading_relid          = 9
        OTHERS                       = 10.


    DATA lo_tree TYPE REF TO lcl_rtti_tree.
    CREATE OBJECT lo_tree.

    l_name = |{ &lt;pernr&gt; } Seqnr { &lt;seqnr&gt; } |.

    lo_tree-&gt;add_variable( EXPORTING iv_root_name = l_name
                                        iv_full_name = l_name
                                        CHANGING io_var =  &lt;cluster&gt; ).

    lo_tree-&gt;display( ).

  ENDMETHOD.

  METHOD run_field_2_plugin.
    LOOP AT lcl_plugins=&gt;mt_field_links INTO DATA(ls_link) WHERE tab = io_viewer-&gt;m_tabname AND field = i_column AND method IS NOT INITIAL.
      CASE ls_link-method.
        WHEN &apos;RUN_PY_CLUSTER&apos;.
          run_py_cluster( io_viewer ).
      ENDCASE.
      is_done = &apos;X&apos;.
    ENDLOOP.
  ENDMETHOD.

  METHOD run_field_2_field.
    DATA: lo_viewer TYPE REF TO lcl_table_viewer.
    GET PARAMETER ID &apos;MOL&apos; FIELD DATA(l_mol).
    LOOP AT lcl_plugins=&gt;mt_field_links INTO DATA(ls_link) WHERE tab = io_viewer-&gt;m_tabname AND field = i_column AND method IS INITIAL.
      ASSIGN COMPONENT ls_link-field OF STRUCTURE i_str TO FIELD-SYMBOL(&lt;field&gt;).
      IF lo_viewer IS INITIAL.
        IF ls_link-rtab IS INITIAL.
          lo_viewer = io_viewer.
        ELSE.
          APPEND INITIAL LINE TO lcl_appl=&gt;mt_obj ASSIGNING FIELD-SYMBOL(&lt;obj&gt;).
          CREATE OBJECT &lt;obj&gt;-alv_viewer EXPORTING i_tname = ls_link-rtab.
          lo_viewer = &lt;obj&gt;-alv_viewer.
        ENDIF.
      ENDIF.
      lo_viewer-&gt;mo_sel-&gt;set_value( i_field = ls_link-rfield i_low = COND aqadh_type_of_icon( WHEN ls_link-const IS INITIAL THEN &lt;field&gt; ELSE ls_link-const ) ).
    ENDLOOP.
    IF sy-subrc = 0.
      lo_viewer-&gt;mo_sel-&gt;set_value( i_field = &apos;SPRSL&apos; i_low = io_viewer-&gt;m_lang  ).
      lo_viewer-&gt;mo_sel-&gt;set_value( i_field = &apos;MOLGA&apos; i_low = l_mol  ).
      lo_viewer-&gt;mo_sel-&gt;raise_selection_done( ).
      is_done = abap_true.
    ENDIF.
  ENDMETHOD.

  METHOD run_data_element.
    DATA: lo_viewer TYPE REF TO lcl_table_viewer.

    GET PARAMETER ID &apos;MOL&apos; FIELD DATA(l_mol).
    READ TABLE lcl_alv_common=&gt;mt_tabfields WITH KEY tabname = io_viewer-&gt;m_tabname fieldname = i_column INTO DATA(l_field).
    LOOP AT lcl_plugins=&gt;mt_el_links INTO DATA(l_el_link) WHERE element = l_field-rollname AND plugin NE &apos;&apos; .&quot; &apos;PA20&apos; .
      CASE l_el_link-plugin.
        WHEN &apos;PA20&apos;.
          lcl_plugins=&gt;run_pa20( io_viewer ).
        WHEN &apos;PP01&apos;.
          lcl_plugins=&gt;run_pp01( io_viewer ).
        WHEN &apos;SHOW_TEXT&apos;.
          lcl_plugins=&gt;run_text( io_viewer ).
        WHEN &apos;SUBTY&apos;.
          lcl_plugins=&gt;run_subty( io_viewer ).
      ENDCASE.
      is_done = abap_true.
    ENDLOOP.
    IF is_done = abap_true.
      RETURN.
    ENDIF.

    LOOP AT lcl_plugins=&gt;mt_el_links INTO l_el_link WHERE element = l_field-rollname .
      IF lo_viewer IS INITIAL.
        APPEND INITIAL LINE TO lcl_appl=&gt;mt_obj ASSIGNING FIELD-SYMBOL(&lt;obj&gt;).
        CREATE OBJECT &lt;obj&gt;-alv_viewer EXPORTING i_tname = l_el_link-rtab.
        lo_viewer = &lt;obj&gt;-alv_viewer.
      ENDIF.
      ASSIGN COMPONENT i_column OF STRUCTURE i_str TO FIELD-SYMBOL(&lt;field&gt;).
      lo_viewer-&gt;mo_sel-&gt;set_value( i_field = l_el_link-rfield i_low = &lt;field&gt;  ).
    ENDLOOP.
    IF sy-subrc = 0.
      lo_viewer-&gt;mo_sel-&gt;set_value( i_field = &apos;SPRSL&apos; i_low = io_viewer-&gt;m_lang  ).
      lo_viewer-&gt;mo_sel-&gt;set_value( i_field = &apos;MOLGA&apos; i_low = l_mol  ).
      lo_viewer-&gt;mo_sel-&gt;raise_selection_done( ).
      is_done = abap_true.
    ENDIF.
  ENDMETHOD.

  METHOD run_dictionary_key.
    DATA: lt_keys TYPE TABLE OF dd05p.

    GET PARAMETER ID &apos;MOL&apos; FIELD DATA(l_mol).
    READ TABLE lcl_alv_common=&gt;mt_tabfields INTO DATA(field) WITH KEY tabname = io_viewer-&gt;m_tabname fieldname = i_column .
    ASSIGN COMPONENT i_column OF STRUCTURE i_str TO FIELD-SYMBOL(&lt;field&gt;).
    CHECK &lt;field&gt; IS NOT INITIAL.
    CALL FUNCTION &apos;DD_FORKEY_GET&apos;
      EXPORTING
        feldname  = CONV fieldname( i_column )
        tabname   = io_viewer-&gt;m_tabname
      TABLES
        forkeytab = lt_keys
      EXCEPTIONS
        not_equal = 1
        not_found = 2
        not_valid = 3
        OTHERS    = 4.

    IF sy-subrc &lt; 2.
      APPEND INITIAL LINE TO lcl_appl=&gt;mt_obj ASSIGNING FIELD-SYMBOL(&lt;obj&gt;).
      CREATE OBJECT &lt;obj&gt;-alv_viewer EXPORTING i_tname = field-checktable.
      LOOP AT lt_keys INTO DATA(l_keys).
        ASSIGN COMPONENT l_keys-forkey OF STRUCTURE i_str TO &lt;field&gt;.
        CHECK sy-subrc = 0.
        &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;set_value( i_field = l_keys-checkfield i_low = &lt;field&gt;  ).
      ENDLOOP.
      &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;set_value( i_field = &apos;SPRSL&apos; i_low = io_viewer-&gt;m_lang  ).
      &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;set_value( i_field = &apos;MOLGA&apos; i_low = l_mol  ).
      &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;raise_selection_done( ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_data_receiver IMPLEMENTATION.
  METHOD constructor.
    lo_sel_to = io_sel_to.
    m_from_field =  i_from_field.
    m_to_field =  i_to_field.
    lo_tab_from = io_tab_from.
    mo_transmitter = io_transmitter.

    IF mo_transmitter IS NOT INITIAL.
      IF lo_tab_from IS INITIAL.
        SET HANDLER me-&gt;update FOR io_transmitter.
      ELSE.
        SET HANDLER me-&gt;update_col FOR io_transmitter.
      ENDIF.
    ELSE.
      SET HANDLER me-&gt;update FOR ALL INSTANCES.
    ENDIF.
  ENDMETHOD.

  METHOD shut_down.
    IF mo_transmitter IS NOT INITIAL.
      SET HANDLER me-&gt;update FOR mo_transmitter  ACTIVATION space.
    ELSE.
      SET HANDLER me-&gt;update FOR ALL INSTANCES  ACTIVATION space.
    ENDIF.
    CLEAR lo_sel_to.
  ENDMETHOD.

  METHOD on_grid_button_click.
    FIELD-SYMBOLS: &lt;f_tab&gt;   TYPE STANDARD TABLE.

    CHECK m_from_field = es_col_id-fieldname.
    ASSIGN lo_tab_from-&gt;mr_table-&gt;* TO &lt;f_tab&gt;.
    READ TABLE &lt;f_tab&gt; INDEX es_row_no-row_id ASSIGNING FIELD-SYMBOL(&lt;tab&gt;).
    ASSIGN COMPONENT es_col_id-fieldname OF STRUCTURE &lt;tab&gt; TO  FIELD-SYMBOL(&lt;f_field&gt;).
    CHECK lo_sel_to IS NOT INITIAL.
    lo_sel_to-&gt;set_value( i_field = m_to_field i_low = &lt;f_field&gt;  ).
    lo_sel_to-&gt;raise_selection_done( ).
  ENDMETHOD.

  METHOD  update.
    DATA: l_updated.

    READ TABLE lo_sel_to-&gt;mt_sel_tab ASSIGNING FIELD-SYMBOL(&lt;to&gt;) WITH KEY field_label = m_to_field.
    IF &lt;to&gt;-range[] = e_row-range[].
      l_updated = abap_true.&quot;so as not to have an infinite event loop
    ENDIF.
    MOVE-CORRESPONDING e_row TO &lt;to&gt;.
    IF &lt;to&gt;-transmitter IS BOUND AND l_updated IS INITIAL.
      &lt;to&gt;-transmitter-&gt;emit( EXPORTING e_row = e_row ).
    ENDIF.
    lo_sel_to-&gt;raise_selection_done( ).
  ENDMETHOD.

  METHOD update_col.
    DATA: l_updated,
          lt_sel_row   TYPE lcl_types=&gt;t_sel_row.

    FIELD-SYMBOLS: &lt;tab&gt;   TYPE STANDARD TABLE,
                   &lt;field&gt; TYPE any.

    CHECK lo_sel_to IS NOT INITIAL.
    READ TABLE lo_sel_to-&gt;mt_sel_tab ASSIGNING FIELD-SYMBOL(&lt;to&gt;) WITH KEY field_label = m_to_field.
    DATA(lt_old_range) = &lt;to&gt;-range.
    CLEAR: &lt;to&gt;-sign, &lt;to&gt;-opti, &lt;to&gt;-low, &lt;to&gt;-high, &lt;to&gt;-range.
    ASSIGN lo_tab_from-&gt;mr_table-&gt;* TO &lt;tab&gt;.

    LOOP AT &lt;tab&gt; ASSIGNING FIELD-SYMBOL(&lt;row&gt;).
      ASSIGN COMPONENT e_column OF STRUCTURE &lt;row&gt; TO &lt;field&gt;.
      IF line_exists( &lt;to&gt;-range[ low = &lt;field&gt; ] ).
        APPEND VALUE #( sign = &apos;I&apos; opti = &apos;EQ&apos; low = &lt;field&gt; ) TO &lt;to&gt;-range.
      ENDIF.
    ENDLOOP.

    IF sy-subrc NE 0.&quot; empty column
      APPEND VALUE #( sign = &apos;I&apos; opti = &apos;EQ&apos; low = &apos;&apos; ) TO &lt;to&gt;-range.
    ENDIF.

    LOOP AT &lt;to&gt;-range ASSIGNING FIELD-SYMBOL(&lt;sel&gt;).
      &lt;to&gt;-low = &lt;sel&gt;-low.
      lo_sel_to-&gt;update_sel_row( CHANGING c_sel_row = &lt;to&gt; ).
      EXIT.
    ENDLOOP.

    MOVE-CORRESPONDING &lt;to&gt; TO lt_sel_row.
    IF &lt;to&gt;-range = lt_old_range.
      l_updated = abap_true.&quot;so as not to have an infinite event loop
    ENDIF.
    IF &lt;to&gt;-transmitter IS BOUND AND l_updated IS INITIAL.
      &lt;to&gt;-transmitter-&gt;emit( EXPORTING e_row = lt_sel_row ).
      lo_sel_to-&gt;raise_selection_done( ).
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_box_handler IMPLEMENTATION.
  METHOD on_box_close.
    DATA: lv_tabix LIKE sy-tabix.
    sender-&gt;free( ).

    &quot;Free Memory
    LOOP AT lcl_appl=&gt;mt_obj ASSIGNING FIELD-SYMBOL(&lt;obj&gt;) WHERE alv_viewer IS NOT INITIAL.
      IF &lt;obj&gt;-alv_viewer-&gt;mo_box = sender.
        lv_tabix = sy-tabix.
        EXIT.
      ENDIF.
    ENDLOOP.
    IF sy-subrc = 0.
      FREE &lt;obj&gt;-alv_viewer-&gt;mr_table.
      FREE &lt;obj&gt;-alv_viewer-&gt;mo_alv.

      &quot;shutdown receivers.
      IF &lt;obj&gt;-alv_viewer-&gt;mo_sel IS NOT INITIAL.
        LOOP AT &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;mt_sel_tab INTO DATA(l_sel).
          IF l_sel-receiver IS BOUND.
            l_sel-receiver-&gt;shut_down( ).
          ENDIF.
        ENDLOOP.
      ENDIF.
      FREE &lt;obj&gt;-alv_viewer.
      IF lv_tabix NE 0.
        DELETE lcl_appl=&gt;mt_obj INDEX lv_tabix.
      ENDIF.
    ENDIF.
  ENDMETHOD.                    &quot;ON_BOX_CLOSE
ENDCLASS.               &quot;lcl_box_handler

CLASS lcl_table_viewer IMPLEMENTATION.
  METHOD constructor.
    DATA: ls_comp         TYPE abap_componentdescr,
          lt_comp_notab   TYPE abap_component_tab,
          lt_comp_tab2str TYPE abap_component_tab,
          lt_comp_str     TYPE abap_component_tab,
          lv_s            TYPE string,
          lv_data         TYPE REF TO data.

    DATA: l_notab   TYPE REF TO data,
          l_tab2str TYPE REF TO data.

    DATA: handle_notab   TYPE REF TO cl_abap_structdescr,
          handle_tab2str TYPE REF TO cl_abap_structdescr,
          lo_new_tab     TYPE REF TO cl_abap_tabledescr.

    FIELD-SYMBOLS: &lt;notab&gt;   TYPE STANDARD TABLE,
                   &lt;tab2str&gt; TYPE STANDARD TABLE,
                   &lt;any_tab&gt; TYPE ANY TABLE,
                   &lt;temptab&gt; TYPE ANY TABLE.

    super-&gt;constructor( i_additional_name = i_additional_name ).
    m_lang = sy-langu.
    mo_sel_width = 0.
    m_tabname = i_tname.
    create_popup( ).

    IF ir_tab IS NOT BOUND.
      lcl_rtti=&gt;create_table_by_name( EXPORTING i_tname = m_tabname CHANGING c_table = mr_table  ).
    ELSE.
      FIELD-SYMBOLS:&lt;any&gt; TYPE any.
      ASSIGN ir_tab-&gt;* TO &lt;any&gt;.
      DATA lo_tabl  TYPE REF TO cl_abap_tabledescr.
      DATA lo_struc TYPE REF TO cl_abap_structdescr.
      lo_tabl ?= cl_abap_typedescr=&gt;describe_by_data( &lt;any&gt; ).
      TRY.
          lo_struc ?= lo_tabl-&gt;get_table_line_type( ).
          ASSIGN ir_tab-&gt;* TO &lt;any_tab&gt;.
          TRY.
              LOOP AT lo_struc-&gt;components INTO DATA(comp).

                IF comp-type_kind NE &apos;h&apos;.
                  ls_comp-name = comp-name.
                  ls_comp-type ?= lo_struc-&gt;get_component_type( comp-name ).
                  APPEND ls_comp TO lt_comp_notab.
                  APPEND ls_comp TO lt_comp_tab2str.
                ELSE.
                  ls_comp-name = comp-name.
                  ls_comp-type ?= cl_abap_typedescr=&gt;describe_by_data( lv_s ).
                  APPEND ls_comp TO lt_comp_tab2str.
                  APPEND ls_comp TO lt_comp_str.

                  ls_comp-name = comp-name &amp;&amp; &apos;_REF&apos;.
                  ls_comp-type ?= cl_abap_typedescr=&gt;describe_by_data( lv_data ).
                  APPEND ls_comp TO lt_comp_tab2str.
                ENDIF.
              ENDLOOP.
            CATCH cx_sy_move_cast_error.
          ENDTRY.

          TRY.
              handle_notab  = cl_abap_structdescr=&gt;create( lt_comp_notab ).
              handle_tab2str  = cl_abap_structdescr=&gt;create( lt_comp_tab2str ).

              lo_new_tab = cl_abap_tabledescr=&gt;create(
                              p_line_type  = handle_notab
                              p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
                              p_unique     = abap_false ).

              CREATE DATA l_notab TYPE HANDLE lo_new_tab.

              lo_new_tab = cl_abap_tabledescr=&gt;create(
                              p_line_type  = handle_tab2str
                              p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
                              p_unique     = abap_false ).

              CREATE DATA l_tab2str TYPE HANDLE lo_new_tab.

              ASSIGN l_notab-&gt;* TO &lt;notab&gt;.
              MOVE-CORRESPONDING &lt;any_tab&gt; TO &lt;notab&gt;.
              ASSIGN l_tab2str-&gt;* TO &lt;tab2str&gt;.
              MOVE-CORRESPONDING &lt;notab&gt; TO &lt;tab2str&gt;.

              LOOP AT &lt;any_tab&gt; ASSIGNING FIELD-SYMBOL(&lt;old_struc&gt;).
                READ TABLE &lt;tab2str&gt; ASSIGNING FIELD-SYMBOL(&lt;new_struc&gt;) INDEX sy-tabix.
                LOOP AT lt_comp_str INTO ls_comp.
                  ASSIGN COMPONENT ls_comp-name OF STRUCTURE &lt;new_struc&gt; TO FIELD-SYMBOL(&lt;field&gt;).
                  ASSIGN COMPONENT ls_comp-name OF STRUCTURE &lt;old_struc&gt; TO &lt;temptab&gt;.
                  &lt;field&gt; = | { icon_view_table } [{ lines( &lt;temptab&gt; ) }] |.
                  ASSIGN COMPONENT ls_comp-name  OF STRUCTURE &lt;old_struc&gt; TO &lt;field&gt;.
                  ASSIGN COMPONENT |{ ls_comp-name }_REF| OF STRUCTURE &lt;new_struc&gt; TO FIELD-SYMBOL(&lt;ref&gt;).
                  GET REFERENCE OF &lt;field&gt; INTO &lt;ref&gt;.
                ENDLOOP.
              ENDLOOP.

              GET REFERENCE OF &lt;tab2str&gt; INTO mr_table.
            CATCH cx_root.
              mr_table = ir_tab.
          ENDTRY.
        CATCH cx_sy_move_cast_error.  &quot;no structure
          ls_comp-name = &apos;FIELD&apos;.
          ls_comp-type ?= cl_abap_typedescr=&gt;describe_by_data( lv_s ).
          APPEND ls_comp TO lt_comp_tab2str.

          handle_tab2str  = cl_abap_structdescr=&gt;create( lt_comp_tab2str ).
          lo_new_tab = cl_abap_tabledescr=&gt;create(
                               p_line_type  = handle_tab2str
                               p_table_kind = cl_abap_tabledescr=&gt;tablekind_std
                               p_unique     = abap_false ).

          CREATE DATA l_tab2str TYPE HANDLE lo_new_tab.
          ASSIGN l_tab2str-&gt;* TO &lt;tab2str&gt;.
          ASSIGN ir_tab-&gt;* TO &lt;any_tab&gt;.

          LOOP AT &lt;any_tab&gt; ASSIGNING &lt;old_struc&gt;.
            APPEND INITIAL LINE TO &lt;tab2str&gt; ASSIGNING &lt;new_struc&gt;.
            ASSIGN COMPONENT &apos;FIELD&apos; OF STRUCTURE &lt;new_struc&gt; TO &lt;field&gt;.
            &lt;field&gt; = &lt;old_struc&gt;.
          ENDLOOP.
          GET REFERENCE OF &lt;tab2str&gt; INTO mr_table.
      ENDTRY.
    ENDIF.

    get_field_info( m_tabname ).

    create_alv( ).
    create_sel_alv( ).
    mo_sel-&gt;mo_viewer-&gt;handle_user_command( &apos;SHOW&apos; ).
    mo_alv-&gt;set_focus( mo_alv ).
  ENDMETHOD.

  METHOD create_popup.
    mo_box = create( i_width = 800 i_hight = 150 ).

    CREATE OBJECT mo_splitter ##FM_SUBRC_OK
      EXPORTING
        parent  = mo_box
        rows    = 1
        columns = 2
      EXCEPTIONS
        OTHERS  = 1.

    mo_splitter-&gt;set_column_mode(  mode = mo_splitter-&gt;mode_absolute ).
    mo_splitter-&gt;set_column_width( id = 1 width = mo_sel_width ).

    CALL METHOD:
     mo_splitter-&gt;get_container(  EXPORTING
        row       = 1
        column    = 1
      RECEIVING
        container = mo_sel_parent ),

      mo_splitter-&gt;get_container
       EXPORTING
        row       = 1
        column    = 2
       RECEIVING
        container = mo_alv_parent.

    IF lcl_appl=&gt;m_ctrl_box_handler IS INITIAL.
      lcl_appl=&gt;m_ctrl_box_handler = NEW #( ).
    ENDIF.
    SET HANDLER lcl_appl=&gt;m_ctrl_box_handler-&gt;on_box_close FOR mo_box.
  ENDMETHOD.

  METHOD create_alv.
    DATA: ls_layout TYPE lvc_s_layo,
          effect    TYPE i,
          lt_f4     TYPE lvc_t_f4.

    FIELD-SYMBOLS: &lt;f_tab&gt;   TYPE table.

    mo_alv = NEW #( i_parent = mo_alv_parent ).
    mt_alv_catalog = create_field_cat( m_tabname ).

    IF mt_alv_catalog IS INITIAL.
      RETURN. &quot;todo show tables without structure
    ENDIF.

    ASSIGN mr_table-&gt;* TO &lt;f_tab&gt;.
    IF m_tabname IS NOT INITIAL.
      read_text_table( ).
      lcl_sql=&gt;read_any_table( EXPORTING i_tabname = m_tabname i_where = get_where( ) i_row_count = 100
                           CHANGING cr_tab =  mr_table c_count = m_count ).
      update_texts( ).


    ENDIF.
    set_header( ).
    ls_layout-cwidth_opt = abap_true.
    ls_layout-sel_mode = &apos;D&apos;.
    CREATE OBJECT lcl_appl=&gt;c_dragdropalv.
    effect = cl_dragdrop=&gt;move + cl_dragdrop=&gt;copy.

    CALL METHOD lcl_appl=&gt;c_dragdropalv-&gt;add
      EXPORTING
        flavor     = &apos;Line&apos; ##NO_TEXT
        dragsrc    = abap_true
        droptarget = abap_true
        effect     = effect.

    CALL METHOD lcl_appl=&gt;c_dragdropalv-&gt;get_handle IMPORTING handle = DATA(handle_alv).
    ls_layout-s_dragdrop-grid_ddid = handle_alv.

    SET HANDLER   before_user_command
                  handle_user_command
                  handle_tab_toolbar
                  handle_doubleclick
                  lcl_dragdrop=&gt;drag
                  FOR mo_alv.

    CALL METHOD mo_alv-&gt;set_table_for_first_display
      EXPORTING
        i_save          = abap_true
        i_default       = abap_true
        is_layout       = ls_layout
      CHANGING
        it_fieldcatalog = mt_alv_catalog
        it_outtab       = &lt;f_tab&gt;.

    mo_alv-&gt;get_frontend_fieldcatalog( IMPORTING et_fieldcatalog = mt_alv_catalog ).
    LOOP AT mt_alv_catalog ASSIGNING FIELD-SYMBOL(&lt;catalog&gt;).
      CLEAR &lt;catalog&gt;-key.
      DATA(ls_f4) = VALUE  lvc_s_f4( register   = abap_true chngeafter = abap_true fieldname  = &lt;catalog&gt;-fieldname ).
      INSERT ls_f4 INTO TABLE lt_f4.
    ENDLOOP.

    mo_alv-&gt;register_f4_for_fields( it_f4 = lt_f4 ).
    mo_alv-&gt;set_frontend_fieldcatalog( EXPORTING it_fieldcatalog = mt_alv_catalog ).

    LOOP AT mt_alv_catalog ASSIGNING FIELD-SYMBOL(&lt;cat&gt;) WHERE scrtext_l IS INITIAL.
      lcl_alv_common=&gt;translate_field(  CHANGING c_fld = &lt;cat&gt; ).
    ENDLOOP.

    mo_alv-&gt;set_frontend_fieldcatalog( EXPORTING  it_fieldcatalog = mt_alv_catalog ).
    me-&gt;handle_user_command( EXPORTING e_ucomm = &apos;TECH&apos; ).
    me-&gt;handle_user_command( EXPORTING e_ucomm = &apos;SHOW&apos; ).
    mo_alv-&gt;set_toolbar_interactive( ).
  ENDMETHOD.

  METHOD translate_field.
    DATA: l_dd04 TYPE dd04v.

    READ TABLE mt_fields INTO DATA(l_field) WITH KEY field = c_fld-fieldname.
    CHECK l_field-elem IS NOT INITIAL.
    CLEAR l_dd04.

    CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
      EXPORTING
        name          = CONV ddobjname( l_field-elem )
        langu         = i_lang
      IMPORTING
        dd04v_wa      = l_dd04
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc = 0.
      IF l_dd04-reptext IS NOT INITIAL.
        MOVE-CORRESPONDING l_dd04 TO c_fld.
      ENDIF.
    ENDIF.
  ENDMETHOD.

  METHOD create_sel_alv.
    IF mo_sel IS INITIAL.
      mo_sel     = NEW #( io_viewer = me io_container = mo_sel_parent ).
      SET HANDLER refresh_table FOR mo_sel.
    ELSE.
      mo_sel-&gt;update_sel_tab( ).
    ENDIF.
  ENDMETHOD.

  METHOD get_where.&quot;dynamic where clause
    DATA: lt_where TYPE rsds_twhere,
          lt_range TYPE rsds_trange.

    IF  mo_sel IS NOT INITIAL.
      APPEND INITIAL LINE TO lt_range ASSIGNING FIELD-SYMBOL(&lt;tabl&gt;).
      &lt;tabl&gt;-tablename = m_tabname.
      LOOP AT mo_sel-&gt;mt_sel_tab INTO DATA(ls_tab) WHERE range IS NOT INITIAL.
        APPEND INITIAL LINE TO &lt;tabl&gt;-frange_t ASSIGNING FIELD-SYMBOL(&lt;t_range&gt;).
        IF sy-subrc = 0.
          &lt;t_range&gt;-fieldname = ls_tab-field_label.
          &lt;t_range&gt;-selopt_t  = ls_tab-range.
        ENDIF.
      ENDLOOP.

      CALL FUNCTION &apos;FREE_SELECTIONS_RANGE_2_WHERE&apos;
        EXPORTING
          field_ranges  = lt_range
        IMPORTING
          where_clauses = lt_where.

      LOOP AT lt_where INTO DATA(ls_where) WHERE tablename = m_tabname.
        LOOP AT ls_where-where_tab INTO DATA(l_where).
          CONDENSE l_where-line.
          c_where = |{ c_where } { l_where-line }|.
        ENDLOOP.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.

METHOD read_text_table.
    FIELD-SYMBOLS: &lt;f_tab&gt; TYPE ANY TABLE.
    lcl_ddic=&gt;get_text_table( EXPORTING i_tname =  m_tabname IMPORTING e_tab = DATA(l_tab) ).
    CHECK l_tab IS NOT INITIAL.
    lcl_rtti=&gt;create_table_by_name( EXPORTING i_tname = l_tab CHANGING c_table = mr_text_table ).
    ASSIGN mr_text_table-&gt;* TO &lt;f_tab&gt;.
    SELECT * FROM (l_tab) INTO TABLE &lt;f_tab&gt; ORDER BY PRIMARY KEY.
  ENDMETHOD.

METHOD update_texts.
    DATA: l_text_field TYPE fieldname,
          l_replace    TYPE string,
          lv_clause    TYPE string.

    FIELD-SYMBOLS: &lt;f_tab&gt; TYPE ANY TABLE.
    FIELD-SYMBOLS: &lt;text_tab&gt; TYPE  STANDARD TABLE,
                   &lt;check&gt;    TYPE any.

    CHECK m_texttabname IS NOT INITIAL.

    &quot;text fields
    ASSIGN mr_text_table-&gt;* TO &lt;text_tab&gt;.
    READ TABLE &lt;text_tab&gt; INDEX 1 ASSIGNING FIELD-SYMBOL(&lt;text_dummy&gt;).
    CHECK sy-subrc = 0.

    READ TABLE lcl_alv_common=&gt;mt_tabfields WITH KEY tabname = m_texttabname domname = &apos;SPRAS&apos; INTO DATA(l_texttabfield).
    IF sy-subrc = 0.
      DATA(l_lang) = l_texttabfield-fieldname.
    ENDIF.

    l_replace = m_texttabname &amp;&amp; &apos;_&apos;.
    ASSIGN mr_table-&gt;* TO &lt;f_tab&gt;.

    LOOP AT &lt;f_tab&gt; ASSIGNING FIELD-SYMBOL(&lt;str&gt;).
      CLEAR lv_clause.
      LOOP AT lcl_alv_common=&gt;mt_tabfields INTO l_texttabfield WHERE tabname = m_texttabname AND keyflag = abap_true.
        UNASSIGN &lt;check&gt;.
        ASSIGN COMPONENT l_texttabfield-fieldname OF STRUCTURE &lt;str&gt; TO &lt;check&gt;.
        IF sy-subrc NE 0.
          READ TABLE lcl_alv_common=&gt;mt_tabfields WITH KEY tabname = m_texttabname fieldname  = l_texttabfield-fieldname INTO DATA(l_texttab).
          READ TABLE lcl_alv_common=&gt;mt_tabfields WITH KEY tabname = m_tabname domname  = l_texttab-domname INTO DATA(l_maintab).
          ASSIGN COMPONENT l_maintab-fieldname OF STRUCTURE &lt;str&gt; TO &lt;check&gt;.
          CLEAR l_maintab.
          IF sy-subrc NE 0.
            CONTINUE.
          ENDIF.
        ENDIF.

        IF lv_clause IS INITIAL.
          lv_clause = |{ l_texttabfield-fieldname } = &apos;{ &lt;check&gt; }&apos;|.
        ELSE.
          lv_clause = |{ lv_clause } AND { l_texttabfield-fieldname } = &apos;{ &lt;check&gt; }&apos;|.
        ENDIF.
      ENDLOOP.

      IF l_lang IS NOT INITIAL.
        ASSIGN COMPONENT l_lang OF STRUCTURE &lt;text_dummy&gt; TO FIELD-SYMBOL(&lt;dummy&gt;).
        IF sy-subrc = 0.
          lv_clause = |{ lv_clause } AND { l_lang } = &apos;{ m_lang }&apos;|.
        ENDIF.
      ENDIF.

      LOOP AT &lt;text_tab&gt; ASSIGNING FIELD-SYMBOL(&lt;text_str&gt;)  WHERE (lv_clause).
        EXIT.
      ENDLOOP.
      CHECK sy-subrc = 0.

      LOOP AT mt_text_components INTO DATA(ls_comp).
        l_text_field = ls_comp-name.
        REPLACE l_replace IN l_text_field WITH &apos;&apos;.
        ASSIGN COMPONENT ls_comp-name OF STRUCTURE &lt;str&gt; TO FIELD-SYMBOL(&lt;to&gt;).
        ASSIGN COMPONENT l_text_field OF STRUCTURE &lt;text_str&gt; TO FIELD-SYMBOL(&lt;from&gt;).
        &lt;to&gt; = &lt;from&gt;.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.


  METHOD set_header.
    DATA: lv_text       TYPE as4text,
          lv_header(80) TYPE c.

    SELECT SINGLE ddtext INTO lv_text
      FROM dd02t
     WHERE tabname = m_tabname
       AND ddlanguage = m_lang.

    lv_header = |{ m_tabname } - { lv_text } { m_additional_name }|.
    mo_box-&gt;set_caption( lv_header ).
  ENDMETHOD.

  METHOD handle_tab_toolbar.
    IF m_visible IS INITIAL.
      DATA(lt_toolbar) = VALUE ttb_button(
       ( function = &apos;SEL_ON&apos; icon = icon_arrow_left quickinfo = &apos;Show Select-Options&apos;  butn_type = 0 )
       ( butn_type = 3 ) ).
    ENDIF.
    APPEND VALUE #( function = &apos;TECH&apos; icon = icon_wd_caption quickinfo = &apos;Tech names&apos;  butn_type = 0 ) TO lt_toolbar.

    LOOP AT lcl_appl=&gt;mt_lang INTO DATA(lang).
      IF sy-tabix &gt; 10.
        EXIT.
      ENDIF.
      APPEND VALUE #( function = lang-spras icon = icon_foreign_trade quickinfo = lang-sptxt butn_type = 0 text = lang-sptxt ) TO lt_toolbar.
    ENDLOOP.

    lt_toolbar = VALUE ttb_button( BASE lt_toolbar
     ( function = &apos;SHOW&apos;  icon = icon_list  quickinfo = &apos;Show empty columns&apos;   butn_type = 0  )
     ( function = &apos;TBAR&apos; icon = COND #( WHEN m_std_tbar IS INITIAL THEN icon_column_right ELSE icon_column_left )
        quickinfo = COND #( WHEN m_std_tbar IS INITIAL THEN &apos;Show standard ALV function&apos;  ELSE &apos;Hide standard ALV function&apos;) )
     ( butn_type = 3 ) ).

    IF m_std_tbar IS INITIAL.
      e_object-&gt;mt_toolbar =  lt_toolbar.
    ELSE.
      e_object-&gt;mt_toolbar =  lt_toolbar = VALUE ttb_button( BASE lt_toolbar ( LINES OF e_object-&gt;mt_toolbar ) ).
    ENDIF.
  ENDMETHOD.

  METHOD create_field_cat.
    DATA: lr_field       TYPE REF TO data,
          lr_table_descr TYPE REF TO cl_abap_structdescr,
          lr_data_descr  TYPE REF TO cl_abap_datadescr,
          it_tabdescr    TYPE abap_compdescr_tab,
          l_replace      TYPE string,
          l_texttab      TYPE tabname,
          lr_temp        TYPE REF TO data,
          l_name         TYPE string,
          l_dd04         TYPE dd04v.

    FIELD-SYMBOLS: &lt;tab&gt;   TYPE STANDARD TABLE,
                   &lt;struc&gt; TYPE any,
                   &lt;field&gt; TYPE any.

    ASSIGN mr_table-&gt;* TO &lt;tab&gt;.
    CREATE DATA lr_temp LIKE LINE OF &lt;tab&gt;.
    ASSIGN lr_temp-&gt;* TO &lt;struc&gt;.

    TRY.
        lr_table_descr ?= cl_abap_typedescr=&gt;describe_by_data_ref( lr_temp ).
      CATCH cx_root.
        RETURN.
    ENDTRY.

    it_tabdescr[] = lr_table_descr-&gt;components[].
    lcl_ddic=&gt;get_text_table( EXPORTING i_tname = i_tname IMPORTING e_tab = l_texttab ).
    l_replace = l_texttab &amp;&amp; &apos;_&apos;.

    LOOP AT it_tabdescr INTO DATA(ls)
       WHERE type_kind NE &apos;h&apos;
         AND type_kind NE &apos;l&apos;.
      DATA(l_ind) = sy-tabix.

      ASSIGN COMPONENT ls-name OF STRUCTURE &lt;struc&gt; TO &lt;field&gt;.
      GET REFERENCE OF &lt;field&gt; INTO lr_field.
      lr_data_descr ?= cl_abap_typedescr=&gt;describe_by_data_ref( lr_field ).
      l_name = lr_data_descr-&gt;absolute_name.
      REPLACE ALL OCCURRENCES OF &apos;\TYPE=&apos; IN l_name WITH &apos;&apos;.
      APPEND VALUE #( field = ls-name elem = l_name ) TO mt_fields.

      CLEAR l_dd04.
      CALL FUNCTION &apos;DDIF_DTEL_GET&apos;
        EXPORTING
          name          = CONV ddobjname( l_name )
          langu         = m_lang
        IMPORTING
          dd04v_wa      = l_dd04
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.



      APPEND INITIAL LINE TO et_catalog ASSIGNING FIELD-SYMBOL(&lt;catalog&gt;).

      READ TABLE lcl_alv_common=&gt;mt_tabfields INTO DATA(ls_tf) WITH KEY tabname = i_tname fieldname = ls-name.

      &lt;catalog&gt;-style = lcl_alv_common=&gt;c_white.
      MOVE-CORRESPONDING ls_tf TO &lt;catalog&gt;.
      &lt;catalog&gt;-f4availabl = abap_true.
      IF ls_tf-is_text = abap_true.
        &lt;catalog&gt;-style = lcl_alv_common=&gt;c_grey.
      ENDIF.

      IF ls_tf-checktable IS NOT INITIAL.
        &lt;catalog&gt;-style = lcl_alv_common=&gt;c_blue.
      ENDIF.

      IF line_exists( lcl_plugins=&gt;mt_field_links[ tab = i_tname field = ls_tf-fieldname ] ).
        &lt;catalog&gt;-style = lcl_alv_common=&gt;c_green.
      ENDIF.

      IF line_exists( lcl_plugins=&gt;mt_el_links[ element = ls_tf-rollname ] ).
        &lt;catalog&gt;-style = lcl_alv_common=&gt;c_green.
      ENDIF.

      IF ls_tf-keyflag = abap_true.
        &lt;catalog&gt;-style = &lt;catalog&gt;-style BIT-OR lcl_alv_common=&gt;c_bold.
      ENDIF.

      &lt;catalog&gt;-col_pos = l_ind.
      &lt;catalog&gt;-fieldname = ls-name.
      &lt;catalog&gt;-f4availabl = abap_true.

      IF l_dd04 IS INITIAL.
        &lt;catalog&gt;-scrtext_s = &lt;catalog&gt;-scrtext_m = &lt;catalog&gt;-scrtext_l = &lt;catalog&gt;-reptext = &lt;catalog&gt;-fieldname = ls-name.
      ELSE.
        MOVE-CORRESPONDING l_dd04 TO &lt;catalog&gt;.
      ENDIF.

    ENDLOOP.


  ENDMETHOD.

  METHOD handle_doubleclick.
    DATA: lo_table_descr TYPE REF TO cl_tpda_script_tabledescr,
          table_clone    TYPE REF TO data.
    FIELD-SYMBOLS: &lt;f_tab&gt;  TYPE STANDARD TABLE.

    CHECK es_row_no-row_id IS NOT INITIAL.
    ASSIGN mr_table-&gt;* TO  &lt;f_tab&gt;.
    READ TABLE &lt;f_tab&gt; INDEX es_row_no-row_id ASSIGNING FIELD-SYMBOL(&lt;tab&gt;).

    ASSIGN COMPONENT |{ e_column-fieldname }_REF| OF STRUCTURE &lt;tab&gt; TO FIELD-SYMBOL(&lt;ref&gt;).
    IF sy-subrc = 0.
      lcl_appl=&gt;open_int_table( EXPORTING iv_name = CONV #( e_column-fieldname ) it_ref = &lt;ref&gt; ).
      RETURN.
    ELSE.
*      TRY.
*          lo_table_descr ?= cl_tpda_script_data_descr=&gt;factory( |{ m_additional_name }[ 1 ]-{ e_column-fieldname }| ).
*          table_clone = lo_table_descr-&gt;elem_clone( ).
*          lcl_appl=&gt;open_int_table( EXPORTING iv_name = |{ m_additional_name }[ 1 ]-{ e_column-fieldname }| it_ref = table_clone ).
*          return.
*        CATCH cx_sy_move_cast_error.
*      ENDTRY.
    ENDIF.


    ASSIGN mr_table-&gt;* TO  &lt;f_tab&gt;.
    READ TABLE &lt;f_tab&gt; INDEX es_row_no-row_id ASSIGNING &lt;tab&gt;.
    lcl_plugins=&gt;link( EXPORTING i_str = &lt;tab&gt; i_column = e_column io_viewer = me ).

  ENDMETHOD.

  METHOD get_field_info.
    DATA: lv_clause      TYPE string,
          lr_struc       TYPE REF TO data,
          lr_table_descr TYPE REF TO cl_abap_structdescr,
          it_tabdescr    TYPE abap_compdescr_tab,
          lt_field_info  TYPE TABLE OF dfies,
          l_fname        TYPE fieldname,
          l_tname        TYPE tabname,
          ls_tf          LIKE LINE OF lcl_alv_common=&gt;mt_tabfields,
          dref           TYPE REF TO data,
          l_x            TYPE xstring.

    CHECK i_tab IS NOT INITIAL.
    CREATE DATA lr_struc TYPE (i_tab).
    lr_table_descr ?= cl_abap_typedescr=&gt;describe_by_data_ref( lr_struc ).
    it_tabdescr[] = lr_table_descr-&gt;components[].

    DATA(l_exist) = lcl_sql=&gt;exist_table( i_tab ).
    IF  l_exist = 1.
      SELECT  COUNT( * ) FROM (i_tab).
      DATA(l_count) = sy-dbcnt.
    ENDIF.

    LOOP AT it_tabdescr INTO DATA(ls) WHERE name NE &apos;MANDT&apos; AND name NE &apos;CLIENT&apos;.
      IF NOT line_exists( lcl_alv_common=&gt;mt_tabfields[ tabname = i_tab fieldname = ls-name ] ).
        l_tname = i_tab.
        l_fname = ls-name.

        CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
          EXPORTING
            tabname        = l_tname
            fieldname      = l_fname
            langu          = sy-langu
          TABLES
            dfies_tab      = lt_field_info
          EXCEPTIONS
            not_found      = 1
            internal_error = 2
            OTHERS         = 3.

        CHECK sy-subrc = 0.
        CLEAR ls_tf.
        MOVE-CORRESPONDING lt_field_info[ 1 ] TO ls_tf.

        &quot;check empty field
        IF l_exist = 1 AND l_count &lt; 10000.
          IF ls_tf-rollname IS NOT INITIAL.
            CREATE DATA dref TYPE (ls_tf-rollname).
            ASSIGN dref-&gt;* TO FIELD-SYMBOL(&lt;field&gt;).
            lv_clause = |{ ls_tf-fieldname } NE &apos;&apos;|.
            SELECT SINGLE (ls_tf-fieldname) INTO @&lt;field&gt;
              FROM (i_tab)
             WHERE (lv_clause).
            IF sy-subrc NE 0.
              ls_tf-empty = abap_true.
            ENDIF.
          ELSEIF ls_tf-datatype = &apos;RAWSTRING&apos;.
            lv_clause = |{ ls_tf-fieldname } NE &apos;&apos;|.
            SELECT SINGLE (ls_tf-fieldname) INTO @l_x
              FROM (i_tab)
             WHERE (lv_clause).
            IF sy-subrc NE 0.
              ls_tf-empty = abap_true.
            ENDIF.
          ENDIF.
        ENDIF.
        INSERT ls_tf INTO TABLE lcl_alv_common=&gt;mt_tabfields.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.


  METHOD before_user_command.
    CASE e_ucomm.
      WHEN &apos;&amp;INFO&apos;.
        DATA(l_url) = &apos;https://ysychov.wordpress.com/2020/02/10/simple-data-explorer/&apos;.
        CALL FUNCTION &apos;CALL_BROWSER&apos; EXPORTING url = l_url.
    ENDCASE.
  ENDMETHOD.

  METHOD handle_user_command.
    DATA: it_fields     TYPE lvc_t_fcat,
          lv_clause(45),
          lv_sel_width  TYPE i.

    FIELD-SYMBOLS: &lt;f_tab&gt;  TYPE STANDARD  TABLE.

    ASSIGN mr_table-&gt;* TO &lt;f_tab&gt;.
    mo_alv-&gt;get_frontend_fieldcatalog( IMPORTING et_fieldcatalog = it_fields[] ).
    IF e_ucomm = &apos;SEL_ON&apos; AND m_visible IS INITIAL.
      create_sel_alv( ).
      m_visible = abap_true.
      IF mo_sel_width = 0.
        lv_sel_width = 500.
      ELSE.
        lv_sel_width = mo_sel_width.
      ENDIF.

      mo_splitter-&gt;set_column_width( EXPORTING id    = 1 width = lv_sel_width ).
      mo_alv-&gt;set_toolbar_interactive( ).
      RETURN.
    ELSEIF e_ucomm = &apos;TBAR&apos;.
      m_std_tbar = BIT-NOT  m_std_tbar.
    ELSE.
      IF e_ucomm = &apos;SHOW&apos;.
        IF m_show_empty IS INITIAL.
          m_show_empty = 1.
        ELSE.
          CLEAR m_show_empty.
        ENDIF.
      ENDIF.

      LOOP AT it_fields ASSIGNING FIELD-SYMBOL(&lt;fields&gt;) WHERE domname NE &apos;MANDT&apos;.
        &lt;fields&gt;-col_pos = sy-tabix.
        CASE e_ucomm.
          WHEN &apos;SHOW&apos;.
            IF m_show_empty = abap_false.
              &lt;fields&gt;-no_out = &apos; &apos;.
            ELSE.
              lv_clause = |{ &lt;fields&gt;-fieldname } IS NOT INITIAL|.
              LOOP AT &lt;f_tab&gt; ASSIGNING FIELD-SYMBOL(&lt;f_line&gt;)  WHERE (lv_clause).
                EXIT.
              ENDLOOP.
              IF sy-subrc NE 0.
                &lt;fields&gt;-no_out = abap_true.
              ENDIF.
            ENDIF.
          WHEN &apos;TECH&apos;. &quot;technical field name
            &lt;fields&gt;-scrtext_l = &lt;fields&gt;-scrtext_m = &lt;fields&gt;-scrtext_s =  &lt;fields&gt;-reptext = &lt;fields&gt;-fieldname.
          WHEN OTHERS. &quot;header names translation
            IF line_exists( lcl_appl=&gt;mt_lang[ spras = e_ucomm ] ).
              translate_field( EXPORTING i_lang = CONV #( e_ucomm )  CHANGING c_fld = &lt;fields&gt; ).
              IF mo_sel IS BOUND.
                READ TABLE mo_sel-&gt;mt_sel_tab ASSIGNING FIELD-SYMBOL(&lt;sel&gt;) WITH KEY field_label = &lt;fields&gt;-fieldname.
                IF sy-subrc = 0.
                  IF &lt;fields&gt;-scrtext_l IS NOT INITIAL.
                    &lt;sel&gt;-name = &lt;fields&gt;-scrtext_l.
                  ENDIF.
                  IF &lt;sel&gt;-name IS INITIAL.
                    IF &lt;fields&gt;-reptext IS NOT INITIAL.
                      &lt;sel&gt;-name = &lt;fields&gt;-reptext.
                    ENDIF.
                  ENDIF.
                ENDIF.
              ENDIF.
            ENDIF.
        ENDCASE.
      ENDLOOP.
    ENDIF.

    IF line_exists( lcl_appl=&gt;mt_lang[ spras = e_ucomm ] ).
      m_lang = e_ucomm.
      set_header( ).
      mo_sel-&gt;set_value( i_field = &apos;SPRSL&apos; i_low = m_lang  ).
    ENDIF.

    CALL METHOD mo_alv-&gt;set_frontend_fieldcatalog EXPORTING it_fieldcatalog = it_fields[].
    lcl_alv_common=&gt;refresh( mo_alv ).
    IF mo_sel IS BOUND.
      IF  e_ucomm = &apos;HIDE&apos; OR e_ucomm = &apos;SHOW&apos; OR e_ucomm = &apos;UPDATE&apos; .
        mo_sel-&gt;update_sel_tab( ).
      ENDIF.
      lcl_alv_common=&gt;refresh( mo_sel-&gt;mo_sel_alv ).
    ENDIF.
  ENDMETHOD.                           &quot;handle_user_command

  METHOD refresh_table.
    DATA: ls_row    TYPE lcl_types=&gt;t_sel_row,
          lt_filter TYPE lvc_t_filt.

    CLEAR lt_filter.
    set_header( ).

    LOOP AT mo_sel-&gt;mt_sel_tab  ASSIGNING FIELD-SYMBOL(&lt;sel&gt;).
      IF &lt;sel&gt;-transmitter IS NOT INITIAL.
        MOVE-CORRESPONDING &lt;sel&gt; TO ls_row.
        &lt;sel&gt;-transmitter-&gt;emit( e_row = ls_row ).
      ENDIF.
      LOOP AT &lt;sel&gt;-range INTO DATA(l_range).
        APPEND VALUE #( fieldname = &lt;sel&gt;-field_label
                              low = l_range-low
                             high = l_range-high
                             sign = l_range-sign
                           option = l_range-opti ) TO lt_filter.
      ENDLOOP.
    ENDLOOP.

    IF mo_sel-&gt;mt_sel_tab IS NOT INITIAL.
      CALL METHOD mo_alv-&gt;set_filter_criteria
        EXPORTING
          it_filter = lt_filter.
      lcl_alv_common=&gt;refresh( mo_sel-&gt;mo_sel_alv ).
      lcl_alv_common=&gt;refresh( mo_alv ).
      mo_sel-&gt;mo_viewer-&gt;handle_user_command( &apos;SHOW&apos; ).
      LOOP AT mo_column_emitters INTO DATA(l_emit).
        l_emit-emitter-&gt;emit_col( l_emit-column ).
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_sel_opt IMPLEMENTATION.
  METHOD constructor.
    DATA: effect     TYPE i,
          handle_alv TYPE i.

    mo_viewer = io_viewer.
    mo_sel_alv = NEW #( i_parent = io_container ).
    update_sel_tab( ).
    CREATE OBJECT lcl_appl=&gt;c_dragdropalv.
    effect =  cl_dragdrop=&gt;copy. &quot; + cl_dragdrop=&gt;move.

    CALL METHOD lcl_appl=&gt;c_dragdropalv-&gt;add
      EXPORTING
        flavor     = &apos;Line&apos;
        dragsrc    = abap_true
        droptarget = abap_true
        effect     = effect.

    CALL METHOD lcl_appl=&gt;c_dragdropalv-&gt;get_handle IMPORTING handle = handle_alv.
    ms_layout-s_dragdrop-col_ddid = handle_alv.
    init_fcat( handle_alv ).
    ms_layout-cwidth_opt = abap_true.
    ms_layout-col_opt = abap_true.
    ms_layout-ctab_fname = &apos;COLOR&apos;.
    ms_layout-stylefname = &apos;STYLE&apos;.

    &quot;fields for F4 event handling
    DATA(gt_f4) = VALUE  lvc_t_f4( register   = abap_true chngeafter = abap_true
                             ( fieldname  = &apos;LOW&apos;  )
                             ( fieldname  = &apos;HIGH&apos;  ) ).

    mo_sel_alv-&gt;register_f4_for_fields( it_f4 = gt_f4 ).
    mo_sel_alv-&gt;register_edit_event( i_event_id = cl_gui_alv_grid=&gt;mc_evt_enter ).
    mo_sel_alv-&gt;register_edit_event( i_event_id = cl_gui_alv_grid=&gt;mc_evt_modified ).

    SET HANDLER handle_user_command
                handle_sel_toolbar
                lcl_dragdrop=&gt;drag
                lcl_dragdrop=&gt;drop
                on_data_changed
                on_data_changed_finished
                on_grid_button_click
                handle_context_menu_request
                handle_doubleclick
                on_f4 FOR mo_sel_alv.

    CALL METHOD mo_sel_alv-&gt;set_table_for_first_display
      EXPORTING
        i_save          = abap_true
        i_default       = abap_true
        is_layout       = ms_layout
      CHANGING
        it_outtab       = mt_sel_tab[]
        it_fieldcatalog = mt_fcat.

    mo_sel_alv-&gt;set_toolbar_interactive( ).
  ENDMETHOD.

  METHOD init_fcat.
    mt_fcat = VALUE #(
     ( fieldname = &apos;IND&apos;         coltext = &apos;&apos;  outputlen = 3 style = &apos;00000003&apos; )
     ( fieldname = &apos;FIELD_LABEL&apos; coltext = &apos;Label&apos;  outputlen = 30 dragdropid = i_dd_handle )
     ( fieldname = &apos;SIGN&apos;        coltext = &apos;SIGN&apos;   tech = abap_true )
     ( fieldname = &apos;OPTI&apos;        coltext = &apos;Option&apos; tech = abap_true )
     ( fieldname = &apos;OPTION_ICON&apos; coltext = &apos;Option&apos; icon = abap_true outputlen = 4 style = cl_gui_alv_grid=&gt;mc_style_button )
     ( fieldname = &apos;LOW&apos;         coltext = &apos;From data&apos; edit = abap_true lowercase = abap_true outputlen = 45 style = cl_gui_alv_grid=&gt;mc_style_f4 col_opt = abap_true  )
     ( fieldname = &apos;HIGH&apos;        coltext = &apos;To data&apos; edit = abap_true lowercase = abap_true outputlen = 45 style = cl_gui_alv_grid=&gt;mc_style_f4  col_opt = abap_true )
     ( fieldname = &apos;MORE_ICON&apos;   coltext = &apos;Range&apos; icon = abap_true  style = cl_gui_alv_grid=&gt;mc_style_button  )
     ( fieldname = &apos;RANGE&apos;   tech = abap_true  )
     ( fieldname = &apos;INHERITED&apos;   coltext = &apos;Inh.&apos; icon = abap_true outputlen = 4 seltext = &apos;Inherited&apos; style = &apos;00000003&apos;)
     ( fieldname = &apos;EMITTER&apos;    coltext = &apos;Emit.&apos; icon = abap_true outputlen = 4 seltext = &apos;Emitter&apos; style = &apos;00000003&apos;)
     ( fieldname = &apos;NAME&apos; coltext = &apos;Field name&apos;  outputlen = 60 style = &apos;00000003&apos;)
     ( fieldname = &apos;ELEMENT&apos; coltext = &apos;Data element&apos;  outputlen = 15 style = &apos;00000209&apos; )
     ( fieldname = &apos;DOMAIN&apos;  coltext = &apos;Domain&apos;  outputlen = 15 style = &apos;00000209&apos; )
     ( fieldname = &apos;DATATYPE&apos; coltext = &apos;Type&apos;  outputlen = 5 style = &apos;00000003&apos;)
     ( fieldname = &apos;LENGTH&apos; coltext = &apos;Length&apos;  outputlen = 5 style = &apos;00000003&apos;)
     ( fieldname = &apos;TRANSMITTER&apos;   tech = abap_true  )
     ( fieldname = &apos;RECEIVER&apos;    tech = abap_true  )
     ( fieldname = &apos;COLOR&apos;    tech = abap_true  ) ).
  ENDMETHOD.

  METHOD raise_selection_done.
    DATA: ls_row TYPE lcl_types=&gt;t_sel_row.
    lcl_alv_common=&gt;refresh( mo_sel_alv ).
    RAISE EVENT selection_done.
    LOOP AT mt_sel_tab  ASSIGNING FIELD-SYMBOL(&lt;sel&gt;).
      IF &lt;sel&gt;-transmitter IS NOT INITIAL.
        MOVE-CORRESPONDING &lt;sel&gt; TO ls_row.
        &lt;sel&gt;-transmitter-&gt;emit( e_row = ls_row ).
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD update_sel_tab.
    IF mt_sel_tab[] IS NOT INITIAL.
      DATA(lt_copy) = mt_sel_tab.
    ENDIF.
    CLEAR mt_sel_tab[].
    mo_viewer-&gt;mo_alv-&gt;get_frontend_fieldcatalog( IMPORTING et_fieldcatalog = mo_viewer-&gt;mt_alv_catalog ).
    LOOP AT mo_viewer-&gt;mt_alv_catalog INTO DATA(l_catalog) WHERE domname NE &apos;MANDT&apos;.
      DATA(lv_ind) = sy-tabix.
      APPEND INITIAL LINE TO mt_sel_tab ASSIGNING FIELD-SYMBOL(&lt;sel_tab&gt;).
      READ TABLE lt_copy INTO DATA(ls_copy) WITH KEY field_label = l_catalog-fieldname.

      IF sy-subrc = 0.
        MOVE-CORRESPONDING ls_copy TO &lt;sel_tab&gt;.
      ELSE.
        &lt;sel_tab&gt;-option_icon = icon_led_inactive.
        &lt;sel_tab&gt;-more_icon = icon_enter_more.
      ENDIF.

      &lt;sel_tab&gt;-ind = lv_ind.
      &lt;sel_tab&gt;-field_label = l_catalog-fieldname.
      &lt;sel_tab&gt;-int_type = l_catalog-inttype.
      &lt;sel_tab&gt;-element = l_catalog-rollname.
      &lt;sel_tab&gt;-domain =  l_catalog-domname.
      &lt;sel_tab&gt;-datatype = l_catalog-datatype.
      &lt;sel_tab&gt;-length = l_catalog-outputlen.
      lcl_alv_common=&gt;translate_field( EXPORTING i_lang = mo_viewer-&gt;m_lang CHANGING c_fld = l_catalog ).
      &lt;sel_tab&gt;-name = l_catalog-scrtext_l.
    ENDLOOP.
  ENDMETHOD.

  METHOD handle_sel_toolbar.
    e_object-&gt;mt_toolbar[] = VALUE #( butn_type = 0 disabled = &apos;&apos;
     ( function = &apos;SEL_OFF&apos; icon = icon_arrow_right    quickinfo = &apos;Hide&apos; )
     ( function = &apos;SEL_CLEAR&apos; icon = icon_delete_row    quickinfo = &apos;Clear Select-Options&apos; ) ).
  ENDMETHOD.

  METHOD set_value.
    READ TABLE mt_sel_tab ASSIGNING FIELD-SYMBOL(&lt;to&gt;) WITH KEY field_label = i_field.
    CHECK sy-subrc = 0.
    IF i_low IS SUPPLIED.
      IF i_clear IS INITIAL.
        APPEND VALUE #( sign = &apos;I&apos; opti = &apos;EQ&apos; low = i_low high = i_high ) TO &lt;to&gt;-range.
      ELSE.
        CLEAR:  &lt;to&gt;-opti, &lt;to&gt;-sign,&lt;to&gt;-range.
        IF i_low IS SUPPLIED.
          &lt;to&gt;-low = i_low.
        ENDIF.
        IF i_high IS SUPPLIED.
          &lt;to&gt;-high = i_high.
        ENDIF.
        update_sel_row( CHANGING c_sel_row = &lt;to&gt; ).
      ENDIF.
    ELSE.
      CLEAR:  &lt;to&gt;-opti, &lt;to&gt;-sign.
      &lt;to&gt;-high = i_high.
      update_sel_row( CHANGING c_sel_row = &lt;to&gt; ).
    ENDIF.
    IF &lt;to&gt;-transmitter IS BOUND.
      DATA: ls_row TYPE lcl_types=&gt;t_sel_row.
      MOVE-CORRESPONDING &lt;to&gt; TO ls_row.
      &lt;to&gt;-transmitter-&gt;emit( EXPORTING e_row = ls_row ).
    ENDIF.
  ENDMETHOD.

  METHOD handle_doubleclick.
    DATA: it_bdcdata TYPE TABLE OF  bdcdata.

    CHECK es_row_no-row_id IS NOT INITIAL.

    READ TABLE mt_sel_tab INDEX es_row_no-row_id INTO DATA(l_sel).
    APPEND VALUE #( program = &apos;SAPLSD_ENTRY&apos; dynpro = &apos;1000&apos; dynbegin = abap_true ) TO it_bdcdata.
    APPEND VALUE #( fnam = &apos;BDC_OKCODE&apos; fval = &apos;WB_DISPLAY&apos; ) TO it_bdcdata.

    IF e_column = &apos;ELEMENT&apos;.
      SET PARAMETER ID &apos;DTYP&apos; FIELD l_sel-element.
      APPEND VALUE #( fnam = &apos;RSRD1-DDTYPE&apos; fval = abap_true ) TO it_bdcdata.
      CALL TRANSACTION &apos;SE11&apos; USING it_bdcdata MODE &apos;E&apos;.
    ELSEIF e_column = &apos;DOMAIN&apos;.
      SET PARAMETER ID &apos;DOM&apos; FIELD l_sel-domain.
      APPEND VALUE #( fnam = &apos;RSRD1-DOMA&apos; fval = abap_true ) TO it_bdcdata.
      CALL TRANSACTION &apos;SE11&apos; USING it_bdcdata MODE &apos;E&apos;.
    ELSE.
      CALL FUNCTION &apos;DOCU_CALL&apos;
        EXPORTING
          id                = &apos;DE&apos;
          langu             = mo_viewer-&gt;m_lang
          object            = l_sel-element
          typ               = &apos;E&apos;
          displ             = abap_true
          displ_mode        = 3
          use_sec_langu     = abap_true
          display_shorttext = abap_true.
    ENDIF.
  ENDMETHOD.

  METHOD update_sel_row. &quot;select patterns rules
    IF c_sel_row-high IS INITIAL AND c_sel_row-opti = &apos;BT&apos;.
      CLEAR c_sel_row-opti.
    ENDIF.

    IF c_sel_row-low IS NOT INITIAL AND c_sel_row-opti IS INITIAL.
      c_sel_row-sign = &apos;I&apos;.
      c_sel_row-opti = &apos;EQ&apos;.
    ENDIF.

    IF c_sel_row-high IS NOT INITIAL AND c_sel_row-opti NE &apos;NB&apos; .
      c_sel_row-opti = &apos;BT&apos;.
    ENDIF.

    IF c_sel_row-sign IS INITIAL AND c_sel_row-opti IS INITIAL.
      CLEAR: c_sel_row-low, c_sel_row-low.
    ENDIF.

    IF c_sel_row-low CA  &apos;*%+&amp;&apos;.
      c_sel_row-sign = &apos;I&apos;.
      c_sel_row-opti = &apos;CP&apos;.
    ENDIF.

    IF c_sel_row-opti IS NOT INITIAL AND c_sel_row-sign IS INITIAL.
      c_sel_row-sign = &apos;I&apos;.
    ENDIF.

    TRY.
        c_sel_row-option_icon = lcl_appl=&gt;m_option_icons[ sign = c_sel_row-sign option = c_sel_row-opti ]-icon_name.
      CATCH cx_sy_itab_line_not_found.                  &quot;#EC NO_HANDLER
    ENDTRY.

    IF c_sel_row-sign IS NOT INITIAL.
      READ TABLE c_sel_row-range ASSIGNING FIELD-SYMBOL(&lt;range&gt;) INDEX 1.
      IF sy-subrc NE 0.
        APPEND INITIAL LINE TO c_sel_row-range ASSIGNING &lt;range&gt;.
      ENDIF.
      MOVE-CORRESPONDING c_sel_row TO &lt;range&gt;.
      IF c_sel_row-opti NE &apos;BT&apos; AND c_sel_row-opti NE &apos;NB&apos; .
        CLEAR c_sel_row-high.
      ENDIF.
      IF c_sel_row-int_type = &apos;D&apos; OR c_sel_row-int_type = &apos;T&apos; .
        DO 2 TIMES.
          ASSIGN COMPONENT  COND string( WHEN sy-index = 1 THEN &apos;LOW&apos; ELSE &apos;HIGH&apos;  ) OF STRUCTURE &lt;range&gt; TO FIELD-SYMBOL(&lt;field&gt;).
          IF &lt;field&gt; IS INITIAL.
            CONTINUE.
          ENDIF.

          IF c_sel_row-int_type = &apos;D&apos;.
            CALL FUNCTION &apos;CONVERT_DATE_TO_INTERNAL&apos; ##FM_SUBRC_OK
              EXPORTING
                date_external            = &lt;field&gt;
              IMPORTING
                date_internal            = &lt;field&gt;
              EXCEPTIONS
                date_external_is_invalid = 1
                OTHERS                   = 2.
          ELSE.
            REPLACE ALL OCCURRENCES OF &apos;:&apos; IN &lt;field&gt; WITH &apos;&apos;.
          ENDIF.
        ENDDO.
      ENDIF.
    ENDIF.
    c_sel_row-more_icon = COND #( WHEN c_sel_row-range IS INITIAL THEN icon_enter_more    ELSE icon_display_more  ).

    IF c_sel_row-receiver IS BOUND AND c_sel_row-inherited IS INITIAL.
      c_sel_row-inherited = icon_businav_value_chain.
    ENDIF.
  ENDMETHOD.

  METHOD on_f4.
    DATA: return_tab TYPE STANDARD TABLE OF ddshretval,
          lt_objec   TYPE TABLE OF objec,
          ls_objec   TYPE objec,
          l_otype    TYPE otype,
          l_plvar    TYPE plvar,
          l_multiple TYPE xfeld,
          l_clear    TYPE xfeld.

    IF e_fieldname = &apos;LOW&apos;.
      l_multiple = abap_true.
    ENDIF.

    READ TABLE mt_sel_tab ASSIGNING FIELD-SYMBOL(&lt;sel&gt;) INDEX es_row_no-row_id.
    DATA(l_fname) =  &lt;sel&gt;-field_label.

    lcl_types=&gt;mt_sel[] = mt_sel_tab[].
    IF &lt;sel&gt;-element = &apos;HROBJID&apos;.
      READ TABLE mt_sel_tab INTO DATA(l_sel) WITH KEY field_label = &apos;OTYPE&apos;.
      l_otype = l_sel-low.
      READ TABLE mt_sel_tab INTO l_sel WITH KEY field_label = &apos;PLVAR&apos;.
      IF sy-subrc = 0 AND l_sel-low IS NOT INITIAL.
        l_plvar = l_sel-low.
      ELSE.
        CALL FUNCTION &apos;RH_GET_ACTIVE_WF_PLVAR&apos;
          IMPORTING
            act_plvar       = l_plvar
          EXCEPTIONS
            no_active_plvar = 1
            OTHERS          = 2.
      ENDIF.
    ELSEIF &lt;sel&gt;-element = &apos;PERSNO&apos;.
      l_otype = &apos;P&apos;.
    ENDIF.

    IF l_otype IS NOT INITIAL.
      CALL FUNCTION &apos;RH_OBJID_REQUEST&apos;
        EXPORTING
          plvar            = l_plvar
          otype            = l_otype
          seark_begda      = sy-datum
          seark_endda      = sy-datum
          dynpro_repid     = sy-repid
          dynpro_dynnr     = sy-dynnr
          set_mode         = l_multiple
        IMPORTING
          sel_object       = ls_objec
        TABLES
          sel_hrobject_tab = lt_objec
        EXCEPTIONS
          OTHERS           = 6.
      IF sy-subrc = 0.
        l_clear = abap_true.
        LOOP AT lt_objec INTO ls_objec.
          IF e_fieldname = &apos;LOW&apos;.
            set_value( EXPORTING i_field = &lt;sel&gt;-field_label i_low = ls_objec-objid i_clear = l_clear ).
            CLEAR l_clear.
          ELSE.
            set_value( EXPORTING i_field = &lt;sel&gt;-field_label i_high = ls_objec-objid i_clear = l_clear ).
          ENDIF.
        ENDLOOP.
      ENDIF.
    ELSE.

      CALL FUNCTION &apos;F4IF_FIELD_VALUE_REQUEST&apos;
        EXPORTING
          tabname           = mo_viewer-&gt;m_tabname
          fieldname         = l_fname
          callback_program  = sy-repid
          callback_form     = &apos;CALLBACK_F4_SEL&apos; &quot;callback_method - doesn&apos;t work for local class
          multiple_choice   = l_multiple
        TABLES
          return_tab        = return_tab
        EXCEPTIONS
          field_not_found   = 1
          no_help_for_field = 2
          inconsistent_help = 3
          no_values_found   = 4
          OTHERS            = 5.

      IF sy-subrc = 0 AND lines( return_tab ) &gt; 0.
        ASSIGN er_event_data-&gt;m_data-&gt;* TO FIELD-SYMBOL(&lt;itab&gt;).
        CLEAR &lt;sel&gt;-range.
        l_clear = abap_true.
        LOOP AT return_tab ASSIGNING FIELD-SYMBOL(&lt;ret&gt;) WHERE fieldname = l_fname.
          IF e_fieldname = &apos;LOW&apos;.
            set_value( EXPORTING i_field = &lt;sel&gt;-field_label i_low = &lt;ret&gt;-fieldval i_clear = l_clear ).
            CLEAR l_clear.
          ELSE.
            set_value( EXPORTING i_field = &lt;sel&gt;-field_label i_high = &lt;ret&gt;-fieldval ).
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.
    er_event_data-&gt;m_event_handled = abap_true.
    raise_selection_done( ).
  ENDMETHOD.

  METHOD on_grid_button_click.
    DATA:
      l_tabfield TYPE rstabfield,
      ls_opt     TYPE rsoptions VALUE &apos;XXXXXXXXXX&apos;,
      lv_sign    TYPE raldb_sign,
      lv_option  TYPE raldb_opti.

    READ TABLE mt_sel_tab INDEX es_row_no-row_id ASSIGNING FIELD-SYMBOL(&lt;tab&gt;).
    CASE es_col_id.
      WHEN &apos;OPTION_ICON&apos;. &quot;edit select logical expression type
        CALL FUNCTION &apos;SELECT_OPTION_OPTIONS&apos;
          EXPORTING
            selctext     = &apos;nnnn&apos;
            option_list  = ls_opt
          IMPORTING
            sign         = lv_sign
            option       = lv_option
          EXCEPTIONS
            delete_line  = 1
            not_executed = 2
            illegal_sign = 3
            OTHERS       = 4.
        IF sy-subrc = 0.
          &lt;tab&gt;-sign = lv_sign.
          &lt;tab&gt;-opti = lv_option.
        ELSEIF sy-subrc = 1.
          CLEAR: &lt;tab&gt;-low, &lt;tab&gt;-high,&lt;tab&gt;-sign, &lt;tab&gt;-opti, &lt;tab&gt;-range.
        ENDIF.
      WHEN &apos;MORE_ICON&apos;. &quot;edit ranges
        l_tabfield-tablename = mo_viewer-&gt;m_tabname.
        l_tabfield-fieldname = &lt;tab&gt;-field_label.

        CALL FUNCTION &apos;COMPLEX_SELECTIONS_DIALOG&apos;
          EXPORTING
            title             = &apos;title&apos;
            text              = &apos;text&apos;
            tab_and_field     = l_tabfield
          TABLES
            range             = &lt;tab&gt;-range
          EXCEPTIONS
            no_range_tab      = 1
            cancelled         = 2
            internal_error    = 3
            invalid_fieldname = 4
            OTHERS            = 5.
        IF sy-subrc = 0.
          READ TABLE &lt;tab&gt;-range INDEX 1 INTO DATA(l_range).
          MOVE-CORRESPONDING l_range TO &lt;tab&gt;.
          IF &lt;tab&gt;-opti NE &apos;BT&apos;.
            CLEAR &lt;tab&gt;-high.
          ENDIF.
        ENDIF.
    ENDCASE.
    update_sel_row( CHANGING c_sel_row = &lt;tab&gt; ).
    RAISE EVENT selection_done.
  ENDMETHOD.

  METHOD on_data_changed.
    DATA: l_start TYPE i,
          lv_time TYPE sy-uzeit.

    FIELD-SYMBOLS: &lt;field&gt; TYPE any.

    LOOP AT er_data_changed-&gt;mt_good_cells ASSIGNING FIELD-SYMBOL(&lt;ls_cells&gt;).
      READ TABLE mt_sel_tab INDEX &lt;ls_cells&gt;-row_id ASSIGNING FIELD-SYMBOL(&lt;tab&gt;).
      ASSIGN COMPONENT &lt;ls_cells&gt;-fieldname OF STRUCTURE &lt;tab&gt; TO &lt;field&gt;.
      READ TABLE mo_viewer-&gt;mt_alv_catalog WITH KEY fieldname = &lt;tab&gt;-field_label INTO DATA(l_cat).

      IF &lt;field&gt; IS NOT INITIAL AND &lt;ls_cells&gt;-value IS INITIAL.
        READ TABLE &lt;tab&gt;-range INTO DATA(l_second) INDEX 2.
        IF sy-subrc = 0.
          IF ( &lt;ls_cells&gt;-fieldname = &apos;LOW&apos; AND &lt;tab&gt;-high IS INITIAL ) OR  ( &lt;ls_cells&gt;-fieldname = &apos;HIGH&apos; AND &lt;tab&gt;-low IS INITIAL  ).
            DELETE &lt;tab&gt;-range INDEX 1.
          ELSE.
            CLEAR l_second.
          ENDIF.
        ENDIF.
      ENDIF.

      IF l_cat-convexit = &apos;ALPHA&apos; AND NOT  &lt;ls_cells&gt;-value CA &apos;+*&apos;.
        &lt;ls_cells&gt;-value = |{ &lt;ls_cells&gt;-value ALPHA = IN }|.
        l_start = 128 - l_cat-dd_outlen.
        &lt;ls_cells&gt;-value = &lt;ls_cells&gt;-value+l_start(l_cat-dd_outlen).
      ENDIF.

      IF &lt;ls_cells&gt;-value IS NOT INITIAL.
        IF &lt;tab&gt;-int_type = &apos;D&apos;.
          DATA: lv_date TYPE sy-datum.
          CALL FUNCTION &apos;CONVERT_DATE_INPUT&apos;
            EXPORTING
              input                     = &lt;ls_cells&gt;-value
              plausibility_check        = abap_true
            IMPORTING
              output                    = lv_date
            EXCEPTIONS
              plausibility_check_failed = 1
              wrong_format_in_input     = 2
              OTHERS                    = 3.

          IF sy-subrc = 0.
            &lt;ls_cells&gt;-value = |{ lv_date DATE = USER }|.
          ENDIF.
        ELSEIF &lt;tab&gt;-int_type = &apos;T&apos;.
          CALL FUNCTION &apos;CONVERT_TIME_INPUT&apos;
            EXPORTING
              input                     = &lt;ls_cells&gt;-value
            IMPORTING
              output                    = lv_time
            EXCEPTIONS
              plausibility_check_failed = 1
              wrong_format_in_input     = 2
              OTHERS                    = 3.
          &lt;ls_cells&gt;-value = lv_time+0(2) &amp;&amp; &apos;:&apos; &amp;&amp; lv_time+2(2) &amp;&amp; &apos;:&apos; &amp;&amp; lv_time+4(2).
        ENDIF.
      ENDIF.
    ENDLOOP.
    CHECK sy-subrc = 0.

    IF l_second IS INITIAL.
      &lt;field&gt; = &lt;ls_cells&gt;-value.
      er_data_changed-&gt;modify_cell( EXPORTING i_row_id = &lt;ls_cells&gt;-row_id i_fieldname = &lt;ls_cells&gt;-fieldname i_value = &lt;ls_cells&gt;-value ).
    ELSE.
      &lt;tab&gt;-low = l_second-low.
      er_data_changed-&gt;modify_cell( EXPORTING i_row_id = &lt;ls_cells&gt;-row_id i_fieldname = &apos;LOW&apos; i_value = l_second-low ).
      IF l_second-high CO &apos;0 &apos;.
        CLEAR l_second-high.
      ENDIF.
      &lt;tab&gt;-high = l_second-high.
      er_data_changed-&gt;modify_cell( EXPORTING i_row_id = &lt;ls_cells&gt;-row_id i_fieldname = &apos;HIGH&apos; i_value = l_second-high ).

      &lt;tab&gt;-opti = l_second-opti.
      er_data_changed-&gt;modify_cell( EXPORTING i_row_id = &lt;ls_cells&gt;-row_id i_fieldname = &apos;OPTI&apos; i_value = l_second-opti ).
      &lt;tab&gt;-sign = l_second-sign.
      er_data_changed-&gt;modify_cell( EXPORTING i_row_id = &lt;ls_cells&gt;-row_id i_fieldname = &apos;SIGN&apos; i_value = l_second-sign ).
    ENDIF.

    update_sel_row( CHANGING c_sel_row = &lt;tab&gt; ).
    lcl_alv_common=&gt;refresh( EXPORTING i_obj = mo_sel_alv i_layout = ms_layout  ).
    raise_selection_done( ).
  ENDMETHOD.

  METHOD on_data_changed_finished.
    CHECK e_modified IS NOT INITIAL.
    RAISE EVENT selection_done.
  ENDMETHOD.

  METHOD handle_context_menu_request.
    DATA: ls_func TYPE ui_func,
          lt_func TYPE ui_functions.

    DATA(l_index) = lcl_alv_common=&gt;get_selected( mo_sel_alv ).

    IF l_index IS NOT INITIAL.
      READ TABLE mt_sel_tab INTO DATA(l_sel) INDEX l_index.
    ENDIF.

    e_object-&gt;get_functions( IMPORTING fcodes = DATA(lt_fcodes) ). &quot;Inactivate all standard functions

    LOOP AT lt_fcodes INTO DATA(ls_fcode) WHERE fcode NE &apos;&amp;OPTIMIZE&apos;.
      ls_func = ls_fcode-fcode.
      APPEND ls_func TO lt_func.
    ENDLOOP.

    e_object-&gt;hide_functions( lt_func ).
    e_object-&gt;add_separator( ).

    IF l_sel-range[]  IS NOT INITIAL OR l_index IS INITIAL.
      CALL METHOD e_object-&gt;add_function
        EXPORTING
          fcode = &apos;SEL_CLEAR&apos;
          text  = &apos;Clear Select-Options&apos;.
    ENDIF.

    IF l_sel-receiver IS NOT INITIAL OR l_index IS INITIAL.
      CALL METHOD e_object-&gt;add_function
        EXPORTING
          fcode = &apos;DELR&apos;
          text  = &apos;Delete receiver&apos;.
    ENDIF.
  ENDMETHOD.

  METHOD handle_user_command.
    DATA: lv_sel_width TYPE i.

    IF e_ucomm = &apos;SEL_OFF&apos;. &quot;Hide select-options alv
      mo_viewer-&gt;m_visible = &apos;&apos;.

      lv_sel_width = 0.
      CALL METHOD mo_viewer-&gt;mo_splitter-&gt;get_column_width ##FM_SUBRC_OK
        EXPORTING
          id                = 1
        IMPORTING
          result            = mo_viewer-&gt;mo_sel_width
        EXCEPTIONS
          cntl_error        = 1
          cntl_system_error = 2
          OTHERS            = 3.

      CALL METHOD mo_viewer-&gt;mo_splitter-&gt;set_column_width
        EXPORTING
          id    = 1
          width = lv_sel_width.
      mo_viewer-&gt;mo_alv-&gt;set_toolbar_interactive( ).
      RETURN.
    ENDIF.

    IF e_ucomm = &apos;SEL_CLEAR&apos; OR e_ucomm = &apos;DELR&apos;. &quot;clear all selections
      mo_sel_alv-&gt;get_selected_rows( IMPORTING et_index_rows = DATA(lt_sel_rows) ).

      LOOP AT lt_sel_rows INTO DATA(l_row).
        READ TABLE mt_sel_tab ASSIGNING FIELD-SYMBOL(&lt;sel&gt;) INDEX l_row-index.
        IF e_ucomm = &apos;SEL_CLEAR&apos;.
          CLEAR : &lt;sel&gt;-low, &lt;sel&gt;-high, &lt;sel&gt;-sign, &lt;sel&gt;-opti, &lt;sel&gt;-range.
        ELSEIF e_ucomm = &apos;DELR&apos;.
          IF &lt;sel&gt;-receiver IS NOT INITIAL.
            &lt;sel&gt;-receiver-&gt;shut_down( ).
            FREE &lt;sel&gt;-receiver.
            CLEAR &lt;sel&gt;-receiver.
            CLEAR &lt;sel&gt;-inherited.
          ENDIF.
        ENDIF.
        update_sel_row( CHANGING c_sel_row = &lt;sel&gt; ).
      ENDLOOP.
      RAISE EVENT selection_done.
    ENDIF.

    lcl_alv_common=&gt;refresh( mo_viewer-&gt;mo_alv ).
    RAISE EVENT selection_done.
  ENDMETHOD.                           &quot;handle_user_command
ENDCLASS.

CLASS lcl_appl IMPLEMENTATION.
  METHOD init_icons_table.
    m_option_icons = VALUE #(
     ( sign = space option = space  icon_name = icon_led_inactive )
     ( sign = &apos;I&apos;   option = &apos;EQ&apos;   icon_name = icon_equal_green )
     ( sign = &apos;I&apos;   option = &apos;NE&apos;   icon_name = icon_not_equal_green )
     ( sign = &apos;I&apos;   option = &apos;LT&apos;   icon_name = icon_less_green )
     ( sign = &apos;I&apos;   option = &apos;LE&apos;   icon_name = icon_less_equal_green )
     ( sign = &apos;I&apos;   option = &apos;GT&apos;   icon_name = icon_greater_green )
     ( sign = &apos;I&apos;   option = &apos;GE&apos;   icon_name = icon_greater_equal_green )
     ( sign = &apos;I&apos;   option = &apos;CP&apos;   icon_name = icon_pattern_include_green )
     ( sign = &apos;I&apos;   option = &apos;NP&apos;   icon_name = icon_pattern_exclude_green )
     ( sign = &apos;I&apos;   option = &apos;BT&apos;   icon_name = icon_interval_include_green )
     ( sign = &apos;I&apos;   option = &apos;NB&apos;   icon_name = icon_interval_exclude_green )
     ( sign = &apos;E&apos;   option = &apos;EQ&apos;   icon_name = icon_equal_red )
     ( sign = &apos;E&apos;   option = &apos;NE&apos;   icon_name = icon_not_equal_red )
     ( sign = &apos;E&apos;   option = &apos;LT&apos;   icon_name = icon_less_red )
     ( sign = &apos;E&apos;   option = &apos;LE&apos;   icon_name = icon_less_equal_red )
     ( sign = &apos;E&apos;   option = &apos;GT&apos;   icon_name = icon_greater_red )
     ( sign = &apos;E&apos;   option = &apos;GE&apos;   icon_name = icon_greater_equal_red )
     ( sign = &apos;E&apos;   option = &apos;CP&apos;   icon_name = icon_pattern_include_red )
     ( sign = &apos;E&apos;   option = &apos;NP&apos;   icon_name = icon_pattern_exclude_red )
     ( sign = &apos;E&apos;   option = &apos;BT&apos;   icon_name = icon_interval_include_red )
     ( sign = &apos;E&apos;   option = &apos;NB&apos;   icon_name = icon_interval_exclude_red ) ).
  ENDMETHOD.

  METHOD init_lang.
    SELECT c~spras t~sptxt INTO CORRESPONDING FIELDS OF TABLE mt_lang
      FROM t002c AS c
      INNER JOIN t002t AS t
      ON c~spras = t~sprsl
      WHERE t~spras = sy-langu
      ORDER BY c~ladatum DESCENDING c~lauzeit DESCENDING.
  ENDMETHOD.

  METHOD open_int_table.

    DATA r_tab TYPE REF TO data.
    IF it_ref IS BOUND.
      r_tab = it_ref.
    ELSE.
      GET REFERENCE OF it_tab INTO r_tab.
    ENDIF.

    IF iv_dummy is INITIAL.
    APPEND INITIAL LINE TO lcl_appl=&gt;mt_obj ASSIGNING FIELD-SYMBOL(&lt;obj&gt;).
    &lt;obj&gt;-alv_viewer = NEW #(  i_additional_name = iv_name ir_tab = r_tab ).
    &lt;obj&gt;-alv_viewer-&gt;mo_sel-&gt;raise_selection_done( ).
    ELSE.
     CALL FUNCTION &apos;Z_DUMMY_SCREEN&apos;  EXPORTING it_tab = it_tab iv_name = iv_name show = iv_show .
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_rtti_tree IMPLEMENTATION .
  METHOD constructor.

    super-&gt;constructor( ).
    create_popup( ).
    &quot;IF i_type = &apos;L&apos;.
    cl_salv_tree=&gt;factory(
         EXPORTING r_container = mo_box
         IMPORTING r_salv_tree = tree
         CHANGING t_table = tree_table ).
    &quot;ENDIF.

    DATA(lo_setting) =  tree-&gt;get_tree_settings( ).
    lo_setting-&gt;set_hierarchy_header( i_header ).
    lo_setting-&gt;set_hierarchy_size( 30 ).
    lo_setting-&gt;set_hierarchy_icon( CONV #( icon_tree ) ).

    DATA(lo_columns) = tree-&gt;get_columns( ).
    &quot;lo_columns-&gt;set_optimize( abap_true ).
    lo_columns-&gt;get_column( &apos;VALUE&apos; )-&gt;set_short_text( &apos;Value&apos; ).
    lo_columns-&gt;get_column( &apos;VALUE&apos; )-&gt;set_output_length( 40 ).

*    lo_columns-&gt;get_column( &apos;FULLNAME&apos; )-&gt;set_short_text( &apos;Full name&apos; ).
*    lo_columns-&gt;get_column( &apos;FULLNAME&apos; )-&gt;set_output_length( 40 ).

    lo_columns-&gt;get_column( &apos;FULLNAME&apos; )-&gt;set_visible( &apos;&apos; ).

    lo_columns-&gt;get_column( &apos;TYPENAME&apos; )-&gt;set_short_text( &apos;Type&apos; ).
    lo_columns-&gt;get_column( &apos;TYPENAME&apos; )-&gt;set_output_length( 20 ).

    add_buttons( ).

    tree-&gt;get_nodes( )-&gt;expand_all( ).
    DATA(lo_event) = tree-&gt;get_event( ) .
    SET HANDLER hndl_double_click
                hndl_user_command FOR lo_event.

    tree-&gt;display( ).
  ENDMETHOD.

  METHOD create_popup.
    mo_box = create( i_width = 500 i_hight = 300 ).

    mo_box-&gt;set_caption( CONV #( &apos;TEST&apos; ) ).

    IF lcl_appl=&gt;m_ctrl_box_handler IS INITIAL.
      lcl_appl=&gt;m_ctrl_box_handler = NEW #( ).
    ENDIF.
    SET HANDLER lcl_appl=&gt;m_ctrl_box_handler-&gt;on_box_close FOR mo_box.
  ENDMETHOD.

  METHOD add_buttons.
    DATA(lo_functions) = tree-&gt;get_functions( ).
    lo_functions-&gt;set_all( ).

*    lo_functions-&gt;add_function(
*       name     = &apos;INITIALS&apos;
*       icon     = CONV #( icon_start_viewer )
*       text     = &apos;Initials&apos;
*       tooltip  = &apos;Show/hide initial values&apos;
*       position = if_salv_c_function_position=&gt;right_of_salv_functions ).

  ENDMETHOD.

  METHOD clear.

    tree-&gt;get_nodes( )-&gt;delete_all( ).

    CLEAR: m_globals_key,
           m_locals_key,
           m_ldb_key,
           m_debug_key,
           m_class_key,
           mt_vars,
           mt_classes_leaf,
           m_no_refresh.
  ENDMETHOD.


  METHOD add_node.

    main_node_key =
          tree-&gt;get_nodes( )-&gt;add_node(
            related_node   = &apos;&apos;
            collapsed_icon = iv_icon
            expanded_icon = iv_icon
            relationship   = if_salv_c_node_relation=&gt;last_child
            row_style = if_salv_c_tree_style=&gt;emphasized_a
            text           = CONV #( iv_name )
            folder         = abap_true
          )-&gt;get_key( ).

    CASE iv_name.
      WHEN &apos;Locals&apos;.
        m_locals_key = main_node_key.
      WHEN &apos;Globals&apos;.
        m_globals_key = main_node_key.
      WHEN &apos;LDB&apos;.
        m_ldb_key = main_node_key.
      WHEN &apos;Class-data global variables&apos;.
        m_class_key = main_node_key.
      WHEN &apos;Debug point&apos;.
        m_debug_key = main_node_key.
    ENDCASE.
  ENDMETHOD.



  METHOD add_obj_var.

    DATA: lv_icon TYPE salv_de_tree_image,
          ls_tree TYPE ts_table,
          l_key   TYPE salv_de_node_key.

    IF iv_icon IS NOT SUPPLIED.
      lv_icon = icon_oo_class.
    ELSE.
      lv_icon = iv_icon.
    ENDIF.

    IF iv_full IS SUPPLIED.
      ls_tree-fullname = iv_full.
    ENDIF.

    IF iv_value IS SUPPLIED.
      ls_tree-value = iv_value.
    ENDIF.

    IF iv_key IS SUPPLIED.
      l_key = iv_key.
    ELSE.
      l_key = main_node_key.
    ENDIF.

    IF l_key IS INITIAL.
      l_key = main_node_key.
    ENDIF.

    er_key = tree-&gt;get_nodes( )-&gt;add_node(
      related_node   = l_key
      relationship   = if_salv_c_node_relation=&gt;last_child
      collapsed_icon = lv_icon
      expanded_icon  = lv_icon
      data_row       = ls_tree
      text           = iv_name
      folder         = abap_false
    )-&gt;get_key( ).
  ENDMETHOD.

  METHOD delete_node.
    DATA(lo_nodes) = tree-&gt;get_nodes( ).
    DATA(l_node) =  lo_nodes-&gt;get_node( iv_key ).
    IF sy-subrc = 0.
      l_node-&gt;delete( ).
    ENDIF.
  ENDMETHOD.

  METHOD display.

    DATA(lo_columns) = tree-&gt;get_columns( ).
    lo_columns-&gt;get_column( &apos;KIND&apos; )-&gt;set_visible( abap_false ).
    DATA(lo_nodes) = tree-&gt;get_nodes( ).
    DATA(lt_nodes) =  lo_nodes-&gt;get_all_nodes( ).

    &quot;expanding only first level nodes.
    DATA lt_sub TYPE salv_t_nodes.
    LOOP AT lt_nodes INTO DATA(l_node).
      READ TABLE lt_sub WITH KEY node = l_node-node TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        TRY.
            l_node-node-&gt;expand( ).
            lt_sub = l_node-node-&gt;get_subtree( ).
          CATCH cx_root.
        ENDTRY.
      ENDIF.
    ENDLOOP.

    tree-&gt;display( ).
  ENDMETHOD.

  METHOD hndl_user_command.
    CONSTANTS: c_mask TYPE x VALUE &apos;01&apos;.

    &quot;lcl_appl=&gt;open_int_table( iv_name = &apos;Steps&apos;   it_tab =  mo_debugger-&gt;mt_steps ).


  ENDMETHOD.

  METHOD hndl_double_click.
    DATA(lo_nodes) = tree-&gt;get_nodes( ).
    DATA(l_node) =  lo_nodes-&gt;get_node( node_key ).
    DATA r_row TYPE REF TO data.
    DATA r_ref TYPE REF TO data.

    r_row = l_node-&gt;get_data_row( ).
    ASSIGN r_row-&gt;* TO FIELD-SYMBOL(&lt;row&gt;).
    ASSIGN COMPONENT &apos;REF&apos; OF STRUCTURE &lt;row&gt; TO FIELD-SYMBOL(&lt;ref&gt;).
    ASSIGN COMPONENT &apos;KIND&apos; OF STRUCTURE &lt;row&gt; TO FIELD-SYMBOL(&lt;kind&gt;).
    ASSIGN COMPONENT &apos;FULLNAME&apos; OF STRUCTURE &lt;row&gt; TO FIELD-SYMBOL(&lt;fullname&gt;).

    CASE &lt;kind&gt;.
      WHEN cl_abap_datadescr=&gt;typekind_table.
        lcl_appl=&gt;open_int_table( iv_name = &lt;fullname&gt; it_ref = &lt;ref&gt; ).
      WHEN cl_abap_datadescr=&gt;typekind_string.
        NEW lcl_text_viewer( &lt;ref&gt; ).
    ENDCASE.
  ENDMETHOD.

  METHOD add_variable.
    DATA: lr_new   TYPE REF TO data,
          lr_struc TYPE REF TO data,
          l_name   TYPE string,
          l_key    TYPE salv_de_node_key,
          l_rel    TYPE salv_de_node_relation.

    FIELD-SYMBOLS: &lt;new&gt;      TYPE any,
                   &lt;tab_from&gt; TYPE ANY TABLE,
                   &lt;tab_to&gt;   TYPE STANDARD TABLE.

    IF i_icon IS SUPPLIED.
      m_icon = i_icon.
    ELSE.
      CLEAR m_icon.
    ENDIF.

    DATA l_full_name TYPE string.
    IF iv_full_name IS SUPPLIED.
      l_full_name = iv_full_name.
    ELSE.
      l_full_name = iv_root_name.
    ENDIF.

    l_name = iv_root_name.
    DESCRIBE FIELD io_var TYPE DATA(lv_type).
    IF lv_type NE cl_abap_typedescr=&gt;typekind_table.
      CREATE DATA lr_new LIKE io_var.
      ASSIGN lr_new-&gt;*  TO &lt;new&gt;.
      &lt;new&gt; = io_var.
    ELSE.
      ASSIGN io_var TO &lt;tab_from&gt;.
      CREATE DATA lr_struc LIKE LINE OF &lt;tab_from&gt;.
      ASSIGN lr_struc-&gt;* TO FIELD-SYMBOL(&lt;ls_record&gt;).
      CREATE DATA lr_new LIKE STANDARD TABLE OF &lt;ls_record&gt;.
      ASSIGN lr_new-&gt;* TO &lt;tab_to&gt;.
      &lt;tab_to&gt; = &lt;tab_from&gt;.
    ENDIF.
    m_variable = lr_new.

    DATA td TYPE sydes_desc.
    DESCRIBE FIELD io_var INTO td.
    IF td-types[ 1 ]-type = &apos;r&apos;.
      m_object = io_var.
    ENDIF.

    IF iv_key IS SUPPLIED AND iv_key IS NOT INITIAL.
      l_key = iv_key.
    ELSE.
      l_key = main_node_key.
    ENDIF.

    l_rel = if_salv_c_node_relation=&gt;last_child.
    ASSIGN m_variable-&gt;* TO FIELD-SYMBOL(&lt;new_value&gt;).
    READ TABLE mt_vars WITH KEY name = l_full_name INTO DATA(l_var).

    IF sy-subrc = 0.
      DATA(lo_nodes) = tree-&gt;get_nodes( ).
      DATA(l_node) =  lo_nodes-&gt;get_node( l_var-key ).
      DATA r_row TYPE REF TO data.
      DATA r_ref TYPE REF TO data.

      IF sy-subrc = 0.
        TRY.
            r_row = l_node-&gt;get_data_row( ).
            ASSIGN r_row-&gt;* TO FIELD-SYMBOL(&lt;row&gt;).
            ASSIGN COMPONENT &apos;REF&apos; OF STRUCTURE &lt;row&gt; TO FIELD-SYMBOL(&lt;ref&gt;).
            ASSIGN COMPONENT &apos;KIND&apos; OF STRUCTURE &lt;row&gt; TO FIELD-SYMBOL(&lt;kind&gt;).
            r_ref = &lt;ref&gt;.
            ASSIGN r_ref-&gt;* TO FIELD-SYMBOL(&lt;old_value&gt;).


          CATCH cx_root.
        ENDTRY.
      ENDIF.
    ELSE.


      IF lv_type NE cl_abap_typedescr=&gt;typekind_table.
        IF &lt;new&gt; IS INITIAL AND m_hide IS NOT INITIAL.
          RETURN.
        ENDIF.
      ELSE.
        IF &lt;tab_to&gt; IS INITIAL AND m_hide IS NOT INITIAL.
          RETURN.
        ENDIF.
      ENDIF.
    ENDIF.

    DATA(l_root_key) = traverse(
     io_type_descr = cl_abap_typedescr=&gt;describe_by_data_ref( m_variable )
     iv_parent_key = l_key
     iv_rel  = l_rel
     iv_name = l_name
     iv_fullname = l_full_name
     ir_up = m_variable
     iv_parent_name = l_name
     i_cl_leaf = i_cl_leaf ).

    READ TABLE mt_vars WITH KEY name = l_full_name TRANSPORTING NO FIELDS.
    IF sy-subrc NE 0.
      APPEND INITIAL LINE TO mt_vars ASSIGNING FIELD-SYMBOL(&lt;vars&gt;).
      &lt;vars&gt;-leaf = m_leaf.
      &lt;vars&gt;-name = l_full_name.
      &lt;vars&gt;-key = l_root_key.
      &lt;vars&gt;-ref = m_variable.
      &lt;vars&gt;-cl_leaf = i_cl_leaf.
      &lt;vars&gt;-tree = me.
    ENDIF.

    IF l_rel = if_salv_c_node_relation=&gt;next_sibling.
      IF &lt;kind&gt; NE &apos;v&apos; AND &lt;kind&gt; NE &apos;u&apos;.
        IF l_node IS NOT INITIAL.
          l_node-&gt;delete( ).
        ENDIF.
      ENDIF.
    ENDIF.
  ENDMETHOD.

  METHOD traverse.
    CASE io_type_descr-&gt;kind.
      WHEN c_kind-struct.
        e_root_key = traverse_struct( io_type_descr = io_type_descr
                                      iv_parent_key = iv_parent_key
                                      iv_rel  = iv_rel
                                      iv_name = iv_name
                                      iv_fullname = iv_fullname
                                      i_cl_leaf = i_cl_leaf
                                      ir_up = ir_up iv_parent_name = iv_parent_name ).

      WHEN c_kind-table.
        e_root_key = traverse_table( io_type_descr = io_type_descr
                                     iv_parent_key = iv_parent_key
                                     iv_rel  = iv_rel
                                     iv_name = iv_name
                                     iv_fullname = iv_fullname
                                     ir_up = ir_up
                                     i_cl_leaf = i_cl_leaf
                                      iv_parent_name = iv_parent_name ).
      WHEN c_kind-elem.
        e_root_key = traverse_elem( io_type_descr = io_type_descr
                                    iv_parent_key = iv_parent_key
                                    iv_rel  = iv_rel
                                    iv_name = iv_name
                                    iv_fullname = iv_fullname
                                    ir_up = ir_up
                                    i_cl_leaf = i_cl_leaf
                                    iv_parent_name = iv_parent_name ).
    ENDCASE.
  ENDMETHOD.

  METHOD traverse_struct.
    DATA: lt_component    TYPE abap_component_tab,
          ls_component    LIKE LINE OF lt_component,
          lo_struct_descr TYPE REF TO cl_abap_structdescr,
          ls_tree         TYPE ts_table,
          lv_text         TYPE lvc_value,
          lv_node_key     TYPE salv_de_node_key,
          lv_icon         TYPE salv_de_tree_image.

    lo_struct_descr ?= io_type_descr.
    ls_tree-ref =  ir_up.
    ls_tree-typename = lo_struct_descr-&gt;absolute_name.
    REPLACE FIRST OCCURRENCE OF &apos;\TYPE=&apos; IN ls_tree-typename+0(6) WITH &apos;&apos;.
    IF ls_tree-typename+0(1) = &apos;%&apos;.
      ls_tree-typename = |{ lo_struct_descr-&gt;type_kind }({ lo_struct_descr-&gt;length / 2 })|.
    ENDIF.

    ls_tree-kind = lo_struct_descr-&gt;type_kind.

    IF m_icon IS INITIAL.
      lv_icon = icon_structure.
    ELSE.
      lv_icon = m_icon.
    ENDIF.

    IF iv_name IS NOT INITIAL.
      lv_text = iv_name.
    ELSE.
      lv_text = ls_tree-typename.
    ENDIF.

    ls_tree-fullname = iv_fullname.
    IF lv_text IS NOT INITIAL.

      READ TABLE mt_vars WITH KEY name = iv_fullname INTO DATA(l_var).
      IF sy-subrc NE 0.
        e_root_key = m_new_node = lv_node_key =
          tree-&gt;get_nodes( )-&gt;add_node(
            related_node   = iv_parent_key
            relationship   = iv_rel
            collapsed_icon = lv_icon
            expanded_icon  = lv_icon
            data_row       = ls_tree
            text           = lv_text
            folder         = abap_true
          )-&gt;get_key( ).
      ELSE.
        lv_node_key = l_var-key.
      ENDIF.
    ENDIF.

    lt_component = lo_struct_descr-&gt;get_components( ).
    LOOP AT lt_component INTO ls_component. &quot;WHERE name IS NOT INITIAL.
      DATA: lr_new_struc TYPE REF TO data.
      ASSIGN ir_up-&gt;* TO FIELD-SYMBOL(&lt;up&gt;).
      IF ls_component-name IS INITIAL.
        lr_new_struc = ir_up.
      ELSE.
        ASSIGN COMPONENT ls_component-name OF STRUCTURE &lt;up&gt; TO FIELD-SYMBOL(&lt;new&gt;).
        GET REFERENCE OF &lt;new&gt; INTO lr_new_struc.
      ENDIF.

      traverse(
        io_type_descr = ls_component-type
        iv_parent_key = lv_node_key
        iv_rel  = if_salv_c_node_relation=&gt;last_child
        iv_name = ls_component-name
        iv_fullname = |{ iv_fullname }-{ ls_component-name }|
        ir_up = lr_new_struc
        iv_parent_name = |{ iv_parent_name }-{ ls_component-name }| ).
    ENDLOOP.
  ENDMETHOD.

  METHOD traverse_elem.
    DATA: lo_elem_descr TYPE REF TO cl_abap_elemdescr,
          ls_tree       TYPE ts_table,
          lv_text       TYPE lvc_value,
          lv_icon       TYPE salv_de_tree_image,
          lv_node_key   TYPE salv_de_node_key,
          l_key         TYPE salv_de_node_key,
          l_rel         TYPE salv_de_node_relation.

    lo_elem_descr ?= io_type_descr.
    ls_tree-ref = ir_up.

    ls_tree-typename = lo_elem_descr-&gt;absolute_name.
    REPLACE FIRST OCCURRENCE OF &apos;\TYPE=&apos; IN ls_tree-typename WITH &apos;&apos;.
    IF ls_tree-typename+0(1) = &apos;%&apos;.
      ls_tree-typename = |{ lo_elem_descr-&gt;type_kind }({ lo_elem_descr-&gt;length / 2 })|.
    ENDIF.

    ls_tree-kind = lo_elem_descr-&gt;type_kind.

    ASSIGN ir_up-&gt;* TO FIELD-SYMBOL(&lt;new_value&gt;).
    IF iv_value IS SUPPLIED.
      ls_tree-value = iv_value.
    ELSE.
      IF &lt;new_value&gt; IS NOT INITIAL.
        ls_tree-value = &lt;new_value&gt;.
      ENDIF.
    ENDIF.

    CASE lo_elem_descr-&gt;type_kind.
      WHEN &apos;D&apos;.
        lv_icon = icon_date.
      WHEN &apos;T&apos;.
        lv_icon = icon_bw_time_sap.
      WHEN &apos;C&apos;.
        lv_icon = icon_wd_input_field.
      WHEN &apos;P&apos;.
        lv_icon = icon_increase_decimal.
      WHEN &apos;g&apos;.
        lv_icon = icon_text_act.
      WHEN &apos;N&apos; OR &apos;I&apos;.
        lv_icon = icon_pm_order.

      WHEN OTHERS.
        lv_icon = icon_element.
    ENDCASE.

    lv_text = iv_name.

    IF ls_tree-value IS INITIAL AND m_hide IS NOT INITIAL.
      RETURN.
    ENDIF.

    ls_tree-fullname = iv_fullname.

    IF iv_parent_key IS NOT INITIAL.
      l_key = iv_parent_key.
    ELSE.
      l_key = main_node_key.
    ENDIF.

    l_rel = iv_rel.
    READ TABLE mt_vars WITH KEY name = iv_fullname INTO DATA(l_var).
    IF sy-subrc = 0.

      DATA(lo_nodes) = tree-&gt;get_nodes( ).
      DATA(l_node) =  lo_nodes-&gt;get_node( l_var-key ).
      DATA r_row TYPE REF TO data.
      DATA r_ref TYPE REF TO data.

      TRY.
          r_row = l_node-&gt;get_data_row( ).
          ASSIGN r_row-&gt;* TO FIELD-SYMBOL(&lt;row&gt;).
          ASSIGN COMPONENT &apos;REF&apos; OF STRUCTURE &lt;row&gt; TO FIELD-SYMBOL(&lt;ref&gt;).
          ASSIGN COMPONENT &apos;KIND&apos; OF STRUCTURE &lt;row&gt; TO FIELD-SYMBOL(&lt;kind&gt;).
          r_ref = &lt;ref&gt;.
          ASSIGN r_ref-&gt;* TO FIELD-SYMBOL(&lt;old_value&gt;).
          IF &lt;old_value&gt; NE &lt;new_value&gt;.
            l_key = l_var-key.
            l_rel = if_salv_c_node_relation=&gt;next_sibling.
            IF &lt;kind&gt; NE &apos;v&apos; AND &lt;kind&gt; NE &apos;u&apos;.
              DELETE mt_vars WHERE name = iv_fullname.
            ENDIF.
          ELSE.
            IF ( &lt;new_value&gt; IS INITIAL AND m_hide IS NOT INITIAL ).
              IF &lt;kind&gt; NE &apos;v&apos; AND &lt;kind&gt; NE &apos;u&apos;.
                DELETE mt_vars WHERE name = iv_fullname.
                l_node-&gt;delete( ).
              ENDIF.
            ENDIF.


          ENDIF.

          IF &lt;new_value&gt; IS INITIAL AND m_hide IS NOT INITIAL.
            DELETE mt_vars WHERE name = iv_fullname.
            l_node-&gt;delete( ).
            RETURN.
          ENDIF.
        CATCH cx_root.
      ENDTRY.
    ELSE.


      IF &lt;new_value&gt; IS INITIAL AND m_hide IS NOT INITIAL.
        RETURN.
      ENDIF.
    ENDIF.

    e_root_key = tree-&gt;get_nodes( )-&gt;add_node(
       related_node   = l_key
       relationship   = l_rel
       data_row       = ls_tree
       collapsed_icon = lv_icon
       expanded_icon  = lv_icon
       text           = lv_text
       folder         = abap_false )-&gt;get_key( ).


    IF l_rel = if_salv_c_node_relation=&gt;next_sibling AND l_node IS NOT INITIAL.
      l_node-&gt;delete( ).
    ENDIF.
  ENDMETHOD.

  METHOD check_change.
  ENDMETHOD.

  METHOD traverse_table.
    DATA: lo_table_descr TYPE REF TO cl_abap_tabledescr,
          ls_tree        TYPE ts_table,
          lv_text        TYPE lvc_value,
          lv_node_key    TYPE salv_de_node_key,
          lv_icon        TYPE salv_de_tree_image,
          l_key          TYPE salv_de_node_key,
          l_rel          TYPE salv_de_node_relation.

    FIELD-SYMBOLS: &lt;tab&gt; TYPE ANY TABLE.

    ASSIGN ir_up-&gt;* TO &lt;tab&gt;.
    DATA(lines) = lines( &lt;tab&gt; ).
    ls_tree-ref = ir_up.

    lo_table_descr ?= io_type_descr.

    ls_tree-fullname = |{ iv_name } ({ lines })|.
    ls_tree-kind = lo_table_descr-&gt;type_kind.
    ls_tree-typename = replace(  val = lo_table_descr-&gt;absolute_name sub = &apos;\TYPE=&apos; with = &apos;&apos;   ).
    lv_icon = icon_view_table.

    IF iv_name IS NOT INITIAL.
      lv_text = ls_tree-fullname.
    ELSE.
      lv_text = ls_tree-typename.
    ENDIF.

    l_rel = iv_rel.
    ASSIGN ir_up-&gt;* TO FIELD-SYMBOL(&lt;new_value&gt;).
    READ TABLE mt_vars WITH KEY name = iv_fullname INTO DATA(l_var).
    IF sy-subrc = 0.

      DATA(lo_nodes) = tree-&gt;get_nodes( ).
      DATA(l_node) =  lo_nodes-&gt;get_node( l_var-key ).
      DATA r_row TYPE REF TO data.
      DATA r_ref TYPE REF TO data.

      TRY.
          r_row = l_node-&gt;get_data_row( ).
          ASSIGN r_row-&gt;* TO FIELD-SYMBOL(&lt;row&gt;).
          ASSIGN COMPONENT &apos;REF&apos; OF STRUCTURE &lt;row&gt; TO FIELD-SYMBOL(&lt;ref&gt;).
          ASSIGN COMPONENT &apos;KIND&apos; OF STRUCTURE &lt;row&gt; TO FIELD-SYMBOL(&lt;kind&gt;).
          r_ref = &lt;ref&gt;.
          ASSIGN r_ref-&gt;* TO FIELD-SYMBOL(&lt;old_value&gt;).
          IF &lt;old_value&gt; NE &lt;new_value&gt;.
            l_key = l_var-key.
            l_rel = if_salv_c_node_relation=&gt;next_sibling.
            IF &lt;kind&gt; NE &apos;v&apos; AND &lt;kind&gt; NE &apos;u&apos;.
              DELETE mt_vars WHERE name = iv_fullname.
            ENDIF.
          ELSE.
            IF ( &lt;new_value&gt; IS INITIAL AND m_hide IS NOT INITIAL ).
              IF &lt;kind&gt; NE &apos;v&apos; AND &lt;kind&gt; NE &apos;u&apos;.
                DELETE mt_vars WHERE name = iv_fullname.
                l_node-&gt;delete( ).
              ENDIF.
            ENDIF.

          ENDIF.

          IF &lt;new_value&gt; IS INITIAL. &quot;AND m_hide IS NOT INITIAL.
            DELETE mt_vars WHERE name = iv_fullname.
            l_node-&gt;delete( ).
            RETURN.
          ENDIF.
        CATCH cx_root.
      ENDTRY.
    ELSE.



    ENDIF.

    IF lines &gt; 0. &quot;OR  m_hide IS INITIAL.
      READ TABLE mt_vars WITH KEY name = iv_parent_name TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.

        ls_tree-fullname = iv_fullname.
        e_root_key =
          tree-&gt;get_nodes( )-&gt;add_node(
            related_node   = iv_parent_key
            relationship   = iv_rel
            collapsed_icon = lv_icon
            expanded_icon  = lv_icon
            data_row       = ls_tree
            text           = lv_text
            folder         = abap_true
          )-&gt;get_key( ).
      ENDIF.
    ENDIF.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_dragdrop IMPLEMENTATION.
  METHOD drag.
    DATA(dataobj) = NEW lcl_dd_data( ).
    dataobj-&gt;m_row = e_row-index.
    dataobj-&gt;m_column = e_column.
    e_dragdropobj-&gt;object = dataobj.
  ENDMETHOD.

  METHOD drop.&quot;It should be refactored someday...
    DATA: ls_row          TYPE lcl_types=&gt;t_sel_row,
          lv_set_receiver.

    LOOP AT lcl_appl=&gt;mt_obj INTO DATA(lo).
      &quot;to
      IF lo-alv_viewer-&gt;mo_sel IS BOUND.
        IF e_dragdropobj-&gt;droptargetctrl = lo-alv_viewer-&gt;mo_sel-&gt;mo_sel_alv.
          DATA(lo_to) = lo-alv_viewer-&gt;mo_sel.
        ENDIF.
      ENDIF.

      &quot;from tab
      IF lo-alv_viewer-&gt;mo_alv = e_dragdropobj-&gt;dragsourcectrl.
        DATA(lo_from_tab) = lo-alv_viewer.
        CONTINUE.
      ENDIF.

      IF e_dragdropobj-&gt;dragsourcectrl = lo-alv_viewer-&gt;mo_sel-&gt;mo_sel_alv.
        DATA(lo_from_sel) = lo-alv_viewer-&gt;mo_sel.
        lo-alv_viewer-&gt;mo_sel-&gt;mo_sel_alv-&gt;get_selected_rows( IMPORTING et_index_rows = DATA(lt_sel_rows) ).
        lo-alv_viewer-&gt;mo_sel-&gt;mo_sel_alv-&gt;get_selected_cells( IMPORTING et_cell = DATA(lt_sel_cells) ).
      ENDIF.
    ENDLOOP.

    IF lo_from_tab IS BOUND.&quot; tab to select
      FIELD-SYMBOLS: &lt;f_tab&gt;   TYPE STANDARD TABLE,
                     &lt;f_field&gt; TYPE any.
      lo_from_tab-&gt;mo_alv-&gt;get_selected_cells( IMPORTING et_cell = lt_sel_cells  ).
      lo_from_tab-&gt;mo_alv-&gt;get_selected_columns( IMPORTING et_index_columns = DATA(lt_sel_col)  ).

      LOOP AT lt_sel_col INTO DATA(l_col).
        TRY.
            lo_from_tab-&gt;mt_alv_catalog[ fieldname = l_col-fieldname ]-style = cl_gui_alv_grid=&gt;mc_style_button.
          CATCH cx_sy_itab_line_not_found.
        ENDTRY.
        READ TABLE lo_from_tab-&gt;mo_column_emitters WITH KEY column = l_col ASSIGNING FIELD-SYMBOL(&lt;emitter&gt;).
        IF sy-subrc NE 0.
          APPEND INITIAL LINE TO lo_from_tab-&gt;mo_column_emitters ASSIGNING &lt;emitter&gt;.
          &lt;emitter&gt;-column = l_col.
          &lt;emitter&gt;-emitter = NEW #( ).
        ENDIF.
      ENDLOOP.

      IF sy-subrc = 0.
        lv_set_receiver = abap_true.
        CALL METHOD lo_from_tab-&gt;mo_alv-&gt;set_frontend_fieldcatalog EXPORTING it_fieldcatalog = lo_from_tab-&gt;mt_alv_catalog.
      ENDIF.

      TRY.
          ASSIGN lo_from_tab-&gt;mr_table-&gt;* TO &lt;f_tab&gt;.
          READ TABLE lo_to-&gt;mt_sel_tab ASSIGNING FIELD-SYMBOL(&lt;to_tab&gt;) INDEX e_row.
          LOOP AT lt_sel_cells INTO DATA(l_cell).
            IF sy-tabix = 1.
              DATA(l_colname) = l_cell-col_id-fieldname.
            ENDIF.
            READ TABLE &lt;f_tab&gt; INDEX l_cell-row_id ASSIGNING FIELD-SYMBOL(&lt;f_str&gt;).
            ASSIGN COMPONENT l_colname OF STRUCTURE &lt;f_str&gt; TO &lt;f_field&gt;.
            IF sy-subrc = 0.
              IF lv_set_receiver IS NOT INITIAL.
                IF &lt;to_tab&gt;-receiver IS BOUND.
                  &lt;to_tab&gt;-receiver-&gt;shut_down( ).
                ENDIF.
                CREATE OBJECT &lt;to_tab&gt;-receiver
                  EXPORTING
                    io_transmitter = &lt;emitter&gt;-emitter
                    i_from_field   = CONV #( lt_sel_cells[ 1 ]-col_id )
                    i_to_field     = &lt;to_tab&gt;-field_label
                    io_sel_to      = lo_to
                    io_tab_from    = lo_from_tab.
                SET HANDLER &lt;to_tab&gt;-receiver-&gt;on_grid_button_click FOR lo_from_tab-&gt;mo_alv.
              ENDIF.

              IF &lt;to_tab&gt;-range IS INITIAL.
                &lt;to_tab&gt;-low = &lt;f_field&gt;.
              ENDIF.
              IF NOT line_exists( &lt;to_tab&gt;-range[ low = &lt;f_field&gt; ] ).
                APPEND VALUE #( sign = &apos;I&apos; opti = &apos;EQ&apos; low = &lt;f_field&gt;  ) TO &lt;to_tab&gt;-range.
              ENDIF.
            ENDIF.
          ENDLOOP.
          lo_to-&gt;update_sel_row( CHANGING c_sel_row = &lt;to_tab&gt; ).
        CATCH cx_sy_itab_line_not_found.                &quot;#EC NO_HANDLER
      ENDTRY.
    ENDIF.

    &quot;select to select
    IF lo_from_sel NE lo_to.
      IF lt_sel_rows[] IS INITIAL.
        DELETE lt_sel_cells WHERE col_id NE &apos;FIELD_LABEL&apos;.
        LOOP AT lt_sel_cells INTO DATA(l_sel).
          APPEND INITIAL LINE TO lt_sel_rows ASSIGNING FIELD-SYMBOL(&lt;row&gt;).
          &lt;row&gt;-index = l_sel-row_id-index.
        ENDLOOP.
      ENDIF.

      LOOP AT lt_sel_rows ASSIGNING &lt;row&gt;.
        READ TABLE lo_from_sel-&gt;mt_sel_tab ASSIGNING FIELD-SYMBOL(&lt;from_tab&gt;) INDEX &lt;row&gt;-index.
        IF lines( lt_sel_rows ) = 1.
          READ TABLE lo_to-&gt;mt_sel_tab ASSIGNING &lt;to_tab&gt; INDEX e_row.
        ELSE.
          READ TABLE lo_to-&gt;mt_sel_tab ASSIGNING &lt;to_tab&gt; WITH KEY field_label = &lt;from_tab&gt;-field_label.
          IF sy-subrc NE 0.
            CONTINUE.
          ENDIF.
        ENDIF.
        MOVE-CORRESPONDING &lt;from_tab&gt; TO ls_row.
        MOVE-CORRESPONDING ls_row TO &lt;to_tab&gt;.
        &lt;from_tab&gt;-emitter = icon_workflow_external_event.
        &lt;to_tab&gt;-inherited = icon_businav_value_chain.
        IF &lt;from_tab&gt;-transmitter IS INITIAL.
          CREATE OBJECT &lt;from_tab&gt;-transmitter.
        ENDIF.
        IF &lt;to_tab&gt;-receiver IS NOT INITIAL.
          &lt;to_tab&gt;-receiver-&gt;shut_down( ). &quot;receiver clearing
          FREE &lt;to_tab&gt;-receiver.
        ENDIF.
        CREATE OBJECT &lt;to_tab&gt;-receiver
          EXPORTING
            io_transmitter = &lt;from_tab&gt;-transmitter
            io_sel_to      = lo_to
            i_to_field     = &lt;to_tab&gt;-field_label.
      ENDLOOP.
    ENDIF.

    DATA(lo_alv) = CAST cl_gui_alv_grid( e_dragdropobj-&gt;dragsourcectrl ).
    lcl_alv_common=&gt;refresh( EXPORTING i_obj = lo_alv ).

    lo_alv ?= e_dragdropobj-&gt;droptargetctrl.
    lo_to-&gt;raise_selection_done( ).
  ENDMETHOD.
ENDCLASS.</source>
</PROG>

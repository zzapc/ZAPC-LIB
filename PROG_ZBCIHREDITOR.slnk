<?xml version="1.0" encoding="utf-8"?>
<PROG NAME="ZBCIHREDITOR" VARCL="X" SUBC="I" RMAND="100" RLOAD="S" UCCHECK="X">
 <source>*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZBCIHREDITOR                                     *
*&amp;---------------------------------------------------------------------*
*----------------------------------------------------------------------*
*   INCLUDE ZHRMPI02                                                   *
*----------------------------------------------------------------------*
* Funciones manejo de textos en dynpros
************************************************************************

DATA: v_hreditor_visualizar,
      v_hreditor_forzar_vis,
      v_hreditor_vis,
      v_hreditor_inicio,
      v_hreditor_maxcols TYPE i VALUE 72.

DATA:  i_hreditor_texto(132) OCCURS 5 WITH HEADER LINE,
      *i_hreditor_texto(132) OCCURS 5 WITH HEADER LINE.

************************ DEFINES ***************************************
* Personalizamos el objeto editor
DATA v_hreditor_repid LIKE sy-repid.

DEFINE set_editor.
  v_hreditor_repid = sy-repid.
  clear v_hreditor_vis.
  if v_hreditor_visualizar = &apos;X&apos; or v_hreditor_forzar_vis = &apos;X&apos;.
    v_hreditor_vis = &apos;X&apos;.
  endif.
  call function &apos;RH_EDITOR_SET&apos;
    exporting
      repid          = v_hreditor_repid
      dynnr          = sy-dynnr
      controlname    = &amp;1
      max_cols       = v_hreditor_maxcols
      show_tool      = &apos; &apos;
      show_status    = &apos; &apos;
      display_mode   = v_hreditor_vis
    tables
      lines          = &amp;2
    exceptions
      create_error   = 1
      internal_error = 2
      others         = 3.
END-OF-DEFINITION.

DEFINE get_editor.
  call function &apos;RH_EDITOR_GET&apos;
    exporting
      controlname    = &amp;1
    tables
      lines          = &amp;2
    exceptions
      internal_error = 1
      others         = 2.
END-OF-DEFINITION.

DEFINE destruye_editor.
  call function &apos;RH_EDITOR_DESTROY&apos;
    exporting
      controlname = &amp;1.
END-OF-DEFINITION.


*---------------------------------------------------------------------*
*       FORM unir_en_linea                                            *
*---------------------------------------------------------------------*
FORM unir_en_linea TABLES i_lineas
                 CHANGING ps_linea.
  DATA: i_tabla TYPE TABLE OF text132.

  LOOP AT i_lineas.
    APPEND i_lineas TO i_tabla.
  ENDLOOP.

  ps_linea = zcl_ap_string=&gt;tabla2string( i_tabla ).

ENDFORM.                    &quot;unir_en_linea

*&amp;---------------------------------------------------------------------*
*&amp;      Form  unir_en_linea_opt
*&amp;---------------------------------------------------------------------*
FORM unir_en_linea_opt TABLES i_lineas
                 USING pe_long_salto
                 CHANGING ps_linea.
  DATA: l_long TYPE i,
        l_tabix LIKE sy-tabix,
        l_ultima,
        l_linea(1000),
        l_letra.

  DATA i_lineas_aux(1000) OCCURS 0 WITH HEADER LINE.

  LOOP AT i_lineas INTO i_lineas_aux.
    APPEND i_lineas_aux.
  ENDLOOP.

  CLEAR ps_linea.
  LOOP AT i_lineas.
    l_tabix = sy-tabix.
    IF ps_linea IS INITIAL.
      ps_linea = i_lineas.
    ELSE.
      l_linea = i_lineas.
      l_long = STRLEN( l_linea ).
      ADD 1 TO l_tabix.
      READ TABLE i_lineas_aux INDEX l_tabix.
      IF sy-subrc = 0.
*        l_long = STRLEN( i_lineas_AUX ).
      ELSE.
        CLEAR l_long.
        l_ultima = &apos;X&apos;.
      ENDIF.

      IF l_ultima IS INITIAL AND
        ( zcl_ap_string=&gt;ultimo_caracter( i_lineas ) = &apos;.&apos;
          OR l_long &lt; pe_long_salto ).
        CONCATENATE ps_linea i_lineas cl_abap_char_utilities=&gt;cr_lf
               INTO ps_linea SEPARATED BY space.
      ELSE.
        l_letra = zcl_ap_string=&gt;ultimo_caracter( ps_linea ).
        IF l_letra = &apos;&apos; OR I_LINEAS(1) = &apos;&apos;.
          CONCATENATE ps_linea i_lineas
                 INTO ps_linea.
        ELSE.
          CONCATENATE ps_linea i_lineas
                 INTO ps_linea SEPARATED BY space.
        ENDIF.
      ENDIF.
    ENDIF.
  ENDLOOP.

ENDFORM.                    &quot;unir_en_linea_opt

*---------------------------------------------------------------------*
*       FORM partir_linea                                             *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
*  --&gt;  I_LINEAS                                                      *
*  --&gt;  PE_LINEA                                                      *
*---------------------------------------------------------------------*
FORM partir_linea TABLES i_lineas
                   USING pe_linea.
  DATA: l_string TYPE string,
        i_tabla TYPE tlinetab,
        l_line TYPE tline.

  l_string = pe_linea.
  zcl_ap_string=&gt;STRING2TABLASTRING( EXPORTING string   = l_string
                                         longitud = v_hreditor_maxcols
                               CHANGING  tabla    = i_tabla ).

  LOOP AT i_tabla INTO l_line.
    i_lineas = l_line.
    APPEND i_lineas.
  ENDLOOP.
*  data: c_aux,  x_aux type x.
*  data: l_enter1.
*  data l_linea like tline-tdline.
*  data l_lin(1000).
*  data: l_cont type i,
*         l_aux type i.
*
*
*  l_lin = pe_linea.
*  clear l_cont.
*  refresh i_lineas.
*  do.
*    add 1 to l_cont.
*    c_aux = l_lin(1).
*
**Pasamos el car치cter a binario para obtener el c칩digo ASCII
*    x_aux = c_aux.
*
*    if x_aux = &apos;0A&apos;.   &quot;C칩digo del enter
*      if l_enter1 = &apos;X&apos;.
*        i_lineas = l_linea.
*        append i_lineas.
*        clear l_linea.
*        clear l_cont.
*      endif.
*    endif.
*
*    if x_aux = &apos;0D&apos;.   &quot;C칩digo del enter
*      l_enter1 = &apos;X&apos;.
*    else.
*      clear l_enter1.
*    endif.
*
*    if x_aux ne &apos;0D&apos;  and x_aux ne &apos;0A&apos;.
*      l_aux = l_cont - 1.
*      l_linea+l_aux(1) = c_aux.
*    endif.
*
*    shift l_lin left.
*    if l_lin is initial.
*      if not l_linea is initial.
*        i_lineas = l_linea.
*        append i_lineas.
*        clear l_cont.
*      endif.
*      exit.
*    endif.
*
*    if l_cont = 132.
*      i_lineas = l_linea.
*      append i_lineas.
*      clear l_linea.
*      clear l_cont.
*    endif.
*
*  enddo.

ENDFORM.                    &quot;partir_linea

*---------------------------------------------------------------------*
*       FORM LEER_TEXTO                                               *
*---------------------------------------------------------------------*
*       ........                                                      *
*---------------------------------------------------------------------*
FORM leer_texto_hr TABLES i_lineas
                USING pe_objid pe_subty.
  DATA: i_1002 LIKE p1002 OCCURS 1 WITH HEADER LINE,
        i_hrt1002 LIKE hrt1002 OCCURS 1 WITH HEADER LINE.

  SELECT * FROM hrp1002
    INTO CORRESPONDING FIELDS OF TABLE i_1002
   WHERE plvar = &apos;01&apos;
     AND otype = &apos;S&apos;
     AND objid = pe_objid
     AND subty = pe_subty
     AND istat = &apos;1&apos;.

  CALL FUNCTION &apos;RH_READ_INFTY_TABDATA&apos;
    EXPORTING
      infty          = &apos;1002&apos;
    TABLES
      innnn          = i_1002
      hrtnnnn        = i_hrt1002
    EXCEPTIONS
      no_table_infty = 1
      innnn_empty    = 2
      nothing_found  = 3
      OTHERS         = 4.

  REFRESH i_lineas.
  LOOP AT i_hrt1002.
    i_lineas = i_hrt1002-tline.
    APPEND i_lineas.
  ENDLOOP.

ENDFORM.                    &quot;leer_texto_hr</source>
</PROG>

*----------------------------------------------------------------------*
*  Program : ZSPRO_AP
*  Author  : S. Hermann
*  Date    : 17.09.2017
*  Version : 2.5.1
*  Required: Table ZSPRO_AP
*----------------------------------------------------------------------*
*  This program allow you to manage a hierarchy of objects
*  Objects can be from several types :
*  - table
*  - program
*  - transaction
*  - function module
*  - url
*  - IMG activity
*  - class
*
*  Typically usage is to build a repository of specific tables/programm
*  like SAP do it with SPRO.
*
*  You can click on any table to display help and structure, or double
*  click to manage content (if maintenance view exist) or display
*  content. You can also display table definition.
*
*  You can click on any program to display help or double click to
*  execute the program. You can also display code.
*
*  You can click on any transaction to display help or double click to
*  execute the transaction.
*
*  You can click on any function module to display help or double click
*  to display screen with input parameters.  You can also display code.
*
*  You can click on any IMG activity to display help or double click to
*  execute the activity.
*
*  You can double click on any URL/application to execute it
*
*  The edition mode embed allow you to add/change/delete entries
*  graphically in the transaction.
*  It allow you also to edit help for specific objets
*
*  To initiate easilly the repository, you can add in mass
*  tables /program and then assign them to correct folder
*
*  This tool can be used by functionnal team to fill specific
*  customizing tables without knowing his technical name
*
*  Another usage of this program is to build a repository of utilities
*  programs. IT team can easilly execute usefull program centralised
*  in this place
*
*  Please send comment & improvements to http://quelquepart.biz
*----------------------------------------------------------------------*
* History
* 2017.09.17 V2.5.1: Fix Better display of program documentation
*                    Fix Add object with a standard empty description
* 2017.01.28 v2.5  : Add Management of stylized abap documentation
*                    Add Interface methods in class documentation
*                    Add default background image for screen rigth part
* 2015.09.18 V2.4  : Add icon for url type image & email
*                    Add Text table on ddic table html display
*                    Add Context menu to Jump to SE11 on Text table
* 2015.05.10 v2.3  : Add XML import
*                    Add node : Class type
*                    Mod help link management for specific cases
*                    Mod Code cleaned
* 2014.11.15 v2.2  : Add node : IMG type
*                    Add node : Function module type
*                    Mod XML generation class to increase compatibility
*                    Fix bug on display techname function
*                    Mod Display "Edit help" only for specific objects
*                    Add link management in help display
* 2014.05.11 v2.1.1: Fix bug on reorder items in tree
* 2014.03.08 v2.1  : Add XML export
* 2014.02.03 v2.0.2: Add separate icons for doc/xls/ppt/pdf links
*                    Mod Transport all the tree content in 1 entry
* 2014.01.03 v2.0.1: Mod Allow transport into an existing request
* 2013.10.12 v2.0  : Mod Big rework to allow more different object types
*                        as nodes
*                    Add node : Transaction type
*                    Add node : Url type
* 2013.08.28 v1.06 : Mod Better display of autodoc on program entries
* 2013.07.05 v1.05 : Mod Better jump to SE11, SE16 & SE38
* 2013.06.14 v1.04 : Add jump to SE11 for table entry
*                    Add Display technical name on/off (in tree)
* 2013.06.12 v1.03 : Add jump to SE38 for program entry
* 2013.06.09 v1.02 : Add table name in documentation for table entry
* 2013.04.04 v1.01 : Add autodoc on program entries
* v1.0  : Initial release
*----------------------------------------------------------------------*
* ajouter sapwr aux link
* ajouter sap aux link : fichier a ouvrir et folder a ouvrir via zal11
PROGRAM ZSPRO_AP.

*######################################################################*
*
*                             DATA SECTION
*
*######################################################################*

* Object declaration deferred
CLASS : lcl_application DEFINITION DEFERRED,
        lcl_gui_simple_tree DEFINITION DEFERRED,
        cl_gui_cfw DEFINITION LOAD.

* Objects declaration
* Spliter
DATA : o_splitter        TYPE REF TO cl_gui_splitter_container,
       o_container       TYPE REF TO cl_gui_custom_container,
       o_container_left  TYPE REF TO cl_gui_container,
       o_container_right TYPE REF TO cl_gui_container,
* html view
       o_html_control    TYPE REF TO cl_gui_html_viewer,
* Tree
       o_application     TYPE REF TO lcl_application,
       o_tree            TYPE REF TO lcl_gui_simple_tree,
       o_behaviour       TYPE REF TO cl_dragdrop,

       o_pic             TYPE REF TO cl_gui_picture.

* Data declaration
* Tree data
DATA : w_handle_tree TYPE i,

       s_ZSPRO_AP       TYPE ZSPRO_AP,
       t_ZSPRO_AP       LIKE SORTED TABLE OF s_ZSPRO_AP WITH UNIQUE KEY node_key,
       t_ZSPRO_AP_copy  LIKE TABLE OF s_ZSPRO_AP,
       s_ZSPRO_AP_upd   TYPE ZSPRO_AP,
       r_ZSPRO_AP_del   TYPE RANGE OF ZSPRO_AP-node_key,
       s_ZSPRO_AP_del   LIKE LINE OF r_ZSPRO_AP_del,
       w_node_key    TYPE ZSPRO_AP-node_key,
       s_node        TYPE ZSPRO_AP.

* General data
DATA : okcode         LIKE sy-ucomm, "screen function code
       w_okcode       LIKE okcode,
       w_first_time   TYPE c,
       w_mode_change  TYPE c,
       w_data_changed TYPE c, "to know if data changed need to be save
       BEGIN OF s_find, "Search structure
         nodetype  TYPE ZSPRO_AP-nodetype,
         nodeparam TYPE ZSPRO_AP-nodeparam,
         patern    TYPE ZSPRO_AP-text,
         index     TYPE i,
* TODO : delete
         tabname   TYPE tabname,
         programm  TYPE programm,
       END OF s_find,
       t_excluded_nochange TYPE TABLE OF sy-ucomm,
       w_techname          TYPE i. "display techname in tree on/off

* Constants
CONSTANTS : c_action_enqueue         TYPE c VALUE 'E',
            c_action_dequeue         TYPE c VALUE 'D',
            c_enqueue_mode_exclusive TYPE c VALUE 'E',
            c_tree_table             TYPE tabname VALUE 'ZSPRO_AP',
            c_wildcard               TYPE c VALUE '#',
            c_state_active           TYPE ddobjstate VALUE 'A',
            c_msg_abort              TYPE c VALUE 'A',
            c_msg_error              TYPE c VALUE 'E',
            c_msg_succes             TYPE c VALUE 'S',
            c_langu_default          TYPE sy-langu VALUE 'E',
            c_doktyp_technical       TYPE dokil-typ VALUE 'T',
            c_doktyp_enduser         TYPE dokil-typ VALUE 'E',
            c_doctype_table          TYPE doku_id VALUE 'TB',
            c_doctype_prog           TYPE doku_id VALUE 'RE',
            c_doctype_img            TYPE doku_id VALUE 'HY',
            c_doctype_fm             TYPE doku_id VALUE 'FU',
            c_doctype_cls            TYPE doku_id VALUE 'CL',
            c_doctype_meth           TYPE doku_id VALUE 'CO',
            c_doctype_clsattr        TYPE doku_id VALUE 'CA',
            c_popup_file             TYPE c VALUE space,
            c_popup_folder           TYPE c VALUE 'X',
            c_popup_find             TYPE c VALUE 'F',
            c_icon_table(4)          TYPE c VALUE '@36@',
            c_icon_table_nomaint(4)  TYPE c VALUE '@3W@',
            c_icon_prog(4)           TYPE c VALUE '@9U@',
            c_icon_transac(4)        TYPE c VALUE '@15@',
            c_icon_url(4)            TYPE c VALUE '@CQ@',
            c_icon_url_broken(4)     TYPE c VALUE '@CR@',
            c_icon_xls(4)            TYPE c VALUE '@J2@',
            c_icon_doc(4)            TYPE c VALUE '@J7@',
            c_icon_ppt(4)            TYPE c VALUE '@J5@',
            c_icon_pdf(4)            TYPE c VALUE '@IT@',
            c_icon_img(4)            TYPE c VALUE '@5H@',
            c_icon_fm(4)             TYPE c VALUE '@12@',
            c_icon_cls(4)            TYPE c VALUE '@7C@',
            c_icon_mail(4)           TYPE c VALUE '@E2@',
            c_icon_png(4)            TYPE c VALUE '@IU@',
            c_icon_unknown(4)        TYPE c VALUE '@AH@',
            c_techname_on            TYPE i VALUE 1,
            c_url_broken(1)          TYPE c VALUE '#',
            c_nodetype_node          TYPE ZSPRO_AP-nodetype VALUE '0',
            c_nodetype_table         TYPE ZSPRO_AP-nodetype VALUE '1',
            c_nodetype_program       TYPE ZSPRO_AP-nodetype VALUE '2',
            c_nodetype_transac       TYPE ZSPRO_AP-nodetype VALUE '3',
            c_nodetype_url           TYPE ZSPRO_AP-nodetype VALUE '4',
            c_nodetype_fm            TYPE ZSPRO_AP-nodetype VALUE '5',
            c_nodetype_img           TYPE ZSPRO_AP-nodetype VALUE '6',
            c_nodetype_cls           TYPE ZSPRO_AP-nodetype VALUE '7',
            c_xmltype_table          TYPE string VALUE 'Table', "#EC NOTEXT
            c_xmltype_program        TYPE string VALUE 'Program', "#EC NOTEXT
            c_xmltype_transac        TYPE string VALUE 'Transaction', "#EC NOTEXT
            c_xmltype_url            TYPE string VALUE 'Link', "#EC NOTEXT
            c_xmltype_fm             TYPE string VALUE 'Function', "#EC NOTEXT
            c_xmltype_img            TYPE string VALUE 'IMG',
            c_xmltype_cls            TYPE string VALUE 'Class', "#EC NOTEXT
            c_xmlnode_root           TYPE string VALUE 'root',
            c_xmlnode_folder         TYPE string VALUE 'node',
            c_xmlnode_file           TYPE string VALUE 'item',
            c_xmlattr_folder_text    TYPE string VALUE 'name',
            c_xmlattr_file_text      TYPE string VALUE 'description',
            c_xmlattr_file_type      TYPE string VALUE 'type',
            c_xmlattr_file_param     TYPE string VALUE 'value',
            c_welcome_bg             TYPE string VALUE 'ZTOOLBG'.

*######################################################################*
*
*                             CLASS SECTION
*
*######################################################################*

*----------------------------------------------------------------------*
*       CLASS LCL_APPLICATION DEFINITION
*----------------------------------------------------------------------*
*       Class to handle application events
*----------------------------------------------------------------------*
CLASS lcl_application DEFINITION FINAL.
  PUBLIC SECTION.
    METHODS:
      handle_select
      FOR EVENT selection_changed
                    OF cl_gui_simple_tree
        IMPORTING node_key,
      handle_node_double_click
      FOR EVENT node_double_click
                    OF cl_gui_simple_tree
        IMPORTING node_key,
      drag
      FOR EVENT on_drag
                    OF cl_gui_simple_tree
        IMPORTING node_key drag_drop_object,
      drop
      FOR EVENT on_drop
                    OF cl_gui_simple_tree
        IMPORTING node_key drag_drop_object,
      handle_node_context_menu_req
      FOR EVENT node_context_menu_request
                    OF cl_gui_simple_tree
        IMPORTING node_key menu,
      handle_def_context_menu_req
      FOR EVENT default_context_menu_request
                    OF cl_gui_simple_tree
        IMPORTING menu,
      handle_def_context_menu_sel
      FOR EVENT default_context_menu_select
                    OF cl_gui_simple_tree
        IMPORTING fcode,
      handle_node_context_menu_sel
      FOR EVENT node_context_menu_select
                    OF cl_gui_simple_tree
        IMPORTING fcode,
      handle_link_clic_html
      FOR EVENT sapevent
                    OF cl_gui_html_viewer
        IMPORTING action.

ENDCLASS.                    "lcl_application DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_gui_simple_tree DEFINITION
*----------------------------------------------------------------------*
* Redefinition of cl_gui_simple_tree to allow events
* SELECTION_CHANGED + NODE_DOUBLE_CLICK
*----------------------------------------------------------------------*
CLASS lcl_gui_simple_tree DEFINITION FINAL
                          INHERITING FROM cl_gui_simple_tree.
  PUBLIC SECTION.
    METHODS set_registered_events REDEFINITION.

ENDCLASS.                    "lcl_gui_simple_tree DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_drag_object DEFINITION
*----------------------------------------------------------------------*
*       Drag&Drop object to keep dragged node_key
*----------------------------------------------------------------------*
CLASS lcl_drag_object DEFINITION FINAL.
  PUBLIC SECTION.
    DATA node_key TYPE ZSPRO_AP-node_key.
ENDCLASS.                    "lcl_drag_object DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_gui_simple_tree IMPLEMENTATION
*----------------------------------------------------------------------*
* Redefinition of cl_gui_simple_tree to allow events
* SELECTION_CHANGED + NODE_DOUBLE_CLICK
*----------------------------------------------------------------------*
CLASS lcl_gui_simple_tree IMPLEMENTATION.
  METHOD set_registered_events.
    DATA: simple_event    TYPE cntl_simple_event,
          ex_event        TYPE cntl_event,
          events_ex       TYPE cntl_events,
          sel_change_used TYPE as4flag.                     "#EC NEEDED

* check if control is alive
    IF h_control IS INITIAL.
      MESSAGE 'Tree control no longer exists'(m13) TYPE c_msg_abort.
    ENDIF.

* check if selection_change event is used
    READ TABLE events WITH KEY eventid = eventid_selection_changed
      TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      IF node_selection_mode <> node_sel_mode_single.
        RAISE illegal_event_combination.
      ENDIF.
      sel_change_used = abap_true.
    ENDIF.
* Register drag drop event. This event only occurs when cl_dragdrop
* is also used --> no need for explicit registration by control user.
    ex_event-is_shellevent = abap_true.
    ex_event-is_systemevent = abap_true.
    ex_event-eventid = cl_gui_control=>shellevt_dragdrop.
    APPEND ex_event TO events_ex.

* map simple_event into ex_event, append to events_ex
    LOOP AT events INTO simple_event.
      CASE simple_event-eventid.
        WHEN eventid_expand_no_children.
        WHEN eventid_node_keypress.
        WHEN eventid_node_double_click.
*          IF NOT sel_change_used IS INITIAL.
*          RAISE ILLEGAL_EVENT_COMBINATION.
*          ENDIF.
        WHEN eventid_selection_changed.
        WHEN eventid_node_context_menu_req
             OR eventid_def_context_menu_req.
* Register context menu select event
          ex_event-eventid = shellevt_ctxmnu_sel.
          ex_event-is_shellevent = abap_true.
          ex_event-is_systemevent = ctx_men_select_system.
          APPEND ex_event TO events_ex.
        WHEN OTHERS.
          RAISE illegal_event_combination.
      ENDCASE.
      ex_event-eventid = simple_event-eventid.
      CLEAR ex_event-is_shellevent.
      IF simple_event-appl_event IS INITIAL.
        ex_event-is_systemevent = abap_true.
      ELSE.
        CLEAR ex_event-is_systemevent.
      ENDIF.
      APPEND ex_event TO events_ex.

    ENDLOOP.

    CALL METHOD me->set_registered_events_ex
      EXPORTING
        eventtab                  = events_ex
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3
        OTHERS                    = 4.
    CASE sy-subrc.
      WHEN 1. RAISE cntl_error.
      WHEN 2. RAISE cntl_system_error.
      WHEN 3. RAISE illegal_event_combination.
      WHEN 4. RAISE cntl_error.
    ENDCASE.

    registered_simple_events[] = events.

  ENDMETHOD.                    "SET_REGISTERED_EVENTS
ENDCLASS.                    "lcl_gui_simple_tree IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS LCL_APPLICATION IMPLEMENTATION
*----------------------------------------------------------------------*
*       Class to handle application events
*----------------------------------------------------------------------*
CLASS lcl_application IMPLEMENTATION.

*&---------------------------------------------------------------------*
*&      CLASS lcl_application
*&      METHOD handle_link_clic_html
*&---------------------------------------------------------------------*
*  When user clic to a link in documentation, jump to the linked object
*  dockat DS:KENO seem "sap help" link in web browser
*  dockat DS:REPO seem object structure display (no really help)
*----------------------------------------------------------------------*
  METHOD handle_link_clic_html.
    DATA : l_dummy   TYPE c,                                "#EC NEEDED
           l_object  TYPE ZSPRO_AP-nodeparam,
           l_doctype TYPE doku_id,
           l_dockat  TYPE dsysh-dokclass.

    SPLIT action AT ':' INTO l_dummy l_object.
    SPLIT l_object AT '.' INTO l_dockat l_object.

* Display external link in browser (KENO)
* Display linked object (REPO)
    IF l_dockat = 'KENO' OR l_dockat = 'REPO'.
      CALL FUNCTION 'DSYS_SHOW'
        EXPORTING
          dokclass         = l_dockat
          dokname          = l_object
        EXCEPTIONS
          class_unknown    = 0
          object_not_found = 0
          OTHERS           = 0.
    ELSE.
      IF l_dockat = 'SIMG'. "link between img activity
        l_doctype = c_doctype_img.
      ELSE.
        l_doctype = l_dockat.
      ENDIF.
      PERFORM write_html_obj USING l_object l_doctype.
    ENDIF.
  ENDMETHOD. "handle_link_clic_html

*&---------------------------------------------------------------------*
*&      CLASS lcl_application
*&      METHOD handle_select
*&---------------------------------------------------------------------*
* When a node is selected, display info in the HTML part of the screen
*----------------------------------------------------------------------*
  METHOD handle_select.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = node_key.
    PERFORM init_html.
  ENDMETHOD.                    "handle_select

*&---------------------------------------------------------------------*
*&      CLASS lcl_application
*&      METHOD handle_def_context_menu_req
*&---------------------------------------------------------------------*
* This method handles the node context menu request event of the tree
* control instance
*----------------------------------------------------------------------*
  METHOD  handle_def_context_menu_req.

*   Allow only in change mode
    IF w_mode_change NE abap_true.
      RETURN.
    ENDIF.

    CALL METHOD menu->add_function
      EXPORTING
        text  = 'Create folder'(c01)
        fcode = 'FOLDER'.
    CALL METHOD menu->add_function
      EXPORTING
        text  = 'Add entry'(c02)
        fcode = 'FILE'.
    CALL METHOD menu->add_function
      EXPORTING
        text  = 'Add entries in mass'(c03)
        fcode = 'MASSFILE'.

  ENDMETHOD.                    "handle_def_context_menu_req

*&---------------------------------------------------------------------*
*&      CLASS lcl_application
*&      METHOD handle_def_context_menu_sel
*&---------------------------------------------------------------------*
* This method handles the node context select event of the tree control
* instance
*----------------------------------------------------------------------*
  METHOD  handle_def_context_menu_sel.
*   Restricted to change mode only
    IF w_mode_change NE abap_true.
      RETURN.
    ENDIF.

    okcode = fcode.
  ENDMETHOD.                    "handle_def_context_menu_sel

*&---------------------------------------------------------------------*
*&      CLASS lcl_application
*&      METHOD handle_node_context_menu_req
*&---------------------------------------------------------------------*
* This method handles the node context menu request event of the tree
* control instance
*----------------------------------------------------------------------*
  METHOD  handle_node_context_menu_req.
    DATA : l_tabletxt TYPE dd08v-tabname,
           l_table    TYPE tabname.

    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = node_key.
    IF s_ZSPRO_AP-isfolder = abap_true.
      IF w_mode_change = abap_true.
        CALL METHOD menu->add_function
          EXPORTING
            text  = 'Create folder'(c01)
            fcode = 'FOLDER'.
        CALL METHOD menu->add_function
          EXPORTING
            text  = 'Add entry'(c02)
            fcode = 'FILE'.
        CALL METHOD menu->add_function
          EXPORTING
            text  = 'Add entries in mass'(c03)
            fcode = 'MASSFILE'.
      ENDIF.
    ELSE.
* Where-used not applicable for url & IMG
      IF s_ZSPRO_AP-nodetype NE c_nodetype_url
      AND s_ZSPRO_AP-nodetype NE c_nodetype_img.
        CALL METHOD menu->add_function
          EXPORTING
            text  = 'Where-used List'(c04)
            fcode = 'WHEREUSED'.
      ENDIF.
* Help applicable for specific objects only
      IF w_mode_change = abap_true
      AND ( s_ZSPRO_AP-nodeparam(1) = 'Z' OR s_ZSPRO_AP-nodeparam(1) = 'Y' )
      AND s_ZSPRO_AP-nodetype NE c_nodetype_url
      AND s_ZSPRO_AP-nodetype NE c_nodetype_transac.
        CALL METHOD menu->add_function
          EXPORTING
            text  = 'Edit help'(c09)
            fcode = 'EDITHELP'.
      ENDIF.
      IF s_ZSPRO_AP-nodetype = c_nodetype_table.
        CALL METHOD menu->add_function
          EXPORTING
            text  = 'View content'(c10)
            fcode = 'SE16'.
        CALL METHOD menu->add_function
          EXPORTING
            text  = 'Display table definition'(c12)
            fcode = 'SE11'.

        l_table = s_ZSPRO_AP-nodeparam.
        CALL FUNCTION 'DDUT_TEXTTABLE_GET'
          EXPORTING
            tabname   = l_table
          IMPORTING
            texttable = l_tabletxt.
        IF NOT l_tabletxt IS INITIAL.
          CALL METHOD menu->add_function
            EXPORTING
              text  = 'Display text table definition'(c17)
              fcode = 'SE11T'.
        ENDIF.
      ENDIF.
      IF s_ZSPRO_AP-nodetype = c_nodetype_cls.
        CALL METHOD menu->add_function
          EXPORTING
            text  = 'Display class'(c15)
            fcode = 'SE24'.
      ENDIF.
      IF s_ZSPRO_AP-nodetype = c_nodetype_program
      OR s_ZSPRO_AP-nodetype = c_nodetype_fm.
        CALL METHOD menu->add_function
          EXPORTING
            text  = 'Display code'(c11)
            fcode = 'SE38'.
      ENDIF.
    ENDIF.
    IF w_mode_change = abap_true.
      CALL METHOD menu->add_function
        EXPORTING
          text  = 'Rename this entry'(c05)
          fcode = 'RENAME'.

      CALL METHOD menu->add_function
        EXPORTING
          text  = 'Delete this entry'(c06)
          fcode = 'DELETE'.

      CALL METHOD menu->add_separator.

      CALL METHOD menu->add_function
        EXPORTING
          text  = 'Up in current folder'(c07)
          fcode = 'UP'.

      CALL METHOD menu->add_function
        EXPORTING
          text  = 'Down in current folder'(c08)
          fcode = 'DOWN'.
    ENDIF.
  ENDMETHOD.                    "handle_node_context_menu_req

*&---------------------------------------------------------------------*
*&      CLASS lcl_application
*&      METHOD handle_node_context_menu_sel
*&---------------------------------------------------------------------*
* This method handles the node context select event of the tree control
* instance
*----------------------------------------------------------------------*
  METHOD  handle_node_context_menu_sel.
    okcode = fcode.
  ENDMETHOD.                    "handle_node_context_menu_sel


*&---------------------------------------------------------------------*
*&      CLASS lcl_application
*&      METHOD handle_node_double_click
*&---------------------------------------------------------------------*
* This method handles the node double click event of the tree control
* instance
*----------------------------------------------------------------------*
  METHOD  handle_node_double_click.
    DATA : lt_node_key TYPE treev_nks,
           l_tabname   TYPE tabname,
           l_url       TYPE string,
           l_img       TYPE cus_act,
           l_function  TYPE rs38l-name.

    READ TABLE t_ZSPRO_AP WITH KEY node_key = node_key INTO s_ZSPRO_AP.

    IF s_ZSPRO_AP-isfolder = abap_true.
*     Dbl click on a node, expand or collapse.
      CLEAR lt_node_key.
      CALL METHOD o_tree->get_expanded_nodes
        CHANGING
          node_key_table = lt_node_key.

      READ TABLE lt_node_key FROM node_key TRANSPORTING NO FIELDS.
      IF sy-subrc <> 0.
*       Node is collapsed, it will be expanded
        CALL METHOD o_tree->expand_node
          EXPORTING
            node_key = node_key.
      ELSE.
*       Node is expanded, it will be collapsed
        CALL METHOD o_tree->collapse_subtree
          EXPORTING
            node_key = node_key.
      ENDIF.
    ELSE.
*     Click on a final node, it will be opened
      CASE s_ZSPRO_AP-nodetype.
        WHEN c_nodetype_table.
          l_tabname = s_ZSPRO_AP-nodeparam.
          IF s_ZSPRO_AP-nomaint = space.
            CALL FUNCTION 'VIEW_MAINTENANCE_CALL'
              EXPORTING
                action                       = 'S'
                view_name                    = l_tabname
                check_ddic_mainflag          = abap_true
              EXCEPTIONS
                client_reference             = 1
                foreign_lock                 = 2
                invalid_action               = 3
                no_clientindependent_auth    = 4
                no_database_function         = 5
                no_editor_function           = 6
                no_show_auth                 = 7
                no_tvdir_entry               = 8
                no_upd_auth                  = 9
                only_show_allowed            = 10
                system_failure               = 11
                unknown_field_in_dba_sellist = 12
                view_not_found               = 13
                maintenance_prohibited       = 14
                OTHERS                       = 15.
            IF sy-subrc <> 0.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ENDIF.
          ELSE.
            CALL FUNCTION 'RS_TOOL_ACCESS'
              EXPORTING
                operation   = 'TAB_CONT'
                object_name = l_tabname
                object_type = 'TABL'.
          ENDIF.
        WHEN c_nodetype_program.
* Execute program
          SUBMIT (s_ZSPRO_AP-nodeparam) VIA SELECTION-SCREEN AND RETURN.
        WHEN c_nodetype_transac.
* Execute transaction
          CALL TRANSACTION s_ZSPRO_AP-nodeparam.
        WHEN c_nodetype_url.
* Do not try to open broken link
          IF s_ZSPRO_AP-nodeparam = c_url_broken.
            RETURN.
          ENDIF.

* Open link
          l_url = s_ZSPRO_AP-nodeparam.
          CALL METHOD cl_gui_frontend_services=>execute
            EXPORTING
              application = l_url
            EXCEPTIONS
              OTHERS      = 10.
          IF sy-subrc NE 0.
            MESSAGE 'Cannot display selected link'(m21)
                    TYPE c_msg_succes DISPLAY LIKE c_msg_error.
          ENDIF.
        WHEN c_nodetype_img.
* Open IMG activity
          l_img = s_ZSPRO_AP-nodeparam.
          CALL FUNCTION 'S_CUS_ACTIVITY_EXECUTE'
            EXPORTING
              activity = l_img.
        WHEN c_nodetype_fm.
* Start the test environement of the function module
          l_function = s_ZSPRO_AP-nodeparam.
          CALL FUNCTION 'SFCS_FA_TEST_FUNCTION'
            EXPORTING
              funcname = l_function
            EXCEPTIONS
              OTHERS   = 0.
        WHEN c_nodetype_cls.
* Display class
          PERFORM start_se24.
      ENDCASE.
    ENDIF.
  ENDMETHOD.                    "handle_node_double_click

*&---------------------------------------------------------------------*
*&      CLASS lcl_application
*&      METHOD drag
*&---------------------------------------------------------------------*
* Handle the drag action on a node, in change mode
*----------------------------------------------------------------------*
  METHOD  drag.
    DATA lo_drag_object TYPE REF TO lcl_drag_object.

*   Restricted to change mode only
    IF w_mode_change NE abap_true.
      RETURN.
    ENDIF.

    CREATE OBJECT lo_drag_object.
    lo_drag_object->node_key = node_key.
    drag_drop_object->object = lo_drag_object.

  ENDMETHOD.                    "handle_node_drag_drop

*&---------------------------------------------------------------------*
*&      CLASS lcl_application
*&      METHOD drop
*&---------------------------------------------------------------------*
* Handle the drop action on a node, in change mode.
* Drop is allowed only on a folder
*----------------------------------------------------------------------*
  METHOD drop.
    DATA : lo_drag_object TYPE REF TO lcl_drag_object,
           l_newkey       LIKE node_key,
           l_sort         TYPE i.

*   Restricted to change mode only
    IF w_mode_change NE abap_true.
      RETURN.
    ENDIF.

    CATCH SYSTEM-EXCEPTIONS move_cast_error = 1.
      lo_drag_object ?= drag_drop_object->object.
    ENDCATCH.
    IF sy-subrc = 1.
* Data object has unexpected class => cancel Drag & Drop operation
      CALL METHOD drag_drop_object->abort.
      RETURN.
    ENDIF.

* drag_object->node_key contain the dragged object
* node_key contain the target object
* Check drop node is folder
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP
               WITH KEY node_key = node_key.
    IF s_ZSPRO_AP-isfolder IS INITIAL.
      MESSAGE 'Target must be a folder'(m01) TYPE c_msg_succes.
      CALL METHOD drag_drop_object->abort.
      RETURN.
    ENDIF.

    PERFORM get_free_number USING node_key
                            CHANGING l_newkey l_sort.

    CLEAR s_ZSPRO_AP.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP
               WITH KEY node_key = lo_drag_object->node_key.

* Affect the new parent for the droped node
    s_ZSPRO_AP-relatkey = node_key.
    s_ZSPRO_AP-updated = abap_true.
    s_ZSPRO_AP-sort = l_sort.
    MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP INDEX sy-tabix.

    CALL METHOD o_tree->move_node
      EXPORTING
        node_key  = lo_drag_object->node_key
        relatkey  = node_key
        relatship = cl_gui_simple_tree=>relat_last_child.

* Rebuild sort position for the sibbling
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP
               WITH KEY node_key = lo_drag_object->node_key.
    PERFORM renum_nodes USING s_ZSPRO_AP-relatkey.

    w_data_changed = abap_true.

  ENDMETHOD.                    "handle_node_drag_drop

ENDCLASS.                    "lcl_application IMPLEMENTATION


*######################################################################*
*
*                             SCREEN SECTION
*
*######################################################################*

SELECTION-SCREEN BEGIN OF SCREEN 200.
SELECT-OPTIONS : s_tables FOR s_find-tabname,
                 s_progrm FOR s_find-programm.
PARAMETERS pdoublon AS CHECKBOX DEFAULT 'X'.
SELECTION-SCREEN END OF SCREEN 200.



*######################################################################*
*
*                             MAIN SECTION
*
*######################################################################*

START-OF-SELECTION.
* Creation of application object
* Allow to catch events
  CREATE OBJECT o_application.

* Call of the main screen
  SET SCREEN 100.

END-OF-SELECTION.


*######################################################################*
*
*                             PBO SECTION
*
*######################################################################*

*&---------------------------------------------------------------------*
*&      Module  STATUS_0100  OUTPUT
*&---------------------------------------------------------------------*
*       Define status for main screen
*----------------------------------------------------------------------*
MODULE status_0100 OUTPUT.
* In change mode, set status 100 with full access
  IF w_mode_change = abap_true.
    SET PF-STATUS 'STATUS_0100'.
* In display mode, set status 100 with restricted acces
  ELSE.
    SET PF-STATUS 'STATUS_0100' EXCLUDING t_excluded_nochange.
  ENDIF.
  SET TITLEBAR 'TITLE_0100'. "Repository of specific objects
ENDMODULE.                 " STATUS_0100  OUTPUT

*&---------------------------------------------------------------------*
*&      Module  INIT_0100  OUTPUT
*&---------------------------------------------------------------------*
*       Initialization of all objects
*----------------------------------------------------------------------*
MODULE init_0100 OUTPUT.
  IF w_first_time = space.
    w_first_time = abap_true.
    w_mode_change = space.

    PERFORM ctrl_active_x.
    PERFORM split_container.
    PERFORM init_tree.      "container menu
    CLEAR s_ZSPRO_AP.
    PERFORM init_html.

    PERFORM init_excluded.

  ENDIF.
ENDMODULE.                 " INIT_0100  OUTPUT

*######################################################################*
*
*                             PAI SECTION
*
*######################################################################*

*&---------------------------------------------------------------------*
*&      Module  USER_COMMAND_0100  INPUT
*&---------------------------------------------------------------------*
*       User command for main screen
*----------------------------------------------------------------------*
MODULE user_command_0100 INPUT.
* CL_GUI_CFW=>DISPATCH must be called if events are registered
* that trigger PAI
* this method calls the event handler method of an event
  IF okcode NE 'BACK'.
    CALL METHOD cl_gui_cfw=>dispatch.
*      IMPORTING
*        return_code = w_return_code.
*    IF w_return_code <> cl_gui_cfw=>rc_noevent.
*    A control event occured => exit PAI
*    CLEAR okcode.
*    exit.
*    ENDIF.
  ENDIF.

  w_okcode = okcode.
  CLEAR okcode.
  CASE w_okcode.
    WHEN 'BACK'.
      PERFORM fonction_back.

    WHEN 'FOLDER'.
      PERFORM create_folder.

    WHEN 'FILE'.
      PERFORM create_file.

    WHEN 'MASSFILE'.
      PERFORM create_mass.

    WHEN 'DELETE'.
      PERFORM delete_nodes.

    WHEN 'RENAME'.
      PERFORM rename_node.

    WHEN 'SAVE'.
      PERFORM save_tree.

    WHEN 'CREA'.
      PERFORM create_ot.

    WHEN 'UP'.
      PERFORM move USING -1.

    WHEN 'DOWN'.
      PERFORM move USING 1.

    WHEN 'FIND'.
      PERFORM find_entry.

    WHEN 'SUITE'.
      PERFORM find_entry_continue.

    WHEN  'WHEREUSED'.
      PERFORM where_used.

    WHEN 'SE16'.
      PERFORM start_se16.

    WHEN 'SE24'.
      PERFORM start_se24.

    WHEN 'SE11'.
      PERFORM start_se11 USING space.

    WHEN 'SE11T'.
      PERFORM start_se11 USING abap_true.

    WHEN 'SE38'.
      PERFORM start_se38.

    WHEN 'EDITHELP'.
      PERFORM edit_help.

    WHEN 'SWITCH'.
      PERFORM switch_disp_edit.

    WHEN 'TECH'.
      PERFORM switch_techname_tree.

    WHEN 'XML'.
      PERFORM export_xml.

    WHEN 'XMLI'.
      PERFORM import_xml.
  ENDCASE.

ENDMODULE.                 " USER_COMMAND_0100  INPUT

*######################################################################*
*
*                             FORM SECTION
*
*######################################################################*
*&---------------------------------------------------------------------*
*&      Form  CTRL_ACTIVE_X
*&---------------------------------------------------------------------*
*       Check that Active X objects are allowed
*----------------------------------------------------------------------*
FORM ctrl_active_x.
  DATA l_has_activex TYPE c.

  CALL FUNCTION 'GUI_HAS_ACTIVEX'
    IMPORTING
      return = l_has_activex.
  IF l_has_activex = space.
    MESSAGE 'Use a Windows GUI for this program'(m15) TYPE c_msg_error.
  ENDIF.
ENDFORM.                    " CTRL_ACTIVE_X

*&---------------------------------------------------------------------*
*&      Form  INIT_TREE
*&---------------------------------------------------------------------*
*       Initialization of tree object
*----------------------------------------------------------------------*
FORM init_tree.
  DATA: lt_events TYPE cntl_simple_events,
        ls_event  TYPE cntl_simple_event.

  IF o_tree IS INITIAL.

* Create a tree control
    CREATE OBJECT o_tree
      EXPORTING
        parent                      = o_container_left
        node_selection_mode         = cl_gui_simple_tree=>node_sel_mode_single
      EXCEPTIONS
        lifetime_error              = 1
        cntl_system_error           = 2
        create_error                = 3
        failed                      = 4
        illegal_node_selection_mode = 5.
    IF sy-subrc <> 0.
      MESSAGE 'Error calling a method of the tree control'(m14)
              TYPE c_msg_abort.
    ENDIF.

* Define the events which will be passed to the backend
* node double click
    ls_event-eventid = cl_gui_simple_tree=>eventid_node_double_click.
    ls_event-appl_event = abap_true. " process PAI if event occurs
    APPEND ls_event TO lt_events.

* node click
    ls_event-eventid = cl_gui_simple_tree=>eventid_selection_changed.
    ls_event-appl_event = abap_true. " process PAI if event occurs
    APPEND ls_event TO lt_events.

* node context menu request
    ls_event-eventid = cl_gui_simple_tree=>eventid_node_context_menu_req.
    ls_event-appl_event = space. " no PAI if event occurs
    APPEND ls_event TO lt_events.

* default context menu request
    ls_event-eventid = cl_gui_simple_tree=>eventid_def_context_menu_req.
    ls_event-appl_event = space. " no PAI if event occurs
    APPEND ls_event TO lt_events.

* process PAI if context menu select event occurs
    CALL METHOD o_tree->set_ctx_menu_select_event_appl
      EXPORTING
        appl_event = abap_true.

* Register events
    CALL METHOD o_tree->set_registered_events
      EXPORTING
        events                    = lt_events
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3.
    IF sy-subrc <> 0.
      MESSAGE 'Error calling a method of the tree control'(m14)
              TYPE c_msg_abort.
    ENDIF.

* Definition of drag drop behaviour
    CREATE OBJECT o_behaviour.
    CALL METHOD o_behaviour->add
      EXPORTING
        flavor         = 'Tree_move'                        "#EC NOTEXT
        dragsrc        = abap_true
        droptarget     = abap_true
        effect         = cl_dragdrop=>move
        effect_in_ctrl = cl_dragdrop=>move.
    CALL METHOD o_behaviour->get_handle
      IMPORTING
        handle = w_handle_tree.

* Create the application object
* This object is needed to handle the ABAP Objects Events of controls
    CREATE OBJECT o_application.

* Assign event handlers in the application class to each desired event
    SET HANDLER :
        o_application->handle_node_double_click FOR o_tree,
        o_application->handle_select FOR o_tree,
        o_application->drag FOR o_tree,
        o_application->drop FOR o_tree,
        o_application->handle_node_context_menu_req FOR o_tree,
        o_application->handle_def_context_menu_req FOR o_tree,
        o_application->handle_node_context_menu_sel FOR o_tree,
        o_application->handle_def_context_menu_sel FOR o_tree.

    PERFORM load_node USING abap_true.

  ENDIF.
ENDFORM.                    " INIT_TREE

*&---------------------------------------------------------------------*
*&      Form  LOAD_NODE
*&---------------------------------------------------------------------*
*       Load tree nodes from DB table ZSPRO_AP
*       or from internal table t_ZSPRO_AP
*----------------------------------------------------------------------*
*      -->FP_FROM_DB X to load data from DB table
*----------------------------------------------------------------------*
FORM load_node USING fp_from_db TYPE c.
* Add some nodes to the tree control
* NOTE: the tree control does not store data at the backend. If an
* application wants to access tree data later, it must store the
* tree data itself.
* Build the node table.
* Caution: The nodes are inserted into the tree according to the order
* in which they occur in the table. In consequence, a node must not
* occur in the node table before its parent node.
  DATA lt_node_table LIKE STANDARD TABLE OF s_node.

* Fill t_ZSPRO_AP from DB if required
  IF fp_from_db = abap_true.
    REFRESH : r_ZSPRO_AP_del,
              t_ZSPRO_AP.
    SELECT * FROM ZSPRO_AP INTO TABLE t_ZSPRO_AP.
  ENDIF.

* Check coherence data
  LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP.
*   Node key have not correct format : num2 for level, num4 for position
    IF NOT ( s_ZSPRO_AP-node_key(10) CO '0123456789').
      DELETE t_ZSPRO_AP.
    ENDIF.

*   No parent and relation number indicate child level
    IF s_ZSPRO_AP-relatkey IS INITIAL AND s_ZSPRO_AP-relatship <> 0.
      DELETE t_ZSPRO_AP.
    ENDIF.

    CHECK NOT s_ZSPRO_AP-relatkey IS INITIAL.

    READ TABLE t_ZSPRO_AP WITH KEY node_key = s_ZSPRO_AP-relatkey
                       TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
*   Parent not found
      DELETE t_ZSPRO_AP.
    ENDIF.
  ENDLOOP.

* Allow drag&drop
  LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP.
    s_ZSPRO_AP-dragdropid = w_handle_tree.
    MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP.
  ENDLOOP.

  INSERT LINES OF t_ZSPRO_AP INTO TABLE lt_node_table.
  SORT lt_node_table BY relatkey sort.
*refresh lt_node_table. "test shn TODO delete
  CALL METHOD o_tree->add_nodes
    EXPORTING
      table_structure_name           = c_tree_table
      node_table                     = lt_node_table
    EXCEPTIONS
      failed                         = 1
      error_in_node_table            = 2
      dp_error                       = 3
      table_structure_name_not_found = 4
      OTHERS                         = 5.
  IF sy-subrc <> 0.
    MESSAGE 'Error calling a method of the tree control'(m14)
            TYPE c_msg_abort.
  ENDIF.
ENDFORM.                    " LOAD_NODE

*&---------------------------------------------------------------------*
*&      Form  SPLIT_CONTAINER
*&---------------------------------------------------------------------*
*       Split the screen into 2 parts :
*  - Tree on the left
*  - Infos (html) on the right
*----------------------------------------------------------------------*
FORM split_container.
  IF o_container IS INITIAL.
* Create main container
    CREATE OBJECT o_container
      EXPORTING
        container_name = 'TREE_CONTAINER_0100'.

* Split the main container into 2 parts
    CREATE OBJECT o_splitter
      EXPORTING
        parent  = o_container
        rows    = 1
        columns = 2.

* Get container of the part 1
    CALL METHOD o_splitter->get_container
      EXPORTING
        row       = 1
        column    = 1
      RECEIVING
        container = o_container_left.

* Get container of the part 2
    CALL METHOD o_splitter->get_container
      EXPORTING
        row       = 1
        column    = 2
      RECEIVING
        container = o_container_right.
  ENDIF.
ENDFORM.                    " SPLIT_CONTAINER

*&---------------------------------------------------------------------*
*&      Form  CREATE_FOLDER
*&---------------------------------------------------------------------*
*       Create a folder
*----------------------------------------------------------------------*
FORM create_folder.
  DATA : l_subfolder   TYPE c,   " To do subfolder special operations
         l_new_key     LIKE w_node_key,
         l_rc          TYPE c,
         l_sort        TYPE i,
         lt_node_table LIKE STANDARD TABLE OF s_node.

* Get the parent node for the creating folder
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = w_node_key.

  IF w_node_key IS INITIAL.
    CLEAR l_subfolder.
  ELSE.
    l_subfolder = abap_true.
  ENDIF.

  IF l_subfolder = abap_true.
*   Check parent is a folder.
    CLEAR s_ZSPRO_AP.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.

    IF s_ZSPRO_AP-isfolder IS INITIAL.
      MESSAGE 'Please select a folder in the tree'(m30)
              TYPE c_msg_succes DISPLAY LIKE c_msg_error.
      RETURN.
    ENDIF.
  ENDIF.

  PERFORM get_free_number USING w_node_key
                          CHANGING l_new_key l_sort.
  CLEAR : s_ZSPRO_AP.

  s_ZSPRO_AP-node_key = l_new_key.
  IF l_subfolder = abap_true.
    s_ZSPRO_AP-relatkey = w_node_key.
    s_ZSPRO_AP-relatship = cl_gui_simple_tree=>relat_last_child.
  ENDIF.
  s_ZSPRO_AP-isfolder = abap_true.

* Prompt for folder name
  PERFORM popup_get_value USING    s_ZSPRO_AP-isfolder
                          CHANGING s_ZSPRO_AP-nodetype
                                   s_ZSPRO_AP-nodeparam
                                   s_ZSPRO_AP-text
                                   l_rc.
  IF l_rc NE space AND l_rc NE 0.
    RETURN.
  ENDIF.

  s_ZSPRO_AP-nodetype = c_nodetype_node.
  s_ZSPRO_AP-new_line = abap_true.
  s_ZSPRO_AP-sort = l_sort.
  s_ZSPRO_AP-dragdropid = w_handle_tree.

  INSERT s_ZSPRO_AP INTO TABLE t_ZSPRO_AP.
  s_node = s_ZSPRO_AP.
  INSERT s_node INTO TABLE lt_node_table.

  CALL METHOD o_tree->add_nodes
    EXPORTING
      table_structure_name           = c_tree_table
      node_table                     = lt_node_table
    EXCEPTIONS
      failed                         = 1
      error_in_node_table            = 2
      dp_error                       = 3
      table_structure_name_not_found = 4
      OTHERS                         = 5.

  IF l_subfolder = abap_true.
*   Expand parent of the new node
    CALL METHOD o_tree->expand_node
      EXPORTING
        node_key = w_node_key.
  ENDIF.

  w_data_changed = abap_true.

ENDFORM.                    " CREATE_FOLDER

*&---------------------------------------------------------------------*
*&      Form  get_free_number
*&---------------------------------------------------------------------*
*       Create node_key for a new node
*----------------------------------------------------------------------*
*      -->L_NODEKEY  Parent node
*      <--L_NEWKEY   New node key generated by the function
*      <--L_SORT     New sort position (first free)
*----------------------------------------------------------------------*
FORM get_free_number USING l_nodekey TYPE ZSPRO_AP-node_key
                     CHANGING l_newkey TYPE ZSPRO_AP-node_key
                              l_sort TYPE i.
  DATA : l_key(10) TYPE n,
         lt_ZSPRO_AP  LIKE TABLE OF s_ZSPRO_AP,
         ls_ZSPRO_AP  LIKE s_ZSPRO_AP,
         l_n       TYPE i.

* Search the greater nodekey number
  lt_ZSPRO_AP = t_ZSPRO_AP.
  SORT lt_ZSPRO_AP BY node_key.
  DESCRIBE TABLE lt_ZSPRO_AP LINES l_n.
  READ TABLE lt_ZSPRO_AP INTO ls_ZSPRO_AP INDEX l_n.
  l_key = ls_ZSPRO_AP-node_key.

* Add 1 to this nodekey number to have the new nodekey
  l_key = l_key + 1.
  l_newkey = l_key.

* Search the greater sort position for the childrens of the new node
* parent
  CLEAR l_sort.
  LOOP AT lt_ZSPRO_AP INTO ls_ZSPRO_AP WHERE relatkey = l_nodekey.
    IF ls_ZSPRO_AP-sort > l_sort.
      l_sort = ls_ZSPRO_AP-sort.
    ENDIF.
  ENDLOOP.
* Add 1 to this position to place the new node at the end of the list
  ADD 1 TO l_sort.

ENDFORM.                    " GET_FREE_NUMBER

*&---------------------------------------------------------------------*
*&      Form  delete_nodes
*&---------------------------------------------------------------------*
*       Delete a node
*----------------------------------------------------------------------*
FORM delete_nodes.
  DATA : l_nodekey TYPE ZSPRO_AP-node_key,
         lt_nodes  LIKE TABLE OF w_node_key,
         lt_peres  LIKE TABLE OF w_node_key WITH HEADER LINE.


* Get node to delete
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = l_nodekey.
  IF l_nodekey IS INITIAL.
    RETURN.
  ENDIF.

  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = l_nodekey.
  IF sy-subrc NE 0.
    RETURN.
  ENDIF.
  DELETE t_ZSPRO_AP INDEX sy-tabix.
  IF s_ZSPRO_AP-isfolder NE space.
    APPEND l_nodekey TO lt_peres.
  ENDIF.

* If the deleted node is already stored in DB, keep del info to
* physically delete the node when user will save the changes
  IF s_ZSPRO_AP-new_line IS INITIAL.
    s_ZSPRO_AP_del = 'IEQ'.
    s_ZSPRO_AP_del-low = s_ZSPRO_AP-node_key.
    APPEND s_ZSPRO_AP_del TO r_ZSPRO_AP_del.
  ENDIF.

* Do same operation for all childrens of the deleted node
  DO.
    LOOP AT lt_peres.
      LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP WHERE relatkey = lt_peres.
        IF s_ZSPRO_AP-isfolder NE space.
          APPEND s_ZSPRO_AP-node_key TO lt_nodes.
        ENDIF.
        IF s_ZSPRO_AP-new_line IS INITIAL.
          s_ZSPRO_AP_del = 'IEQ'.
          s_ZSPRO_AP_del-low = s_ZSPRO_AP-node_key.
          APPEND s_ZSPRO_AP_del TO r_ZSPRO_AP_del.
        ENDIF.
        DELETE t_ZSPRO_AP.
      ENDLOOP.
    ENDLOOP.
    IF lt_nodes[] IS INITIAL.
      EXIT.
    ELSE.
      lt_peres[] = lt_nodes[].
      REFRESH lt_nodes.
    ENDIF.
  ENDDO.

* Delete selected nodes in the displayed tree
  CALL METHOD o_tree->delete_node
    EXPORTING
      node_key = l_nodekey.
  w_data_changed = abap_true.

ENDFORM.                    "delete_nodes

*&---------------------------------------------------------------------*
*&      Form  CREATE_FILE
*&---------------------------------------------------------------------*
*       Add a node (table)
*----------------------------------------------------------------------*
FORM create_file.
  DATA : l_new_key     LIKE w_node_key,
         l_subfolder   TYPE c, " To do subfolder special operations
         l_rc,
         l_sort        TYPE i,
         lt_node_table LIKE STANDARD TABLE OF s_node,
         l_tabname     TYPE tabname.

* Get parent node
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = w_node_key.

  IF w_node_key IS INITIAL.
    CLEAR l_subfolder.
  ELSE.
    l_subfolder = abap_true.
  ENDIF.

  IF l_subfolder = abap_true.
*   Check parent is a folder.
    CLEAR s_ZSPRO_AP.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
    IF s_ZSPRO_AP-isfolder IS INITIAL.
      MESSAGE 'Please select a folder in the tree'(m30)
              TYPE c_msg_succes DISPLAY LIKE c_msg_error.
      RETURN.
    ENDIF.
  ENDIF.

  PERFORM get_free_number USING w_node_key
                          CHANGING l_new_key l_sort.
  CLEAR : s_ZSPRO_AP.

* Prompt for object name
  PERFORM popup_get_value USING    s_ZSPRO_AP-isfolder
                          CHANGING s_ZSPRO_AP-nodetype
                                   s_ZSPRO_AP-nodeparam
                                   s_ZSPRO_AP-text
                                   l_rc.
  IF l_rc NE space AND l_rc NE 0.
    RETURN.
  ENDIF.

  s_ZSPRO_AP-node_key = l_new_key.
  IF l_subfolder = abap_true.
    s_ZSPRO_AP-relatkey = w_node_key.
    s_ZSPRO_AP-relatship = cl_gui_simple_tree=>relat_last_child.
  ENDIF.

  s_ZSPRO_AP-new_line = abap_true.
  s_ZSPRO_AP-sort = l_sort.
  s_ZSPRO_AP-dragdropid = w_handle_tree.
  IF s_ZSPRO_AP-nodetype = c_nodetype_table.
    l_tabname = s_ZSPRO_AP-nodeparam.
*   Check if maintenance view exist
    SELECT SINGLE tabname
           INTO l_tabname
           FROM tvdir
           WHERE tabname = l_tabname.
    IF sy-subrc = 0.
      s_ZSPRO_AP-n_image = c_icon_table.
    ELSE.
      s_ZSPRO_AP-nomaint = abap_true.
      s_ZSPRO_AP-n_image = c_icon_table_nomaint.
    ENDIF.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_program.
    s_ZSPRO_AP-n_image = c_icon_prog.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_transac.
    s_ZSPRO_AP-n_image = c_icon_transac.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_url.
    PERFORM get_url_icon USING s_ZSPRO_AP-nodeparam
                         CHANGING s_ZSPRO_AP-n_image.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_img.
    s_ZSPRO_AP-n_image = c_icon_img.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_fm.
    s_ZSPRO_AP-n_image = c_icon_fm.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_cls.
    s_ZSPRO_AP-n_image = c_icon_cls.
  ELSE.
    s_ZSPRO_AP-n_image = c_icon_unknown.
  ENDIF.
  INSERT s_ZSPRO_AP INTO TABLE t_ZSPRO_AP.

* Add techname if relevant (not for url)
  IF w_techname = c_techname_on AND s_ZSPRO_AP-nodetype NE c_nodetype_url.
    IF NOT s_ZSPRO_AP-nodeparam IS INITIAL.
      CONCATENATE s_ZSPRO_AP-nodeparam '-' s_ZSPRO_AP-text INTO s_ZSPRO_AP-text
                  SEPARATED BY space.
    ENDIF.
  ENDIF.

  s_node = s_ZSPRO_AP.
  INSERT s_node INTO TABLE lt_node_table.

  CALL METHOD o_tree->add_nodes
    EXPORTING
      table_structure_name           = c_tree_table
      node_table                     = lt_node_table
    EXCEPTIONS
      failed                         = 1
      error_in_node_table            = 2
      dp_error                       = 3
      table_structure_name_not_found = 4
      OTHERS                         = 5.

  IF l_subfolder = abap_true.
*   Expand parent of the new node
    CALL METHOD o_tree->expand_node
      EXPORTING
        node_key = w_node_key.
  ENDIF.

  w_data_changed = abap_true.

ENDFORM.                    " CREATE_FILE

*&---------------------------------------------------------------------*
*&      Form  check_table
*&---------------------------------------------------------------------*
*       Check if table exist and get text if not filled
*----------------------------------------------------------------------*
*      -->FP_TABLE   Table to check
*      -->FP_TEXT    Label of the table : empty if table does not exist
*----------------------------------------------------------------------*
FORM check_table  USING    fp_table TYPE ZSPRO_AP-nodeparam
                  CHANGING fp_text  TYPE ZSPRO_AP-text.
  DATA : l_tabname        TYPE tabname,
         l_dd02l_tabclass TYPE dd02l-tabclass,
         ls_dd25d         TYPE dd25v.
  l_tabname = fp_table.
  SELECT SINGLE tabclass FROM dd02l INTO l_dd02l_tabclass
           WHERE tabname EQ l_tabname
           AND as4local EQ c_state_active
           AND as4vers EQ '0000'.
  IF sy-subrc EQ 0.
* Table exists
* If text is not given, find it in the db
    IF NOT fp_text IS INITIAL.
      RETURN.
    ENDIF.
    IF l_dd02l_tabclass EQ 'VIEW'.
      CALL FUNCTION 'DDIF_VIEW_GET'
        EXPORTING
          name          = l_tabname
          state         = c_state_active
          langu         = sy-langu
        IMPORTING
          dd25v_wa      = ls_dd25d
        EXCEPTIONS
          illegal_input = 1
          OTHERS        = 2.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ELSE.
        MOVE ls_dd25d-ddtext TO fp_text.
      ENDIF.
    ELSE.
      SELECT SINGLE ddtext FROM dd02t INTO fp_text
             WHERE tabname EQ l_tabname
             AND ddlanguage EQ sy-langu
             AND as4local EQ c_state_active
             AND as4vers EQ '0000'.
    ENDIF.

* Empty standard text => fill text with key
    IF fp_text IS INITIAL.
      fp_text = fp_table.
    ENDIF.
  ELSE.
* If table does not exists, clear text
    CLEAR fp_text.
  ENDIF.
ENDFORM.                    " check_table

*&---------------------------------------------------------------------*
*&      Form  check_prog
*&---------------------------------------------------------------------*
*       Check if program exist and get text if not filled
*----------------------------------------------------------------------*
*      -->FP_PROG  Program to check
*      -->FP_TEXT  Label of the program : empty if prog does not exist
*----------------------------------------------------------------------*
FORM check_prog   USING    fp_prog TYPE ZSPRO_AP-nodeparam
                  CHANGING fp_text TYPE ZSPRO_AP-text.
  DATA l_prog TYPE programm.
  l_prog = fp_prog.

  SELECT SINGLE name INTO l_prog
                FROM trdir
                WHERE name = l_prog.
  IF sy-subrc NE 0.
    CLEAR fp_text.
    RETURN.
  ENDIF.

  IF fp_text = space.
    SELECT SINGLE text INTO fp_text
                  FROM trdirt
                  WHERE name = l_prog
                  AND sprsl = sy-langu.
    IF sy-subrc NE 0.
      SELECT SINGLE text INTO fp_text
                    FROM trdirt
                    WHERE name = l_prog.                    "#EC WARNOK
    ENDIF.
  ENDIF.

* Empty standard text => fill text with key
  IF fp_text = space.
    fp_text = fp_prog.
  endif.
ENDFORM.                    " check_prog

*&---------------------------------------------------------------------*
*&      Form  check_cls
*&---------------------------------------------------------------------*
*       Check if class exists and get text if not filled
*----------------------------------------------------------------------*
*      -->FP_CLS   Class to check
*      -->FP_TEXT  Label of the class : empty if class does not exist
*----------------------------------------------------------------------*
FORM check_cls   USING    fp_cls TYPE ZSPRO_AP-nodeparam
                 CHANGING fp_text TYPE ZSPRO_AP-text.

  DATA l_cls TYPE seoclsname.
  l_cls = fp_cls.

  SELECT SINGLE clsname INTO l_cls
                FROM seoclass
                WHERE clsname = l_cls.
  IF sy-subrc NE 0.
    CLEAR fp_text.
    RETURN.
  ENDIF.

  IF fp_text = space.
    SELECT SINGLE descript INTO fp_text
                  FROM seoclasstx
                  WHERE clsname = l_cls
                  AND langu = sy-langu.
    IF sy-subrc NE 0.
      SELECT SINGLE descript INTO fp_text
                    FROM seoclasstx
                    WHERE clsname = l_cls.                  "#EC WARNOK
    ENDIF.
  ENDIF.

* Empty standard text => fill text with key
  IF fp_text = space.
    fp_text = fp_cls.
  endif.
ENDFORM.                    " check_cls

*&---------------------------------------------------------------------*
*&      Form  check_transac
*&---------------------------------------------------------------------*
*       Check if transaction exist and get text if not filled
*----------------------------------------------------------------------*
*      -->FP_TRANSAC Transaction to check
*      -->FP_TEXT    Label of the transaction : empty if dont exist
*----------------------------------------------------------------------*
FORM check_transac USING    fp_transac TYPE ZSPRO_AP-nodeparam
                   CHANGING fp_text TYPE ZSPRO_AP-text.
  DATA l_transac TYPE tstc-tcode.
  l_transac = fp_transac.

  SELECT SINGLE tcode INTO l_transac
                FROM tstc
                WHERE tcode = l_transac.
  IF sy-subrc NE 0.
    CLEAR fp_text.
    RETURN.
  ENDIF.

  IF fp_text = space.
    SELECT SINGLE ttext INTO fp_text
                  FROM tstct
                  WHERE tcode = l_transac
                  AND sprsl = sy-langu.
    IF sy-subrc NE 0.
      SELECT SINGLE ttext INTO fp_text
                    FROM tstct
                    WHERE tcode = l_transac.                "#EC WARNOK
    ENDIF.
  ENDIF.

* Empty standard text => fill text with key
    IF fp_text IS INITIAL.
      fp_text = fp_transac.
    ENDIF.
ENDFORM.                    " check_transac

*&---------------------------------------------------------------------*
*&      Form  check_img
*&---------------------------------------------------------------------*
*       Check if SAP IMG Activity exist and get text if not filled
*----------------------------------------------------------------------*
*      -->FP_IMG     IMG Activity
*      -->FP_TEXT    Label of the activity : empty if dont exist
*----------------------------------------------------------------------*
FORM check_img USING    fp_img TYPE ZSPRO_AP-nodeparam
               CHANGING fp_text TYPE ZSPRO_AP-text.
  DATA l_img TYPE cus_acth-act_id.
  l_img = fp_img.

  SELECT SINGLE act_id INTO l_img
                FROM cus_acth
                WHERE act_id = l_img.
  IF sy-subrc NE 0.
    CLEAR fp_text.
    RETURN.
  ENDIF.

  IF fp_text = space.
    SELECT SINGLE text INTO fp_text
                  FROM cus_actt
                  WHERE act_id = l_img
                  AND spras = sy-langu.
    IF sy-subrc NE 0.
      SELECT SINGLE text INTO fp_text
                    FROM cus_actt
                    WHERE act_id = l_img.                   "#EC WARNOK
    ENDIF.
  ENDIF.
ENDFORM.                    " check_img

*&---------------------------------------------------------------------*
*&      Form  check_fm
*&---------------------------------------------------------------------*
*       Check if function module exist and get text if not filled
*----------------------------------------------------------------------*
*      -->FP_FM     Function module
*      -->FP_TEXT   Label of the function : empty if dont exist
*----------------------------------------------------------------------*
FORM check_fm USING    fp_fm TYPE ZSPRO_AP-nodeparam
              CHANGING fp_text TYPE ZSPRO_AP-text.
  DATA l_fm TYPE tfdir-funcname.
  l_fm = fp_fm.

  SELECT SINGLE funcname INTO l_fm
         FROM tfdir
         WHERE funcname = l_fm.
  IF sy-subrc NE 0.
    CLEAR fp_text.
    RETURN.
  ENDIF.

  IF fp_text = space.
    SELECT SINGLE stext INTO fp_text
           FROM tftit
           WHERE funcname = l_fm
           AND spras = sy-langu.
    IF sy-subrc NE 0.
      SELECT SINGLE stext INTO fp_text
             FROM tftit
             WHERE funcname = l_fm.                         "#EC WARNOK
    ENDIF.
  ENDIF.

* Empty standard text => fill text with key
    IF fp_text IS INITIAL.
      fp_text = fp_fm.
    ENDIF.
ENDFORM.                    " check_fm

*&---------------------------------------------------------------------*
*&      Form  RENAME_NODE
*&---------------------------------------------------------------------*
*       Rename node
*----------------------------------------------------------------------*
FORM rename_node.
  DATA : l_tabix LIKE sy-tabix,
         l_rc    TYPE c.

* Get node to rename
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = w_node_key.
  IF w_node_key IS INITIAL.
    RETURN.
  ENDIF.

  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  l_tabix = sy-tabix.

* Prompt for table/programm/folder name
  PERFORM popup_get_value USING    s_ZSPRO_AP-isfolder
                          CHANGING s_ZSPRO_AP-nodetype
                                   s_ZSPRO_AP-nodeparam
                                   s_ZSPRO_AP-text
                                   l_rc.
  IF l_rc NE space AND l_rc NE 0.
    RETURN.
  ENDIF.

  IF s_ZSPRO_AP-nodetype = c_nodetype_url.
    PERFORM get_url_icon USING s_ZSPRO_AP-nodeparam
                         CHANGING s_ZSPRO_AP-n_image.
  ENDIF.

* Node to be updated in table ZSPRO_AP
  s_ZSPRO_AP-updated = abap_true.

  MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP INDEX l_tabix.

* Add techname if relevant (not for url
  IF w_techname = c_techname_on AND s_ZSPRO_AP-nodetype NE c_nodetype_url.
    IF NOT s_ZSPRO_AP-nodeparam IS INITIAL.
      CONCATENATE s_ZSPRO_AP-nodeparam '-' s_ZSPRO_AP-text INTO s_ZSPRO_AP-text
                  SEPARATED BY space.
    ENDIF.
  ENDIF.

* Modify the node text
  CALL METHOD o_tree->node_set_text
    EXPORTING
      node_key = w_node_key
      text     = s_ZSPRO_AP-text.

* Modify icon for url
  IF s_ZSPRO_AP-nodetype = c_nodetype_url.
    CALL METHOD o_tree->node_set_n_image
      EXPORTING
        node_key = w_node_key
        n_image  = s_ZSPRO_AP-n_image.
  ENDIF.

  w_data_changed = abap_true.
ENDFORM.                    " RENAME_NODE

*&---------------------------------------------------------------------*
*&      Form  SAVE_TREE
*&---------------------------------------------------------------------*
*       Save tree changes in the DB (ZSPRO_AP DB Table)
*----------------------------------------------------------------------*
FORM save_tree.
* Check that changes are done
  IF w_data_changed IS INITIAL.
    MESSAGE 'Saving not necessary. No changes were made'(m05)
            TYPE c_msg_succes.
  ELSE.
* Delete entries that has been deleted
    IF NOT r_ZSPRO_AP_del IS INITIAL.
      DELETE FROM ZSPRO_AP WHERE node_key IN r_ZSPRO_AP_del.
    ENDIF.
    REFRESH r_ZSPRO_AP_del.

* Add/change entries that has been changed/created
    LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP.
      CHECK s_ZSPRO_AP-new_line = abap_true OR s_ZSPRO_AP-updated = abap_true.
      IF s_ZSPRO_AP-new_line = abap_true.
        CLEAR : s_ZSPRO_AP-new_line, s_ZSPRO_AP-updated.
        MOVE-CORRESPONDING s_ZSPRO_AP TO s_ZSPRO_AP_upd.
        INSERT ZSPRO_AP FROM s_ZSPRO_AP_upd.
      ELSEIF s_ZSPRO_AP-updated = abap_true.
        CLEAR s_ZSPRO_AP-updated.
        MOVE-CORRESPONDING s_ZSPRO_AP TO s_ZSPRO_AP_upd.
        UPDATE ZSPRO_AP FROM s_ZSPRO_AP_upd.
      ENDIF.
      MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP TRANSPORTING new_line updated.
    ENDLOOP.
    CLEAR w_data_changed.
    MESSAGE 'Data saved successfully'(m06) TYPE c_msg_succes.
  ENDIF.
ENDFORM.                    " SAVE_TREE

*&---------------------------------------------------------------------*
*&      Form  FONCTION_BACK
*&---------------------------------------------------------------------*
*  Leave transaction
*  In change mode, ask to save before extif a modification is done
*----------------------------------------------------------------------*
FORM fonction_back.
  DATA : l_message(70) TYPE c,
         l_titel(50)   TYPE c, "Message text variable
         l_answer      TYPE c. "Popup to decide return code

* If data changed, ask to save before exit
  IF w_data_changed = abap_true.
    l_message = 'Do you wish to save your data first ?'(m18).
    l_titel = 'Exit from specific customizing'(m02).

    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        titlebar              = l_titel
        text_question         = l_message
        default_button        = '1'
        display_cancel_button = abap_true
      IMPORTING
        answer                = l_answer.

    IF l_answer = '1'.
      okcode = 'SAVE'.
    ELSEIF l_answer = '2'.
      CLEAR w_mode_change.
      CLEAR w_first_time.
      CALL FUNCTION 'VIEW_ENQUEUE'
        EXPORTING
          action       = c_action_dequeue
          enqueue_mode = c_enqueue_mode_exclusive
          view_name    = c_tree_table.
      LEAVE PROGRAM.
    ENDIF.

* If no data changed, exit directly
  ELSE.                  " Display mode or unchanged data
    IF w_mode_change = abap_true.
      CLEAR w_mode_change.
      CLEAR w_first_time.
      CALL FUNCTION 'VIEW_ENQUEUE'
        EXPORTING
          action       = c_action_dequeue
          enqueue_mode = c_enqueue_mode_exclusive
          view_name    = c_tree_table.
    ENDIF.
    LEAVE PROGRAM.
  ENDIF.
ENDFORM.                    " FONCTION_BACK

*&---------------------------------------------------------------------*
*&      Form  create_ot
*&---------------------------------------------------------------------*
*       Create transport request with all tree nodes
*----------------------------------------------------------------------*
FORM create_ot .
*  TYPE-POOLS trwbo.
*
*  DATA : lt_e071_empty TYPE TABLE OF e071,
*         lt_e071       TYPE TABLE OF ko200,
*         ls_e071       LIKE LINE OF lt_e071,
*         lt_e071k      TYPE e071k OCCURS 0 WITH HEADER LINE.
*  DATA l_ot TYPE trkorr.
** Ask for Transport request number
*  CALL FUNCTION 'TRINT_ORDER_CHOICE'
*    IMPORTING
*      we_order = l_ot
*    TABLES
*      wt_e071  = lt_e071_empty
*      wt_e071k = lt_e071k
*    EXCEPTIONS
*      OTHERS   = 6.
*  IF sy-subrc <> 0.
*    MESSAGE 'Action cancelled'(m22) TYPE c_msg_error.
*    RETURN.
*  ENDIF.
*
*  REFRESH lt_e071.
*  CLEAR ls_e071.
*  ls_e071-as4pos = 1.
*  ls_e071-pgmid = 'R3TR'.
*  ls_e071-object = 'TABU'.
*  ls_e071-obj_name = c_tree_table.
*  ls_e071-objfunc = 'K'.
*  APPEND ls_e071 TO lt_e071.
*
*  REFRESH lt_e071k.
*  CLEAR lt_e071k.
*  lt_e071k-pgmid = ls_e071-pgmid.
*  lt_e071k-object = ls_e071-object.
*  lt_e071k-objname = ls_e071-obj_name.
*  lt_e071k-mastertype = ls_e071-object.
*  lt_e071k-mastername = ls_e071-obj_name.
*  lt_e071k-as4pos = sy-tabix.
*  lt_e071k-tabkey = '*'.
*  APPEND lt_e071k.
*
*  CALL FUNCTION 'SMGF_TRANSPORT_ADD_OBJECTS'
*    TABLES
*      wt_e071    = lt_e071
*      wt_e071k   = lt_e071k
*    CHANGING
*      ta_request = l_ot.
*  MESSAGE 'Tree successfully included in transport request'(m09)
*          TYPE c_msg_succes.
  DATA : ls_object  TYPE rs_s_tr_object,
         lt_objects LIKE TABLE OF ls_object,
         lt_msg     TYPE rs_t_msg,
         ls_msg     LIKE LINE OF lt_msg.

  ls_object-object = 'TABU'.
  ls_object-obj_name = c_tree_table.
  APPEND ls_object TO lt_objects.

* Add table entries to request
  CALL FUNCTION 'RS_TR_WRITE_OBJECTS_TO_REQUEST'
    EXPORTING
      i_t_tr_object = lt_objects
    IMPORTING
      e_t_msg       = lt_msg.

* Display return message
  READ TABLE lt_msg INTO ls_msg INDEX 1.
  MESSAGE ID ls_msg-msgid TYPE ls_msg-msgty NUMBER ls_msg-msgno
          WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4.

ENDFORM.                    " create_ot

*&---------------------------------------------------------------------*
*&      Form  renum_nodes
*&---------------------------------------------------------------------*
*       Rebuild sort number of all childrens of given node
*       Used for drag folder in a drap/drop operation
*----------------------------------------------------------------------*
*      -->l_node_key : Folder which children must be reordered
*----------------------------------------------------------------------*
FORM renum_nodes USING l_nodekey TYPE ZSPRO_AP-node_key.
  DATA : lt_ZSPRO_AP LIKE TABLE OF s_ZSPRO_AP,
         ls_ZSPRO_AP LIKE LINE OF lt_ZSPRO_AP,
         l_count  TYPE i.

  lt_ZSPRO_AP = t_ZSPRO_AP.
  SORT lt_ZSPRO_AP BY relatkey sort.
  CLEAR l_count.
  LOOP AT lt_ZSPRO_AP INTO ls_ZSPRO_AP WHERE relatkey = l_nodekey.
    ADD 1 TO l_count.
    IF l_count NE ls_ZSPRO_AP-sort.
      ls_ZSPRO_AP-sort = l_count.
      ls_ZSPRO_AP-updated = abap_true.
      MODIFY lt_ZSPRO_AP FROM ls_ZSPRO_AP TRANSPORTING updated sort.
      w_data_changed = abap_true.
    ENDIF.
  ENDLOOP.
  SORT lt_ZSPRO_AP BY node_key.
  t_ZSPRO_AP = lt_ZSPRO_AP.
ENDFORM.                    " renum_nodes

*&---------------------------------------------------------------------*
*&      Form  move
*&---------------------------------------------------------------------*
*       Move a node in the same folder
*----------------------------------------------------------------------*
*      -->delta : To know if node go up or down
*----------------------------------------------------------------------*
FORM move USING delta TYPE i.
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = w_node_key.
  IF w_node_key IS INITIAL.
    RETURN.
  ENDIF.
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  s_ZSPRO_AP-sort = s_ZSPRO_AP-sort + delta.
  IF s_ZSPRO_AP-sort LT 1.
    RETURN.
  ENDIF.
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY relatkey = s_ZSPRO_AP-relatkey
                                           sort = s_ZSPRO_AP-sort.
* If destination node not found, try to renum all children of the parent
  IF sy-subrc NE 0.
    PERFORM renum_nodes USING s_ZSPRO_AP-relatkey.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
    s_ZSPRO_AP-sort = s_ZSPRO_AP-sort + delta.
    IF s_ZSPRO_AP-sort LT 1.
      RETURN.
    ENDIF.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY relatkey = s_ZSPRO_AP-relatkey
                                             sort = s_ZSPRO_AP-sort.
  ENDIF.
  IF sy-subrc NE 0.
    RETURN.
  ENDIF.
  s_ZSPRO_AP-sort = s_ZSPRO_AP-sort - delta.
  s_ZSPRO_AP-updated = abap_true.
  MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP INDEX sy-tabix
                 TRANSPORTING updated sort.

* Move the node regarding his sibbling
  IF delta = 1.
    CALL METHOD o_tree->move_node
      EXPORTING
        node_key  = w_node_key
        relatkey  = s_ZSPRO_AP-node_key
        relatship = cl_gui_simple_tree=>relat_next_sibling.
  ELSE.
    CALL METHOD o_tree->move_node
      EXPORTING
        node_key  = w_node_key
        relatkey  = s_ZSPRO_AP-node_key
        relatship = cl_gui_simple_tree=>relat_prev_sibling.
  ENDIF.

  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  s_ZSPRO_AP-sort = s_ZSPRO_AP-sort + delta.
  s_ZSPRO_AP-updated = abap_true.
  MODIFY t_ZSPRO_AP FROM s_ZSPRO_AP INDEX sy-tabix
                 TRANSPORTING updated sort.
  w_data_changed = abap_true.

* If a node move, reset find structure
  CLEAR s_find.
ENDFORM.                    " move

*&---------------------------------------------------------------------*
*&      Form  init_html
*&---------------------------------------------------------------------*
*       Initialization of html object
*----------------------------------------------------------------------*
FORM init_html.
  DATA : l_program TYPE ZSPRO_AP-nodeparam,
         lt_events TYPE cntl_simple_events,
         ls_event  TYPE cntl_simple_event.

* Create html object
  IF o_html_control IS INITIAL.
    CREATE OBJECT o_html_control
      EXPORTING
        parent = o_container_right.

    ls_event-eventid = o_html_control->m_id_sapevent.
    ls_event-appl_event = 'x'.
    APPEND ls_event TO lt_events.
    CALL METHOD o_html_control->set_registered_events
      EXPORTING
        events = lt_events.

    SET HANDLER o_application->handle_link_clic_html FOR o_html_control.
  ENDIF.

  CASE s_ZSPRO_AP-nodetype.
* For table, display table informations
    WHEN c_nodetype_table.
      PERFORM write_html_table USING s_ZSPRO_AP-nodeparam.
* For program, display program informations
    WHEN c_nodetype_program.
      PERFORM write_html_prog USING s_ZSPRO_AP-nodeparam.
* For transaction, display program informations
    WHEN c_nodetype_transac.
      SELECT SINGLE pgmna INTO l_program
             FROM tstc
             WHERE tcode = s_ZSPRO_AP-nodeparam.
      IF sy-subrc = 0 AND l_program NE space.
        PERFORM write_html_prog USING l_program.
      ENDIF.
* For SAP IMG activity, display associated help
    WHEN c_nodetype_img.
      PERFORM write_html_obj USING s_ZSPRO_AP-nodeparam c_doctype_img.
* For Function module, display documentation
    WHEN c_nodetype_fm.
      "PERFORM write_html_fm USING s_ZSPRO_AP-nodeparam.
      PERFORM write_html_obj USING s_ZSPRO_AP-nodeparam c_doctype_fm.
    WHEN c_nodetype_cls.
      PERFORM write_html_obj USING s_ZSPRO_AP-nodeparam c_doctype_cls.
*    WHEN c_nodetype_url.
* No specific right part for link, display default
    WHEN OTHERS.
      PERFORM write_html_default.
  ENDCASE.

ENDFORM.                    " init_html

*&---------------------------------------------------------------------*
*&      Form  write_html_default
*&---------------------------------------------------------------------*
*       Display default background for right part of the screen
*----------------------------------------------------------------------*
FORM write_html_default.
  DATA : lw_url(2048) TYPE c,
         lt_pic_data  LIKE w3mime OCCURS 0,
         lw_pic_size  TYPE i,
         lw_pic       TYPE string.

  DATA : ls_data_pic TYPE htmlline,
         lt_data_pic TYPE  htmltable.

  DEFINE htmlp.
    ls_data_pic = &1.
    append ls_data_pic to lt_data_pic.
  END-OF-DEFINITION.

  IF o_pic IS INITIAL.
    CREATE OBJECT o_pic EXPORTING parent = o_container_right.
    CALL METHOD o_pic->set_display_mode
      EXPORTING
        display_mode = cl_gui_picture=>display_mode_fit_center.
    IF c_welcome_bg IS INITIAL.
      lw_pic = 'HTMLCNTL_TESTHTM2_SAP_AG'.
    ELSE.
      lw_pic = c_welcome_bg.
    ENDIF.
    PERFORM load_pic_from_db
            TABLES lt_pic_data
            USING lw_pic
            CHANGING lw_pic_size.

* Request an URL from the data provider by exporting the pic_data.
    CLEAR lw_url.
    CALL FUNCTION 'DP_CREATE_URL'
      EXPORTING
        type     = 'image'
        subtype  = cndp_sap_tab_unknown
        size     = lw_pic_size
        lifetime = cndp_lifetime_transaction
      TABLES
        data     = lt_pic_data
      CHANGING
        url      = lw_url
      EXCEPTIONS
        OTHERS   = 1.

    CALL METHOD o_pic->load_picture_from_url
      EXPORTING
        url = lw_url.
  ENDIF.
  o_html_control->set_visible( abap_false ).
  o_pic->set_visible( abap_true ).

ENDFORM.

*---------------------------------------------------------------------*
*       FORM load_pic_from_db                                         *
*---------------------------------------------------------------------*
*       Load given picture from Web Repository                        *
*---------------------------------------------------------------------*
FORM load_pic_from_db
     TABLES ft_pic_data
     USING fw_pic_name
     CHANGING fw_pic_size.
  DATA : lt_query_table    LIKE w3query OCCURS 1 WITH HEADER LINE,
         lt_html_table     LIKE w3html OCCURS 1,
         lw_return_code    LIKE  w3param-ret_code,
         lw_content_type   LIKE  w3param-cont_type,
         lw_content_length LIKE  w3param-cont_len.

  CLEAR lt_query_table.
  lt_query_table-name = '_OBJECT_ID'.
  lt_query_table-value = fw_pic_name.
  APPEND lt_query_table.

  CALL FUNCTION 'WWW_GET_MIME_OBJECT'
    TABLES
      query_string        = lt_query_table
      html                = lt_html_table
      mime                = ft_pic_data
    CHANGING
      return_code         = lw_return_code
      content_type        = lw_content_type
      content_length      = lw_content_length
    EXCEPTIONS
      invalid_table       = 1
      parameter_not_found = 2
      OTHERS              = 3.
  IF sy-subrc = 0.
    fw_pic_size = lw_content_length.
  ENDIF.
ENDFORM.

*&---------------------------------------------------------------------*
*&      Form  write_html_table
*&---------------------------------------------------------------------*
*       Display table info in HTML format
*----------------------------------------------------------------------*
*      -->FP_TABLE   table name
*----------------------------------------------------------------------*
FORM write_html_table USING fp_table TYPE ZSPRO_AP-nodeparam.
  DATA : ls_data_table  TYPE htmlline,
         lt_data_table  TYPE  htmltable,
         l_url(2048),
         lt_sel         LIKE TABLE OF vimsellist WITH HEADER LINE,
         lt_head        LIKE TABLE OF vimdesc WITH HEADER LINE,
         lt_tab         LIKE TABLE OF vimnamtab WITH HEADER LINE,
         l_object       TYPE  doku_obj,
         lt_lines       LIKE TABLE OF tline WITH HEADER LINE,
         l_docu_to_html TYPE REF TO cl_epss_docu_to_html,
         l_n            TYPE i,
         l_mandant(1)   TYPE c,
         lt_nametab     TYPE TABLE OF dntab WITH HEADER LINE,
         l_table        TYPE tabname,
         l_tabletxt     TYPE dd08v-tabname.

  DEFINE htmlt.
    ls_data_table = &1.
    append ls_data_table to lt_data_table.
  END-OF-DEFINITION.

  l_table = fp_table.

  CALL FUNCTION 'VIEW_GET_DDIC_INFO'
    EXPORTING
      viewname        = l_table
    TABLES
      sellist         = lt_sel
      x_header        = lt_head
      x_namtab        = lt_tab
    EXCEPTIONS
      no_tvdir_entry  = 1
      table_not_found = 2
      OTHERS          = 3.
  CASE sy-subrc.
    WHEN 1.
*  l_nomaint = abap_true.
    WHEN 0.
*  l_nomaint = space.
    WHEN OTHERS.
      RETURN.
  ENDCASE.

  l_object = fp_table.

  SELECT SINGLE object INTO l_object
         FROM  dokil
         WHERE id         = c_doctype_table
         AND   object     = l_object
         AND   langu      = sy-langu
         AND   typ        = c_doktyp_enduser.
  IF sy-subrc EQ 0.
    CALL FUNCTION 'DOCU_GET'
      EXPORTING
        id     = c_doctype_table
        object = l_object
        langu  = sy-langu
      TABLES
        line   = lt_lines
      EXCEPTIONS
        OTHERS = 2.
    IF sy-subrc NE 0.
      CLEAR lt_lines.
    ENDIF.
  ELSE.
    SELECT SINGLE object INTO l_object
           FROM  dokil
           WHERE id         = c_doctype_table
           AND   object     = l_object
           AND   langu      = c_langu_default
           AND   typ        = c_doktyp_enduser.

    IF sy-subrc EQ 0.
      CALL FUNCTION 'DOCU_GET'
        EXPORTING
          id     = c_doctype_table
          object = l_object
          langu  = c_langu_default
        TABLES
          line   = lt_lines
        EXCEPTIONS
          OTHERS = 2.
      IF sy-subrc NE 0.
        CLEAR lt_lines.
      ENDIF.
    ENDIF.
  ENDIF.

* If no maint view title found, search table title
  IF lt_head-ddtext IS INITIAL.
    SELECT SINGLE ddtext INTO lt_head-ddtext
           FROM dd02t
           WHERE tabname = l_table
           AND as4local = c_state_active
           AND ddlanguage = sy-langu
           AND as4vers = space. "not used field
    IF sy-subrc NE 0.
      SELECT SINGLE ddtext INTO lt_head-ddtext
             FROM dd02t
             WHERE tabname = l_table
             AND as4local = c_state_active
             AND ddlanguage = c_langu_default
             AND as4vers = space. "not used field
    ENDIF.
  ENDIF.

* Write Header tags
  REFRESH lt_data_table.
  htmlt '<html>'.
  htmlt '<title>Table info</title>'.
  htmlt '<body bgcolor=#EEF4FB>'.
  htmlt '<table width=100%><tr>'.
  htmlt '<td align="center" colspan=2><strong>'.
  htmlt fp_table.
  htmlt '-'.
  htmlt lt_head-ddtext.
  htmlt '</strong><br>&nbsp;'.
  htmlt '</td></tr>'.

* If doc found, display it in html
  IF NOT lt_lines[] IS INITIAL.
* Create doc html converter
    CREATE OBJECT l_docu_to_html.
    CONCATENATE 'DS:' c_doctype_table '.' l_object
                INTO l_docu_to_html->doc_link.
* Load doc into converter
    l_docu_to_html->itflines = lt_lines[].
* Convert doc into html
    CALL METHOD l_docu_to_html->convert_itf_to_html.
    CALL METHOD l_docu_to_html->add_sapicons_to_html.

* Delete end tags </body> and </html>
    DESCRIBE TABLE l_docu_to_html->htmllines LINES l_n.
    DELETE l_docu_to_html->htmllines INDEX l_n.
    l_n = l_n - 1.
    DELETE l_docu_to_html->htmllines INDEX l_n.

* Delete all header until <body>
    LOOP AT l_docu_to_html->htmllines INTO ls_data_table.
      TRANSLATE ls_data_table TO UPPER CASE.
      CONDENSE ls_data_table NO-GAPS.
      DELETE l_docu_to_html->htmllines.
      IF ls_data_table(5) NE '<BODY'.
        CONTINUE.
      ELSE.
        EXIT.
      ENDIF.
    ENDLOOP.

* Write doc
    htmlt '<tr><td colspan=2>'.
    APPEND LINES OF l_docu_to_html->htmllines TO lt_data_table.
    htmlt '<hr color=black><br>'.
    htmlt '</td></tr>'.
  ENDIF.

  CLEAR l_mandant.
* Display maintenance view fields
  LOOP AT lt_tab.
    IF lt_tab-domname = 'MANDT' AND sy-tabix = 1.
      l_mandant = abap_true.
    ELSE.
      htmlt '<tr><td>'.
      htmlt lt_tab-viewfield.
      htmlt '</td><td>'.
      htmlt lt_tab-scrtext.
      htmlt '</td></tr>'.
    ENDIF.
  ENDLOOP.
  IF sy-subrc NE 0.
* If no maintenance view exists, inform user and get table fields
    htmlt '<tr><td colspan=2 align=center><strong>'.
    htmlt 'NO MAINTENANCE VIEW FOR THIS TABLE'(004).
    htmlt '</strong></td></tr>'.

    CALL FUNCTION 'NAMETAB_GET'
      EXPORTING
        langu               = sy-langu
        tabname             = l_table
      TABLES
        nametab             = lt_nametab
      EXCEPTIONS
        internal_error      = 1
        table_has_no_fields = 2
        table_not_activ     = 3
        no_texts_found      = 4
        OTHERS              = 5.
    IF sy-subrc EQ 0.
      htmlt '<tr><td colspan=2><br><hr color=black><br></td></tr>'.
      LOOP AT lt_nametab.
        IF lt_nametab-fieldname = 'MANDT' AND sy-tabix = 1.
          l_mandant = abap_true.
        ELSE.
          htmlt '<tr><td>'.
          htmlt lt_nametab-fieldname.
          htmlt '</td><td>'.
          htmlt lt_nametab-fieldtext.
          htmlt '</td></tr>'.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDIF.

* Add mandant dependance
  htmlt '<tr><td colspan=2><br>'.
  htmlt 'Data depend on mandant :'(001).
  htmlt '<strong>'.
  IF l_mandant IS INITIAL.
    htmlt 'No'(003).
  ELSE.
    htmlt 'Yes'(002).
  ENDIF.
  htmlt '</strong></td></tr>'.

* Add text table info
  CALL FUNCTION 'DDUT_TEXTTABLE_GET'
    EXPORTING
      tabname   = l_table
    IMPORTING
      texttable = l_tabletxt.
  IF l_tabletxt IS INITIAL.
    l_tabletxt = '-'.
  ENDIF.
  htmlt '<tr><td colspan=2><br>'.
  htmlt 'Associated text table :'(005).
  htmlt '<strong>'.
  htmlt l_tabletxt.
  htmlt '</strong></td></tr>'.

* Write end tags
  htmlt '</table>'.
  htmlt '</body></html>'.

* Generate url from html data
  CALL METHOD o_html_control->load_data
    IMPORTING
      assigned_url = l_url
    CHANGING
      data_table   = lt_data_table.

* Display page
  CALL METHOD o_html_control->show_url
    EXPORTING
      url = l_url.
  o_pic->set_visible( abap_false ).
  o_html_control->set_visible( abap_true ).

ENDFORM.                    "write_html_table

*&---------------------------------------------------------------------*
*&      Form  write_html_prog
*&---------------------------------------------------------------------*
*       Display program info in HTML format
*----------------------------------------------------------------------*
*      -->FP_PROG    Program name
*----------------------------------------------------------------------*
FORM write_html_prog USING fp_prog TYPE ZSPRO_AP-nodeparam.
  DATA : l_object           TYPE doku_obj,
         ls_data_table      TYPE htmlline,
         lt_data_table      LIKE TABLE OF ls_data_table,
         lt_lines           LIKE TABLE OF tline WITH HEADER LINE,
         l_docu_to_html     TYPE REF TO cl_epss_docu_to_html,
         l_n                TYPE i,
         l_url(2048),
         l_report           TYPE string,
         l_report_char1(1)  TYPE c,
         lt_report          LIKE TABLE OF l_report,
         l_comment_found(1) TYPE c,
         l_prog             TYPE programm,
         l_style(1)         TYPE c,
         l_open(1)          TYPE c.

  DEFINE htmlp.
    ls_data_table = &1.
    append ls_data_table to lt_data_table.
  END-OF-DEFINITION.

  l_object = fp_prog.
* Get doc language
  SELECT SINGLE object INTO l_object
         FROM  dokil
         WHERE id         = c_doctype_prog
         AND   object     = l_object
         AND   langu      = sy-langu
         AND   typ        = c_doktyp_enduser.
  IF sy-subrc EQ 0.
    CALL FUNCTION 'DOCU_GET'
      EXPORTING
        id     = c_doctype_prog
        object = l_object
        langu  = sy-langu
      TABLES
        line   = lt_lines
      EXCEPTIONS
        OTHERS = 2.
    IF sy-subrc NE 0.
      CLEAR lt_lines.
    ENDIF.
  ELSE.
    SELECT SINGLE object INTO l_object
           FROM  dokil
           WHERE id         = c_doctype_prog
           AND   object     = l_object
           AND   langu      = c_langu_default
           AND   typ        = c_doktyp_enduser.

    IF sy-subrc EQ 0.
      CALL FUNCTION 'DOCU_GET'
        EXPORTING
          id     = c_doctype_prog
          object = l_object
          langu  = c_langu_default
        TABLES
          line   = lt_lines
        EXCEPTIONS
          OTHERS = 2.
      IF sy-subrc NE 0.
        CLEAR lt_lines.
      ENDIF.
    ENDIF.
  ENDIF.

* Write Header tags
  REFRESH lt_data_table.
  htmlp '<html>'.
  htmlp '<title>Program info</title>'.
  htmlp '<style type="text/css">'.
  htmlp 'p{margin:0;}'.
  htmlp '.spacer{margin-top:10px;}'.
  htmlp '.code{font-family:courier;}'.
  htmlp '</style>'.
  htmlp '<body bgcolor=#EEF4FB>'.

* If doc found, display it in html
  IF NOT lt_lines[] IS INITIAL.
* Create doc html converter
    CREATE OBJECT l_docu_to_html.
    CONCATENATE 'DS:' c_doctype_prog '.' l_object
                INTO l_docu_to_html->doc_link.
* Load doc into converter
    l_docu_to_html->itflines = lt_lines[].
* Convert doc into html
    CALL METHOD l_docu_to_html->convert_itf_to_html.
    CALL METHOD l_docu_to_html->add_sapicons_to_html.

* Delete end tags </body> and </html>
    DESCRIBE TABLE l_docu_to_html->htmllines LINES l_n.
    DELETE l_docu_to_html->htmllines INDEX l_n.
    l_n = l_n - 1.
    DELETE l_docu_to_html->htmllines INDEX l_n.

* Delete all header until <body>
    LOOP AT l_docu_to_html->htmllines INTO ls_data_table.
      TRANSLATE ls_data_table TO UPPER CASE.
      CONDENSE ls_data_table NO-GAPS.
      DELETE l_docu_to_html->htmllines.
      IF ls_data_table(5) NE '<BODY'.
        CONTINUE.
      ELSE.
        EXIT.
      ENDIF.
    ENDLOOP.

* Write doc
    APPEND LINES OF l_docu_to_html->htmllines TO lt_data_table.
  ELSE.
* if no help is found, display the header of the program
    l_prog = fp_prog.
    READ REPORT l_prog INTO lt_report.
    CLEAR l_comment_found.
    CLEAR l_open.
    LOOP AT lt_report INTO l_report.
      l_report_char1 = l_report.
      IF l_report_char1 NE '*'.
        IF l_comment_found = abap_true.
          EXIT.
        ELSE.
          CONTINUE.
        ENDIF.
      ELSE.
        l_comment_found = abap_true.
        l_report = l_report+1.
        CLEAR l_style.
        IF NOT l_report IS INITIAL AND l_report(1) CA '&=23E'.
          l_style = l_report(1).
          l_report = l_report+1.
        ENDIF.

* Try top remove &* at end of line
        if not l_report is initial.
          l_n = strlen( l_report ) - 1.
          if l_report+l_n(1) = '*'.
            l_report = l_report(l_n).
            l_n = l_n - 1.
            if l_n gt 0 and l_report+l_n(1) = '&'.
              l_report = l_report(l_n).
            endif.
          endif.
        endif.
        IF l_report IS INITIAL or l_report co '*& '.
          IF l_open = abap_true.
            htmlp '</p>'.
            CLEAR l_open.
          ENDIF.
          htmlp '<p class="spacer"> </p>'.
        ELSEIF l_report CO '*&-' AND l_report CA '-'.
          IF l_open = abap_true.
            htmlp '</p>'.
            CLEAR l_open.
          ENDIF.
          htmlp '<hr>'.
        ELSEIF NOT l_style IS INITIAL.
          CASE l_style.
            WHEN '3'.
              IF l_open = abap_true.
                htmlp '</p>'.
                CLEAR l_open.
              ENDIF.
              CONCATENATE '<h3>' l_report '</h3>' INTO l_report.
              htmlp l_report.
            WHEN '2'.
              IF l_open = abap_true.
                htmlp '</p>'.
                CLEAR l_open.
              ENDIF.
              CONCATENATE '<h2>' l_report '</h2>' INTO l_report.
              htmlp l_report.
            WHEN '='.
              htmlp l_report.
            WHEN 'E'.
              IF l_open = abap_true.
                htmlp '</p>'.
                CLEAR l_open.
              ENDIF.
              htmlp '<p class="code">'.
              htmlp l_report.
              l_open = abap_true.
            WHEN OTHERS.
              IF l_open = abap_true.
                htmlp '</p>'.
                CLEAR l_open.
              ENDIF.
              htmlp '<p>'.
              htmlp l_report.
              l_open = abap_true.
          ENDCASE.
        ELSE.
          IF l_open = abap_true.
            htmlp '</p>'.
            CLEAR l_open.
          ENDIF.
          htmlp '<p>'.
          htmlp l_report.
          l_open = abap_true.
        ENDIF.
      ENDIF.
    ENDLOOP.
    IF sy-subrc NE 0 OR NOT l_comment_found = abap_true.
      htmlp '<p align="center">No Help for this program</p>'.
    ENDIF.
    IF l_open = abap_true.
      htmlp '</p>'.
      CLEAR l_open.
    ENDIF.
  ENDIF.

* Write end tags
  htmlp '</body></html>'.

  CALL METHOD o_html_control->load_data
    IMPORTING
      assigned_url = l_url
    CHANGING
      data_table   = lt_data_table.

  CALL METHOD o_html_control->show_url
    EXPORTING
      url = l_url.

  o_pic->set_visible( abap_false ).
  o_html_control->set_visible( abap_true ).
ENDFORM.                    " write_html_prog

*&---------------------------------------------------------------------*
*&      Form  write_html_obj
*&---------------------------------------------------------------------*
*       Display Object info in HTML format
*----------------------------------------------------------------------*
*      -->FP_OBJ     Object name
*      -->FP_OBJTYPE Object type
*----------------------------------------------------------------------*
FORM write_html_obj USING fp_obj TYPE ZSPRO_AP-nodeparam
                          fp_objtype TYPE doku_id.

  DATA : l_object       TYPE doku_obj,
         ls_data_table  TYPE htmlline,
         lt_data_table  LIKE TABLE OF ls_data_table,
         lt_lines       LIKE TABLE OF tline WITH HEADER LINE,
         lt_lines2      LIKE TABLE OF tline,
         l_docu_to_html TYPE REF TO cl_epss_docu_to_html,
         l_url(2048),
         l_title        TYPE dsyst-doktitle,
         l_doctype      TYPE dokil-typ,
         l_langu        TYPE sy-langu,
         lt_styles      TYPE tlinetab,
         l_stylename    TYPE doku_obj.
  DATA : BEGIN OF ls_clsmeth,
           clsname  TYPE seocompo-clsname,
           cmpname  TYPE seocompo-cmpname,
           descript TYPE seocompotx-descript,
         END OF ls_clsmeth,
         lt_clsmeth LIKE TABLE OF ls_clsmeth.

  DEFINE htmlo.
    ls_data_table = &1.
    append ls_data_table to lt_data_table.
  END-OF-DEFINITION.

  IF fp_objtype = c_doctype_img.
* Search Documentation
    SELECT SINGLE docu_id INTO l_object
           FROM cus_imgach
           WHERE activity = fp_obj.
    IF sy-subrc NE 0.
* If no specific documentation, try to display object documentation
      CONCATENATE 'SIMG' fp_obj INTO l_object.
    ENDIF.
  ELSE.
    l_object = fp_obj.
  ENDIF.

* Get doc
  DO 4 TIMES.
* Search in first enduser doc in connexion language
    IF sy-index = 1.
      l_langu = sy-langu.
      l_doctype = c_doktyp_enduser.
* If not found, search enduser doc in english
    ELSEIF sy-index = 2.
      l_langu = c_langu_default.
      l_doctype = c_doktyp_enduser.
* If not found, search technical doc in connexion language
    ELSEIF sy-index = 3.
      l_langu = c_langu_default.
      l_doctype = c_doktyp_technical.
* If not found, search technical doc in english
    ELSEIF sy-index = 4.
      l_langu = sy-langu.
      l_doctype = c_doktyp_technical.
    ELSE.
      EXIT. " exit do
    ENDIF.

    SELECT SINGLE object INTO l_object
           FROM  dokil
           WHERE id         = fp_objtype
           AND   object     = l_object
           AND   langu      = l_langu
           AND   typ        = l_doctype.
    IF sy-subrc EQ 0.
      CLEAR l_title.
      CALL FUNCTION 'DOCU_GET'
        EXPORTING
          id       = fp_objtype
          object   = l_object
          langu    = l_langu
          typ      = l_doctype
        IMPORTING
          doktitle = l_title
        TABLES
          line     = lt_lines
        EXCEPTIONS
          OTHERS   = 2.
      IF sy-subrc NE 0.
        CLEAR lt_lines.
      ELSE.
* Add appendix
        CALL FUNCTION 'DOCU_GET_APPENDIX'
          EXPORTING
            langu  = l_langu
            id     = fp_objtype
            object = l_object
          TABLES
            docu   = lt_lines2.
        APPEND LINES OF lt_lines2 TO lt_lines.
      ENDIF.
      EXIT. "exit do
    ENDIF.
  ENDDO.

* Write Header tags
  REFRESH lt_data_table.
  htmlo '<html><head>'.
  htmlo '<title>Object'.
  htmlo l_object.
  htmlo 'info</title>'.

* Add sap style
* check for customer style, since modifications or other
* includes/commands we will not be supported here
* this style should exist only in English, since before SAP one existed
* only in German (DE)
  SELECT SINGLE object FROM dokil INTO l_stylename
    WHERE id = 'TX'
      AND object = 'Z_EPSS_STYLES'
      AND langu = 'E'
      AND typ = c_doktyp_enduser.
  IF sy-subrc = 0.
* Get EPSS styles from SE61 store
    CALL FUNCTION 'DOCU_GET'
      EXPORTING
        id     = 'TX'
        langu  = 'E'
        object = l_stylename
      TABLES
        line   = lt_styles
      EXCEPTIONS
        OTHERS = 1.
  ENDIF.
  IF sy-subrc <> 0 OR lt_styles[] IS INITIAL.
* customer styles is not found, check for SAP one
    l_stylename = 'EPSS_STYLES'.
* Get EPSS styles from SE61 store
    CALL FUNCTION 'DOCU_GET'
      EXPORTING
        id     = 'TX'
        langu  = 'D'
        object = l_stylename
      TABLES
        line   = lt_styles
      EXCEPTIONS
        OTHERS = 0.
    IF lt_styles[] IS INITIAL.
* second language
      CALL FUNCTION 'DOCU_GET'
        EXPORTING
          id     = 'TX'
          langu  = 'E'
          object = l_stylename
        TABLES
          line   = lt_styles
        EXCEPTIONS
          OTHERS = 0.
    ENDIF.
  ENDIF.
* Insert styles into HTML lines
  IF lt_styles[] IS NOT INITIAL.
    APPEND LINES OF lt_styles TO lt_data_table.
  ENDIF.

  htmlo '</head><body bgcolor=#EEF4FB>'.

* For class, search Method list
  IF fp_objtype = c_doctype_cls.
    SELECT t1~clsname t1~cmpname t2~descript
           INTO TABLE lt_clsmeth
           FROM seocompo AS t1
           LEFT JOIN seocompotx AS t2

           ON t1~clsname = t2~clsname
           AND t1~cmpname = t2~cmpname
           AND t2~langu = c_langu_default
           WHERE ( t1~clsname = fp_obj
           OR t1~clsname IN ( SELECT refclsname
                              FROM vseoimplem
                              WHERE clsname = fp_obj )
                  )
           AND t1~cmptype = '1'. "method

    IF sy-subrc = 0.
      CLEAR lt_lines.
      lt_lines-tdformat = 'U1'.
      lt_lines-tdline = 'Methods'.
      APPEND lt_lines.

      LOOP AT lt_clsmeth INTO ls_clsmeth.
        CLEAR lt_lines.
        lt_lines-tdformat = 'AS'.

* For each method, search if a doc exist.
* If found, add a link to the method documentaiton
        CLEAR l_object.
        l_object(30) = ls_clsmeth-clsname.
        l_object+30 = ls_clsmeth-cmpname.
        SELECT SINGLE object INTO l_object
               FROM dokil
               WHERE id = c_doctype_meth
               AND object = l_object.
        IF sy-subrc = 0.
          CONCATENATE '<DS:CO.' l_object '>' ls_clsmeth-cmpname
                      '</>'
                      INTO lt_lines-tdline.
        ELSE.
          IF ls_clsmeth-clsname = fp_obj.
            lt_lines-tdline = ls_clsmeth-cmpname.
          ELSE.
            CONCATENATE ls_clsmeth-clsname ls_clsmeth-cmpname
                        INTO lt_lines-tdline SEPARATED BY '~'.
          ENDIF.
        ENDIF.
        IF NOT ls_clsmeth-descript IS INITIAL.
          CONCATENATE lt_lines-tdline ls_clsmeth-descript
                      INTO lt_lines-tdline SEPARATED BY ' : '.
        ENDIF.
        APPEND lt_lines.
      ENDLOOP.
    ENDIF.
  ENDIF.

* If doc found, display it in html
  IF NOT lt_lines[] IS INITIAL.
* Add doc title
    IF l_title IS INITIAL.
      IF fp_objtype = c_doctype_img.
        SELECT SINGLE text INTO l_title
               FROM cus_imgact
               WHERE activity = fp_obj
               AND spras = sy-langu.
        IF sy-subrc NE 0.
          SELECT SINGLE text INTO l_title
                 FROM cus_imgact
                 WHERE activity = fp_obj
                 AND spras = c_langu_default.
        ENDIF.
      ELSEIF fp_objtype = c_doctype_fm.
        SELECT SINGLE stext INTO l_title
               FROM tftit
               WHERE funcname = fp_obj
               AND spras = sy-langu.
        IF sy-subrc NE 0.
          SELECT SINGLE stext INTO l_title
                 FROM tftit
                 WHERE funcname = fp_obj
                 AND spras = c_langu_default.
        ENDIF.
      ELSEIF fp_objtype = c_doctype_cls.
        l_title = fp_obj.
      ELSEIF fp_objtype = c_doctype_meth
      OR fp_objtype = c_doctype_clsattr.
        CONCATENATE fp_obj(30) '->' fp_obj+30 INTO l_title.
        CONDENSE l_title NO-GAPS.
      ENDIF.
    ENDIF.
    IF l_title NE space.
      CLEAR lt_lines.
      lt_lines-tdformat = 'U1'.
      lt_lines-tdline = l_title.
      INSERT lt_lines INDEX 1.
    ENDIF.

* Create doc html converter
    CREATE OBJECT l_docu_to_html.
    CONCATENATE 'DS:' fp_objtype '.' l_object
                INTO l_docu_to_html->doc_link.
* Load doc into converter
    l_docu_to_html->itflines = lt_lines[].

* Fill header
    l_docu_to_html->header-tdname = l_object.
    l_docu_to_html->header-tdid = fp_objtype.
    l_docu_to_html->header-tdform = 'S_DOCU_SHOW'.
    l_docu_to_html->header-tdstyle = 'S_DOCUS1'.
    IF fp_objtype = c_doctype_img.
      l_docu_to_html->header-tdobject = 'DSYS'.
    ELSE.
      l_docu_to_html->header-tdobject = 'DOKU'.
    ENDIF.

* Convert doc into html
    CALL METHOD l_docu_to_html->convert_itf_to_html.
    CALL METHOD l_docu_to_html->add_sapicons_to_html.

* Delete all header until <body>
    LOOP AT l_docu_to_html->htmllines INTO ls_data_table.
      TRANSLATE ls_data_table TO UPPER CASE.
      CONDENSE ls_data_table NO-GAPS.
      DELETE l_docu_to_html->htmllines.
      IF ls_data_table(5) NE '<BODY'.
        CONTINUE.
      ELSE.
        EXIT.
      ENDIF.
    ENDLOOP.

* Write doc
    APPEND LINES OF l_docu_to_html->htmllines TO lt_data_table.
  ELSE.
* No help found
    htmlo '<p align="center">No Help for this entry</p>'.
    htmlo '</body></html>'.
  ENDIF.

  CALL METHOD o_html_control->load_data
    IMPORTING
      assigned_url = l_url
    CHANGING
      data_table   = lt_data_table.

  CALL METHOD o_html_control->show_url
    EXPORTING
      url = l_url.

  o_pic->set_visible( abap_false ).
  o_html_control->set_visible( abap_true ).
ENDFORM.                    " write_html_img

*&---------------------------------------------------------------------*
*&      Form  find_entry
*&---------------------------------------------------------------------*
*       Search popup to find an entry by name or label
*----------------------------------------------------------------------*
FORM find_entry .
  DATA l_rc TYPE c.

  CLEAR s_ZSPRO_AP.

* Prompt for table/programm name
  PERFORM popup_get_value USING    c_popup_find
                          CHANGING s_ZSPRO_AP-nodetype
                                   s_ZSPRO_AP-nodeparam
                                   s_ZSPRO_AP-text
                                   l_rc.
  IF l_rc NE space AND l_rc NE 0.
    RETURN.
  ENDIF.

  CLEAR s_find.
  IF NOT s_ZSPRO_AP-nodetype IS INITIAL.
    s_find-nodetype = s_ZSPRO_AP-nodetype.
  ENDIF.
  s_find-nodeparam = s_ZSPRO_AP-nodeparam.
  s_find-patern = s_ZSPRO_AP-text.

  IF NOT s_find IS INITIAL.
    PERFORM find_entry_continue.
  ENDIF.

ENDFORM.                    " find_entry

*&--------------------------------------------------------------------*
*&      Form  find_entry_continue
*&--------------------------------------------------------------------*
*       Search an entry
*---------------------------------------------------------------------*
FORM find_entry_continue.
  DATA : l_index  TYPE i,
         lt_ZSPRO_AP LIKE TABLE OF s_ZSPRO_AP.

  IF s_find IS INITIAL.
    PERFORM find_entry.
  ENDIF.

  lt_ZSPRO_AP = t_ZSPRO_AP.
  SORT lt_ZSPRO_AP STABLE BY relatkey sort.

  l_index = s_find-index + 1.
  IF NOT s_find-nodetype IS INITIAL.
    LOOP AT lt_ZSPRO_AP INTO s_ZSPRO_AP FROM l_index.
      IF s_ZSPRO_AP-nodetype = s_find-nodetype
      AND s_ZSPRO_AP-nodeparam = s_find-nodeparam.
        s_find-index = sy-tabix.
        EXIT.
      ENDIF.
    ENDLOOP.
  ELSE.
    LOOP AT lt_ZSPRO_AP INTO s_ZSPRO_AP FROM l_index.
      FIND s_find-patern IN s_ZSPRO_AP-text IGNORING CASE.
      IF sy-subrc IS INITIAL.
        s_find-index = sy-tabix.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDIF.

  l_index = l_index - 1.
  IF s_find-index IS INITIAL.
    MESSAGE 'The search has not produced any hits'(m10)
            TYPE c_msg_succes.
  ELSEIF s_find-index = l_index.
    MESSAGE 'No further hits were found'(m11) TYPE c_msg_succes.
  ELSE.
    CALL METHOD o_tree->set_selected_node
      EXPORTING
        node_key = s_ZSPRO_AP-node_key.
    PERFORM init_html.
  ENDIF.
ENDFORM.                    "find_entry_continue

*&---------------------------------------------------------------------*
*&      Form  create_mass
*&---------------------------------------------------------------------*
*       Insert table/program in mass
*----------------------------------------------------------------------*
FORM create_mass .
  DATA : l_new_key      LIKE w_node_key,
         l_sort         TYPE i,
         l_subfolder(1) TYPE c,   " To do subfolder special operations
         lt_tables      LIKE TABLE OF dd02l-tabname WITH HEADER LINE,
         lt_progs       LIKE TABLE OF trdir-name WITH HEADER LINE,
         l_message(100) TYPE c,
         l_nbtable      TYPE string,
         l_n            TYPE i,
         lt_node_table  LIKE STANDARD TABLE OF s_node,
         l_table        TYPE tabname.

* Get parent folder node
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = w_node_key.

  IF w_node_key IS INITIAL.
    CLEAR l_subfolder.
  ELSE.
    l_subfolder = abap_true.
  ENDIF.

  IF l_subfolder = abap_true.
*   Check parent is a folder.
    CLEAR s_ZSPRO_AP.
    READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
    IF s_ZSPRO_AP-isfolder IS INITIAL.
      MESSAGE 'Please select a folder in the tree'(m30)
              TYPE c_msg_succes DISPLAY LIKE c_msg_error.
      RETURN.
    ENDIF.
  ENDIF.

  CLEAR s_ZSPRO_AP.

* Prompt table range to add in mass
  CALL SELECTION-SCREEN 200 STARTING AT 10 10.
  IF s_tables[] IS INITIAL AND s_progrm[] IS INITIAL.
    MESSAGE 'Action cancelled by the user'(m19) TYPE c_msg_succes
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

  IF NOT s_tables[] IS INITIAL.
    SELECT tabname INTO TABLE lt_tables
           FROM dd02l
           WHERE tabname IN s_tables.

    LOOP AT lt_tables.
      IF pdoublon NE space.
* Delete tables already in the tree
        READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP
                           WITH KEY nodetype = c_nodetype_table
                                    nodeparam = lt_tables.
        CHECK sy-subrc NE 0.
      ENDIF.

      PERFORM get_free_number USING w_node_key
                              CHANGING l_new_key l_sort.

      CLEAR s_ZSPRO_AP.

      s_ZSPRO_AP-node_key = l_new_key.
      IF l_subfolder = abap_true.
        s_ZSPRO_AP-relatkey = w_node_key.
        s_ZSPRO_AP-relatship = cl_gui_simple_tree=>relat_last_child.
      ENDIF.
      s_ZSPRO_AP-nodetype = c_nodetype_table.
      s_ZSPRO_AP-nodeparam = lt_tables.
*   Check if maintenance view exist
      l_table = s_ZSPRO_AP-nodeparam.
      SELECT SINGLE tabname
             INTO l_table
             FROM tvdir
             WHERE tabname = l_table.
      IF sy-subrc = 0.
        s_ZSPRO_AP-n_image = c_icon_table.
      ELSE.
        s_ZSPRO_AP-nomaint = abap_true.
        s_ZSPRO_AP-n_image = c_icon_table_nomaint.
      ENDIF.

      PERFORM check_table USING s_ZSPRO_AP-nodeparam CHANGING s_ZSPRO_AP-text.

      CHECK NOT s_ZSPRO_AP-text IS INITIAL.
      CHECK NOT s_ZSPRO_AP-nodeparam IS INITIAL.
      s_ZSPRO_AP-new_line = abap_true.
      s_ZSPRO_AP-sort = l_sort.
      s_ZSPRO_AP-dragdropid = w_handle_tree.
      INSERT s_ZSPRO_AP INTO TABLE t_ZSPRO_AP.

* Add techname if relevant
      IF w_techname = c_techname_on.
        CONCATENATE s_ZSPRO_AP-nodeparam '-' s_ZSPRO_AP-text INTO s_ZSPRO_AP-text
                    SEPARATED BY space.
      ENDIF.
      s_node = s_ZSPRO_AP.
      INSERT s_node INTO TABLE lt_node_table.
    ENDLOOP.
  ENDIF.

  IF NOT s_progrm[] IS INITIAL.
    SELECT name INTO TABLE lt_progs
           FROM trdir
           WHERE name IN s_progrm.

    LOOP AT lt_progs.
      IF pdoublon NE space.
* Delete programs already in the tree
        READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP
                           WITH KEY nodetype = c_nodetype_program
                                    nodeparam = lt_progs.
        CHECK sy-subrc NE 0.
      ENDIF.

      PERFORM get_free_number USING w_node_key
                              CHANGING l_new_key l_sort.

      CLEAR s_ZSPRO_AP.

      s_ZSPRO_AP-node_key = l_new_key.
      IF l_subfolder = abap_true.
        s_ZSPRO_AP-relatkey = w_node_key.
        s_ZSPRO_AP-relatship = cl_gui_simple_tree=>relat_last_child.
      ENDIF.
      s_ZSPRO_AP-nodetype = c_nodetype_program.
      s_ZSPRO_AP-nodeparam = lt_progs.
      s_ZSPRO_AP-n_image = c_icon_prog.

      PERFORM check_prog USING s_ZSPRO_AP-nodeparam CHANGING s_ZSPRO_AP-text.

      CHECK NOT s_ZSPRO_AP-text IS INITIAL.
      CHECK NOT s_ZSPRO_AP-nodeparam IS INITIAL.
      s_ZSPRO_AP-new_line = abap_true.
      s_ZSPRO_AP-sort = l_sort.
      s_ZSPRO_AP-dragdropid = w_handle_tree.
      INSERT s_ZSPRO_AP INTO TABLE t_ZSPRO_AP.

* Add techname if relevant
      IF w_techname = c_techname_on.
        CONCATENATE s_ZSPRO_AP-nodeparam '-' s_ZSPRO_AP-text INTO s_ZSPRO_AP-text
                    SEPARATED BY space.
      ENDIF.
      s_node = s_ZSPRO_AP.
      INSERT s_node INTO TABLE lt_node_table.
    ENDLOOP.
  ENDIF.

  REFRESH : s_tables, s_progrm.

  DESCRIBE TABLE lt_node_table LINES l_n.
  IF l_n IS INITIAL.
    MESSAGE 'No entries for these selection criteria'(m12)
            TYPE c_msg_succes.
  ELSE.
    CALL METHOD o_tree->add_nodes
      EXPORTING
        table_structure_name           = c_tree_table
        node_table                     = lt_node_table
      EXCEPTIONS
        failed                         = 1
        error_in_node_table            = 2
        dp_error                       = 3
        table_structure_name_not_found = 4
        OTHERS                         = 5.
    IF sy-subrc = 0.
      l_message = '# table(s) added'(m17).
      l_nbtable = l_n.
      REPLACE c_wildcard WITH l_nbtable INTO l_message.
      MESSAGE l_message TYPE c_msg_succes.
    ENDIF.

    IF l_subfolder = abap_true.
*   Expand parent of the new node
      CALL METHOD o_tree->expand_node
        EXPORTING
          node_key = w_node_key.
    ENDIF.
    w_data_changed = abap_true.
  ENDIF.
ENDFORM.                    " create_mass

*&---------------------------------------------------------------------*
*&      Form  where_used
*&---------------------------------------------------------------------*
*       Where-used function
*----------------------------------------------------------------------*
FORM where_used.
  DATA : l_obj_type TYPE rseuap-obj_type,
         l_objname  TYPE rseuap-obj_name,
         l_tabclass LIKE dd02l-tabclass.

* Get node
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check node is not IMG or url
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF s_ZSPRO_AP-nodetype NE c_nodetype_table
  AND s_ZSPRO_AP-nodetype NE c_nodetype_program
  AND s_ZSPRO_AP-nodetype NE c_nodetype_transac
  AND s_ZSPRO_AP-nodetype NE c_nodetype_fm
  AND s_ZSPRO_AP-nodetype NE c_nodetype_cls.
    RETURN.
  ENDIF.

  l_objname = s_ZSPRO_AP-nodeparam.
  IF s_ZSPRO_AP-nodetype = c_nodetype_table.
    SELECT SINGLE tabclass FROM dd02l INTO l_tabclass
           WHERE tabname EQ l_objname
           AND as4local EQ c_state_active
           AND as4vers EQ '0000'.
    IF l_tabclass = 'VIEW'.
      l_obj_type = 'DV'.
    ELSE.
      l_obj_type = 'DT'.
    ENDIF.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_program.
    l_obj_type = 'P'.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_transac.
    l_obj_type = 'T'.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_fm.
    l_obj_type = 'FF'.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_cls.
    l_obj_type = 'OC'.
  ENDIF.

  SUBMIT wb_mngr_start_from_tool_access AND RETURN
         WITH action   = 'WHEREUSED'
         WITH obj_type = l_obj_type
         WITH obj_name = l_objname
         WITH tool     = 'CL_WB_INFOSYSTEM'.
ENDFORM.                    "where_used

*&---------------------------------------------------------------------*
*&      Form  edit_help
*&---------------------------------------------------------------------*
*       Edit standard help of table/program/IMG/Function module
*----------------------------------------------------------------------*
FORM edit_help.
  DATA : l_object TYPE doku_obj,
         l_id     TYPE doku_id.

* Get active node
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check that node is not a folder
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF NOT s_ZSPRO_AP-isfolder IS INITIAL.
    MESSAGE 'Please not select a folder in the tree'(m31)
            TYPE c_msg_succes DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

* Call Help editor
  IF s_ZSPRO_AP-nodetype = c_nodetype_table.
    l_id = c_doctype_table.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_program.
    l_id = c_doctype_prog.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_img.
    l_id = c_doctype_img.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_fm.
    l_id = c_doctype_fm.
  ELSE.
* Help only for table, program, function, IMG
    RETURN.
  ENDIF.
  l_object = s_ZSPRO_AP-nodeparam.
  CALL FUNCTION 'DOCU_CALL'
    EXPORTING
      id     = l_id
      langu  = sy-langu
      object = l_object.
ENDFORM.                    "edit_help

*&---------------------------------------------------------------------*
*&      Form  switch_disp_edit
*&---------------------------------------------------------------------*
*       Switch between edit and display mode
*       Display is the default mode
*----------------------------------------------------------------------*
FORM switch_disp_edit.
  IF w_mode_change = abap_true.
    IF w_data_changed NE space.
      MESSAGE 'You must first save the data'(m04) TYPE c_msg_error.
      RETURN.
    ENDIF.
    CLEAR w_mode_change.
    CALL FUNCTION 'VIEW_ENQUEUE'
      EXPORTING
        action       = c_action_dequeue
        enqueue_mode = c_enqueue_mode_exclusive
        view_name    = c_tree_table.
  ELSE.
    CALL FUNCTION 'VIEW_ENQUEUE'
      EXPORTING
        action               = c_action_enqueue
        enqueue_mode         = c_enqueue_mode_exclusive
        view_name            = c_tree_table
      EXCEPTIONS
        client_reference     = 1
        foreign_lock         = 2
        invalid_action       = 3
        invalid_enqueue_mode = 4
        system_failure       = 5
        table_not_found      = 6
        OTHERS               = 7.
    IF sy-subrc EQ 0.
      w_mode_change = abap_true.
    ELSE.
      w_mode_change = space.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.
ENDFORM.                    "switch_disp_edit

*&---------------------------------------------------------------------*
*&      Form  INIT_EXCLUDED
*&---------------------------------------------------------------------*
*       Fill table t_excluded_nochange with list of forbidden okcode
*       in display mode
*----------------------------------------------------------------------*
FORM init_excluded .
  REFRESH t_excluded_nochange.
  APPEND 'FOLDER' TO t_excluded_nochange.
  APPEND 'FILE' TO t_excluded_nochange.
  APPEND 'MASSFILE' TO t_excluded_nochange.
  APPEND 'DELETE' TO t_excluded_nochange.
  APPEND 'RENAME' TO t_excluded_nochange.
  APPEND 'EDITHELP' TO t_excluded_nochange.
  APPEND 'CREA' TO t_excluded_nochange.
  APPEND 'UP' TO t_excluded_nochange.
  APPEND 'DOWN' TO t_excluded_nochange.
  APPEND 'SAVE' TO t_excluded_nochange.
  APPEND 'XMLI' TO t_excluded_nochange.
ENDFORM.                    " INIT_EXCLUDED

*&---------------------------------------------------------------------*
*&      Form  POPUP_GET_VALUE
*&---------------------------------------------------------------------*
*       Display popup to ask table/program/label
*----------------------------------------------------------------------*
*      -->FP_ACTION  Type of popup to display, controls to do
*      <--FP_TABNAME Table Name
*      <--FP_PRGNAME Program Name
*      <--FP_LABEL   Label of the program/table
*      <--FP_RC Return code : space if OK
*----------------------------------------------------------------------*
FORM popup_get_value  USING    fp_action TYPE c
                      CHANGING fp_nodetype TYPE ZSPRO_AP-nodetype
                               fp_nodeparam TYPE ZSPRO_AP-nodeparam
                               fp_label TYPE ZSPRO_AP-text
                               fp_rc TYPE c.
  DATA : ls_sval LIKE sval,
         lt_sval LIKE TABLE OF ls_sval.

  IF fp_action NE c_popup_folder.
* Table - 1
    CLEAR ls_sval.
    ls_sval-tabname = 'DD02L'.
    ls_sval-fieldname = 'TABNAME'.
    IF fp_nodetype = c_nodetype_table.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* Program - 2
    CLEAR ls_sval.
    ls_sval-tabname = 'REPOSRC'.
    ls_sval-fieldname = 'PROGNAME'.
    IF fp_nodetype = c_nodetype_program.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* Function module - 5
    CLEAR ls_sval.
    ls_sval-tabname = 'TFDIR'.
    ls_sval-fieldname = 'FUNCNAME'.
    IF fp_nodetype = c_nodetype_fm.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* Class - 7
    CLEAR ls_sval.
    ls_sval-tabname = 'SEOCLASS'.
    ls_sval-fieldname = 'CLSNAME'.
    ls_sval-fieldtext = 'Class name'(c16).
    IF fp_nodetype = c_nodetype_cls.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* Transaction code - 3
    CLEAR ls_sval.
    ls_sval-tabname = 'TSTC'.
    ls_sval-fieldname = 'TCODE'.
    IF fp_nodetype = c_nodetype_transac.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* URL - 4
    CLEAR ls_sval.
    ls_sval-tabname = 'AGR_BUFFI'.
    ls_sval-fieldname = 'URL'. "string
    IF fp_nodetype = c_nodetype_url.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
* IMG Activity - 6
    CLEAR ls_sval.
    ls_sval-tabname = 'CUS_ACTH'.
    ls_sval-fieldname = 'ACT_ID'.
    IF fp_nodetype = c_nodetype_img.
      ls_sval-value = fp_nodeparam.
    ENDIF.
    APPEND ls_sval TO lt_sval.
  ENDIF.
  ls_sval-tabname = 'ZSPRO_AP'.
  ls_sval-fieldname = 'TEXT'.
  ls_sval-value = fp_label.
  APPEND ls_sval TO lt_sval.
  fp_rc = 0.
  DO.
    CALL FUNCTION 'POPUP_GET_VALUES'
      EXPORTING
        popup_title     = space
      IMPORTING
        returncode      = fp_rc
      TABLES
        fields          = lt_sval
      EXCEPTIONS
        error_in_fields = 1
        OTHERS          = 2.
    IF sy-subrc NE 0 OR fp_rc NE space.
      fp_rc = 8.
      EXIT.
    ELSEIF fp_action = c_popup_folder.
      fp_rc = 0.
      READ TABLE lt_sval INTO ls_sval INDEX 1.
      fp_label = ls_sval-value.
      EXIT.
    ENDIF.
    CLEAR fp_nodetype.
    fp_rc = 0.
    LOOP AT lt_sval INTO ls_sval.
      IF ls_sval-fieldname = 'TEXT'.
        fp_label = ls_sval-value.
        CONTINUE.
      ENDIF.
      IF ls_sval-value NE space.
        IF fp_nodetype IS INITIAL.
          CASE ls_sval-fieldname.
            WHEN 'TABNAME'.
              fp_nodetype = c_nodetype_table.
            WHEN 'PROGNAME'.
              fp_nodetype = c_nodetype_program.
            WHEN 'FUNCNAME'.
              fp_nodetype = c_nodetype_fm.
            WHEN 'CLSNAME'.
              fp_nodetype = c_nodetype_cls.
            WHEN 'TCODE'.
              fp_nodetype = c_nodetype_transac.
            WHEN 'URL'.
              fp_nodetype = c_nodetype_url.
            WHEN 'ACT_ID'.
              fp_nodetype = c_nodetype_img.
            WHEN OTHERS.
              CLEAR fp_nodetype.
          ENDCASE.
          fp_nodeparam = ls_sval-value.
        ELSE.
          fp_rc = 1.
          EXIT.
        ENDIF.
      ENDIF.
    ENDLOOP.
    IF fp_action = c_popup_file
    AND ( fp_nodetype IS INITIAL OR fp_rc = 1 ).
      MESSAGE 'Fill one object entry'(m20) TYPE c_msg_succes
              DISPLAY LIKE c_msg_error.
    ELSE.
      fp_rc = 0.
      EXIT.
    ENDIF.
  ENDDO.
  IF fp_rc NE 0.
    MESSAGE 'Action cancelled by the user'(m19) TYPE c_msg_succes
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

* For file popup, check table name
  IF fp_nodetype = c_nodetype_table AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_table USING fp_nodeparam CHANGING fp_label.
  ENDIF.
* For file popup, check program name
  IF fp_nodetype = c_nodetype_program AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_prog USING fp_nodeparam CHANGING fp_label.
  ENDIF.
* For file popup, check class name
  IF fp_nodetype = c_nodetype_cls AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_cls USING fp_nodeparam CHANGING fp_label.
  ENDIF.
* For file popup, check transaction name
  IF fp_nodetype = c_nodetype_transac AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_transac USING fp_nodeparam CHANGING fp_label.
  ENDIF.
* For file popup, copy url in url name if empty
  IF fp_nodetype = c_nodetype_url AND fp_nodeparam NE space
  AND fp_action = c_popup_file AND fp_label = space.
    fp_label = fp_nodeparam.
  ENDIF.
* For file popup, check img name
  IF fp_nodetype = c_nodetype_img AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_img USING fp_nodeparam CHANGING fp_label.
  ENDIF.
* For file popup, check function name
  IF fp_nodetype = c_nodetype_fm AND fp_nodeparam NE space
  AND fp_action = c_popup_file.
    PERFORM check_fm USING fp_nodeparam CHANGING fp_label.
  ENDIF.

* For file/folder popup, Cancel if text not filled
* For find, cancel if none of the fields is filled
  IF fp_label IS INITIAL
  AND ( fp_action NE c_popup_find OR fp_nodeparam IS INITIAL ).
    fp_rc = 8.
    RETURN.
  ENDIF.
ENDFORM.                    " POPUP_GET_VALUE

*&---------------------------------------------------------------------*
*&      Form  START_SE16
*&---------------------------------------------------------------------*
*       Display table content in SE16
*----------------------------------------------------------------------*
FORM start_se16.
  DATA l_table TYPE tabname.

* Get node
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check node is a table
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF s_ZSPRO_AP-nodetype NE c_nodetype_table.
    RETURN.
  ENDIF.

* Display selection-screen from SE16
  l_table = s_ZSPRO_AP-nodeparam.
  CALL FUNCTION 'RS_TOOL_ACCESS'
    EXPORTING
      operation   = 'TAB_CONT'
      object_name = l_table
      object_type = 'TABL'.
ENDFORM.                    " START_SE16

*&---------------------------------------------------------------------*
*&      Form  START_SE24
*&---------------------------------------------------------------------*
*       Display class in SE24
*----------------------------------------------------------------------*
FORM start_se24.
  DATA l_cls TYPE seoclsname.

* Get node
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check node is a class
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF s_ZSPRO_AP-nodetype NE c_nodetype_cls.
    RETURN.
  ENDIF.

* Display class method
  l_cls = s_ZSPRO_AP-nodeparam.
  CALL FUNCTION 'RS_TOOL_ACCESS'
    EXPORTING
      operation   = 'SHOW'
      object_name = l_cls
      object_type = 'CLAS'.

ENDFORM.                    " START_SE24

*&---------------------------------------------------------------------*
*&      Form  START_SE38
*&---------------------------------------------------------------------*
*       Display program code in SE38
*----------------------------------------------------------------------*
FORM start_se38.
  DATA : l_prog TYPE programm,
         l_name TYPE rs38l-include,
         l_numb TYPE tfdir-include.

* Get node
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check node is a program or a fm
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF s_ZSPRO_AP-nodetype = c_nodetype_program.
    l_prog = s_ZSPRO_AP-nodeparam.
  ELSEIF s_ZSPRO_AP-nodetype = c_nodetype_fm.
    SELECT SINGLE pname include INTO (l_name, l_numb)
           FROM tfdir
           WHERE funcname = s_ZSPRO_AP-nodeparam.
    CALL FUNCTION 'FUNCTION_INCLUDE_CONCATENATE'
      EXPORTING
        include_number = l_numb
      IMPORTING
        include        = l_prog
      CHANGING
        program        = l_name
      EXCEPTIONS
        OTHERS         = 4.
    IF sy-subrc <> 0 OR l_prog IS INITIAL.
      RETURN.
    ENDIF.
  ELSE.
    RETURN.
  ENDIF.

* Display code in SE38
  EDITOR-CALL FOR REPORT l_prog DISPLAY-MODE.
ENDFORM.                    " START_SE38

*&---------------------------------------------------------------------*
*&      Form  START_SE11
*&---------------------------------------------------------------------*
*       Display table definition in SE11
*----------------------------------------------------------------------*
*      -->FP_TEXT    Display text table instead of main table
*----------------------------------------------------------------------*
FORM start_se11 USING fp_text.
  DATA l_table TYPE tabname.
* Get node
  CALL METHOD o_tree->get_selected_node
    IMPORTING
      node_key = w_node_key.

* Check node is a table
  READ TABLE t_ZSPRO_AP INTO s_ZSPRO_AP WITH KEY node_key = w_node_key.
  IF s_ZSPRO_AP-nodetype NE c_nodetype_table.
    RETURN.
  ENDIF.

  l_table = s_ZSPRO_AP-nodeparam.

* Search text table name
  IF fp_text NE space.
    CALL FUNCTION 'DDUT_TEXTTABLE_GET'
      EXPORTING
        tabname   = l_table
      IMPORTING
        texttable = l_table.
    IF l_table IS INITIAL.
      RETURN.
    ENDIF.
  ENDIF.

* Display table definition in SE11
  CALL METHOD cl_wb_ddic=>access_ddic_via_manager
    EXPORTING
      p_obj_name  = l_table
      p_obj_type  = 'TABL'
      p_operation = 'S'. "display
ENDFORM.                    " START_SE11

*&---------------------------------------------------------------------*
*&      Form  SWITCH_TECHNAME_TREE
*&---------------------------------------------------------------------*
*       Redraw tree with or without techname
*----------------------------------------------------------------------*
FORM switch_techname_tree .
  w_techname = 1 - w_techname.

  LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP.
    IF w_techname = c_techname_on
    AND NOT s_ZSPRO_AP-nodetype = c_nodetype_url
    AND s_ZSPRO_AP-isfolder = space.
      CONCATENATE s_ZSPRO_AP-nodeparam '-' s_ZSPRO_AP-text INTO s_ZSPRO_AP-text
                  SEPARATED BY space.
    ENDIF.
    CALL METHOD o_tree->node_set_text
      EXPORTING
        node_key = s_ZSPRO_AP-node_key
        text     = s_ZSPRO_AP-text.
  ENDLOOP.
ENDFORM.                    " SWITCH_TECHNAME_TREE

*&---------------------------------------------------------------------*
*&      Form  GET_URL_ICON
*&---------------------------------------------------------------------*
*       Get icon related to an url
*----------------------------------------------------------------------*
*      -->FP_URL  : Url to scan
*      <--FP_ICON : Icon related to this url
*----------------------------------------------------------------------*
FORM get_url_icon  USING    fp_url TYPE ZSPRO_AP-nodeparam
                   CHANGING fp_icon TYPE tv_image.
  DATA : lv_string TYPE string,
         lv_offset TYPE i.

* For empty link, return broken link icon
  IF fp_url = c_url_broken.
    fp_icon = c_icon_url_broken.
    RETURN.
  ENDIF.

* Try to find extension even if internet link
** For internet link, return link icon
*  IF fp_url(4) = 'http'.
*    fp_icon = c_icon_url.
*    RETURN.
*  ENDIF.

* Search file extension
  lv_string = fp_url.
  DO.
    FIND FIRST OCCURRENCE OF '.' IN lv_string MATCH OFFSET lv_offset.
    IF sy-subrc NE 0.
      EXIT. "exit do
    ELSE.
      lv_offset = lv_offset + 1.
      lv_string = lv_string+lv_offset.
    ENDIF.
  ENDDO.

* No extension found, return link icon
  IF lv_string = fp_url.
    fp_icon = c_icon_url.
    RETURN.
  ENDIF.

  TRANSLATE lv_string TO LOWER CASE.
  CASE lv_string.
* Excel file
    WHEN 'xls' OR 'xlsx' OR 'xlm' OR 'xlam'.
      fp_icon = c_icon_xls.
      RETURN.
* Word file
    WHEN 'doc' OR 'docx'.
      fp_icon = c_icon_doc.
      RETURN.
* Powerpoint file
    WHEN 'ppt' OR 'pptx'.
      fp_icon = c_icon_ppt.
      RETURN.
* PDF File
    WHEN 'pdf'.
      fp_icon = c_icon_pdf.
      RETURN.
* Images File
    WHEN 'png' OR 'bmp' OR 'jpg' OR 'jpeg' OR 'gif'.
      fp_icon = c_icon_png.
      RETURN.
* Email
    WHEN 'msg'.
      fp_icon = c_icon_mail.
* No known extension, return link icon
    WHEN OTHERS.
      fp_icon = c_icon_url.
      RETURN.
  ENDCASE.
ENDFORM.                    " GET_URL_ICON

*&---------------------------------------------------------------------*
*&      Form  Export_xml
*&---------------------------------------------------------------------*
*       Export tree in xml format
*----------------------------------------------------------------------*
FORM export_xml.
  DATA : BEGIN OF ls_xml,
           line(256) TYPE x,
         END OF ls_xml,
         lt_xml     LIKE TABLE OF ls_xml,
         ls_ZSPRO_AP   LIKE s_ZSPRO_AP,
         l_filename TYPE string,
         l_path     TYPE string,
         l_fullpath TYPE string.
  DATA : lo_xml      TYPE REF TO if_ixml,
         lo_document TYPE REF TO if_ixml_document,
         lo_root     TYPE REF TO if_ixml_element,
         lo_element  TYPE REF TO if_ixml_element,
         lo_parent   TYPE REF TO if_ixml_element,
         BEGIN OF ls_node_link,
           nodekey LIKE ls_ZSPRO_AP-node_key,
           element TYPE REF TO if_ixml_element,
         END OF ls_node_link,
         lt_node_link     LIKE TABLE OF ls_node_link,
         lw_string        TYPE string,
         lo_streamfactory TYPE REF TO if_ixml_stream_factory,
         lo_ostream       TYPE REF TO if_ixml_ostream,
         lo_renderer      TYPE REF TO if_ixml_renderer,
         l_title          TYPE string,
         l_filter         TYPE string.

* Ask name of file to generate
  l_title = 'Choose file to create'(m23).
  l_filter = 'XML File (*.xml)|*.xml'(m24).
  CALL METHOD cl_gui_frontend_services=>file_save_dialog
    EXPORTING
      window_title = l_title
      file_filter  = l_filter
    CHANGING
      path         = l_path
      filename     = l_filename
      fullpath     = l_fullpath
    EXCEPTIONS
      OTHERS       = 1.
  IF sy-subrc NE 0 OR l_filename IS INITIAL OR l_path IS INITIAL.
    MESSAGE 'Action cancelled by the user'(m19) TYPE c_msg_succes
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

  t_ZSPRO_AP_copy = t_ZSPRO_AP.

  SORT t_ZSPRO_AP_copy BY relatkey sort.

  lo_xml = cl_ixml=>create( ).
  lo_document = lo_xml->create_document( ).

  lo_root  = lo_document->create_simple_element( name = c_xmlnode_root
                                                 parent = lo_document ).
  LOOP AT t_ZSPRO_AP_copy INTO ls_ZSPRO_AP.

    IF ls_ZSPRO_AP-relatkey IS INITIAL.
      lo_parent = lo_root.
    ELSE.
      READ TABLE lt_node_link INTO ls_node_link
                 WITH KEY nodekey = ls_ZSPRO_AP-relatkey.
      lo_parent = ls_node_link-element.
    ENDIF.
    IF ls_ZSPRO_AP-isfolder NE space.
      lw_string = c_xmlnode_folder.
    ELSE.
      lw_string = c_xmlnode_file.
    ENDIF.

    lo_element  = lo_document->create_simple_element( name = lw_string
                                                      parent = lo_parent ).
    IF ls_ZSPRO_AP-isfolder NE space.
      lw_string = ls_ZSPRO_AP-text.
      lo_element->set_attribute( name = c_xmlattr_folder_text value = lw_string ).
    ELSE.
      CASE ls_ZSPRO_AP-nodetype.
        WHEN c_nodetype_table.
          lw_string = c_xmltype_table.
        WHEN c_nodetype_program.
          lw_string = c_xmltype_program.
        WHEN c_nodetype_transac.
          lw_string = c_xmltype_transac.
        WHEN c_nodetype_url.
          lw_string = c_xmltype_url.
        WHEN c_nodetype_img.
          lw_string = c_xmltype_img.
        WHEN c_nodetype_fm.
          lw_string = c_xmltype_fm.
        WHEN c_nodetype_cls.
          lw_string = c_xmltype_cls.
      ENDCASE.
      lo_element->set_attribute( name = c_xmlattr_file_type value = lw_string ).
      lw_string = ls_ZSPRO_AP-text.
      lo_element->set_attribute( name = c_xmlattr_file_text value = lw_string ).
      lw_string = ls_ZSPRO_AP-nodeparam.
      lo_element->set_attribute( name = c_xmlattr_file_param value = lw_string ).
    ENDIF.
    ls_node_link-element = lo_element.
    ls_node_link-nodekey = ls_ZSPRO_AP-node_key.
    APPEND ls_node_link TO lt_node_link.
  ENDLOOP.

  lo_streamfactory = lo_xml->create_stream_factory( ).

  lo_ostream  = lo_streamfactory->create_ostream_itable( lt_xml ).

  lo_renderer = lo_xml->create_renderer( ostream  = lo_ostream
                                         document = lo_document ).
  lo_ostream->set_pretty_print( abap_true ).
  lo_renderer->render( ).

  CALL METHOD cl_gui_frontend_services=>gui_download
    EXPORTING
      filename = l_fullpath
      filetype = 'BIN'
    CHANGING
      data_tab = lt_xml.
ENDFORM.                    "Export_xml

*&---------------------------------------------------------------------*
*&      Form  Import_xml                                     @C.Cabrita
*&---------------------------------------------------------------------*
*       Import tree in xml format
*----------------------------------------------------------------------*
FORM import_xml.
  DATA : lt_filetab       TYPE filetable,
         ls_file          TYPE file_table,
         l_filename       TYPE string,
         l_subrc          LIKE sy-subrc,
         l_xmldata        TYPE xstring,
         l_answer         TYPE c,
         lo_xml           TYPE REF TO if_ixml,
         lo_document      TYPE REF TO if_ixml_document,
         lo_streamfactory TYPE REF TO if_ixml_stream_factory,
         lo_stream        TYPE REF TO if_ixml_istream,
         lo_parser        TYPE REF TO if_ixml_parser,
         BEGIN OF ls_node_link,
           nodekey LIKE s_ZSPRO_AP-node_key,
           obj     TYPE x LENGTH 8,
         END OF ls_node_link,
         lt_node_link LIKE TABLE OF ls_node_link,
         l_sort       TYPE i.
  DATA: lo_iterator       TYPE REF TO if_ixml_node_iterator,
        lo_node           TYPE REF TO if_ixml_node,
        lo_element_parent TYPE REF TO if_ixml_element,
        l_node_name       TYPE string,
        lo_element        TYPE REF TO if_ixml_element,
        l_type            TYPE string,
        l_label           TYPE string,
        l_obj             TYPE string,
        l_tabname         TYPE tabname,
        l_title           TYPE string,
        l_filter          TYPE string.
  DATA : lo_obj TYPE REF TO cl_ixml_unknown.

* Choose file to import
  l_title = 'Choose file to import'(m25).
  l_filter = 'XML File (*.xml)|*.xml'(m24).
  CALL METHOD cl_gui_frontend_services=>file_open_dialog
    EXPORTING
      window_title   = l_title
      file_filter    = l_filter
      multiselection = space
    CHANGING
      file_table     = lt_filetab
      rc             = l_subrc.

* Check user action (1 OPEN, 2 CANCEL)
  IF l_subrc NE 1.
    MESSAGE 'Action cancelled by the user'(m19) TYPE c_msg_succes
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

* Read filetable
  READ TABLE lt_filetab INTO ls_file INDEX 1.
  l_filename = ls_file-filename.

* Popup to confirm
  CLEAR l_answer.
  CALL FUNCTION 'POPUP_TO_CONFIRM'
    EXPORTING
      titlebar              = 'Confirm import of new tree'(m26)
      text_question         = 'Current tree will be replaced by content of file. Do you want to continue ?'(m27)
      text_button_1         = 'Yes'(002)
      text_button_2         = 'No'(003)
      default_button        = '2'
      display_cancel_button = ''
    IMPORTING
      answer                = l_answer.

  IF l_answer <> 1.
    MESSAGE 'Action cancelled by the user'(m19) TYPE c_msg_succes
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

* Get xml flow from file
* Or alternatively (if method does not exist) use the method
* cl_gui_frontend_services=>gui_upload and then convert the
* x-tab to xstring
  TRY.
      l_xmldata = cl_openxml_helper=>load_local_file( l_filename ).
    CATCH cx_openxml_not_found.
      MESSAGE 'Error when opening the input XML file'(m29)
              TYPE c_msg_error.
      RETURN.
  ENDTRY.

  lo_xml = cl_ixml=>create( ).

  lo_document = lo_xml->create_document( ).
  lo_streamfactory = lo_xml->create_stream_factory( ).
  lo_stream = lo_streamfactory->create_istream_xstring( string = l_xmldata ).

  lo_parser = lo_xml->create_parser( stream_factory = lo_streamfactory
                                     istream        = lo_stream
                                     document       = lo_document ).
*-- parse the stream
  IF lo_parser->parse( ) NE 0.
    IF lo_parser->num_errors( ) NE 0.
      MESSAGE 'Error when parsing the input XML file'(m28)
              TYPE c_msg_error.
      RETURN.
    ENDIF.
  ENDIF.

*-- we don't need the stream any more, so let's close it...
  CALL METHOD lo_stream->close( ).
  CLEAR lo_stream.

* Flag all old nodes as deleted
  LOOP AT t_ZSPRO_AP INTO s_ZSPRO_AP.
    CLEAR s_ZSPRO_AP_del.
    s_ZSPRO_AP_del = 'IEQ'.
    s_ZSPRO_AP_del-low = s_ZSPRO_AP-node_key.
    APPEND s_ZSPRO_AP_del TO r_ZSPRO_AP_del.
  ENDLOOP.

* Clear data
  REFRESH t_ZSPRO_AP.

* Rebuild itab t_ZSPRO_AP
  lo_iterator = lo_document->create_iterator( ).
  lo_node = lo_iterator->get_next( ).
  WHILE NOT lo_node IS INITIAL.
    l_node_name = lo_node->get_name( ).
    IF l_node_name = c_xmlnode_folder OR l_node_name = c_xmlnode_file.
      CLEAR s_ZSPRO_AP.
      s_ZSPRO_AP-new_line = abap_true.
      s_ZSPRO_AP-dragdropid = w_handle_tree.

* Cast node to element
      lo_element ?= lo_node. "->query_interface( ixml_iid_element ).

* Get node_key of the parent
      lo_element_parent ?= lo_node->get_parent( ).
      lo_obj ?= lo_element_parent.
      READ TABLE lt_node_link INTO ls_node_link
                 WITH KEY obj = lo_obj->m_pointee.
      IF sy-subrc = 0.
        s_ZSPRO_AP-relatkey = ls_node_link-nodekey.
        s_ZSPRO_AP-relatship = cl_gui_simple_tree=>relat_last_child.
      ENDIF.

      PERFORM get_free_number USING s_ZSPRO_AP-relatkey
                              CHANGING s_ZSPRO_AP-node_key
                                       l_sort.
      s_ZSPRO_AP-sort = l_sort.
* Keep the node for further reference (search parent)
      lo_obj ?= lo_element.
      ls_node_link-obj = lo_obj->m_pointee.
      ls_node_link-nodekey = s_ZSPRO_AP-node_key.
      APPEND ls_node_link TO lt_node_link.

      IF l_node_name = c_xmlnode_folder.
        l_label = lo_element->get_attribute( name = c_xmlattr_folder_text ).
        s_ZSPRO_AP-isfolder = abap_true.
        s_ZSPRO_AP-text = l_label.
        s_ZSPRO_AP-nodetype = c_nodetype_node.
      ELSE.
        l_type = lo_element->get_attribute( name = c_xmlattr_file_type ).
        l_label = lo_element->get_attribute( name = c_xmlattr_file_text ).
        l_obj = lo_element->get_attribute( name = c_xmlattr_file_param ).

        s_ZSPRO_AP-text = l_label.
        s_ZSPRO_AP-nodeparam = l_obj.
        CASE l_type.
          WHEN c_xmltype_table.
            s_ZSPRO_AP-nodetype = c_nodetype_table.
            l_tabname = s_ZSPRO_AP-nodeparam.
*   Check if maintenance view exist
            SELECT SINGLE tabname
                   INTO l_tabname
                   FROM tvdir
                   WHERE tabname = l_tabname.
            IF sy-subrc = 0.
              s_ZSPRO_AP-n_image = c_icon_table.
            ELSE.
              s_ZSPRO_AP-nomaint = abap_true.
              s_ZSPRO_AP-n_image = c_icon_table_nomaint.
            ENDIF.
          WHEN c_xmltype_program.
            s_ZSPRO_AP-nodetype = c_nodetype_program.
            s_ZSPRO_AP-n_image = c_icon_prog.
          WHEN c_xmltype_transac.
            s_ZSPRO_AP-nodetype = c_nodetype_transac.
            s_ZSPRO_AP-n_image = c_icon_transac.
          WHEN c_xmltype_url.
            s_ZSPRO_AP-nodetype = c_nodetype_url.
            PERFORM get_url_icon USING s_ZSPRO_AP-nodeparam
                                 CHANGING s_ZSPRO_AP-n_image.
          WHEN c_xmltype_img.
            s_ZSPRO_AP-nodetype = c_nodetype_img.
            s_ZSPRO_AP-n_image = c_icon_img.
          WHEN c_xmltype_fm.
            s_ZSPRO_AP-nodetype = c_nodetype_fm.
            s_ZSPRO_AP-n_image = c_icon_fm.
          WHEN c_xmltype_cls.
            s_ZSPRO_AP-nodetype = c_nodetype_cls.
            s_ZSPRO_AP-n_image = c_icon_cls.
          WHEN OTHERS.
            s_ZSPRO_AP-n_image = c_icon_unknown.
            CLEAR s_ZSPRO_AP-nodetype.
        ENDCASE.
      ENDIF.
      APPEND s_ZSPRO_AP TO t_ZSPRO_AP.
    ENDIF.
    lo_node = lo_iterator->get_next( ).
  ENDWHILE.

* Set data changed (to manage the save function)
  w_data_changed = abap_true.

* Delete all nodes
  CALL METHOD o_tree->delete_all_nodes.

* Reload all tree from internal tables t_ZSPRO_AP
  PERFORM load_node USING space.

ENDFORM.                    "import_xml
<?xml version="1.0" encoding="utf-8"?>
<PROG NAME="ZSQL_APC" VARCL="X" SUBC="1" RMAND="012" RLOAD="S" FIXPT="X" UCCHECK="X">
 <textPool>
  <language SPRAS="S">
   <textElement ID="I" KEY="001" ENTRY="Domain Definitions" LENGTH="18 "/>
   <textElement ID="I" KEY="002" ENTRY="Data Element Definitions" LENGTH="24 "/>
   <textElement ID="I" KEY="003" ENTRY="Lock Object Definitions" LENGTH="23 "/>
   <textElement ID="I" KEY="004" ENTRY="Indexes" LENGTH="7 "/>
   <textElement ID="I" KEY="005" ENTRY="Table Definitions" LENGTH="17 "/>
   <textElement ID="I" KEY="006" ENTRY="Table Technical Attriibutes" LENGTH="27 "/>
   <textElement ID="I" KEY="007" ENTRY="Table Type definitions" LENGTH="22 "/>
   <textElement ID="I" KEY="008" ENTRY="Text Component Table Type definitions" LENGTH="37 "/>
   <textElement ID="I" KEY="009" ENTRY="View definitions" LENGTH="16 "/>
   <textElement ID="I" KEY="010" ENTRY="View Technical Attributes" LENGTH="25 "/>
   <textElement ID="I" KEY="011" ENTRY="Domains" LENGTH="7 "/>
   <textElement ID="I" KEY="012" ENTRY="Domain definitions" LENGTH="18 "/>
   <textElement ID="I" KEY="013" ENTRY="Data Elements" LENGTH="13 "/>
   <textElement ID="I" KEY="014" ENTRY="Lock Objects" LENGTH="12 "/>
   <textElement ID="I" KEY="015" ENTRY="Logical Databases" LENGTH="17 "/>
   <textElement ID="I" KEY="016" ENTRY="Number Ranges" LENGTH="13 "/>
   <textElement ID="I" KEY="017" ENTRY="Tables" LENGTH="6 "/>
   <textElement ID="I" KEY="018" ENTRY="Table Contents" LENGTH="14 "/>
   <textElement ID="I" KEY="019" ENTRY="Table Types" LENGTH="11 "/>
   <textElement ID="I" KEY="020" ENTRY="Data Models" LENGTH="11 "/>
   <textElement ID="I" KEY="021" ENTRY="Entity Types" LENGTH="12 "/>
   <textElement ID="I" KEY="022" ENTRY="Views" LENGTH="5 "/>
   <textElement ID="I" KEY="023" ENTRY="Pretty Printer" LENGTH="14 "/>
   <textElement ID="I" KEY="024" ENTRY="(...) INNER JOIN Checktable" LENGTH="27 "/>
   <textElement ID="I" KEY="025" ENTRY="(...) LEFT OUTER JOIN Checktable" LENGTH="32 "/>
   <textElement ID="I" KEY="026" ENTRY="(...) SELECT FOR ALL ENTRIES Checktable" LENGTH="39 "/>
   <textElement ID="I" KEY="027" ENTRY="Delete Folder" LENGTH="13 "/>
   <textElement ID="I" KEY="028" ENTRY="(...) Foreign Key Relations" LENGTH="27 "/>
   <textElement ID="I" KEY="029" ENTRY="Delete All" LENGTH="10 "/>
   <textElement ID="I" KEY="030" ENTRY="Create New Folder" LENGTH="17 "/>
   <textElement ID="I" KEY="031" ENTRY="Paste" LENGTH="5 "/>
   <textElement ID="I" KEY="032" ENTRY="Rename Folder" LENGTH="13 "/>
   <textElement ID="I" KEY="033" ENTRY="Create New Folder" LENGTH="17 "/>
   <textElement ID="I" KEY="034" ENTRY="Cut" LENGTH="3 "/>
   <textElement ID="I" KEY="035" ENTRY="Paste" LENGTH="5 "/>
   <textElement ID="I" KEY="036" ENTRY="Delete All Commands" LENGTH="19 "/>
   <textElement ID="I" KEY="037" ENTRY="Display" LENGTH="7 "/>
   <textElement ID="I" KEY="038" ENTRY="Delete" LENGTH="6 "/>
   <textElement ID="I" KEY="039" ENTRY="Properties" LENGTH="10 "/>
   <textElement ID="I" KEY="040" ENTRY="Execute" LENGTH="7 "/>
   <textElement ID="I" KEY="041" ENTRY="Do you want to move the commands in the Repository" LENGTH="50 "/>
   <textElement ID="I" KEY="042" ENTRY="to the Current commands after emptying the Repository?" LENGTH="54 "/>
   <textElement ID="I" KEY="043" ENTRY="Confirm deletion" LENGTH="16 "/>
   <textElement ID="I" KEY="044" ENTRY="Do you really want to delete all current commands?" LENGTH="50 "/>
   <textElement ID="I" KEY="045" ENTRY="Do you want to move the commands in the selected folder" LENGTH="55 "/>
   <textElement ID="I" KEY="046" ENTRY="to the Current commands after Deleting the Folder?" LENGTH="50 "/>
   <textElement ID="I" KEY="047" ENTRY="Enter Folder Name" LENGTH="17 "/>
   <textElement ID="I" KEY="048" ENTRY="and all of its subcommands" LENGTH="26 "/>
   <textElement ID="I" KEY="049" ENTRY="Do you really want to delete the command" LENGTH="40 "/>
   <textElement ID="I" KEY="050" ENTRY="Display table definition" LENGTH="24 "/>
   <textElement ID="I" KEY="051" ENTRY="Display indexes" LENGTH="15 "/>
   <textElement ID="I" KEY="052" ENTRY="Display technical settings" LENGTH="26 "/>
   <textElement ID="I" KEY="053" ENTRY="Display foreign key relations" LENGTH="29 "/>
   <textElement ID="I" KEY="054" ENTRY="Display text table" LENGTH="18 "/>
   <textElement ID="I" KEY="055" ENTRY="Display runtime object" LENGTH="22 "/>
   <textElement ID="I" KEY="056" ENTRY="Where Used List" LENGTH="15 "/>
   <textElement ID="I" KEY="057" ENTRY="Display contents" LENGTH="16 "/>
   <textElement ID="I" KEY="058" ENTRY="Use Value Ranges" LENGTH="16 "/>
   <textElement ID="I" KEY="059" ENTRY="Toggle Display/Change mode" LENGTH="26 "/>
   <textElement ID="I" KEY="060" ENTRY="Display Tree" LENGTH="12 "/>
   <textElement ID="I" KEY="061" ENTRY="Select All Rows" LENGTH="15 "/>
   <textElement ID="I" KEY="062" ENTRY="Deselect All Rows" LENGTH="17 "/>
   <textElement ID="I" KEY="063" ENTRY="Column display settings" LENGTH="23 "/>
   <textElement ID="I" KEY="064" ENTRY="Toggle automatic check" LENGTH="22 "/>
   <textElement ID="I" KEY="065" ENTRY="Append row" LENGTH="10 "/>
   <textElement ID="I" KEY="066" ENTRY="Insert row" LENGTH="10 "/>
   <textElement ID="I" KEY="067" ENTRY="Delete row" LENGTH="10 "/>
   <textElement ID="I" KEY="068" ENTRY="Copy row" LENGTH="8 "/>
   <textElement ID="I" KEY="069" ENTRY="Updated/Inserted/Deleted rows" LENGTH="29 "/>
   <textElement ID="I" KEY="070" ENTRY="Update DB table" LENGTH="15 "/>
   <textElement ID="I" KEY="071" ENTRY="Insert lines to DB table" LENGTH="24 "/>
   <textElement ID="I" KEY="072" ENTRY="Modify DB table" LENGTH="15 "/>
   <textElement ID="I" KEY="073" ENTRY="Delete visible lines from DB" LENGTH="28 "/>
   <textElement ID="I" KEY="074" ENTRY="Delete deleted lines from DB" LENGTH="28 "/>
   <textElement ID="I" KEY="075" ENTRY="Undo all changes" LENGTH="16 "/>
   <textElement ID="I" KEY="076" ENTRY="Enter Table Name" LENGTH="16 "/>
   <textElement ID="I" KEY="077" ENTRY="Dynamic Selection" LENGTH="17 "/>
   <textElement ID="I" KEY="078" ENTRY="Key fields as normal" LENGTH="20 "/>
   <textElement ID="I" KEY="079" ENTRY="To edit the result sets, key fields &amp;1 have to be included in the field list." LENGTH="77 "/>
   <textElement ID="I" KEY="081" ENTRY="Display alias" LENGTH="13 "/>
   <textElement ID="I" KEY="082" ENTRY="Modify source table" LENGTH="19 "/>
   <textElement ID="I" KEY="083" ENTRY="Modify other table" LENGTH="18 "/>
   <textElement ID="I" KEY="084" ENTRY="Insert into source table" LENGTH="24 "/>
   <textElement ID="I" KEY="085" ENTRY="Insert into other table" LENGTH="23 "/>
   <textElement ID="I" KEY="086" ENTRY="Create table" LENGTH="12 "/>
   <textElement ID="I" KEY="087" ENTRY="Update source table" LENGTH="19 "/>
   <textElement ID="I" KEY="088" ENTRY="Update other table" LENGTH="18 "/>
   <textElement ID="I" KEY="089" ENTRY="Fix key columns" LENGTH="15 "/>
   <textElement ID="I" KEY="090" ENTRY="Display original field name" LENGTH="27 "/>
   <textElement ID="I" KEY="091" ENTRY="Display generated field name" LENGTH="28 "/>
   <textElement ID="I" KEY="092" ENTRY="Diaplay short text" LENGTH="18 "/>
   <textElement ID="I" KEY="093" ENTRY="Display All records" LENGTH="19 "/>
   <textElement ID="I" KEY="094" ENTRY="Display Updated records" LENGTH="23 "/>
   <textElement ID="I" KEY="095" ENTRY="Display Inserted records" LENGTH="24 "/>
   <textElement ID="I" KEY="096" ENTRY="Display Deleted records" LENGTH="23 "/>
   <textElement ID="I" KEY="097" ENTRY="Total" LENGTH="5 "/>
   <textElement ID="I" KEY="098" ENTRY="Structure" LENGTH="9 "/>
   <textElement ID="I" KEY="099" ENTRY="Script" LENGTH="6 "/>
   <textElement ID="I" KEY="100" ENTRY="Select for All Entries" LENGTH="22 "/>
   <textElement ID="I" KEY="101" ENTRY="Loop-at Workbench" LENGTH="17 "/>
   <textElement ID="I" KEY="102" ENTRY="Delete SQL" LENGTH="10 "/>
   <textElement ID="I" KEY="103" ENTRY="Update SQL" LENGTH="10 "/>
   <textElement ID="I" KEY="104" ENTRY="Select SQL" LENGTH="10 "/>
   <textElement ID="I" KEY="105" ENTRY="* field symbols for the work area and for a specific field" LENGTH="58 "/>
   <textElement ID="I" KEY="106" ENTRY="* the table name MUST be p_itab" LENGTH="31 "/>
   <textElement ID="I" KEY="107" ENTRY="* replace XYZ with the field name in UPPERCASE" LENGTH="46 "/>
   <textElement ID="I" KEY="108" ENTRY="Create table and insert" LENGTH="23 "/>
   <textElement ID="I" KEY="109" ENTRY="Refresh" LENGTH="7 "/>
   <textElement ID="I" KEY="110" ENTRY="Display Options" LENGTH="15 "/>
   <textElement ID="I" KEY="111" ENTRY="Display Grid" LENGTH="12 "/>
   <textElement ID="I" KEY="112" ENTRY="Data has changed" LENGTH="16 "/>
   <textElement ID="I" KEY="113" ENTRY="Do you really want to quit without saving?" LENGTH="42 "/>
   <textElement ID="I" KEY="114" ENTRY="Yes" LENGTH="3 "/>
   <textElement ID="I" KEY="115" ENTRY="No" LENGTH="2 "/>
   <textElement ID="I" KEY="116" ENTRY="ABAP Documentation" LENGTH="18 "/>
   <textElement ID="I" KEY="117" ENTRY="Syntax Diagram" LENGTH="14 "/>
   <textElement ID="I" KEY="118" ENTRY="You have unsaved modifications of the result list." LENGTH="50 "/>
   <textElement ID="I" KEY="119" ENTRY="Do you really want to cancel editing?" LENGTH="37 "/>
   <textElement ID="I" KEY="120" ENTRY="Warning" LENGTH="7 "/>
   <textElement ID="I" KEY="121" ENTRY="You have unsaved modifications of the result list of a command" LENGTH="62 "/>
   <textElement ID="I" KEY="122" ENTRY="Do you really want to exit?" LENGTH="27 "/>
   <textElement ID="I" KEY="123" ENTRY="Exif from the application" LENGTH="25 "/>
   <textElement ID="I" KEY="124" ENTRY="Lock records" LENGTH="12 "/>
   <textElement ID="I" KEY="125" ENTRY="Unlock records" LENGTH="14 "/>
   <textElement ID="I" KEY="126" ENTRY="Deleted records" LENGTH="15 "/>
   <textElement ID="I" KEY="127" ENTRY="Updated records" LENGTH="15 "/>
   <textElement ID="I" KEY="128" ENTRY="Inserted records" LENGTH="16 "/>
   <textElement ID="I" KEY="129" ENTRY="Simulate" LENGTH="8 "/>
   <textElement ID="I" KEY="130" ENTRY="Move Result Set" LENGTH="15 "/>
   <textElement ID="I" KEY="131" ENTRY="Update other table" LENGTH="18 "/>
   <textElement ID="I" KEY="132" ENTRY="Insert into other table" LENGTH="23 "/>
   <textElement ID="I" KEY="133" ENTRY="Modify other table" LENGTH="18 "/>
   <textElement ID="I" KEY="134" ENTRY="Current Commands" LENGTH="16 "/>
   <textElement ID="I" KEY="135" ENTRY="My Repository" LENGTH="13 "/>
   <textElement ID="I" KEY="136" ENTRY="Application Components" LENGTH="22 "/>
   <textElement ID="I" KEY="137" ENTRY="Table/Value range" LENGTH="17 "/>
   <textElement ID="I" KEY="138" ENTRY="Select" LENGTH="6 "/>
   <textElement ID="I" KEY="139" ENTRY="Update" LENGTH="6 "/>
   <textElement ID="I" KEY="140" ENTRY="Delete" LENGTH="6 "/>
   <textElement ID="I" KEY="141" ENTRY="Loop at Workbench" LENGTH="17 "/>
   <textElement ID="I" KEY="142" ENTRY="Select for all entries..." LENGTH="25 "/>
   <textElement ID="I" KEY="143" ENTRY="Domain:" LENGTH="7 "/>
   <textElement ID="I" KEY="144" ENTRY="Length:" LENGTH="7 "/>
   <textElement ID="I" KEY="145" ENTRY="Description" LENGTH="11 "/>
   <textElement ID="I" KEY="146" ENTRY="Navigation Tree" LENGTH="15 "/>
   <textElement ID="I" KEY="147" ENTRY="Recognize tables" LENGTH="16 "/>
   <textElement ID="I" KEY="148" ENTRY="Advanced Paste" LENGTH="14 "/>
   <textElement ID="I" KEY="149" ENTRY="(...) SUBQUERY for Checktable" LENGTH="29 "/>
   <textElement ID="I" KEY="150" ENTRY="Field Selector" LENGTH="14 "/>
   <textElement ID="I" KEY="151" ENTRY="Check" LENGTH="5 "/>
   <textElement ID="I" KEY="152" ENTRY="* Original command text:" LENGTH="24 "/>
   <textElement ID="I" KEY="153" ENTRY="Delete backup table" LENGTH="19 "/>
   <textElement ID="I" KEY="154" ENTRY="Column options" LENGTH="14 "/>
   <textElement ID="I" KEY="155" ENTRY="First page" LENGTH="10 "/>
   <textElement ID="I" KEY="156" ENTRY="Previous page" LENGTH="13 "/>
   <textElement ID="I" KEY="157" ENTRY="Next page" LENGTH="9 "/>
   <textElement ID="I" KEY="158" ENTRY="Last page" LENGTH="9 "/>
   <textElement ID="I" KEY="159" ENTRY="Do you really wanto to display all records?" LENGTH="43 "/>
   <textElement ID="I" KEY="160" ENTRY="Show all records" LENGTH="16 "/>
   <textElement ID="I" KEY="161" ENTRY="Confirmation" LENGTH="12 "/>
   <textElement ID="I" KEY="162" ENTRY="Report generated by Hovitaga Report Generator" LENGTH="45 "/>
   <textElement ID="I" KEY="163" ENTRY="at" LENGTH="2 "/>
   <textElement ID="I" KEY="164" ENTRY="Report title:" LENGTH="13 "/>
   <textElement ID="I" KEY="165" ENTRY="Created by:" LENGTH="11 "/>
   <textElement ID="I" KEY="166" ENTRY="Created on:" LENGTH="11 "/>
   <textElement ID="I" KEY="167" ENTRY="Fields for the selection screen" LENGTH="31 "/>
   <textElement ID="I" KEY="168" ENTRY="You have unsaved modifications of a command text" LENGTH="48 "/>
   <textElement ID="I" KEY="169" ENTRY="Linked Query Assistant" LENGTH="22 "/>
   <textElement ID="R" KEY="170" ENTRY="SQL" LENGTH="36 "/>
  </language>
 </textPool>
 <dynpros>
  <dynpro PROG="ZSQL_APC" DNUM="0100" FNUM="0100" BZMX="0 " BZBR="0 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="27 " NOCO="120 " VALP="0 " CUAN="G" SPRA="S" DTEXT="">
   <dynprofield FNAM="OK_CODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
   <dynproflowsource>PROCESS BEFORE OUTPUT.
MODULE status_0100.

PROCESS AFTER INPUT.
MODULE user_command_0100_exit.
MODULE user_command_0100.</dynproflowsource>
  </dynpro>
 </dynpros>
 <pfstatus>
  <pfstatus_sta CODE="100_MAIN" MODAL="D" ACTCODE="000001" PFKCODE="000001" BUTCODE="0001" INT_NOTE="MAIN"/>
  <pfstatus_fun CODE="BACK" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="BACK"/>
  <pfstatus_fun CODE="CANCEL" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="BACK"/>
  <pfstatus_fun CODE="EXEC" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Execute" INFO_TEXT="Execute"/>
  <pfstatus_fun CODE="EXIT" TEXTNO="001" TEXT_TYPE="S" FUN_TEXT="BACK"/>
  <pfstatus_fun CODE="SIMULATE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SIMULATE" ICON_ID="@8Z@" FUN_TEXT="Simulate" INFO_TEXT="Simulate"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="01" PFNO="08"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="02" PFNO="20"/>
  <pfstatus_pfk CODE="000001" PFNO="03" FUNCODE="BACK" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="08" FUNCODE="EXEC" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="12" FUNCODE="CANCEL" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="15" FUNCODE="EXIT" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="20" FUNCODE="SIMULATE" FUNNO="001"/>
  <pfstatus_set STATUS="100_MAIN" FUNCTION="BACK"/>
  <pfstatus_set STATUS="100_MAIN" FUNCTION="CANCEL"/>
  <pfstatus_set STATUS="100_MAIN" FUNCTION="EXEC"/>
  <pfstatus_set STATUS="100_MAIN" FUNCTION="EXIT"/>
  <pfstatus_set STATUS="100_MAIN" FUNCTION="SIMULATE"/>
  <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000001" MODAL="D" INT_NOTE="MAIN"/>
  <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000001" MODAL="D" INT_NOTE="MAIN"/>
  <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000001" MODAL="D" NORM="0" INT_NOTE="MAIN"/>
  <pfstatus_tit CODE="100_TITLE" TEXT="&amp;"/>
 </pfstatus>
 <source>REPORT zsql_apc MESSAGE-ID zsql_free.

TYPE-POOLS: abap, icon, rsds, sqlt, trdev, slis.

TYPES: lty_commandtype(2) TYPE n.
TYPES: lty_keycol_type TYPE c.
TYPES: lty_last_display_mode TYPE c.
TYPES: lty_commandid TYPE i.
TYPES: lty_zhtdb_table_type TYPE c.

TYPES: lty_zhtdb_vrange_text(255) TYPE c.

TYPES: BEGIN OF lty_zhtdb_alv_tab,
         ddtext    TYPE lty_zhtdb_vrange_text,
         tablename TYPE tabname,
         fieldname TYPE fieldname,
         alias     TYPE tabname,
       END OF lty_zhtdb_alv_tab.

TYPES: BEGIN OF lty_zhtdb_checktable_struc,
         tabname    TYPE tabname,
         fieldname  TYPE forfield,
         forkey     TYPE forkey,
         cardleft   TYPE cardleft,
         card       TYPE card,
         checktable TYPE checktable,
       END OF lty_zhtdb_checktable_struc.

TYPES: lty_zhtdb_join_text(512) TYPE c.

TYPES: BEGIN OF lty_zhtdb_checktable_struc_alv,
         tabname  TYPE tabname,
         ddtext   TYPE as4text,
         longtext TYPE lty_zhtdb_join_text,
       END OF lty_zhtdb_checktable_struc_alv.

TYPES: BEGIN OF lty_zhtdb_fieldinfo,
         table           TYPE tabname,
         field           TYPE fieldname,
         is_key	         TYPE flag,
         orig_field	     TYPE char50,
         field_alias     TYPE char50,
         table_alias     TYPE char50,
         agg_function	   TYPE char50,
         distinctf       TYPE flag,
         generated_field TYPE char50,
         samecount       TYPE int4,
       END OF lty_zhtdb_fieldinfo.

TYPES: BEGIN OF lty_zhtdb_keyword,
         keyword   TYPE string,
         required	 TYPE c,
         order_pos TYPE i,
         begins_at TYPE i,
         ends_at   TYPE i,
         additions TYPE string,
         text	     TYPE string,
       END OF lty_zhtdb_keyword.

TYPES: BEGIN OF lty_zhtdb_sign_pos,
         position TYPE i,
         type(3)  TYPE c,
       END OF lty_zhtdb_sign_pos.

TYPES: BEGIN OF lty_zhtdb_table_aliases,
         table         TYPE tabname,
         alias         TYPE  string,
         explain_alias TYPE string,
         type	         TYPE lty_zhtdb_table_type,
         position	     TYPE i,
       END OF lty_zhtdb_table_aliases.

TYPES: lty_zhtdbt_string_tab TYPE TABLE OF string.


TYPES: lty_zhtdb_fieldinfo_tt TYPE TABLE OF lty_zhtdb_fieldinfo.
TYPES: lty_zhtdb_sign_pos_tt TYPE TABLE OF lty_zhtdb_sign_pos.



TYPES: lty_zhtdb_table_aliases_tt TYPE TABLE OF lty_zhtdb_table_aliases.

TYPES: BEGIN OF lty_zhdb_vrange,
         alias      TYPE tabname,
         rsds_range TYPE rsds_range,
       END OF lty_zhdb_vrange.

TYPES: lty_zhdb_vrange_tab TYPE STANDARD TABLE OF lty_zhdb_vrange.

CONSTANTS: gc_line_length            TYPE i VALUE 132.

CONSTANTS: gc_ctype_select TYPE lty_commandtype VALUE 1,
           gc_ctype_lawb   TYPE lty_commandtype VALUE 4,
           gc_ctype_selfae TYPE lty_commandtype VALUE 5,
           gc_ctype_script TYPE lty_commandtype VALUE 6.


* Distinguish the possible nodes
TYPES: lty_colmn_header TYPE c.

TYPES: BEGIN OF ty_notes,
         line(gc_line_length) TYPE c,
       END OF ty_notes.

TYPES: gty_tb_name  TYPE dd02d-dbtabname,
       gty_fld_name TYPE dd03p-fieldname.

TYPES: gty_fieldinfo     TYPE lty_zhtdb_fieldinfo.

TYPES: gty_table_aliases TYPE lty_zhtdb_table_aliases.

TYPES: BEGIN OF gty_ddicref,
         fieldname  TYPE gty_fld_name,
         checktable TYPE tabname,
         ref_table  TYPE gty_tb_name,
         ref_field  TYPE gty_fld_name,
         key        TYPE c,
       END OF gty_ddicref.

TYPES: BEGIN OF source,
         line(gc_line_length) TYPE c,
       END OF source.

*source_table TYPE rcg_bag_rssource.
TYPES: source_table    TYPE soli_tab.

TYPES: gty_commandtext TYPE string.

TYPES: BEGIN OF gty_linkedquery,
         fcode         TYPE ui_func,
         tabname       TYPE gty_tb_name,
         checktable    TYPE gty_tb_name,
         fieldname     TYPE gty_fld_name,
         checkfield    TYPE gty_fld_name,
         text(40)      TYPE c,
         longtext(255) TYPE c,
         join_type     TYPE c,
         ddtext        TYPE dd02t-ddtext,
         primpos       TYPE dd05m-primpos,
       END OF gty_linkedquery.

TYPES: BEGIN OF gty_ranges,
*        tablename     TYPE dd02d-dbtabname,
         table_alias TYPE string,
         fieldname   TYPE dd03p-fieldname,
         range       TYPE rsds_selopt_t,
         node_text   TYPE lvc_value,
         node_key    TYPE lvc_nkey,
         where_text  TYPE string,
       END OF gty_ranges.

TYPES: BEGIN OF gty_tab_node_xref,
         node_key  TYPE lvc_nkey,
         tablename TYPE tabname,
         alias     TYPE string,
       END OF gty_tab_node_xref.

TYPES: BEGIN OF gty_alias_ranges,
         table_alias TYPE string,
         fields      TYPE rsdsfields_t,
         expr        TYPE rsds_texpr, &quot; zhtdb_exprtab,
         sel_id      TYPE rsdynsel-selid,
         active      TYPE i,
       END OF gty_alias_ranges.

TYPES: BEGIN OF mty_t_type,
         line(255),
       END OF mty_t_type.

FIELD-SYMBOLS: &lt;gt_result&gt;  TYPE STANDARD TABLE,
               &lt;gt_display&gt; TYPE STANDARD TABLE,
               &lt;gt_temp&gt;    TYPE STANDARD TABLE,
               &lt;gt_tree&gt;    TYPE STANDARD TABLE,
               &lt;gt_undo&gt;    TYPE STANDARD TABLE,
               &lt;gs_result&gt;,
               &lt;gf_result&gt;,
               &lt;gs_temp&gt;,
               &lt;gs_undo&gt;.


DATA: gv_def_col_hdr     TYPE lty_colmn_header,
      gv_def_keycol_type TYPE lty_keycol_type,

      gv_0100_first_run  TYPE flag VALUE &apos;X&apos;.

DATA: gs_tab_node_xref TYPE gty_tab_node_xref.

DATA: gs_linkedquery      TYPE gty_linkedquery,
      gt_linkedquery      TYPE TABLE OF gty_linkedquery,

      gs_linkedquery_comp TYPE gty_linkedquery,
      gt_linkedquery_comp TYPE TABLE OF gty_linkedquery.


DATA: gs_ranges              TYPE gty_ranges.

DATA: ok_code      TYPE sy-ucomm.

DATA: g_textedit             TYPE REF TO cl_gui_abapedit. &quot;cl_gui_textedit.

DATA: g_alv              TYPE REF TO cl_gui_alv_grid,
      gs_layo            TYPE lvc_s_layo,
      gt_toolbar_exclude TYPE ui_functions,
      gs_toolbar_exclude TYPE ui_func.

DATA: g_tree_tb         TYPE REF TO cl_gui_alv_tree,
      gs_fcat_tb        TYPE lvc_s_fcat,
      gt_fcat_tb        TYPE lvc_t_fcat,
      gs_layo_tb        TYPE lvc_s_layo,
      gs_outtab_tb      TYPE lty_zhtdb_alv_tab,
      g_toolbar_tb_tree TYPE REF TO cl_gui_toolbar.

DATA: autotrace(1)       TYPE c.


*----------------------------------------------------------------------*
*       CLASS lcl_event_grid DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_event_grid DEFINITION INHERITING FROM zcl_ap_alv_grid_eventos.
  PUBLIC SECTION.
    METHODS: double_click REDEFINITION,
      user_command REDEFINITION,
      data_changed REDEFINITION.
ENDCLASS.                    &quot;lcl_event_grid DEFINITION

*APC20160419
DATA: o_alv           TYPE REF TO zcl_ap_alv_grid,
      o_event         TYPE REF TO lcl_event_grid,
      i_sql           TYPE TABLE OF ztemps,
      l_sql           TYPE ztemps,
      v_comando       TYPE string,
      i_lineas        TYPE TABLE OF text255,
      l_linea         TYPE text255,
      ztemps          TYPE ztemps,
      *ztemps         TYPE ztemps,
      i_lineas_sql    TYPE source_table,
      v_es_report,
      v_nombre_report TYPE string.




START-OF-SELECTION.

  CALL SCREEN 100.

*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZHTDB_CLASSES                                    *
*&amp;---------------------------------------------------------------------*



CLASS lcl_toolbox DEFINITION.

*&quot;* public components of class LCL_TOOLBOX
*&quot;* do not include other source files here!!!
  PUBLIC SECTION.

    CLASS-METHODS split_string
      IMPORTING
        !iv_string     TYPE string
        !iv_maxlen     TYPE i
        !iv_log_handle TYPE balloghndl OPTIONAL
      EXPORTING
        !et_string_tab TYPE lty_zhtdbt_string_tab.
    CLASS-METHODS get_word_at_pos
      IMPORTING
        !iv_string   TYPE string
        !iv_position TYPE i
      EXPORTING
        !ev_word     TYPE string.
    CLASS-METHODS parse_aptph
      IMPORTING
        !iv_condense   TYPE flag DEFAULT &apos;X&apos;
        !iv_log_handle TYPE balloghndl OPTIONAL
      EXPORTING
        !et_aptph_pos  TYPE lty_zhtdb_sign_pos_tt
        !et_paranth    TYPE lty_zhtdb_sign_pos_tt
      CHANGING
        !cv_string     TYPE string
      EXCEPTIONS
        missing_aptph
        missing_parnth .
    CLASS-METHODS select_single_gen
      IMPORTING
        !is_key_value  TYPE REF TO data
        !iv_table_name TYPE strukname
        !it_keyf_list  TYPE lty_zhtdbt_string_tab
      EXPORTING
        !es_record     TYPE REF TO data .
    CLASS-METHODS convert_to_uppercase
      CHANGING
        !cv_string TYPE string .
    CLASS-METHODS pretty_printer
      CHANGING
        !ct_source TYPE soli_tab .
    CLASS-METHODS is_client_field
      IMPORTING
        !iv_tabname            TYPE tabname
        !iv_fieldname          TYPE fieldname
      RETURNING
        VALUE(ev_client_field) TYPE char1 .
    CLASS-METHODS has_client_field
      IMPORTING
        !iv_tabname                TYPE tabname
      RETURNING
        VALUE(ev_has_client_field) TYPE char1 .
    CLASS-METHODS pretty_printer_string
      CHANGING
        !ct_source TYPE lty_zhtdbt_string_tab .

ENDCLASS.                    &quot;LCL_TOOLBOX DEFINITION

*----------------------------------------------------------------------*
*       CLASS LCL_TOOLBOX IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_toolbox IMPLEMENTATION.

  METHOD get_word_at_pos.

    DATA: lv_length TYPE i,
          lv_char   TYPE char1,
          lv_shift  TYPE i,
          lv_start  TYPE i,
          lv_end    TYPE i.


    lv_length = strlen( iv_string ).

* check if position is valid
    IF lv_length   &lt; iv_position OR
       iv_position &lt; 1.
      RETURN.
    ENDIF.

    lv_shift = iv_position - 1.
    lv_char = iv_string+lv_shift(1).

* space does not matter
    IF lv_char = space.
      RETURN.
    ENDIF.

* determine start
    DO.
      lv_char = iv_string+lv_shift(1).

      IF lv_char = space.
        lv_start = lv_shift + 1.
        EXIT.
      ENDIF.

      lv_shift = lv_shift - 1.
      IF lv_shift &lt; 0.
        lv_start = lv_shift + 1.
        EXIT.
      ENDIF.
    ENDDO.

* determine end
    lv_shift = iv_position - 1.
    DO.
      lv_char = iv_string+lv_shift(1).

      IF lv_char = space.
        lv_end = lv_shift.
        EXIT.
      ENDIF.

      lv_shift = lv_shift + 1.
      IF lv_shift = lv_length.
        lv_end = lv_shift.
        EXIT.
      ENDIF.
    ENDDO.

    lv_length = lv_end - lv_start.
    ev_word = iv_string+lv_start(lv_length).

  ENDMETHOD.                    &quot;

  METHOD split_string.

    DATA: lt_aptph_pos TYPE lty_zhtdb_sign_pos_tt,
          ls_aptph_pos TYPE lty_zhtdb_sign_pos,
          lv_string    TYPE string,
          lv_newstr    TYPE string,
          lv_actstr    TYPE string,
          lv_char      TYPE c,
          lv_shift     TYPE i,
          lv_lastsp    TYPE i,
          lv_length    TYPE i,
          lv_strg_lgth TYPE i,
          lv_index     TYPE i.


    IF iv_string IS INITIAL.
      RETURN.
    ENDIF.

    lv_string = iv_string.

    parse_aptph( EXPORTING  iv_condense   = space
                            iv_log_handle = iv_log_handle
                 IMPORTING  et_aptph_pos  = lt_aptph_pos
                 CHANGING   cv_string     = lv_string
                 EXCEPTIONS OTHERS        = 1 ).

    lv_shift = -1.
    lv_strg_lgth = strlen( lv_string ).

    DO.
      lv_shift = lv_shift + 1.
      IF lv_shift &gt;= lv_strg_lgth.
        EXIT.
      ENDIF.

      lv_char = lv_string+lv_shift(1).  &quot; current character

      IF lv_char = space.
        CONCATENATE lv_actstr lv_char INTO lv_actstr
          SEPARATED BY space.   &quot; otherwise the SPACE will be lost ...
        lv_length = lv_length + 1.

*     check, if the SPACE is inside of apostrophes
        lv_index = lv_shift + 1.
        READ TABLE lt_aptph_pos INDEX lv_index INTO ls_aptph_pos.

        IF ls_aptph_pos-type = &apos;O&apos;.  &quot; outside of apostrophes
          IF lv_length &gt; iv_maxlen.
*       the length of actual line is bigger than the maximum allowed
            IF lv_lastsp &lt;&gt; 0.   &quot; there is a right position to cut
*           cut string at the last SPACE to get the current line
              lv_newstr = lv_actstr(lv_lastsp).
              IF lv_newstr(1) = &apos;*&apos;.
                SHIFT lv_newstr RIGHT BY 1 PLACES.
              ENDIF.

*           the rest is the new line
              lv_actstr = lv_actstr+lv_lastsp.
              lv_length = lv_length - lv_lastsp.
              lv_lastsp = lv_length.
              APPEND lv_newstr TO et_string_tab.

*           the new line might be already longer, than allowed
              IF lv_length &gt;= iv_maxlen.
                IF lv_actstr(1) = &apos;*&apos;.
                  SHIFT lv_actstr RIGHT BY 1 PLACES.
                ENDIF.
                APPEND lv_actstr TO et_string_tab.
                CLEAR lv_actstr.
                lv_length = 0.
              ENDIF.
            ELSE.    &quot; there is no right position to cut
              IF lv_actstr(1) = &apos;*&apos;.
                SHIFT lv_actstr RIGHT BY 1 PLACES.
              ENDIF.
              APPEND lv_actstr TO et_string_tab.
              CLEAR lv_actstr.
              lv_length = 0.
            ENDIF.
          ELSE.
*         this is the position of the last SPACE, where the string can be cut,
*         if no better position will be found
            lv_lastsp = lv_length.
          ENDIF.
        ENDIF.
      ELSE.    &quot; not a SPACE
        CONCATENATE lv_actstr lv_char INTO lv_actstr.
        lv_length = lv_length + 1.
      ENDIF.
    ENDDO.

    IF lv_actstr IS NOT INITIAL.
      IF lv_length &gt; iv_maxlen.
*   the length of actual line is bigger than the maximum allowed
        IF lv_lastsp &lt;&gt; 0.   &quot; there is a right position to cut
*       cut string at the last SPACE to get the current line
          lv_newstr = lv_actstr(lv_lastsp).
          IF lv_newstr(1) = &apos;*&apos;.
            SHIFT lv_newstr RIGHT BY 1 PLACES.
          ENDIF.
          APPEND lv_newstr TO et_string_tab.

*       the rest is the new line
          lv_actstr = lv_actstr+lv_lastsp.
          IF lv_actstr(1) = &apos;*&apos;.
            SHIFT lv_actstr RIGHT BY 1 PLACES.
          ENDIF.
          APPEND lv_actstr TO et_string_tab.
        ELSE.    &quot; there is no right position to cut
          IF lv_actstr(1) = &apos;*&apos;.
            SHIFT lv_actstr RIGHT BY 1 PLACES.
          ENDIF.
          APPEND lv_actstr TO et_string_tab.
        ENDIF.
      ELSE.  &quot; length OK
        IF lv_actstr(1) = &apos;*&apos;.
          SHIFT lv_actstr RIGHT BY 1 PLACES.
        ENDIF.
        APPEND lv_actstr TO et_string_tab.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD parse_aptph.
* fills up the et_aptph_pos table: for each character of the command
* it sets the following flag:
*  - O - if the character is not part of a text
*  - A - if it is an apostrophe
*  - I - if it is part of a text

* fills up the et_paranth table with the positions of paranthesis

* executes a kind of CONDENSE, but outside of apostrophes only

    DATA: ls_aptph     LIKE LINE OF et_aptph_pos,
          ls_paranth   LIKE LINE OF et_aptph_pos,

          lv_strg_lgth TYPE i,
          lv_char      TYPE c,

          lv_shift     TYPE i,
          lv_shift_sp  TYPE i,
          lv_shift_end TYPE i,
          lv_next      TYPE i,
          lv_in_apostr TYPE xfeld,
          lv_par_cnt   TYPE i.


    IF cv_string IS INITIAL.
      RETURN.
    ENDIF.

    lv_shift = -1.
    lv_strg_lgth = strlen( cv_string ).

    DO.
      lv_shift = lv_shift + 1.
      IF lv_shift &gt;= lv_strg_lgth.
        EXIT.
      ENDIF.

      lv_char = cv_string+lv_shift(1).  &quot; current character

      IF lv_char = &apos;&apos;&apos;&apos;.

        IF lv_in_apostr = &apos; &apos;.
*       =&gt; beginning of a text
          lv_in_apostr = &apos;X&apos;.   &quot; mark, that we are within a text

          ls_aptph-position = lv_shift + 1.
          ls_aptph-type = &apos;A&apos;.
          APPEND ls_aptph TO et_aptph_pos.

          CONTINUE.
        ENDIF.

*     we are within a text

*     the next apostrophe closes the text, if it isn&apos;t doubled!
*     then both will be ignored
*     =&gt; the next character must be checked
        lv_next = lv_shift + 1.

        IF lv_next &lt; lv_strg_lgth.

          IF cv_string+lv_next(1) = &apos;&apos;&apos;&apos;.
*         these two apostrophes will be ignored
            ls_aptph-position = lv_shift + 1.
            ls_aptph-type = &apos;I&apos;.
            APPEND ls_aptph TO et_aptph_pos.

            ls_aptph-position = lv_shift + 2.
            APPEND ls_aptph TO et_aptph_pos.

            lv_shift = lv_shift + 1.  &quot; skip next character
          ELSE.
*         this apostrophe closes the text
            IF lv_in_apostr = &apos;X&apos;.
              lv_in_apostr = &apos; &apos;.   &quot; mark, that we are not in a text
            ENDIF.
            ls_aptph-position = lv_shift + 1.
            ls_aptph-type = &apos;A&apos;.
            APPEND ls_aptph TO et_aptph_pos.
          ENDIF.

        ELSE.

*       this apostrophe closes the text
          IF lv_in_apostr = &apos;X&apos;.
            lv_in_apostr = &apos; &apos;.   &quot; mark, that we are not in a text
          ENDIF.
          ls_aptph-position = lv_shift + 1.
          ls_aptph-type = &apos;A&apos;.
          APPEND ls_aptph TO et_aptph_pos.

        ENDIF.

      ELSE.  &quot; lv_char &lt;&gt; &apos;&apos;&apos;&apos;

        ls_aptph-position = lv_shift + 1.
        IF lv_in_apostr = &apos;X&apos;.  &quot; inside a text
          ls_aptph-type = &apos;I&apos;.
        ELSE.
          ls_aptph-type = &apos;O&apos;.  &quot; outside of text
        ENDIF.
        APPEND ls_aptph TO et_aptph_pos.

*     check for &apos;(&apos;
        IF lv_char      = &apos;(&apos; AND
           lv_in_apostr = &apos; &apos;.    &quot; not in a text

          lv_par_cnt = lv_par_cnt + 1.
          ls_paranth-type = lv_par_cnt.
          ls_paranth-position = lv_shift + 1.
          APPEND ls_paranth TO et_paranth.

        ENDIF.

*     check for &apos;)&apos;
        IF lv_char      = &apos;)&apos; AND
           lv_in_apostr = &apos; &apos;.    &quot; not in a text

          ls_paranth-type = lv_par_cnt.
          lv_par_cnt = lv_par_cnt - 1.
          ls_paranth-position = lv_shift + 1.
          APPEND ls_paranth TO et_paranth.

        ENDIF.

        IF iv_condense = &apos;X&apos;.
*       condense SPACEs (outside of apostrophes only!)
          IF lv_char      = space AND
             lv_in_apostr = &apos; &apos;.

            lv_shift_sp  = lv_shift + 1.
            lv_shift_end = lv_shift + 2.

            IF lv_shift_sp &gt;= lv_strg_lgth.
              EXIT.
            ENDIF.

            DO.
              IF lv_shift_sp &gt;= lv_strg_lgth.
                EXIT.
              ENDIF.

              lv_char = cv_string+lv_shift_sp(1).
              IF lv_char = space.
                lv_strg_lgth = lv_strg_lgth - 1.
*             remove SPACE from position lv_shift_sp + 1
                CONCATENATE cv_string(lv_shift_sp) cv_string+lv_shift_end INTO cv_string.
              ELSE.
                EXIT.
              ENDIF.
            ENDDO.

          ENDIF.
        ENDIF.

      ENDIF.

    ENDDO.

    IF lv_in_apostr = &apos;X&apos;.  &quot; the command was not closed properly

      IF iv_log_handle IS INITIAL.
*     Message: An ending apostrophe is missing
        MESSAGE e005 RAISING missing_aptph.
      ELSE.
        RAISE missing_aptph.
      ENDIF.

    ENDIF.

    IF lv_par_cnt &lt;&gt; 0.  &quot; the command was not closed properly
      IF iv_log_handle IS INITIAL.
*     Message: An closing paranthesis is missing
        MESSAGE e059 RAISING missing_parnth.
      ELSE.
        RAISE missing_parnth.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD select_single_gen.

    DATA: lv_keyfield TYPE fieldname,
          lr_data     TYPE REF TO data,
          lv_where    TYPE string,
          lv_keyval   TYPE string.

    FIELD-SYMBOLS: &lt;ls_data&gt;      TYPE any,
                   &lt;lv_keyval&gt;    TYPE any,
                   &lt;ls_keyfields&gt; TYPE any.


* create work area
    CREATE DATA lr_data TYPE (iv_table_name).
    ASSIGN lr_data-&gt;* TO &lt;ls_data&gt;.

    ASSIGN is_key_value-&gt;* TO &lt;ls_keyfields&gt;.

* create WHERE clause
    LOOP AT it_keyf_list INTO lv_keyfield.
      IF lv_where IS NOT INITIAL.
        CONCATENATE lv_where &apos;AND&apos; INTO lv_where
          SEPARATED BY space.
      ENDIF.

      ASSIGN COMPONENT lv_keyfield OF STRUCTURE &lt;ls_keyfields&gt; TO &lt;lv_keyval&gt;.
      lv_keyval = &lt;lv_keyval&gt;.

      CONCATENATE lv_where lv_keyfield &apos;= &apos;&apos;&apos; INTO lv_where
        SEPARATED BY space.
      CONCATENATE lv_where lv_keyval &apos;&apos;&apos;&apos; INTO lv_where.
    ENDLOOP.

    SELECT SINGLE * FROM (iv_table_name) INTO &lt;ls_data&gt;
      WHERE (lv_where).

    es_record = lr_data.

  ENDMETHOD.                    &quot;

  METHOD convert_to_uppercase.

    DATA: lt_aptph_pos TYPE lty_zhtdb_sign_pos_tt,
          lv_aptph     TYPE lty_zhtdb_sign_pos,
          lv_char      TYPE c,
          lv_uppercase TYPE string.


    CALL METHOD lcl_toolbox=&gt;parse_aptph
      EXPORTING
        iv_condense    = &apos; &apos;
        iv_log_handle  = &apos;DUMMY&apos;
      IMPORTING
        et_aptph_pos   = lt_aptph_pos
      CHANGING
        cv_string      = cv_string
      EXCEPTIONS
        missing_aptph  = 1
        missing_parnth = 2
        OTHERS         = 3.

    LOOP AT lt_aptph_pos INTO lv_aptph.

      lv_aptph-position = lv_aptph-position - 1.
      lv_char = cv_string+lv_aptph-position(1).

      IF lv_aptph-type EQ &apos;O&apos;.
        TRANSLATE lv_char TO UPPER CASE.
      ENDIF.

      IF lv_char = space.
        CONCATENATE lv_uppercase lv_char INTO lv_uppercase SEPARATED BY space.   &quot; otherwise the SPACE will be lost ...
      ELSE.
        CONCATENATE lv_uppercase lv_char INTO lv_uppercase.
      ENDIF.

    ENDLOOP.

    cv_string = lv_uppercase.

  ENDMETHOD.                    &quot;convert_to_uppercase

  METHOD pretty_printer.

    DATA: ls_source LIKE LINE OF ct_source,
          lv_string TYPE string,
          lv_tabix  TYPE i.


    LOOP AT ct_source INTO ls_source.
      lv_tabix = sy-tabix.
      lv_string = ls_source-line.

      CALL METHOD lcl_toolbox=&gt;convert_to_uppercase
        CHANGING
          cv_string = lv_string.

      ls_source-line = lv_string.

      MODIFY ct_source FROM ls_source INDEX lv_tabix.
    ENDLOOP.

  ENDMETHOD.                    &quot;pretty_printer

  METHOD is_client_field.

    DATA: lv_datatype  TYPE dd03l-datatype,
          lv_fieldname TYPE fieldname,
          lv_tabname   TYPE tabname,

          lt_x031l_tab TYPE TABLE OF x031l,
          ls_x031l     TYPE x031l.

    CLEAR ev_client_field.

    lv_tabname   = iv_tabname.
    lv_fieldname = iv_fieldname.

    TRANSLATE lv_tabname   TO UPPER CASE.
    TRANSLATE lv_fieldname TO UPPER CASE.

    SELECT SINGLE datatype
      FROM dd03l INTO lv_datatype
      WHERE tabname   = lv_tabname AND
            fieldname = lv_fieldname AND
            keyflag   = &apos;X&apos;.

    IF sy-subrc EQ 0.
      CALL FUNCTION &apos;DD_DICTIONARY_TO_NAMETAB&apos;
        EXPORTING
          foreign_key = &apos; &apos;
          status      = &apos;A&apos;
          tabname     = lv_tabname
        TABLES
          x031l_tab   = lt_x031l_tab.

      IF sy-subrc EQ 0.
        READ TABLE lt_x031l_tab INTO ls_x031l
          WITH KEY fieldname = lv_fieldname.

        IF ls_x031l-dtyp = &apos;CLNT&apos; AND ls_x031l-position = 1.
          ev_client_field = &apos;X&apos;.
        ENDIF.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;is_client_field

  METHOD has_client_field.

    DATA: x030l_wa TYPE x030l.


    CLEAR ev_has_client_field.

    CHECK iv_tabname IS NOT INITIAL.

    CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
      EXPORTING
        tabname        = iv_tabname
      IMPORTING
        x030l_wa       = x030l_wa
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.

    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
         WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    IF x030l_wa-clpos NE 0.
      ev_has_client_field = &apos;X&apos;.
    ENDIF.

  ENDMETHOD.                    &quot;has_client_field

  METHOD pretty_printer_string.

    DATA: ls_source LIKE LINE OF ct_source,
          lv_tabix  TYPE i.


    LOOP AT ct_source INTO ls_source.
      lv_tabix = sy-tabix.

      CALL METHOD lcl_toolbox=&gt;convert_to_uppercase
        CHANGING
          cv_string = ls_source.

      MODIFY ct_source FROM ls_source INDEX lv_tabix.
    ENDLOOP.

  ENDMETHOD.                    &quot;pretty_printer_string


ENDCLASS.                    &quot;LCL_TOOLBOX IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_lawb DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_lawb DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    &quot;lcl_lawb DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_lawb IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_lawb IMPLEMENTATION.

ENDCLASS.                    &quot;lcl_lawb IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_select_fae_command DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_select_fae_command DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    &quot;lcl_select_fae_command DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_select_fae_command IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_select_fae_command IMPLEMENTATION.

ENDCLASS.                    &quot;lcl_select_fae_command IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_update_command DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_update_command DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    &quot;lcl_update_command DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_update_command IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_update_command IMPLEMENTATION.

ENDCLASS.                    &quot;lcl_update_command IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_delete_command DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_delete_command DEFINITION.
  PUBLIC SECTION.
ENDCLASS.                    &quot;lcl_delete_command DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_delete_command IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_delete_command IMPLEMENTATION.

ENDCLASS.                    &quot;lcl_delete_command IMPLEMENTATION




*----------------------------------------------------------------------*
*       CLASS LCL_HTDB_CL_COMMAND DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command DEFINITION.

*&quot;* public components of class lcl_htdb_cl_command
*&quot;* do not include other source files here!!!
  PUBLIC SECTION.

    TYPES: BEGIN OF lty_zhdb_vrange,
             alias      TYPE tabname,
             rsds_range TYPE rsds_range,
           END OF lty_zhdb_vrange.

    TYPES: lty_zhdb_vrange_tab TYPE STANDARD TABLE OF lty_zhdb_vrange.

    METHODS create_new
      IMPORTING
        !iv_command_id     TYPE lty_commandid OPTIONAL
        !iv_command        TYPE string
        !it_vranges        TYPE lty_zhdb_vrange_tab OPTIONAL
        !iv_log_handle     TYPE balloghndl OPTIONAL
        !iv_test_from_file TYPE c OPTIONAL
      EXCEPTIONS
        no_id .
    METHODS is_client_spec
      RETURNING
        VALUE(ev_cspec) TYPE flag .
    METHODS constructor
      EXCEPTIONS
        no_id .
    METHODS get_id
      EXPORTING
        !ev_id TYPE guid_32 .
    METHODS execute
      IMPORTING
        !iv_simulation          TYPE flag OPTIONAL
        !iv_bg_proc             TYPE flag OPTIONAL
        !iv_bg_date             TYPE tbtcjob-sdlstrtdt OPTIONAL
        !iv_bg_time             TYPE tbtcjob-sdlstrttm OPTIONAL
      EXPORTING
        VALUE(er_result)        TYPE REF TO data
        !ev_dbcnt               TYPE sy-dbcnt
        VALUE(er_lock_argument) TYPE REF TO data
        !er_exc                 TYPE REF TO cx_root
        !ev_job_name            TYPE btcjob
        !ev_job_count           TYPE btcjobcnt
        !et_srccode             TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        parse_error
        exec_error
        job_submit_error
        table_locked
        no_auth_for_table
        no_auth_for_columns .
    METHODS parse
      EXCEPTIONS
        parse_error
        no_auth_for_table .
    METHODS get_message_dropped
      RETURNING
        VALUE(ev_message_dropped) TYPE char1 .
    METHODS get_where
      RETURNING
        VALUE(es_where) TYPE lty_zhtdb_keyword .
    METHODS get_command
      RETURNING
        VALUE(ev_command) TYPE string .
    TYPE-POOLS rsds .

*&quot;* protected components of class lcl_htdb_cl_command
*&quot;* do not include other source files here!!!
  PROTECTED SECTION.

    TYPES gty_keyword TYPE lty_zhtdb_keyword .

    DATA mv_command_id TYPE lty_commandid .
    DATA mv_parsed TYPE flag .
    DATA mv_prog_id TYPE guid_32. &quot;lty_gen_prog_nro .
    DATA mv_command TYPE string .
    DATA mt_vranges TYPE lty_zhdb_vrange_tab .
    DATA:
      mt_keywords TYPE STANDARD TABLE OF gty_keyword .
    DATA mt_aptph_pos TYPE lty_zhtdb_sign_pos_tt .
    CONSTANTS mc_prog_prefix TYPE string VALUE &apos;Z&apos;.  &quot; &apos;ZENITH_&apos;. &quot;#EC NOTEXT
    DATA mv_log_handle TYPE balloghndl .
    DATA ms_s_msg TYPE bal_s_msg .
    DATA mv_test_from_file TYPE c .
    DATA mv_message_dropped TYPE char1 .
    DATA mt_paranth TYPE lty_zhtdb_sign_pos_tt .
    DATA mt_query_depth TYPE lty_zhtdb_sign_pos_tt .
    DATA mv_jobname TYPE btcjob .
    DATA mv_jobcount TYPE btcjobcnt .
    METHODS call_gen_form
      IMPORTING
        !iv_program             TYPE programm
        !iv_bg_proc             TYPE flag OPTIONAL
        !iv_bg_date             TYPE tbtcjob-sdlstrtdt OPTIONAL
        !iv_bg_time             TYPE tbtcjob-sdlstrttm OPTIONAL
      EXPORTING
        !ev_dbcnt               TYPE sy-dbcnt
        VALUE(er_result)        TYPE REF TO data
        VALUE(er_lock_argument) TYPE REF TO data
        !er_exc                 TYPE REF TO cx_root
      EXCEPTIONS
        error
        job_submit_error
        table_locked .
    METHODS create_program
      IMPORTING
        !iv_program             TYPE programm
        !it_srccode             TYPE lty_zhtdbt_string_tab
        !iv_force_insert_report TYPE c OPTIONAL
      EXPORTING
        !ev_msg                 TYPE string
        !ev_line                TYPE int4
      EXCEPTIONS
        syntax_error
        internal_error .
    METHODS det_subquery .
    METHODS execute_int
      IMPORTING
        !iv_simulation          TYPE flag OPTIONAL
        !iv_bg_proc             TYPE flag OPTIONAL
        !iv_bg_date             TYPE tbtcjob-sdlstrtdt OPTIONAL
        !iv_bg_time             TYPE tbtcjob-sdlstrttm OPTIONAL
      EXPORTING
        !ev_dbcnt               TYPE sy-dbcnt
        VALUE(er_result)        TYPE REF TO data
        VALUE(er_lock_argument) TYPE REF TO data
        !er_exc                 TYPE REF TO cx_root
        !et_srccode             TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        syntax_error
        error
        job_submit_error
        table_locked
        no_auth_for_columns .
    METHODS generate_srccode
      EXPORTING
        et_srccode TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        error
        no_auth_for_columns .
    METHODS generate_vranges
      EXPORTING
        !et_srccode TYPE lty_zhtdbt_string_tab .
    METHODS parse_keywords
      EXCEPTIONS
        missing_keyword
        wrong_position
        wrong_keyword .
    METHODS parse_check_dot
      EXCEPTIONS
        parse_error .
    METHODS split_string
      IMPORTING
        !iv_string TYPE string
      EXPORTING
        et_words   TYPE lty_zhtdbt_string_tab .
    METHODS add_message
      IMPORTING
        !iv_msgty TYPE symsgty
        !iv_msgid TYPE symsgid
        !iv_msgno TYPE symsgno
        !iv_msgv1 TYPE any OPTIONAL
        !iv_msgv2 TYPE any OPTIONAL
        !iv_msgv3 TYPE any OPTIONAL
        !iv_msgv4 TYPE any OPTIONAL .

    TYPE-POOLS rsds .

ENDCLASS.                    &quot;LCL_HTDB_CL_COMMAND DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_HTDB_CL_COMMAND IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command IMPLEMENTATION.


  METHOD call_gen_form.
* calls the generated program to execute the command

    DATA: lx_root   TYPE REF TO cx_root,
          lv_locked TYPE flag.

* execute command
    TRY.
        PERFORM exec_command IN PROGRAM (iv_program)
          TABLES mt_vranges
          CHANGING lv_locked
                   ev_dbcnt.
      CATCH cx_root INTO lx_root.
*     Message: Internal error: generated program could not be called
        MESSAGE e003 RAISING error.
    ENDTRY.

    IF lv_locked = &apos;X&apos;.
*   Message: Table could not be locked
      MESSAGE e146 RAISING table_locked.
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD create_program.
* creates a repository program, which includes the command

    DATA: lv_program TYPE programm,
          lv_msg     TYPE string,
          lv_line    TYPE n,
          lv_word    TYPE char50,
          lt_str     TYPE TABLE OF string,
          ls_trdir   TYPE trdir,

          lv_str1    TYPE string,
          lv_str2    TYPE string,
          lv_str3    TYPE string,
          lv_str4    TYPE string.


    IF iv_program IS INITIAL.
      RETURN.
    ELSE.
      lv_program = iv_program.
    ENDIF.

* syntax check
    SYNTAX-CHECK FOR it_srccode
      MESSAGE lv_msg
      LINE lv_line
      WORD lv_word
      PROGRAM LV_PROGRAM.

    IF sy-subrc = 4.
      ev_line = lv_line.
      ev_msg  = lv_msg.

      IF mv_log_handle IS INITIAL.
        MESSAGE lv_msg TYPE &apos;I&apos; DISPLAY LIKE &apos;E&apos;.
        MESSAGE e019 RAISING syntax_error.
      ELSE.
*     split message to four parts (for four placeholders)
        CALL METHOD lcl_toolbox=&gt;split_string
          EXPORTING
            iv_log_handle = mv_log_handle
            iv_string     = lv_msg
            iv_maxlen     = 50
          IMPORTING
            et_string_tab = lt_str.

        READ TABLE lt_str INTO lv_str1 INDEX 1.
        READ TABLE lt_str INTO lv_str2 INDEX 2.
        READ TABLE lt_str INTO lv_str3 INDEX 3.
        READ TABLE lt_str INTO lv_str4 INDEX 4.

        CALL METHOD add_message(
            iv_msgty = &apos;E&apos;
            iv_msgid = &apos;ZSQL_FREE&apos;
            iv_msgno = &apos;085&apos;
            iv_msgv1 = lv_str1
            iv_msgv2 = lv_str2
            iv_msgv3 = lv_str3
            iv_msgv4 = lv_str4 ).

        IF iv_force_insert_report EQ &apos;X&apos;.
*       create program in repository
          TRANSLATE lv_program TO UPPER CASE.            &quot;#EC TRANSLANG
          INSERT REPORT lv_program FROM it_srccode.         &quot;#EC *
        ENDIF.

        RAISE syntax_error.
      ENDIF.

    ELSEIF sy-subrc = 8.
*   Message: Internal error during syntax check

      IF mv_log_handle IS INITIAL.
        MESSAGE e002 RAISING internal_error.
      ELSE.
        CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;002&apos; ).
        RAISE internal_error.
      ENDIF.

    ENDIF.

* create program in repository
    TRANSLATE lv_program TO UPPER CASE.                  &quot;#EC TRANSLANG
    DELETE REPORT LV_PROGRAM.

    lt_str[] = it_srccode[].

    CALL METHOD lcl_toolbox=&gt;pretty_printer_string
      CHANGING
        ct_source = lt_str.

    IF v_es_report = &apos;X&apos;.
      CLEAR ls_trdir.
      ls_trdir-name = lv_program = LV_PROGRAM.
      ls_trdir-clas = &apos;TEMP&apos;.
      ls_trdir-dbna = &apos; &apos;.
      ls_trdir-fixpt = &apos;X&apos;.
      ls_trdir-rstat = &apos;P&apos;.
      ls_trdir-subc = &apos;1&apos;.
      ls_trdir-rmand = sy-mandt.
      IF ls_trdir-sqlx LT &apos;R&apos;.
        ls_trdir-sqlx = &apos;R&apos;.
      ENDIF.
      MODIFY trdir FROM ls_trdir.
      INSERT REPORT lv_program FROM lt_str.
      GENERATE REPORT lv_program.
    ELSE.
      CLEAR ls_trdir.
      ls_trdir-name = lv_program = LV_PROGRAM.
      ls_trdir-rmand = sy-mandt.

      ls_trdir-subc = &apos;1&apos;.
      ls_trdir-fixpt = &apos;X&apos;.
      ls_trdir-uccheck = &apos;X&apos;.

*      cl_demo_output=&gt;display( lt_str ).

      INSERT REPORT lv_program FROM lt_str DIRECTORY ENTRY ls_trdir.
      GENERATE REPORT lv_program.
    ENDIF.


* mert a zsql futtataskor torli a nem lockoltakat!


    CALL FUNCTION &apos;ENQUEUE_ES_PROG&apos;
      EXPORTING
        mode_trdir     = &apos;E&apos;
        name           = lv_program
*       X_NAME         = &apos; &apos;
*       _SCOPE         = &apos;2&apos;
*       _WAIT          = &apos; &apos;
*       _COLLECT       = &apos; &apos;
      EXCEPTIONS
        foreign_lock   = 1
        system_failure = 2
        OTHERS         = 3.

    IF sy-subrc &lt;&gt; 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = sy-msgty
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE internal_error.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD det_subquery.

    DATA: lv_str_lgth    TYPE i,
          lt_query_depth LIKE mt_query_depth,
          ls_query_depth LIKE LINE OF mt_query_depth,
          ls_depth_old   LIKE LINE OF mt_query_depth,
          ls_depth_new   LIKE LINE OF mt_query_depth,
          lv_act_depth   TYPE i,
          ls_aptph       LIKE LINE OF mt_aptph_pos,
          lv_shift       TYPE i,
          lv_position    TYPE i,
          lv_subq_end    TYPE i,
          lt_subq_end    TYPE STANDARD TABLE OF i,
          lv_depth_old   TYPE i,
          lv_depth_new   TYPE i.


    IF mv_command IS INITIAL.
      RETURN.
    ENDIF.

    lv_str_lgth  = strlen( mv_command ).
    lv_act_depth = 1.
    lv_subq_end  = lv_str_lgth.
    APPEND lv_subq_end TO lt_subq_end.

* init lt_query_depth
    ls_query_depth-position = 1.
    ls_query_depth-type     = 1.
    APPEND ls_query_depth TO lt_query_depth.
    ls_query_depth-position = lv_str_lgth.
    ls_query_depth-type     = -1.
    APPEND ls_query_depth TO lt_query_depth.

    DO.
      lv_shift = lv_position + 1.

      SEARCH mv_command
        FOR &apos;. ( SELECT .&apos;
        STARTING AT lv_shift.

      IF sy-subrc EQ 0.
*        DEFINE add_keyword.
        lv_position = sy-fdpos + lv_shift + 1.

        READ TABLE mt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_position.

        IF ls_aptph-type = &apos;O&apos;.  &quot; it&apos;s not inside a text =&gt; found a new subquery
*       determine depth of the suqquery
          LOOP AT lt_subq_end INTO lv_subq_end.
            IF lv_position &lt; lv_subq_end.
              lv_act_depth = lv_act_depth + 1.
              EXIT.
            ELSE.
              lv_act_depth = lv_act_depth - 1.
              DELETE lt_subq_end.
            ENDIF.
          ENDLOOP.

*       mark beginning of the subqery
          ls_query_depth-position = lv_position.
          ls_query_depth-type     = lv_act_depth.
          APPEND ls_query_depth TO lt_query_depth.

*       find end of the suqery
          READ TABLE mt_paranth INTO ls_aptph
            WITH KEY position = lv_position.

          IF sy-subrc = 0.
*         now ls_aptph-type is the depth of the (
*         find the closing paranthesis - the next with the same depth
            lv_shift = sy-tabix + 1.
            LOOP AT mt_paranth FROM lv_shift INTO ls_aptph
                 WHERE type = ls_aptph-type.
              lv_subq_end = ls_aptph-position.
              INSERT lv_subq_end INTO lt_subq_end INDEX 1.
              EXIT.
            ENDLOOP.
          ENDIF.

*       mark end of subqery -&gt; use negative numbers!!
          ls_query_depth-position = lv_subq_end.
          ls_query_depth-type     = - lv_act_depth.
          APPEND ls_query_depth TO lt_query_depth.
        ENDIF.
*        END-OF-DEFINITION.
*        add_keyword.
      ELSE.
        EXIT.
*        SEARCH mv_command
*          FOR &apos;. ( UPDATE .&apos;
*          STARTING AT lv_shift.
*        IF sy-subrc = 0.
*          add_keyword.
*        ENDIF.
      ENDIF.

    ENDDO.

    SORT lt_query_depth BY position.

* complete query_depth table
    READ TABLE lt_query_depth INTO ls_depth_old INDEX 1.
    lv_act_depth = 1.

    LOOP AT lt_query_depth INTO ls_query_depth.
*   determine depth
      lv_depth_old = ls_depth_old-type.
      lv_depth_new = ls_query_depth-type.
      IF abs( lv_depth_old ) = abs( lv_depth_new ).
        IF lv_depth_old &lt; lv_depth_new.     &quot; between two subquerys on the same level
          lv_act_depth = lv_depth_new - 1.
        ELSE.
          lv_act_depth = lv_depth_old.       &quot; within one subquery
        ENDIF.
      ELSE.
        IF lv_depth_old &lt; lv_depth_new.      &quot; between subquery and new subquery, one level deeper
          lv_act_depth = lv_depth_old.
        ELSEIF lv_depth_old &gt; lv_depth_new.  &quot; between closed subquery and subquery one level higher
          lv_act_depth = - lv_depth_new.
        ENDIF.
      ENDIF.

*   complete missing positions
      lv_position = ls_depth_old-position + 1.
      WHILE ls_query_depth-position &gt; lv_position.
        ls_depth_new-position = lv_position.
        ls_depth_new-type     = lv_act_depth.
        APPEND ls_depth_new TO mt_query_depth.

        lv_position = lv_position + 1.
      ENDWHILE.

      ls_query_depth-type = abs( ls_query_depth-type ).
      APPEND ls_query_depth TO mt_query_depth.
      ls_depth_old = ls_query_depth.
    ENDLOOP.

  ENDMETHOD.                    &quot;

  METHOD execute_int.
* execute command

    DATA: lt_srccode             TYPE lty_zhtdbt_string_tab,
          lv_line                TYPE string,
          lv_force_insert_report TYPE c,
          lv_program             TYPE programm.


* create source code of the program
    CALL METHOD generate_srccode
      IMPORTING
        et_srccode          = lt_srccode
      EXCEPTIONS
        no_auth_for_columns = 1
        error               = 2
        OTHERS              = 3.

    IF sy-subrc = 1.
      MESSAGE e148 RAISING no_auth_for_columns.
    ELSEIF ( sy-subrc = 2 ) OR ( sy-subrc = 3 ).
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = &apos;E&apos;
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE error.
      ENDIF.
    ENDIF.

* program name
    lv_line = mv_prog_id.
    CONCATENATE mc_prog_prefix lv_line INTO lv_program.
    lv_program = lv_program(30).

*    IF v_es_report = &apos;X&apos;.
    GET TIME.
    lv_program = &apos;ZSQL_APC_TEMP&apos; &amp;&amp; &apos;_&apos; &amp;&amp; SY-UZEIT.
*    ENDIF.

    CALL FUNCTION &apos;RS_DELETE_PROGRAM&apos;
      EXPORTING
        program            = lv_program
        suppress_checks    = &apos;X&apos;
        suppress_popup     = &apos;X&apos;
        with_includes      = &apos; &apos;
        with_cua           = &apos; &apos;
        with_documentation = &apos; &apos;
        with_dynpro        = &apos; &apos;
        with_textpool      = &apos; &apos;
        skip_progress_ind  = &apos;X&apos;
      EXCEPTIONS
        enqueue_lock       = 1
        object_not_found   = 2
        permission_failure = 3
        reject_deletion    = 4
        OTHERS             = 5.

    IF mv_log_handle IS INITIAL.
      CLEAR lv_force_insert_report.
    ELSE.
      lv_force_insert_report = &apos;X&apos;.
    ENDIF.


* create program in the repository
    CALL METHOD create_program
      EXPORTING
        iv_program             = lv_program
        it_srccode             = lt_srccode
        iv_force_insert_report = lv_force_insert_report
      EXCEPTIONS
        syntax_error           = 1
        internal_error         = 2
        OTHERS                 = 3.

    IF sy-subrc &lt;&gt; 0.
      IF mv_log_handle IS INITIAL.
        IF sy-subrc &lt;&gt; 1.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
            RAISING error.
        ELSE.
*       the syntax check displayed the error already!
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
            RAISING syntax_error.
        ENDIF.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = &apos;E&apos;
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        IF sy-subrc &lt;&gt; 1.
          RAISE error.
        ELSE.
          RAISE syntax_error.
        ENDIF.
      ENDIF.
    ENDIF.

    IF iv_simulation IS INITIAL.
      IF v_es_report = &apos;X&apos;.
        SUBMIT (lv_program) VIA SELECTION-SCREEN AND RETURN.
      ELSE.
*   call generated program
        CALL METHOD call_gen_form
          EXPORTING
            iv_program       = lv_program
            iv_bg_proc       = iv_bg_proc
            iv_bg_date       = iv_bg_date
            iv_bg_time       = iv_bg_time
          IMPORTING
            er_result        = er_result
            ev_dbcnt         = ev_dbcnt
            er_lock_argument = er_lock_argument
            er_exc           = er_exc
          EXCEPTIONS
            job_submit_error = 1
            table_locked     = 2
            OTHERS           = 3.

        IF sy-subrc = 1.
          IF mv_log_handle IS INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                    RAISING job_submit_error.
          ELSE.
            CALL METHOD add_message(
                iv_msgty = &apos;E&apos;
                iv_msgid = sy-msgid
                iv_msgno = sy-msgno
                iv_msgv1 = sy-msgv1
                iv_msgv2 = sy-msgv2
                iv_msgv3 = sy-msgv3
                iv_msgv4 = sy-msgv4 ).
            RAISE job_submit_error.
          ENDIF.
        ENDIF.
      ENDIF.

      IF sy-subrc = 2.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING table_locked.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE table_locked.
        ENDIF.
      ENDIF.

      IF sy-subrc = 3.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE error.
        ENDIF.
      ENDIF.

    ENDIF.

* Siempre quiero borrarlo!
*    IF mv_log_handle IS NOT INITIAL.
**   if error occurred, keep the program
*      IF ms_s_msg IS INITIAL.
**   delete program from the repository

    CALL FUNCTION &apos;RS_DELETE_PROGRAM&apos;
      EXPORTING
        program            = lv_program
        suppress_checks    = &apos;X&apos;
        suppress_popup     = &apos;X&apos;
        with_includes      = &apos; &apos;
        with_cua           = &apos; &apos;
        with_documentation = &apos; &apos;
        with_dynpro        = &apos; &apos;
        with_textpool      = &apos; &apos;
        skip_progress_ind  = &apos;X&apos;
      EXCEPTIONS
        enqueue_lock       = 1
        object_not_found   = 2
        permission_failure = 3
        reject_deletion    = 4
        OTHERS             = 5.

    IF sy-subrc &lt;&gt; 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = &apos;E&apos;
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE error.
      ENDIF.
    ENDIF.
*      ENDIF.
*    ENDIF.

    et_srccode = lt_srccode.

  ENDMETHOD.                    &quot;


  METHOD create_new.

    DATA: lv_returncode TYPE inri-returncode.


    CLEAR: mv_prog_id.

    mv_command_id = iv_command_id.

*** get program ID from number range
**    CALL FUNCTION &apos;NUMBER_GET_NEXT&apos;
**      EXPORTING
**        nr_range_nr   = &apos;01&apos;
**        object        = &apos;ZHTDB_PROG&apos;
**        ignore_buffer = &apos;X&apos;
**      IMPORTING
**        number        = mv_prog_id
**        returncode    = lv_returncode
**      EXCEPTIONS
**        OTHERS        = 1.

*    CALL FUNCTION &apos;GUID_CREATE&apos;
*      IMPORTING
*        ev_guid_32 = mv_prog_id.
    mv_prog_id = &apos;ZSQL_APC_TEMP_012345678901234567&apos;.
    IF sy-subrc &lt;&gt; 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING no_id.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = &apos;E&apos;
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE no_id.
      ENDIF.
    ELSE.
      IF lv_returncode IS NOT INITIAL.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE &apos;S&apos; NUMBER &apos;116&apos; DISPLAY LIKE &apos;E&apos;
                  WITH lv_returncode sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING no_id.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = &apos;ZSQL_FREE&apos;
              iv_msgno = &apos;116&apos;
              iv_msgv1 = lv_returncode ).
          RAISE no_id.
        ENDIF.
      ELSE.
        COMMIT WORK.
      ENDIF.
    ENDIF.

* clear attributes
    CLEAR mv_command.
    CLEAR mt_aptph_pos.
    CLEAR mt_paranth.
    CLEAR mt_keywords.
    CLEAR mt_vranges.
    CLEAR mv_parsed.
    CLEAR ms_s_msg.

* take over data
    mv_command    = iv_command.    &quot; Open SQL command
    SHIFT mv_command RIGHT DELETING TRAILING &apos;. &apos;.

    mt_vranges    = it_vranges.    &quot; value ranges for the WHERE clause
    mv_log_handle = iv_log_handle. &quot; Application Log handle. If supplied, no messages given.

* If select commands are loaded from file, some messages are suppressed in add_message
    mv_test_from_file = iv_test_from_file.
* if a message is suppressed, this indicator is set, so no messages are logged from outside (ZSQL)
    CLEAR mv_message_dropped.

  ENDMETHOD.                    &quot;

  METHOD generate_srccode.
* generates a program source code, which includes the command

    DATA: lv_program TYPE programm,
          lv_line    TYPE string,
          lv_tmp     TYPE string.

    IF v_es_report = &apos;X&apos;.
      et_srccode = i_lineas.
      EXIT.
    ENDIF.

*****************************************************************************************
* create source code for the program

* build program name
    lv_tmp = mv_prog_id.
    CONCATENATE mc_prog_prefix lv_tmp INTO lv_program.

    lv_line = &apos;PROGRAM&apos;.
    CONCATENATE lv_line lv_program &apos;.&apos; INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

    APPEND &apos;  TYPE-POOLS: rsds.&apos; TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* FORM
    APPEND &apos;FORM exec_command TABLES pt_vranges CHANGING p_locked p_dbcnt.&apos; TO et_srccode.
    APPEND &apos;  DATA: lv_lock_argument(150) TYPE c,&apos;                          TO et_srccode.
    APPEND &apos;        lv_table              TYPE tabname.&apos;                    TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* create value range tables
    IF mt_vranges IS NOT INITIAL.
      generate_vranges( IMPORTING et_srccode = et_srccode ).
    ENDIF.

* insert command
    APPEND mv_command TO et_srccode.
    APPEND &apos;.&apos;        TO et_srccode.

* save SY-DBCNT
    APPEND &apos;  p_dbcnt = sy-dbcnt.&apos; TO et_srccode.
    APPEND &apos;ENDFORM.&apos;              TO et_srccode.

  ENDMETHOD.                    &quot;

  METHOD generate_vranges.

    DATA: ls_vrange   LIKE LINE OF mt_vranges,
          ls_frange   TYPE rsds_frange,
          lv_line     TYPE string,
          lv_index_vr TYPE sy-tabix,
          lv_index_fr TYPE sy-tabix.


    APPEND INITIAL LINE TO et_srccode.

* work area for value range entries
    APPEND &apos;  TYPES: BEGIN OF lty_zhdb_vrange,&apos;        TO et_srccode.
    APPEND &apos;           alias      TYPE tabname,&apos;       TO et_srccode.
    APPEND &apos;           rsds_range TYPE rsds_range,&apos;    TO et_srccode.
    APPEND &apos;  END OF lty_zhdb_vrange.&apos;                 TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.
    APPEND &apos;  TYPES: lty_zhdb_vrange_tab TYPE STANDARD TABLE OF lty_zhdb_vrange.&apos;                 TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.
    APPEND &apos;  DATA: ls_vrange TYPE lty_zhdb_vrange,&apos; TO et_srccode.
    APPEND &apos;        ls_frange TYPE rsds_frange.&apos; TO et_srccode.

    LOOP AT mt_vranges INTO ls_vrange.
      lv_index_vr = sy-tabix.

      LOOP AT ls_vrange-rsds_range-frange_t INTO ls_frange.
        lv_index_fr = sy-tabix.

*     define new value range table
        CONCATENATE &apos;  DATA: r_&apos; ls_vrange-alias &apos;_&apos; ls_frange-fieldname INTO lv_line.
        CONCATENATE lv_line &apos;TYPE RSDS_SELOPT_T.&apos; INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        lv_line = lv_index_vr.

*     take over content
        CONCATENATE &apos;  READ TABLE pt_vranges INDEX&apos; lv_line &apos;INTO ls_vrange.&apos; INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        lv_line = lv_index_fr.
        CONCATENATE &apos;  READ TABLE ls_vrange-rsds_range-frange_t INDEX&apos; lv_line &apos;INTO ls_frange.&apos; INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        CONCATENATE &apos;  r_&apos; ls_vrange-alias &apos;_&apos; ls_frange-fieldname INTO lv_line.
        CONCATENATE lv_line &apos;= ls_frange-selopt_t.&apos; INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        APPEND INITIAL LINE TO et_srccode.

      ENDLOOP.

    ENDLOOP.

  ENDMETHOD.                    &quot;


  METHOD parse_keywords.
* extracts keywords of the command and fills up the MT_KEYWORDS table

    DATA: lv_keyword      TYPE string,
          lv_search_str   TYPE string,
          ls_prev_keyword TYPE gty_keyword,
          ls_next_keyword TYPE gty_keyword,

          lv_length       TYPE i,
          lv_position     TYPE i,
          lv_ends_at      TYPE i,
          lv_lines        TYPE i,
          lv_index        TYPE i,
          lv_shift        TYPE i,
          lv_delta        TYPE i,
          ls_aptph        LIKE LINE OF mt_aptph_pos.

    FIELD-SYMBOLS: &lt;ls_keyword&gt; TYPE gty_keyword.

    IF v_es_report = &apos;X&apos;. EXIT. ENDIF.

* determine subquerys
    det_subquery( ).

************************************************************************
* get keywords

    lv_length = strlen( mv_command ).

* search for keywords
    LOOP AT mt_keywords ASSIGNING &lt;ls_keyword&gt;.
      lv_keyword = &lt;ls_keyword&gt;-keyword.
      CONCATENATE &apos;.&apos; lv_keyword &apos;.&apos; INTO lv_search_str
        SEPARATED BY space.

      CLEAR lv_position.

      DO.
        lv_shift = lv_position + 1.

        SEARCH mv_command
          FOR lv_search_str
          STARTING AT lv_shift.

        IF sy-subrc EQ 0.
          lv_position = sy-fdpos + lv_shift + 1.
          lv_ends_at  = lv_position + strlen( lv_keyword ) - 1.

          READ TABLE mt_aptph_pos INTO ls_aptph
            WITH KEY position = lv_position.

          IF ls_aptph-type = &apos;O&apos;.  &quot; it&apos;s not inside a text

            READ TABLE mt_query_depth INTO ls_aptph
              WITH KEY position = lv_position.

            IF ls_aptph-type = 1.  &quot; top level, not a subquery
*           keyword found
              &lt;ls_keyword&gt;-begins_at = lv_position.
              &lt;ls_keyword&gt;-ends_at   = lv_ends_at.

              IF &lt;ls_keyword&gt;-order_pos = 1 AND
              &lt;ls_keyword&gt;-begins_at &lt;&gt; 2.
                IF mv_log_handle IS INITIAL.
*               Message: Command does not begin with the keyword &apos;&amp;1&apos;
                  MESSAGE e088 WITH lv_keyword
                  RAISING missing_keyword.
                ELSE.
                  CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;088&apos; iv_msgv1 = lv_keyword ).

                  RAISE missing_keyword.
                ENDIF.
              ENDIF.

              EXIT.
            ENDIF.
          ENDIF.
        ELSE.
*       keyword not found at all
          CLEAR lv_position.
          EXIT.
        ENDIF.
      ENDDO.

      IF lv_position IS INITIAL AND
         &lt;ls_keyword&gt;-required = &apos;X&apos;.    &quot; required keyword

        IF mv_log_handle IS INITIAL.
*       Message: Keyword &apos;&amp;1&apos; is missing
          MESSAGE e006 WITH lv_keyword
            RAISING missing_keyword.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;006&apos; iv_msgv1 = lv_keyword ).

          RAISE missing_keyword.
        ENDIF.

      ENDIF.
    ENDLOOP.


************************************************************************
* check positions

* delete keywords, which are not defined in the current command
    DELETE mt_keywords WHERE begins_at IS INITIAL.

    SORT mt_keywords BY begins_at.

    LOOP AT mt_keywords ASSIGNING &lt;ls_keyword&gt;.
      IF ls_prev_keyword-order_pos &gt; &lt;ls_keyword&gt;-order_pos.
        IF mv_log_handle IS INITIAL.
*       Message: Wrong order of keywords: &amp;1 on wrong position
          MESSAGE e018 WITH &lt;ls_keyword&gt;-keyword
            RAISING wrong_position.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;006&apos; iv_msgv1 = ls_prev_keyword-keyword ).

          RAISE wrong_position.
        ENDIF.

      ENDIF.

      ls_prev_keyword = &lt;ls_keyword&gt;.
    ENDLOOP.

************************************************************************
* get texts

* MOVED before loop above: why loop through obsolete records?
** delete keywords, which are not defined in the current command
*  LOOP AT mt_keywords ASSIGNING &lt;ls_keyword&gt;
*       WHERE begins_at IS INITIAL.
*    DELETE mt_keywords.
*  ENDLOOP.

    DESCRIBE TABLE mt_keywords LINES lv_lines.

* get texts
    LOOP AT mt_keywords ASSIGNING &lt;ls_keyword&gt;.
      lv_index = sy-tabix + 1.

      IF lv_index &lt;= lv_lines.  &quot; til the position of the next keyword
        READ TABLE mt_keywords INTO ls_next_keyword
          INDEX lv_index.

        lv_shift = &lt;ls_keyword&gt;-ends_at + 1.
        lv_delta = ls_next_keyword-begins_at - lv_shift - 1.
      ELSE.                    &quot; til the end of the command
        lv_shift = &lt;ls_keyword&gt;-ends_at + 1.
        lv_delta = lv_length - lv_shift.
      ENDIF.

      MOVE mv_command+lv_shift(lv_delta) TO &lt;ls_keyword&gt;-text.  &quot; trim text

      lv_index = lv_index - 1.
      MODIFY mt_keywords INDEX lv_index FROM &lt;ls_keyword&gt;.
    ENDLOOP.

  ENDMETHOD. &quot;

  METHOD parse_check_dot.
* check that there is no new command after a closing dot

    DATA: lv_strg_lgth TYPE i,
          lv_char      TYPE c,
          lv_shift     TYPE i,
          lv_end       TYPE c,
          ls_aptph     LIKE LINE OF mt_aptph_pos.


    IF mv_command IS INITIAL.
      RETURN.
    ENDIF.

    IF v_es_report = &apos;X&apos;.
      EXIT.
    ENDIF.
*APC20160419
    IF NOT mv_command CS &apos;SELECT&apos;. EXIT. ENDIF.

    lv_strg_lgth = strlen( mv_command ).

* check dots
    DO.
      lv_char = mv_command+lv_shift(1).

      IF lv_end  = &apos;X&apos; AND
         lv_char IS NOT INITIAL.
        IF mv_log_handle IS INITIAL.
*       Message: &apos;Don&apos;&apos;t write any commands after the closing dot&apos;
          MESSAGE e001 RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;001&apos; ).

          RAISE parse_error.
        ENDIF.
      ENDIF.

      IF lv_char = &apos;.&apos;.
*     check that the dot is not inside a text
        READ TABLE mt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_shift.

        IF ls_aptph-type = &apos;O&apos;.  &quot; outside a text
          lv_end = &apos;X&apos;.          &quot; the dot closes the command
        ENDIF.
      ENDIF.

      lv_shift = lv_shift + 1.
      IF lv_shift &gt;= lv_strg_lgth.
        EXIT.
      ENDIF.
    ENDDO.

  ENDMETHOD.                    &quot;


  METHOD is_client_spec.

    DATA: ls_keyword LIKE LINE OF mt_keywords.


    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = &apos;CLIENT SPECIFIED&apos;.

    IF ls_keyword-begins_at IS NOT INITIAL.
      ev_cspec = &apos;X&apos;.
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD split_string.
* splits a string at SPACE, but outside apostrophes only

    DATA: lv_string    TYPE string,
          lt_aptph_pos LIKE mt_aptph_pos,
          lv_length    TYPE i,
          lv_shift     TYPE i,
          lv_pos       TYPE i,
          lv_char      TYPE c,
          lv_word      TYPE string,
          ls_aptph     LIKE LINE OF mt_aptph_pos.


    lv_string = iv_string.

    lcl_toolbox=&gt;parse_aptph(
      EXPORTING
        iv_condense  = space
      IMPORTING
        et_aptph_pos = lt_aptph_pos
      CHANGING
        cv_string    = lv_string ).
* get words
    lv_shift = -1.
    lv_length = strlen( iv_string ).

    DO.
      lv_shift = lv_shift + 1.

      IF lv_shift &gt;= lv_length.
        EXIT.
      ENDIF.

      lv_char = iv_string+lv_shift(1).

      IF lv_char = space.
        lv_pos = lv_shift + 1.

        READ TABLE lt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_pos.

        IF ls_aptph-type = &apos;O&apos;.

          IF lv_word IS NOT INITIAL.

            APPEND lv_word TO et_words.
            CLEAR lv_word.
          ENDIF.
          CONTINUE.
        ENDIF.
      ENDIF.

      CONCATENATE lv_word lv_char INTO lv_word.
    ENDDO.

* the last word
    IF lv_word IS NOT INITIAL.
      APPEND lv_word TO et_words.
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD add_message.

    IF     iv_msgid = &apos;SD&apos;    AND iv_msgno = 94.
      RETURN.
    ELSEIF iv_msgid = &apos;FL&apos;    AND iv_msgno = 714.
      RETURN.
    ELSEIF iv_msgid = &apos;VSCAN&apos; AND iv_msgno = 33.
      RETURN.
    ELSEIF iv_msgid = &apos;E4&apos;    AND iv_msgno = &apos;035&apos;.
      RETURN.
    ENDIF.

    IF mv_test_from_file EQ &apos;X&apos;.
      IF iv_msgid = &apos;ZSQL_FREE&apos;.
        IF iv_msgno = 14 OR iv_msgno = 68 OR iv_msgno = 16 OR iv_msgno = 36 OR iv_msgno = 8.
          mv_message_dropped = &apos;X&apos;.
          RETURN.
        ENDIF.
      ENDIF.
    ENDIF.

    CLEAR ms_s_msg.

    ms_s_msg-msgid = iv_msgid.
    ms_s_msg-msgno = iv_msgno.

    ms_s_msg-msgv1 = iv_msgv1.
    ms_s_msg-msgv2 = iv_msgv2.
    ms_s_msg-msgv3 = iv_msgv3.
    ms_s_msg-msgv4 = iv_msgv4.

    IF ms_s_msg IS INITIAL.
      RETURN.
    ENDIF.

    CONDENSE: ms_s_msg-msgv1, ms_s_msg-msgv2, ms_s_msg-msgv3, ms_s_msg-msgv4.

    ms_s_msg-msgty = iv_msgty.

    CALL FUNCTION &apos;BAL_LOG_MSG_ADD&apos;
      EXPORTING
        i_log_handle = mv_log_handle
        i_s_msg      = ms_s_msg
      EXCEPTIONS
        OTHERS       = 1.

    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

  ENDMETHOD.                    &quot;add_message


  METHOD constructor.


  ENDMETHOD.                    &quot;

  METHOD get_id.

    ev_id = mv_prog_id.

  ENDMETHOD.                    &quot;

  METHOD execute.
* execute command

    IF mv_command IS INITIAL.
      RETURN.
    ENDIF.

* parse command if needed
    IF mv_parsed IS INITIAL.
      CALL METHOD parse
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc &lt;&gt; 0.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE parse_error.
        ENDIF.

      ENDIF.
    ENDIF.

* execute command
    CALL METHOD execute_int
      EXPORTING
        iv_simulation       = iv_simulation
        iv_bg_proc          = iv_bg_proc
        iv_bg_date          = iv_bg_date
        iv_bg_time          = iv_bg_time
*       it_selscr_fields    = it_selscr_fields
      IMPORTING
        er_result           = er_result
        ev_dbcnt            = ev_dbcnt
        er_lock_argument    = er_lock_argument
        er_exc              = er_exc
        et_srccode          = et_srccode
      EXCEPTIONS
        error               = 1
        syntax_error        = 2
        job_submit_error    = 3
        table_locked        = 4
        no_auth_for_columns = 5
        OTHERS              = 6.

    CASE sy-subrc.
      WHEN 1.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING exec_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE exec_error.
        ENDIF.

      WHEN 2.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE parse_error.
        ENDIF.

      WHEN 3.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING job_submit_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE job_submit_error.
        ENDIF.

      WHEN 4.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING table_locked.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE table_locked.
        ENDIF.
      WHEN 5.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING no_auth_for_columns.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE no_auth_for_columns.
        ENDIF.
    ENDCASE.

    ev_job_name  = mv_jobname.
    ev_job_count = mv_jobcount.

  ENDMETHOD.                    &quot;

  METHOD parse.
* parse command and execute checks

    IF mv_parsed = &apos;X&apos;.
      RETURN.
    ELSE.
      mv_parsed = &apos;X&apos;.
    ENDIF.

* check apostrophes
    CLEAR mt_aptph_pos.
    CALL METHOD lcl_toolbox=&gt;parse_aptph
      EXPORTING
        iv_log_handle  = mv_log_handle
      IMPORTING
        et_aptph_pos   = mt_aptph_pos
        et_paranth     = mt_paranth
      CHANGING
        cv_string      = mv_command
      EXCEPTIONS
        missing_aptph  = 1
        missing_parnth = 2
        OTHERS         = 3.

    CASE sy-subrc.
      WHEN 1.
        IF mv_log_handle IS INITIAL.
*       Message: An ending apostrophe is missing
          MESSAGE e005 RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = &apos;ZSQL_FREE&apos;
              iv_msgno = &apos;005&apos; ).
          RAISE parse_error.
        ENDIF.

      WHEN 2.
        IF mv_log_handle IS INITIAL.
*       Message: An closing paranthesis is missing
          MESSAGE e059 RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = &apos;ZSQL_FREE&apos;
              iv_msgno = &apos;059&apos; ).
          RAISE parse_error.
        ENDIF.

      WHEN 3.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE parse_error.
        ENDIF.
    ENDCASE.

* if there is a closing dot, check that there is no new command after it
    parse_check_dot( EXCEPTIONS OTHERS = 1 ).

    IF sy-subrc &lt;&gt; 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = &apos;E&apos;
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

** determine subquerys
*  det_subquery( ).

* extract keywords
    parse_keywords( EXCEPTIONS OTHERS = 1 ).

    IF sy-subrc &lt;&gt; 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = &apos;E&apos;
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD get_message_dropped.

    ev_message_dropped = mv_message_dropped.

  ENDMETHOD.                    &quot;get_message_dropped

  METHOD get_where.

    CLEAR es_where.

    READ TABLE mt_keywords WITH KEY keyword = &apos;WHERE&apos;
      INTO es_where.

  ENDMETHOD.                    &quot;get_where

  METHOD get_command.

    ev_command = mv_command.

  ENDMETHOD.                    &quot;get_command

ENDCLASS.                    &quot;lcl_HTDB_CL_COMMAND IMPLEMENTATION



*----------------------------------------------------------------------*
*       CLASS LCL_HTDB_CL_COMMAND_SELECT  DEFINITIO
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command_select DEFINITION
  INHERITING FROM lcl_htdb_cl_command.

*&quot;* public components of class lcl_htdb_cl_command_select
*&quot;* do not include other source files here!!!
  PUBLIC SECTION.

    DATA mt_adt_tables TYPE lty_zhtdb_table_aliases_tt .

    METHODS can_edit
      RETURNING
        VALUE(ev_can_edit) TYPE char1 .
    METHODS get_fieldinfo
      EXPORTING
        !et_fieldinfo  TYPE lty_zhtdb_fieldinfo_tt
        !ev_can_edit   TYPE flag
        !ev_can_insert TYPE flag .
    METHODS get_program_name
      RETURNING
        VALUE(ev_program_name) TYPE programm .
    METHODS get_table_alias
      EXPORTING
        !et_table_alias TYPE lty_zhtdb_table_aliases_tt .
    METHODS get_texts
      EXPORTING
        !ev_select_text   TYPE string
        !ev_from_text     TYPE string
        !ev_where_text    TYPE string
        !ev_group_by_text TYPE string
        !ev_having_text   TYPE string
        !ev_order_by_text TYPE string .

    METHODS create_new
        REDEFINITION .
    METHODS parse
        REDEFINITION .


*&quot;* protected components of class lcl_htdb_cl_command_select
*&quot;* do not include other source files here!!!
  PROTECTED SECTION.

    TYPES:
      BEGIN OF gty_table_field,
        table    TYPE tabname,
        field    TYPE fieldname,
        keyflag  TYPE flag,
        position TYPE tabfdpos,
      END OF gty_table_field .

    DATA mt_fieldinfo TYPE lty_zhtdb_fieldinfo_tt .
    DATA mt_table_alias TYPE lty_zhtdb_table_aliases_tt .
    DATA:
      mt_table_fields TYPE STANDARD TABLE OF gty_table_field .
    DATA mv_sel_single TYPE flag .
    DATA mv_can_edit TYPE flag .
    DATA mv_can_insert TYPE flag .
    DATA mv_has_dupl_fields TYPE flag .
    CONSTANTS mc_type_name_res TYPE string VALUE &apos;GTY_RES&apos;. &quot;#EC NOTEXT
    CONSTANTS mc_type_name_tech_res TYPE string VALUE &apos;GTY_RES_TECH&apos;. &quot;#EC NOTEXT
    DATA mv_type_name_tech_res TYPE string .
    DATA mv_prog_id_str TYPE string .
    DATA mv_type_name_res TYPE string .
    DATA mv_program TYPE programm .
    CONSTANTS mc_result_prefix TYPE string VALUE &apos;GT_RES&apos;.  &quot;#EC NOTEXT
    DATA mv_result_name TYPE string .
    DATA mt_authorizations TYPE rsec_t_usvalues .
    DATA:
      mt_subqu_where TYPE STANDARD TABLE OF lty_zhtdb_keyword .

    METHODS extend_where_clause
      IMPORTING
        !iv_where_addition TYPE string .
    METHODS add_where_excl_all
      IMPORTING
        !iv_table          TYPE tabname
      CHANGING
        !cv_where_addition TYPE string .
    METHODS create_type
      IMPORTING
        !iv_type_name        TYPE string
        !it_fieldinfo        TYPE lty_zhtdb_fieldinfo_tt
        !iv_with_tech_fields TYPE c
      CHANGING
        !ct_srccode          TYPE lty_zhtdbt_string_tab .
    METHODS expand_asterisk
      EXCEPTIONS
        table_not_found .
    METHODS parse_adt_tables
      EXPORTING
        !et_table_alias TYPE lty_zhtdb_table_aliases_tt
      EXCEPTIONS
        parse_error .
    METHODS parse_check_fieldname
      IMPORTING
        !iv_word        TYPE string
        !it_keywords    TYPE lty_zhtdbt_string_tab OPTIONAL
      RETURNING
        VALUE(rv_valid) TYPE xfeld .
    METHODS parse_check_name
      IMPORTING
        !iv_word        TYPE string
        !it_keywords    TYPE lty_zhtdbt_string_tab OPTIONAL
      RETURNING
        VALUE(rv_valid) TYPE xfeld .
    METHODS parse_check_value
      IMPORTING
        !iv_word        TYPE string
      RETURNING
        VALUE(rv_valid) TYPE xfeld .
    METHODS parse_fields
      EXCEPTIONS
        parse_error
        no_fields_found
        table_not_found
        field_not_found .
    METHODS parse_tables
      EXCEPTIONS
        parse_error
        no_tables_found
        table_not_exist .
    METHODS prepare_from_text
      CHANGING
        !cv_string TYPE string .
    METHODS prepare_sel_text
      CHANGING
        !cv_string TYPE string .
    METHODS rebuild_field_list
      CHANGING
        ct_srccode TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        error
        no_auth_for_columns .
    METHODS remove_duplicates .
    METHODS check_inserted_orgcritdep
      IMPORTING
        !it_inserted TYPE REF TO data
      EXCEPTIONS
        no_auth_for_inserted_records
        assign_error .

    METHODS call_gen_form
        REDEFINITION .
    METHODS generate_srccode
        REDEFINITION .
    METHODS parse_keywords
        REDEFINITION .
ENDCLASS.                    &quot;LCL_HTDB_CL_COMMAND_SELECT  DEFINITIO

*----------------------------------------------------------------------*
*       CLASS lcl_HTDB_CL_COMMAND_SELECT IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_htdb_cl_command_select IMPLEMENTATION.

  METHOD call_gen_form.

    IF iv_bg_proc = space.   &quot; execute command instantly
      TRY.
          PERFORM exec_command IN PROGRAM (iv_program)
            TABLES mt_vranges          &quot; value ranges
            CHANGING er_result         &quot; result set
                     ev_dbcnt          &quot; sy-dbcnt
                     er_lock_argument  &quot; lock argument
                     er_exc.           &quot; exception object

          IF er_exc IS NOT INITIAL.
            RAISE error.
          ENDIF.

        CATCH cx_root.
          IF mv_log_handle IS INITIAL.
*         Message: Internal error: generated program could not be called
            MESSAGE e003 RAISING error.
          ELSE.
            CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = 003 ).
          ENDIF.
      ENDTRY.
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD create_new.

    DATA: ls_keyword LIKE LINE OF mt_keywords.


    super-&gt;create_new(
      EXPORTING
        iv_command_id     = iv_command_id
        iv_command        = iv_command
        it_vranges        = it_vranges
        iv_log_handle     = iv_log_handle
        iv_test_from_file = iv_test_from_file
      EXCEPTIONS
        no_id             = 1
        OTHERS            = 2 ).

    IF sy-subrc = 1.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING no_id.
    ENDIF.

* clear attributes
    CLEAR mt_fieldinfo.
    CLEAR mt_table_alias.
    CLEAR mt_adt_tables.
    CLEAR mt_table_fields.
    CLEAR mv_has_dupl_fields.
    CLEAR mv_sel_single.
    CLEAR mv_prog_id_str.
    CLEAR mt_query_depth.
    CLEAR mt_subqu_where.

    CLEAR mt_authorizations.

    mv_prog_id_str = mv_prog_id.

    CONCATENATE mc_type_name_tech_res mv_prog_id_str INTO mv_type_name_tech_res.
    mv_type_name_tech_res = mv_type_name_tech_res(30).
    CONCATENATE mc_type_name_res      mv_prog_id_str INTO mv_type_name_res.
    mv_type_name_res = mv_type_name_res(30).
    CONCATENATE mc_result_prefix      mv_prog_id_str INTO mv_result_name.
    mv_result_name = mv_result_name(30).

    CONCATENATE mc_prog_prefix        mv_prog_id_str INTO mv_program.
    mv_program = mv_program(30).

* set to editable as default
    mv_can_edit = &apos;X&apos;.

* fill up keywords table
    ls_keyword-keyword   = &apos;SELECT&apos;.
*    ls_keyword-required  = &apos;X&apos;.
    ls_keyword-order_pos = 1.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = &apos;DELETE&apos;.
    ls_keyword-required  = &apos; &apos;.
    ls_keyword-order_pos = 1.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = &apos;FROM&apos;.
*    ls_keyword-required  = &apos;X&apos;.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = &apos;CLIENT SPECIFIED&apos;.
    ls_keyword-required  = &apos; &apos;.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = &apos;BYPASSING BUFFER&apos;.
    ls_keyword-required  = &apos; &apos;.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = &apos;UP TO&apos;.
    ls_keyword-required  = &apos; &apos;.
    ls_keyword-order_pos = 2.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = &apos;WHERE&apos;.
    ls_keyword-required  = &apos; &apos;.
    ls_keyword-order_pos = 5.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = &apos;GROUP BY&apos;.
    ls_keyword-required  = &apos; &apos;.
    ls_keyword-order_pos = 6.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = &apos;HAVING&apos;.
    ls_keyword-required  = &apos; &apos;.
    ls_keyword-order_pos = 7.
    APPEND ls_keyword TO mt_keywords.

    ls_keyword-keyword   = &apos;ORDER BY&apos;.
    ls_keyword-required  = &apos; &apos;.
    ls_keyword-order_pos = 8.
    APPEND ls_keyword TO mt_keywords.


  ENDMETHOD.                    &quot;

  METHOD generate_srccode.

    DATA: lv_line    TYPE string,
          ls_keyword LIKE LINE OF mt_keywords,
          lv_shift   TYPE i,
          l_error.

    CLEAR et_srccode.
    IF v_es_report = &apos;X&apos;.
      et_srccode = i_lineas.
      v_es_report = &apos;X&apos;.
      EXIT.
    ENDIF.


    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = &apos;SELECT&apos;.
    IF sy-subrc NE 0. &quot;APC20160411
      v_comando = &apos;X&apos;.
    ENDIF.

    CONCATENATE &apos;PROGRAM&apos; mv_program &apos;.&apos; INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* Type Pools
    APPEND &apos;  TYPE-POOLS: rsds.&apos; TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

    IF v_comando IS INITIAL.
* create local type for the result set
      create_type(
        EXPORTING
          iv_type_name        = mv_type_name_res
          it_fieldinfo        = mt_fieldinfo
          iv_with_tech_fields = &apos; &apos;
        CHANGING
          ct_srccode          = et_srccode ).
      APPEND INITIAL LINE TO et_srccode.

* create local type for the result set with technical fields
      create_type(
        EXPORTING
          iv_type_name        = mv_type_name_tech_res
          it_fieldinfo        = mt_fieldinfo
          iv_with_tech_fields = &apos;X&apos;
        CHANGING
          ct_srccode          = et_srccode ).
      APPEND INITIAL LINE TO et_srccode.

* create result set table
      CONCATENATE &apos;DATA&apos; mv_result_name &apos;TYPE STANDARD TABLE OF&apos; mv_type_name_tech_res &apos;.&apos;
        INTO lv_line SEPARATED BY space.
      APPEND lv_line TO et_srccode.
      APPEND INITIAL LINE TO et_srccode.
    ENDIF.

* create FORM routine
    APPEND &apos;FORM exec_command TABLES   pt_vranges&apos;                  TO et_srccode.
    APPEND &apos;                  CHANGING p_result&apos;                    TO et_srccode.
    APPEND &apos;                           p_dbcnt&apos;                     TO et_srccode.
    APPEND &apos;                           p_lock_argument&apos;             TO et_srccode.
    APPEND &apos;                           po_exc TYPE REF TO cx_root.&apos; TO et_srccode.
    APPEND INITIAL LINE TO et_srccode.

* create value range tables
    IF mt_vranges IS NOT INITIAL.
      generate_vranges( IMPORTING et_srccode = et_srccode ).
    ENDIF.

    IF v_comando IS INITIAL.
      IF mv_sel_single = &apos;X&apos;.
*   create result structure
        CONCATENATE &apos;  DATA: ls_result LIKE LINE OF &apos; mv_result_name &apos;.&apos;
          INTO lv_line SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        APPEND INITIAL LINE TO et_srccode.
      ENDIF.
    ENDIF.

    APPEND &apos;TRY.&apos; TO et_srccode.

    IF v_comando IS INITIAL.
* create SELECT command
      READ TABLE mt_keywords INTO ls_keyword
        WITH KEY keyword = &apos;SELECT&apos;.

      lv_line = &apos;SELECT&apos;.
      IF ls_keyword-additions IS NOT INITIAL.
        CONCATENATE lv_line ls_keyword-additions INTO lv_line
          SEPARATED BY space.
      ENDIF.
      APPEND lv_line TO et_srccode.

* build field list (SELECT clause)
      rebuild_field_list(
        CHANGING
          ct_srccode          = et_srccode
        EXCEPTIONS
          no_auth_for_columns = 1
          OTHERS              = 2 ).

      IF sy-subrc = 1.
        MESSAGE e148 RAISING no_auth_for_columns.
      ELSEIF sy-subrc = 2.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE error.
        ENDIF.
      ENDIF.

* insert addition INTO ...
      IF mv_sel_single = &apos;X&apos;.
        APPEND &apos;  INTO CORRESPONDING FIELDS OF ls_result&apos; TO et_srccode.
      ELSE.
        CONCATENATE &apos;  INTO CORRESPONDING FIELDS OF TABLE &apos; mv_result_name INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
      ENDIF.

* append the rest: &apos;FROM ...&apos;
      READ TABLE mt_keywords INTO ls_keyword
        WITH KEY keyword = &apos;FROM&apos;.
      lv_shift = ls_keyword-begins_at - 1.
      CONCATENATE mv_command+lv_shift &apos;.&apos; INTO lv_line.

* split line by 100
      CALL METHOD lcl_toolbox=&gt;split_string
        EXPORTING
          iv_string     = lv_line
          iv_maxlen     = 100
        IMPORTING
          et_string_tab = et_srccode.

*      lv_line = &apos;__break_ap.&apos;.
*      APPEND lv_line TO et_srccode.


* save SY-DBCNT
      lv_line = &apos;p_dbcnt = sy-dbcnt.&apos;.
      APPEND lv_line TO et_srccode.

      IF mv_sel_single = &apos;X&apos;.
*   append result structure to result tab
        APPEND &apos; IF sy-subrc EQ 0.&apos; TO et_srccode.
        CONCATENATE &apos;   APPEND ls_result TO &apos; mv_result_name &apos;.&apos; INTO lv_line
          SEPARATED BY space.
        APPEND lv_line TO et_srccode.
        APPEND &apos; ENDIF.&apos; TO et_srccode.
      ENDIF.

* return reference on result set
      CONCATENATE &apos; GET REFERENCE OF &apos; mv_result_name &apos;INTO p_result.&apos; INTO lv_line
        SEPARATED BY space.
      APPEND lv_line TO et_srccode.
    ELSE.
      LOOP AT i_lineas INTO l_linea.
        TRANSLATE l_linea TO UPPER CASE.
        IF l_linea CS &apos;UPDATE&apos; OR l_linea CS &apos;DELETE&apos;.
          DATA(l_upd_del) = &apos;X&apos;.
        ENDIF.
        IF l_linea CS &apos;WHERE&apos;.
          DATA(l_where) = &apos;X&apos;.
        ENDIF.
      ENDLOOP.
      IF l_upd_del = &apos;X&apos; AND l_where = &apos;&apos;.
        MESSAGE &apos;Es necesario indicar WHERE&apos; TYPE &apos;E&apos;.
      ENDIF.

      IF zcl_c=&gt;existe( constante = &apos;USUARIO_AP&apos; valor = sy-uname ) = &apos;X&apos;.
        CLEAR l_error.
      ELSE.
        IF zcl_ap_lista=&gt;es_elemento( lista = zcl_c=&gt;usuarios_sistemas elemento = sy-uname ) = &apos;X&apos;.
          IF zcl_ap_popup=&gt;confirmar( texto = &apos;Esta accin puede ser peligrosa&apos; texto2 = &apos;Est seguro de continuar?&apos; ) = &apos;&apos;.
            l_error = &apos;X&apos;.
            EXIT.
          ENDIF.
        ELSE.
          l_error = &apos;X&apos;.
        ENDIF.
      ENDIF.
      IF l_error IS INITIAL.
        v_comando = &apos;X&apos;.
        LOOP AT i_lineas INTO l_linea.
          APPEND l_linea TO et_srccode.
        ENDLOOP.
        APPEND &apos;.&apos; TO et_srccode.

        lv_line = &apos;p_dbcnt = sy-dbcnt.&apos;.
        APPEND lv_line TO et_srccode.
      ELSE.
        MESSAGE &apos;No autorizado a ejecutar estas acciones&apos; TYPE &apos;E&apos;.
      ENDIF.
    ENDIF.


    APPEND &apos;CATCH cx_root INTO po_exc.&apos;
                                        TO et_srccode.
    APPEND &apos;ENDTRY.&apos;                    TO et_srccode.

    lv_line = &apos;ENDFORM.&apos;.
    APPEND lv_line TO et_srccode.

  ENDMETHOD.                    &quot;

  METHOD parse_keywords.
* extracts keywords of the command and fills up the MT_KEYWORDS table

    FIELD-SYMBOLS: &lt;ls_keyword&gt; LIKE LINE OF mt_keywords.


* extract keywords
    super-&gt;parse_keywords(
      EXCEPTIONS
        missing_keyword = 1
        wrong_position  = 2 ).

    IF sy-subrc = 1.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING missing_keyword.
    ELSEIF sy-subrc = 2.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING wrong_position.
    ENDIF.

* check the SELECT keyword
    READ TABLE mt_keywords ASSIGNING &lt;ls_keyword&gt;
      WITH KEY keyword = &apos;SELECT&apos;.
    IF sy-subrc = 0.


      IF strlen( &lt;ls_keyword&gt;-text ) &gt;= 8.
        IF &lt;ls_keyword&gt;-text(8) = &apos;DISTINCT&apos;.
          SHIFT &lt;ls_keyword&gt;-text LEFT BY 8 PLACES.
          &lt;ls_keyword&gt;-additions = &apos;DISTINCT&apos;.
*     &lt;ls_keyword&gt;-ends_at   =  &lt;ls_keyword&gt;-ends_at + 8.
        ENDIF.
      ENDIF.

      IF strlen( &lt;ls_keyword&gt;-text ) &gt;= 6.
        IF &lt;ls_keyword&gt;-text(6) = &apos;SINGLE&apos;.
          SHIFT &lt;ls_keyword&gt;-text LEFT BY 6 PLACES.
          &lt;ls_keyword&gt;-additions = &apos;SINGLE&apos;.
*     &lt;ls_keyword&gt;-ends_at   = &lt;ls_keyword&gt;-ends_at + 6.
          mv_sel_single = &apos;X&apos;.
        ENDIF.
      ENDIF.

      SEARCH &lt;ls_keyword&gt;-text FOR &apos;. FOR UPDATE .&apos;.
      IF sy-subrc = 0.
        IF mv_log_handle IS INITIAL.
          MESSAGE e068 RAISING wrong_keyword.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;W&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;068&apos; ).
          RAISE wrong_keyword.
        ENDIF.
      ENDIF.
    ELSE.
*APC20160411
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD parse.

    IF v_es_report = &apos;X&apos;.
      RETURN.
    ENDIF.

    IF mv_parsed = &apos;X&apos;.
      RETURN.
    ENDIF.

* make search for keywords easier - start and end with SPACE
    SHIFT mv_command RIGHT BY 1 PLACES.
    CONCATENATE mv_command space INTO mv_command
      SEPARATED BY space.

* elemtary check of command (apostrophes, dots, keywords)
    super-&gt;parse( EXCEPTIONS OTHERS = 1 ).

    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              RAISING parse_error.
    ENDIF.

* clear attributes
    CLEAR mt_fieldinfo.
    CLEAR mt_table_alias.
    CLEAR mv_has_dupl_fields.

* set to editable as default
    mv_can_edit = &apos;X&apos;.

* get tables involved
    CALL METHOD parse_tables
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc &lt;&gt; 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = &apos;E&apos;
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

* get field list
    CALL METHOD parse_fields
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc &lt;&gt; 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = &apos;E&apos;
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;parse

  METHOD extend_where_clause.

    DATA: ls_keywords LIKE LINE OF mt_keywords,
          lv_tabix    TYPE i,
          lv_len      TYPE i,
          lv_shift    TYPE i,
          lv_tmp      TYPE i.


    IF iv_where_addition IS NOT INITIAL.

      READ TABLE mt_keywords INTO ls_keywords WITH KEY keyword = &apos;WHERE&apos;.

      IF sy-subrc EQ 0.   &quot; extend WHERE clause

        lv_tabix = sy-tabix.

*     add pre stuff to mv_command
        lv_shift = ls_keywords-begins_at + 4.
        lv_tmp   = lv_shift + 1.
        CONCATENATE mv_command(lv_shift) &apos;(&apos; iv_where_addition &apos;) AND (&apos; mv_command+lv_tmp
          INTO mv_command SEPARATED BY space.

*     add pre stuff to ls_keywords-text
        CONCATENATE &apos;(&apos; iv_where_addition &apos;) AND (&apos; ls_keywords-text
          INTO ls_keywords-text SEPARATED BY space.

        lv_len = strlen( ls_keywords-text ) - 1.

        IF ls_keywords-text+lv_len(1) = &apos;.&apos;.
*       add post stuff to mv_command
          lv_shift = ls_keywords-ends_at + strlen( ls_keywords-text ) - 1.
          CONCATENATE mv_command(lv_shift) &apos;).&apos; INTO mv_command SEPARATED BY space.
*       add post stuff to ls_keywords-text
          CONCATENATE ls_keywords-text(lv_len) &apos;).&apos; INTO ls_keywords-text SEPARATED BY space.
        ELSE.
*       add post stuff to ls_keywords-text
          CONCATENATE ls_keywords-text &apos;)&apos; INTO ls_keywords-text SEPARATED BY space.

          LOOP AT mt_keywords TRANSPORTING NO FIELDS
               WHERE order_pos &gt; ls_keywords-order_pos.
            lv_shift = ls_keywords-ends_at + lv_len + 1.
            lv_tmp   = lv_shift + 1.
            CONCATENATE mv_command(lv_shift) &apos;)&apos; mv_command+lv_shift
              INTO mv_command SEPARATED BY space.
            EXIT.
          ENDLOOP.

          IF sy-subrc EQ 4.
*         add post stuff to mv_command
            CONCATENATE mv_command &apos;)&apos; INTO mv_command SEPARATED BY space.
          ENDIF.
        ENDIF.

        MODIFY mt_keywords FROM ls_keywords INDEX lv_tabix.

      ELSE.   &quot; create WHERE clause

        LOOP AT mt_keywords INTO ls_keywords WHERE order_pos &gt; 5. &quot; WHERE keyword
          lv_shift = ls_keywords-begins_at - 1.
          CONCATENATE mv_command(lv_shift) &apos;WHERE&apos; iv_where_addition mv_command+lv_shift
            INTO mv_command SEPARATED BY space.
          EXIT.
        ENDLOOP.

        IF sy-subrc EQ 4.
          CONCATENATE mv_command &apos;WHERE&apos; iv_where_addition
            INTO mv_command SEPARATED BY space.
        ENDIF.

        ls_keywords-keyword   = &apos;WHERE&apos;.
        ls_keywords-text      = iv_where_addition.
        ls_keywords-order_pos = 5.
        ls_keywords-begins_at = lv_shift.
        ls_keywords-ends_at   = lv_shift + 4.

        APPEND ls_keywords TO mt_keywords.

      ENDIF.

    ENDIF.

  ENDMETHOD.                    &quot;extend_where_clause

  METHOD add_where_excl_all.

  ENDMETHOD.                    &quot;ADD_WHERE_EXCL_ALL


  METHOD can_edit.

    ev_can_edit = mv_can_edit.

  ENDMETHOD.                    &quot;can_edit

  METHOD create_type.
* create a type for the result set of the command

    DATA: lt_srccode   TYPE STANDARD TABLE OF string,
          lv_line      TYPE string,
          ls_fieldinfo LIKE LINE OF it_fieldinfo.


    IF it_fieldinfo IS INITIAL.
      RETURN.
    ENDIF.

    CONCATENATE &apos;TYPES: BEGIN OF&apos; iv_type_name &apos;,&apos; INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO lt_srccode.

    IF iv_with_tech_fields EQ &apos;X&apos;.
*   add system fields HTDB_ROWID and HTDB_SELECTED and HTDB_ICON
      lv_line = &apos;zenith_rowid TYPE i,&apos;.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

      lv_line = &apos;zenith_selected TYPE c,&apos;.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

*   add style field
      lv_line = &apos;zenith_style TYPE lvc_t_styl,&apos;.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

*   add coloring field
      lv_line = &apos;zenith_color TYPE lvc_t_scol,&apos;.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.

*   who locked the row?
      lv_line = &apos;zenith_locked_by TYPE sy-uname,&apos;.
      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.
    ENDIF.

* for each entry in the field list there will be a field in the structure
    LOOP AT it_fieldinfo INTO ls_fieldinfo.
      TRANSLATE ls_fieldinfo-generated_field TO LOWER CASE.
      TRANSLATE ls_fieldinfo-field_alias     TO LOWER CASE.
      TRANSLATE ls_fieldinfo-orig_field      TO LOWER CASE.
      TRANSLATE ls_fieldinfo-table           TO LOWER CASE.
      TRANSLATE ls_fieldinfo-field           TO LOWER CASE.

      IF ls_fieldinfo-agg_function = &apos;COUNT&apos;.
        CONCATENATE ls_fieldinfo-generated_field &apos;TYPE i,&apos;
          INTO lv_line SEPARATED BY space.
*      ELSEIF ls_fieldinfo-agg_function = &apos;SUM&apos;.
*        CONCATENATE ls_fieldinfo-generated_field &apos;TYPE f,&apos;
*          INTO lv_line SEPARATED BY space.
      ELSEIF ls_fieldinfo-agg_function = &apos;AVG&apos;.
        CONCATENATE ls_fieldinfo-generated_field &apos;TYPE p DECIMALS 4,&apos;
          INTO lv_line SEPARATED BY space.
      ELSE.
        IF ls_fieldinfo-generated_field IS NOT INITIAL.
          CONCATENATE ls_fieldinfo-generated_field &apos;TYPE&apos; ls_fieldinfo-table
            INTO lv_line SEPARATED BY space.
        ELSEIF ls_fieldinfo-field_alias IS INITIAL.
          CONCATENATE ls_fieldinfo-field_alias &apos;TYPE&apos; ls_fieldinfo-table
            INTO lv_line SEPARATED BY space.
        ELSE.
          CONCATENATE ls_fieldinfo-orig_field &apos;TYPE&apos; ls_fieldinfo-table
            INTO lv_line SEPARATED BY space.
        ENDIF.

        CONCATENATE lv_line &apos;-&apos; ls_fieldinfo-field &apos;,&apos; INTO lv_line.
      ENDIF.

      SHIFT lv_line RIGHT BY 9 PLACES.
      APPEND lv_line TO lt_srccode.
    ENDLOOP.

    CONCATENATE &apos;       END OF&apos; iv_type_name &apos;.&apos; INTO lv_line
      SEPARATED BY space.
    APPEND lv_line TO lt_srccode.

    APPEND LINES OF lt_srccode TO ct_srccode.

  ENDMETHOD.                    &quot;

  METHOD expand_asterisk.
* get field list in case of SELECT *

    DATA: lv_lines       TYPE i,
          ls_table_field LIKE LINE OF mt_table_fields,
          ls_table_alias LIKE LINE OF mt_table_alias,
          ls_fieldinfo   LIKE LINE OF mt_fieldinfo.


    CLEAR mt_fieldinfo.

    LOOP AT mt_table_alias INTO ls_table_alias.

      ls_fieldinfo-table = ls_table_alias-table.

*   get table fields
      LOOP AT mt_table_fields INTO ls_table_field
           WHERE table = ls_fieldinfo-table.

        ls_fieldinfo-orig_field = ls_table_field-field.
        ls_fieldinfo-field      = ls_table_field-field.
        ls_fieldinfo-is_key     = ls_table_field-keyflag.

*      READ TABLE mt_table_alias INTO ls_table_alias
*        WITH KEY table = ls_table_alias-table.

        IF ls_table_alias-alias IS INITIAL.
          ls_fieldinfo-table_alias = ls_table_alias-table.
        ELSE.
          ls_fieldinfo-table_alias = ls_table_alias-alias.
        ENDIF.

        READ TABLE mt_fieldinfo
          WITH KEY orig_field = ls_table_field-field
          TRANSPORTING NO FIELDS.

        IF sy-subrc EQ 0.
          mv_has_dupl_fields = &apos;X&apos;.
        ENDIF.

        APPEND ls_fieldinfo TO mt_fieldinfo.

      ENDLOOP.

    ENDLOOP.

* result set can be edited, if there is only one table
    DESCRIBE TABLE mt_table_alias LINES lv_lines.
    IF lv_lines NE 1.
      CLEAR mv_can_edit.    &quot; result set can&apos;t be edited
      CLEAR mv_can_insert.  &quot; new records can&apos;t inserted to the result set
    ENDIF.

* clean field list from duplicates
    remove_duplicates( ).

  ENDMETHOD.                    &quot;


  METHOD get_fieldinfo.
* returns the field list (from the SELECT clause)

    et_fieldinfo  = mt_fieldinfo.
    ev_can_edit   = mv_can_edit.
    ev_can_insert = mv_can_insert.

  ENDMETHOD.                    &quot;

  METHOD get_program_name.

    ev_program_name = mv_program.

  ENDMETHOD.                    &quot;get_program_name

  METHOD get_table_alias.
* returns the table list (from the FROM clause and subquerys)

    CLEAR et_table_alias.

    et_table_alias = mt_table_alias.                   &quot; FROM clause
    APPEND LINES OF mt_adt_tables TO et_table_alias.   &quot; subquerys

  ENDMETHOD.                    &quot;

  METHOD get_texts.
* returns the SELECT, FROM, etc. clauses of the command

    DATA: ls_keyword LIKE LINE OF mt_keywords.


* get SELECT text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = &apos;SELECT&apos;.
    ev_select_text = ls_keyword-text.

* get FROM text
    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = &apos;FROM&apos;.
    ev_from_text = ls_keyword-text.

* ...
    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = &apos;WHERE&apos;.
    ev_where_text = ls_keyword-text.

    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = &apos;GROUP BY&apos;.
    ev_group_by_text = ls_keyword-text.

    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = &apos;HAVING&apos;.
    ev_having_text = ls_keyword-text.

    CLEAR ls_keyword.
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = &apos;ORDER BY&apos;.
    ev_order_by_text = ls_keyword-text.

  ENDMETHOD.                    &quot;


  METHOD parse_adt_tables.

    DATA: ls_keyword     LIKE LINE OF mt_keywords,
          lv_where       TYPE string,
          lt_aptph_pos   LIKE mt_aptph_pos,
          lt_paranth     LIKE mt_aptph_pos,
          ls_aptph       LIKE LINE OF mt_aptph_pos,
          lv_offset      TYPE i,
          lv_found       TYPE flag,
          lv_reparse     TYPE flag,

          lv_subquery    TYPE string,
          lv_subq_begin  TYPE i,
          lv_subq_end    TYPE i,
          lv_subq_lgth   TYPE i,
          lv_new_lgth    TYPE i,
          lv_shift       TYPE i,
          lv_left        TYPE i,
          lv_right       TYPE i,

          lo_sel_cmd     TYPE REF TO lcl_htdb_cl_command_select,
          lt_table_alias LIKE mt_table_alias.


* get WHERE text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = &apos;WHERE&apos;.

    IF sy-subrc &lt;&gt; 0.
      EXIT.
    ENDIF.

* WHERE text
    lv_where = ls_keyword-text.
* SPACE as the first character
    SHIFT lv_where RIGHT BY 1 PLACES.

* identify apostrophes and paranthesis
    CALL METHOD lcl_toolbox=&gt;parse_aptph
      EXPORTING
        iv_log_handle = mv_log_handle
      IMPORTING
        et_aptph_pos  = lt_aptph_pos
        et_paranth    = lt_paranth
      CHANGING
        cv_string     = lv_where
      EXCEPTIONS
        OTHERS        = 1.

    IF sy-subrc &lt;&gt; 0.
      IF mv_log_handle IS INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                RAISING parse_error.
      ELSE.
        CALL METHOD add_message(
            iv_msgty = &apos;E&apos;
            iv_msgid = sy-msgid
            iv_msgno = sy-msgno
            iv_msgv1 = sy-msgv1
            iv_msgv2 = sy-msgv2
            iv_msgv3 = sy-msgv3
            iv_msgv4 = sy-msgv4 ).
        RAISE parse_error.
      ENDIF.
    ENDIF.

* create new instance for the subquery
    CREATE OBJECT lo_sel_cmd.

    DO.
      CLEAR lv_found.
      lv_offset = lv_subq_begin + 1.

*   search for subquerys
      SEARCH lv_where
        FOR &apos;. IN ( SELECT .&apos;
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      &lt; lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 4.
          lv_found = &apos;X&apos;.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR &apos;. ALL ( SELECT .&apos;
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      &lt; lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 5.
          lv_found = &apos;X&apos;.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR &apos;. SOME ( SELECT .&apos;
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      &lt; lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 6.
          lv_found = &apos;X&apos;.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR &apos;. ANY ( SELECT .&apos;
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      &lt; lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 5.
          lv_found = &apos;X&apos;.
        ENDIF.
      ENDIF.

      SEARCH lv_where
        FOR &apos;. EXISTS ( SELECT .&apos;
        STARTING AT lv_offset.

      IF sy-subrc = 0.
        IF sy-fdpos      &lt; lv_subq_begin OR
           lv_subq_begin = 0.
          lv_subq_begin = sy-fdpos + 8.
          lv_found = &apos;X&apos;.
        ENDIF.
      ENDIF.

      IF lv_found = &apos;X&apos;.
        lv_reparse = &apos;X&apos;.

*     absolute position
        lv_subq_begin = lv_subq_begin + lv_offset.

*     check, whether it&apos;s outside of apostrophes
        READ TABLE lt_aptph_pos INTO ls_aptph
          WITH KEY position = lv_subq_begin.

        IF ls_aptph-type = &apos;O&apos;.  &quot; outside apostrophes
*       identify the depth of the paranthesis in &apos; ### ( SELECT&apos;
          READ TABLE lt_paranth INTO ls_aptph
            WITH KEY position = lv_subq_begin.

          IF sy-subrc = 0.
*         now ls_aptph-type is the depth of the (
*         find the closing paranthesis - the next with the same depth
            lv_subq_end = sy-tabix + 1.
            LOOP AT lt_paranth FROM lv_subq_end INTO ls_aptph
                 WHERE type = ls_aptph-type.
              lv_subq_end = ls_aptph-position.
              EXIT.
            ENDLOOP.

            IF sy-subrc = 0.
*           extract subquery from string
              lv_subq_lgth = lv_subq_end - lv_subq_begin - 1.
              lv_subquery  = lv_where+lv_subq_begin(lv_subq_lgth).

*           create new subquery
              CALL METHOD lo_sel_cmd-&gt;create_new
                EXPORTING
                  iv_command    = lv_subquery
                  iv_log_handle = mv_log_handle.

*           parse subquery
              CALL METHOD lo_sel_cmd-&gt;parse
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc &lt;&gt; 0.
                IF mv_log_handle IS INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                          RAISING parse_error.
                ELSE.
                  CALL METHOD add_message(
                      iv_msgty = &apos;E&apos;
                      iv_msgid = sy-msgid
                      iv_msgno = sy-msgno
                      iv_msgv1 = sy-msgv1
                      iv_msgv2 = sy-msgv2
                      iv_msgv3 = sy-msgv3
                      iv_msgv4 = sy-msgv4 ).
                  RAISE parse_error.
                ENDIF.
              ENDIF.

*           extract tables from subquery
              lo_sel_cmd-&gt;get_table_alias( IMPORTING et_table_alias = lt_table_alias ).
              APPEND LINES OF lt_table_alias TO mt_adt_tables.

*           get modified command text
              lo_sel_cmd-&gt;get_command( RECEIVING ev_command = lv_subquery ).

*           new length of the subquery
              lv_new_lgth = strlen( lv_subquery ).

*           insert modified subquery into the original command
*             position of WHERE + rest of the word &apos;WHERE&apos; + start of subq &apos;(&apos;
              lv_left  = ls_keyword-begins_at + 4 + lv_subq_begin + lv_shift.
*             position of WHERE + rest of the word &apos;WHERE&apos; + end of subq &apos;)&apos; - 1
              lv_right = ls_keyword-begins_at + 4 + lv_subq_end - 1 + lv_shift.
              CONCATENATE mv_command(lv_left) lv_subquery mv_command+lv_right
                INTO mv_command SEPARATED BY space.

*           offset due to the new length of the subquery
              lv_shift = lv_shift + lv_new_lgth - lv_subq_lgth + 2.

*           continue search on the same level!
              lv_subq_begin = lv_subq_begin + lv_subq_lgth.
            ENDIF.
          ENDIF.
        ELSE.                    &quot; inside apostrophes -&gt; ignore
          CONTINUE.
        ENDIF.

      ELSE.    &quot; no more subquerys found
*     the command could have been changed due to authority checks
        IF lv_reparse = &apos;X&apos;.
          parse_keywords( ).
        ENDIF.

        EXIT.
      ENDIF.

    ENDDO.

  ENDMETHOD.                    &quot;

  METHOD parse_check_fieldname.
* checks if the string is a valid field name, including ~ for table alias

    CLEAR rv_valid.

    READ TABLE it_keywords WITH KEY table_line = iv_word
      TRANSPORTING NO FIELDS.

    IF sy-subrc = 0.                                       &quot; 1 -&gt; error
      RETURN.
    ELSE.
*    IF iv_word CO &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ_~0123456789&apos;.
      rv_valid = &apos;X&apos;.
*    ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD parse_check_name.
* checks if the string is a valid name for tables, fields or aliases

    rv_valid = &apos;X&apos;.

*  CLEAR rv_valid.
*
*  READ TABLE it_keywords WITH KEY table_line = iv_word
*    TRANSPORTING NO FIELDS.
*
*  IF sy-subrc = 0.                                       &quot; 1 -&gt; error
*    RETURN.
*  ELSE.
*    IF iv_word CO &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789&apos;.
*      rv_valid = &apos;X&apos;.
*    ENDIF.
*  ENDIF.

  ENDMETHOD.                    &quot;

  METHOD parse_check_value .
* checks the string if it is between apostrophes;
* the number of apostrophes is correct anyway

    rv_valid = &apos;X&apos;.

*  DATA: lv_length TYPE i,
*        lv_word   LIKE iv_word.
*
*  CLEAR rv_valid.
*
*  lv_word = iv_word.
*
*  TRANSLATE lv_word TO UPPER CASE.
*
*  IF lv_word IS INITIAL.
*    RETURN.
*  ENDIF.
*
*  IF lv_word = &apos;SPACE&apos;.
*    rv_valid = &apos;X&apos;.
*  ENDIF.
*
*  IF lv_word CO &apos;0123456789&apos;.
*    rv_valid = &apos;X&apos;.
*  ENDIF.
*
*  lv_length = strlen( lv_word ).
*  lv_length = lv_length - 1.
*
*  IF lv_length &gt; 3.
*    IF lv_word(3) = &apos;SY-&apos;.
*      rv_valid = &apos;X&apos;.
*    ENDIF.
*  ENDIF.
*
*  IF lv_length &gt; 5.
*    IF lv_word(5) = &apos;SYST-&apos;.
*      rv_valid = &apos;X&apos;.
*    ENDIF.
*  ENDIF.
*
*  IF lv_word(1)           = &apos;&apos;&apos;&apos; AND
*     lv_word+lv_length(1) = &apos;&apos;&apos;&apos;.
*    rv_valid = &apos;X&apos;.
*  ENDIF.

  ENDMETHOD.                    &quot;


  METHOD parse_fields.
* extracts field names from the SELECT clause
* and fills up the MT_FIELDINFO table

    DATA: lv_state       TYPE i,
          lv_error       TYPE xfeld,
          lv_lines       TYPE i,

          ls_keyword     LIKE LINE OF mt_keywords,
          lt_words       TYPE lty_zhtdbt_string_tab,
          lt_keywords    TYPE lty_zhtdbt_string_tab,
          lv_word        TYPE string,
          ls_fieldinfo   LIKE LINE OF mt_fieldinfo,
          ls_table_alias LIKE LINE OF mt_table_alias,
          lv_fdpos       TYPE i,
          ls_table_field LIKE LINE OF mt_table_fields.


* get words of select_text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = &apos;SELECT&apos;.

    IF sy-subrc = 0. &quot;APC20160419

      prepare_sel_text( CHANGING cv_string = ls_keyword-text ).

      CALL METHOD split_string
        EXPORTING
          iv_string = ls_keyword-text
        IMPORTING
          et_words  = lt_words.

* list of possible keywords
      APPEND &apos;AS&apos;       TO lt_keywords.
      APPEND &apos;MIN(&apos;     TO lt_keywords.
      APPEND &apos;MAX(&apos;     TO lt_keywords.
      APPEND &apos;AVG(&apos;     TO lt_keywords.
      APPEND &apos;SUM(&apos;     TO lt_keywords.
      APPEND &apos;COUNT(&apos;   TO lt_keywords.
      APPEND &apos;*&apos;        TO lt_keywords.
      APPEND &apos;DISTINCT&apos; TO lt_keywords.
      APPEND &apos;)&apos;        TO lt_keywords.

      IF lt_words IS INITIAL.
        IF mv_log_handle IS INITIAL.
*     Message: Field list is missing
          MESSAGE e017 RAISING no_fields_found.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;017&apos; ).
          RAISE no_fields_found.
        ENDIF.
      ENDIF.

* parse words

* The parser is a simple automat having 10 states defined as follows:

* &lt;field_list&gt;: 1  &apos;*&apos; 4                                                                    |
*               1  {fieldname} 2                                                            |
*               1  &apos;MIN(&apos; | &apos;MAX(&apos; | &apos;AVG(&apos; | &apos;SUM(&apos; 5 [&apos;DISTINCT&apos;] 6 {fieldname } 7  &apos;)&apos; 8 |
*               1  &apos;COUNT(&apos; 9
*
*               2  &apos;AS&apos; 3 {name} 1
*               2  {fieldname} 2                        |
*               2  &apos;MIN(&apos; | &apos;MAX(&apos; | &apos;AVG(&apos; | &apos;SUM(&apos; 5  |
*               2  &apos;COUNT(&apos; 9
*
*               8  &apos;AS&apos; 3 {name} 1                      |
*               8  {fieldname} 2                        |
*               8  &apos;MIN(&apos; | &apos;MAX(&apos; | &apos;AVG(&apos; | &apos;SUM(&apos; 5  |
*               8  &apos;COUNT(&apos; 9
*
*               9  &apos;*&apos; 7         |
*               9  &apos;DISTINCT&apos; 10 |
*               9  {fieldname } 7
*
*               10 &apos;*&apos; 7          |
*               10 {fieldname } 7
*
* 1 is the START state, 2, 4 and 8 are END states.

      lv_state = 1.

      LOOP AT lt_words INTO lv_word
           WHERE table_line IS NOT INITIAL.

        CASE lv_state.

          WHEN 1. &quot;************************************************

*       check wether it&apos;s a keyword
            CASE lv_word.
              WHEN &apos;*&apos;.                                       &quot; 1 -&gt; 4
                lv_state = 4.
                CONTINUE.
              WHEN &apos;MIN(&apos; OR                                  &quot; 1 -&gt; 5
                   &apos;MAX(&apos; OR
                   &apos;AVG(&apos; OR
                   &apos;SUM(&apos;.
                lv_state = 5.
                ls_fieldinfo-agg_function = lv_word(3).
                CONTINUE.
              WHEN &apos;COUNT(&apos;.                                  &quot; 1 -&gt; 9
                lv_state = 9.
                ls_fieldinfo-agg_function = lv_word(5).

*           if only one record will be returned
*           -&gt; it&apos;s like a SELECT SINGLE
*           depends if there is a group by clause or  not
                READ TABLE mt_keywords TRANSPORTING NO FIELDS
                  WITH KEY keyword = &apos;GROUP BY&apos;.

                IF sy-subrc EQ 0.
                  CLEAR mv_sel_single.
                ELSE.
                  mv_sel_single = &apos;X&apos;.
                ENDIF.

                CONTINUE.
            ENDCASE.

*       check wether it&apos;s a valid fieldname
            IF parse_check_fieldname(
                 iv_word = lv_word
                 it_keywords = lt_keywords ) = &apos;X&apos;.           &quot; 1 -&gt; 2
              lv_state = 2.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               &quot; 1 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 2. &quot;************************************************

            CASE lv_word.
              WHEN &apos;AS&apos;.                                      &quot; 2 -&gt; 3
                lv_state = 3.
                CONTINUE.
              WHEN &apos;MIN(&apos; OR                                  &quot; 2 -&gt; 5
                   &apos;MAX(&apos; OR
                   &apos;AVG(&apos; OR
                   &apos;SUM(&apos;.
                lv_state = 5.
                APPEND ls_fieldinfo TO mt_fieldinfo.
                CLEAR ls_fieldinfo.
                ls_fieldinfo-agg_function = lv_word(3).
                CONTINUE.
              WHEN &apos;COUNT(&apos;.                                  &quot; 2 -&gt; 9
                lv_state = 9.
                APPEND ls_fieldinfo TO mt_fieldinfo.
                CLEAR ls_fieldinfo.
                ls_fieldinfo-agg_function = lv_word(5).
*           if only one record will be returned
*           -&gt; it&apos;s like a SELECT SINGLE
*           depends if there is a group by clause or  not
                READ TABLE mt_keywords TRANSPORTING NO FIELDS
                  WITH KEY keyword = &apos;GROUP BY&apos;.

                IF sy-subrc EQ 0.
                  CLEAR mv_sel_single.
                ELSE.
                  mv_sel_single = &apos;X&apos;.
                ENDIF.

                CONTINUE.
            ENDCASE.

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = &apos;X&apos;.           &quot; 2 -&gt; 2
              APPEND ls_fieldinfo TO mt_fieldinfo.
              CLEAR ls_fieldinfo.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               &quot; 2 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 3. &quot;************************************************

            IF parse_check_name(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = &apos;X&apos;.           &quot; 3 -&gt; 1
              lv_state = 1.
              ls_fieldinfo-field_alias = lv_word.
              APPEND ls_fieldinfo TO mt_fieldinfo.
              CLEAR ls_fieldinfo.
              CONTINUE.
            ELSE.                                               &quot; 3 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 4. &quot;************************************************

            IF lv_word IS NOT INITIAL.                          &quot; 4 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 5. &quot;************************************************

            IF lv_word = &apos;DISTINCT&apos;.                          &quot; 5 -&gt; 6
              ls_fieldinfo-distinctf = &apos;X&apos;.
              lv_state = 6.
              CONTINUE.
            ENDIF.

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = &apos;X&apos;.           &quot; 5 -&gt; 7
              lv_state = 7.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               &quot; 5 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 6. &quot;************************************************

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = &apos;X&apos;.           &quot; 6 -&gt; 7
              ls_fieldinfo-orig_field = lv_word.
              lv_state = 7.
              CONTINUE.
            ELSE.                                               &quot; 6 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 7. &quot;************************************************

            IF lv_word = &apos;)&apos;.                                 &quot; 7 -&gt; 8
              lv_state = 8.
              CONTINUE.
            ENDIF.

            lv_error = &apos;X&apos;.
            EXIT.

          WHEN 8. &quot;************************************************

            CASE lv_word.
              WHEN &apos;AS&apos;.                                      &quot; 8 -&gt; 3
                lv_state = 3.
                CONTINUE.
              WHEN &apos;MIN(&apos; OR                                  &quot; 8 -&gt; 5
                   &apos;MAX(&apos; OR
                   &apos;AVG(&apos; OR
                   &apos;SUM(&apos;.
                lv_state = 5.
                APPEND ls_fieldinfo TO mt_fieldinfo.
                CLEAR ls_fieldinfo.
                ls_fieldinfo-agg_function = lv_word(3).
                CONTINUE.
              WHEN &apos;COUNT(&apos;.                                  &quot; 8 -&gt; 9
                lv_state = 9.
                APPEND ls_fieldinfo TO mt_fieldinfo.
                CLEAR ls_fieldinfo.
                ls_fieldinfo-agg_function = lv_word(5).

*           if only one record will be returned
*           -&gt; it&apos;s like a SELECT SINGLE
*           depends if there is a group by clause or  not
                READ TABLE mt_keywords TRANSPORTING NO FIELDS
                  WITH KEY keyword = &apos;GROUP BY&apos;.

                IF sy-subrc EQ 0.
                  CLEAR mv_sel_single.
                ELSE.
                  mv_sel_single = &apos;X&apos;.
                ENDIF.

                CONTINUE.
            ENDCASE.

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = &apos;X&apos;.           &quot; 8 -&gt; 2
              lv_state = 2.
              APPEND ls_fieldinfo TO mt_fieldinfo.
              CLEAR ls_fieldinfo.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               &quot; 8 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 9. &quot;************************************************

            CASE lv_word.
              WHEN &apos;*&apos;.                                       &quot; 9 -&gt; 7
                lv_state = 7.
                ls_fieldinfo-orig_field = &apos;*&apos;.
                CONTINUE.
              WHEN &apos;DISTINCT&apos;.                                &quot; 9 -&gt; 10
                ls_fieldinfo-distinctf = &apos;X&apos;.
                lv_state = 10.
                CONTINUE.
            ENDCASE.

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = &apos;X&apos;.           &quot; 9 -&gt; 7
              lv_state = 7.
*         CLEAR ls_fieldinfo.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               &quot; 9 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 10. &quot;************************************************

            CASE lv_word.
              WHEN &apos;*&apos;.                                       &quot; 10 -&gt; 7
                lv_state = 7.
                ls_fieldinfo-orig_field = &apos;*&apos;.
                CONTINUE.
            ENDCASE.

            IF parse_check_fieldname(
                 iv_word     = lv_word
                 it_keywords = lt_keywords ) = &apos;X&apos;.           &quot; 10 -&gt; 7
              lv_state = 7.
*         CLEAR ls_fieldinfo.
              ls_fieldinfo-orig_field = lv_word.
              CONTINUE.
            ELSE.                                               &quot; 10 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

        ENDCASE.

      ENDLOOP.


* check errors
      IF lv_error = &apos;X&apos;.
        IF mv_log_handle IS INITIAL.
*     Message: &apos;&amp;1&apos; was not expected in the field list
          MESSAGE e010 WITH lv_word
            RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;010&apos; iv_msgv1 = lv_word ).
          RAISE parse_error.
        ENDIF.
      ENDIF.

* check END state
      IF lv_state &lt;&gt; 1 AND
         lv_state &lt;&gt; 2 AND
         lv_state &lt;&gt; 4 AND
         lv_state &lt;&gt; 8.

        IF mv_log_handle IS INITIAL.
*     Message: Field list ended unexpectedly with &apos;&amp;1&apos;
          MESSAGE e011 WITH lv_word
            RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;011&apos; iv_msgv1 = lv_word ).
          RAISE parse_error.
        ENDIF.
      ENDIF.

      IF lv_state = 4.
* SELECT * -&gt; expand *
        expand_asterisk( EXCEPTIONS table_not_found = 1 ).

        IF sy-subrc &lt;&gt; 0.
          IF mv_log_handle IS INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                    RAISING table_not_found.
          ELSE.
            CALL METHOD add_message(
                iv_msgty = &apos;E&apos;
                iv_msgid = sy-msgid
                iv_msgno = sy-msgno
                iv_msgv1 = sy-msgv1
                iv_msgv2 = sy-msgv2
                iv_msgv3 = sy-msgv3
                iv_msgv4 = sy-msgv4 ).
            RAISE table_not_found.
          ENDIF.
        ENDIF.

        RETURN.
      ENDIF.

      IF ls_fieldinfo IS NOT INITIAL.
*   an END state was reached -&gt; save the last entry
        APPEND ls_fieldinfo TO mt_fieldinfo.
      ENDIF.

************************************************************************
* expand table aliases, fields

      LOOP AT mt_fieldinfo INTO ls_fieldinfo.

        SEARCH ls_fieldinfo-orig_field FOR &apos;~&apos;.

        IF sy-subrc EQ 0.
          lv_fdpos = sy-fdpos.

          MOVE ls_fieldinfo-orig_field(lv_fdpos) TO ls_fieldinfo-table_alias.
          TRANSLATE ls_fieldinfo-table_alias TO UPPER CASE.
          lv_fdpos = lv_fdpos + 1.
          MOVE ls_fieldinfo-orig_field+lv_fdpos TO ls_fieldinfo-field.
          TRANSLATE ls_fieldinfo-field TO UPPER CASE.

          MODIFY mt_fieldinfo FROM ls_fieldinfo.
        ELSE.
          MOVE ls_fieldinfo-orig_field TO ls_fieldinfo-field.
          TRANSLATE ls_fieldinfo-field TO UPPER CASE.
          MODIFY mt_fieldinfo FROM ls_fieldinfo.
        ENDIF.

        IF ls_fieldinfo-field EQ &apos;*&apos;.
          ls_fieldinfo-field = &apos;ALL&apos;.
        ELSEIF ls_fieldinfo-table_alias IS NOT INITIAL.
          READ TABLE mt_table_alias
            INTO ls_table_alias
            WITH KEY alias = ls_fieldinfo-table_alias.

          IF sy-subrc &lt;&gt; 0.
            READ TABLE mt_table_alias
              INTO ls_table_alias
              WITH KEY table = ls_fieldinfo-table_alias.
          ENDIF.

          IF sy-subrc &lt;&gt; 0.
            IF mv_log_handle IS INITIAL.
*         Message: Field list: can not find table alias &amp;1
              MESSAGE e012 WITH ls_fieldinfo-table_alias
                RAISING table_not_found.
            ELSE.
              CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;012&apos; iv_msgv1 = ls_fieldinfo-table_alias ).
              RAISE table_not_found.
            ENDIF.
          ELSE.
            ls_fieldinfo-table = ls_table_alias-table.

            READ TABLE mt_table_fields INTO ls_table_field
              WITH KEY table = ls_table_alias-table
                       field = ls_fieldinfo-field.

            IF sy-subrc &lt;&gt; 0.
              IF mv_log_handle IS INITIAL.
*           Message: Field &apos;&amp;1&apos; does not belong to tables &apos;&amp;2&apos;
                MESSAGE e036 WITH ls_fieldinfo-field ls_table_alias-table
                  RAISING field_not_found.
              ELSE.
                CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;036&apos; iv_msgv1 = ls_fieldinfo-field iv_msgv2 = ls_table_alias-table ).
                RAISE field_not_found.
              ENDIF.
            ELSE.
              ls_fieldinfo-is_key = ls_table_field-keyflag.
            ENDIF.
          ENDIF.
        ELSE.
          READ TABLE mt_table_fields INTO ls_table_field
            WITH KEY field = ls_fieldinfo-field.

          IF sy-subrc &lt;&gt; 0.
            IF mv_log_handle IS INITIAL.
*         Message: Field &apos;&amp;1&apos; does not belong to any of the tables
              MESSAGE e016 WITH ls_fieldinfo-field
                RAISING field_not_found.
            ELSE.
              CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;016&apos; iv_msgv1 = ls_fieldinfo-field ).
              RAISE field_not_found.
            ENDIF.
          ELSE.
            ls_fieldinfo-table  = ls_table_field-table.
            ls_fieldinfo-is_key = ls_table_field-keyflag.
          ENDIF.
        ENDIF.

        MODIFY mt_fieldinfo FROM ls_fieldinfo.

      ENDLOOP.

* tackle with duplicated fields
      remove_duplicates( ).

* result set can be edited, if there is only one table and
* all key fields were selected

      DESCRIBE TABLE mt_table_alias LINES lv_lines.

      IF lv_lines = 1.
        LOOP AT mt_table_fields INTO ls_table_field
             WHERE keyflag = &apos;X&apos;.
          READ TABLE mt_fieldinfo
            WITH KEY field = ls_table_field-field
            TRANSPORTING NO FIELDS.

          IF sy-subrc &lt;&gt; 0.
            CLEAR mv_can_edit.
            EXIT.
          ENDIF.
        ENDLOOP.
      ELSE.
        CLEAR mv_can_edit.
      ENDIF.

    ELSE.
      v_comando = &apos;X&apos;.
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD parse_tables.
* extracts table names from the FROM clause
* and fills up the MT_TABLE_ALIAS table

    DATA: lv_state       TYPE i,
          lv_tabix       TYPE i,
          lv_error       TYPE xfeld,
          lv_viewgrant   TYPE dd25l-viewgrant,

          ls_keyword     LIKE LINE OF mt_keywords,
          lt_from_words  TYPE lty_zhtdbt_string_tab,
          lt_keywords    TYPE lty_zhtdbt_string_tab,
          lt_operators   TYPE lty_zhtdbt_string_tab,
          lv_word        TYPE string,
          ls_table_alias LIKE LINE OF mt_table_alias.

    FIELD-SYMBOLS: &lt;ls_table_alias&gt; LIKE LINE OF mt_table_alias.


* get words from from_text
    READ TABLE mt_keywords INTO ls_keyword
      WITH KEY keyword = &apos;FROM&apos;.
    IF sy-subrc = 0.

      prepare_from_text( CHANGING cv_string = ls_keyword-text ).

      CALL METHOD split_string
        EXPORTING
          iv_string = ls_keyword-text
        IMPORTING
          et_words  = lt_from_words.

      IF lt_from_words IS INITIAL.
        IF mv_log_handle IS INITIAL.
*     Message: No tables were found
          MESSAGE e013 RAISING no_tables_found.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;013&apos; ).
          RAISE no_tables_found.
        ENDIF.
      ENDIF.

* list of possible keywords
      APPEND &apos;AS&apos;      TO lt_keywords.
      APPEND &apos;INNER&apos;   TO lt_keywords.
      APPEND &apos;LEFT&apos;    TO lt_keywords.
      APPEND &apos;OUTER&apos;   TO lt_keywords.
      APPEND &apos;JOIN&apos;    TO lt_keywords.
      APPEND &apos;ON&apos;      TO lt_keywords.
      APPEND &apos;IS&apos;      TO lt_keywords.
      APPEND &apos;NOT&apos;     TO lt_keywords.
      APPEND &apos;NULL&apos;    TO lt_keywords.
      APPEND &apos;BETWEEN&apos; TO lt_keywords.
      APPEND &apos;AND&apos;     TO lt_keywords.

* list of possible operators
      APPEND &apos;=&apos;       TO lt_operators.
      APPEND &apos;&lt;&apos;       TO lt_operators.
      APPEND &apos;&gt;&apos;       TO lt_operators.
      APPEND &apos;&lt;=&apos;      TO lt_operators.
      APPEND &apos;&gt;=&apos;      TO lt_operators.
      APPEND &apos;=&lt;&apos;      TO lt_operators.
      APPEND &apos;=&gt;&apos;      TO lt_operators.
      APPEND &apos;&lt;&gt;&apos;      TO lt_operators.
      APPEND &apos;&gt;&lt;&apos;      TO lt_operators.
      APPEND &apos;EQ&apos;      TO lt_operators.
      APPEND &apos;NE&apos;      TO lt_operators.
      APPEND &apos;LT&apos;      TO lt_operators.
      APPEND &apos;GT&apos;      TO lt_operators.
      APPEND &apos;LE&apos;      TO lt_operators.
      APPEND &apos;GE&apos;      TO lt_operators.

* parse words

* The parser is a simple automat having 19 states defined as follows:

* &lt;from_text&gt;: 1 {dbtab} 2 [as 3 {alias}] 4 [[inner|[left] 5 outer ] 6 join 7 {dbtab} 8 [as 9 {alias}] 10 ON 11 &lt;join_condition&gt;]
* &lt;join_condition&gt;: {field} 12 (IS 13 NOT 14 NULL) | (BETWEEN 15 {value} 16 AND 17 {value}) | (&lt;comp&gt; 18 {field}) 19 [AND 20 &lt;join_condition&gt;]
* &lt;comp&gt;: =|&lt;|&gt;|&lt;=|&gt;=|EQ|NE|GT|LT|LE|GE

* 1 is the START state, 2, 4 and 19 are END states.

      lv_state = 1.

      LOOP AT lt_from_words INTO lv_word
           WHERE table_line IS NOT INITIAL.

        CASE lv_state.

          WHEN 1. &quot;************************************************

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = &apos;X&apos;.            &quot; 1 -&gt; 2
              lv_state = 2.
              ls_table_alias-table = lv_word.  &quot; store table name
              CONTINUE.
            ELSE.                                               &quot; 1 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 2. &quot;************************************************

*       check wether it is a keyword
            CASE lv_word.
              WHEN &apos;AS&apos;.                                      &quot; 2 -&gt; 3
                lv_state = 3.
                CONTINUE.
              WHEN &apos;INNER&apos;.                                   &quot; 2 -&gt; 6
                lv_state = 6.
*           store table
                APPEND ls_table_alias TO mt_table_alias.
                CLEAR ls_table_alias.
                CONTINUE.
              WHEN &apos;LEFT&apos;.                                    &quot; 2 -&gt; 5
                lv_state = 5.
*           store table
                APPEND ls_table_alias TO mt_table_alias.
                CLEAR ls_table_alias.
                CONTINUE.
              WHEN &apos;OUTER&apos;.                                   &quot; 2 -&gt; 6
                lv_state = 6.
*           store table
                APPEND ls_table_alias TO mt_table_alias.
                CLEAR ls_table_alias.
                CONTINUE.
              WHEN &apos;JOIN&apos;.                                    &quot; 2 -&gt; 7
                lv_state = 7.
*           store table
                APPEND ls_table_alias TO mt_table_alias.
                CLEAR ls_table_alias.
                CONTINUE.
            ENDCASE.

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = &apos;X&apos;.            &quot; 2 -&gt; 2
              ls_table_alias-table = lv_word.  &quot; store table name
              CONTINUE.
            ELSE.                                               &quot; 2 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 3. &quot;************************************************

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = &apos;X&apos;.            &quot; 3 -&gt; 4
              lv_state = 4.
              ls_table_alias-alias = lv_word. &quot; store table alias
*         store table
              APPEND ls_table_alias TO mt_table_alias.
              CLEAR ls_table_alias.
              CONTINUE.
            ELSE.                                               &quot; 3 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 4. &quot;************************************************

            CASE lv_word.
              WHEN &apos;INNER&apos;.                                   &quot; 4 -&gt; 6
                lv_state = 6.
                CONTINUE.
              WHEN &apos;LEFT&apos;.                                    &quot; 4 -&gt; 5
                lv_state = 5.
                CONTINUE.
              WHEN &apos;OUTER&apos;.                                   &quot; 4 -&gt; 6
                lv_state = 6.
                CONTINUE.
              WHEN &apos;JOIN&apos;.                                    &quot; 4 -&gt; 7
                lv_state = 7.
                CONTINUE.
            ENDCASE.

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = &apos;X&apos;.            &quot; 4 -&gt; 2
              lv_state = 2.
              ls_table_alias-table = lv_word.  &quot; store table name
              CONTINUE.
            ELSE.                                               &quot; 4 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 5. &quot;************************************************

            CASE lv_word.
              WHEN &apos;OUTER&apos;.                                   &quot; 5 -&gt; 6
                lv_state = 6.
                CONTINUE.
              WHEN &apos;JOIN&apos;.                                    &quot; 5 -&gt; 7
                lv_state = 7.
                CONTINUE.
              WHEN OTHERS.                                      &quot; 5 -&gt; error
                lv_error = &apos;X&apos;.
                EXIT.
            ENDCASE.

          WHEN 6. &quot;************************************************

            IF lv_word = &apos;JOIN&apos;.                              &quot; 6 -&gt; 7
              lv_state = 7.
              CONTINUE.
            ELSE.                                               &quot; 6 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 7. &quot;************************************************

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = &apos;X&apos;.            &quot; 7 -&gt; 8
              lv_state = 8.
              ls_table_alias-table = lv_word. &quot; store table name
              CONTINUE.
            ELSE.                                               &quot; 7 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 8. &quot;************************************************

            CASE lv_word.
              WHEN &apos;AS&apos;.                                      &quot; 8 -&gt; 9
                lv_state = 9.
                CONTINUE.
              WHEN &apos;ON&apos;.                                      &quot; 8 -&gt; 11
                lv_state = 11.
*           store table
                APPEND ls_table_alias TO mt_table_alias.
                CLEAR ls_table_alias.
                CONTINUE.
            ENDCASE.

            lv_error = &apos;X&apos;.                                     &quot; 8 -&gt; error
            EXIT.

          WHEN 9. &quot;************************************************

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = &apos;X&apos;.            &quot; 9 -&gt; 10
              lv_state = 10.
              ls_table_alias-alias = lv_word. &quot; store table alias
*         store table
              APPEND ls_table_alias TO mt_table_alias.
              CLEAR ls_table_alias.
              CONTINUE.
            ELSE.                                               &quot; 9 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 10. &quot;***********************************************

            IF lv_word =  &apos;ON&apos;.                               &quot; 10 -&gt; 11
              lv_state = 11.
              CONTINUE.
            ELSE.                                               &quot; 10 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 11. &quot;***********************************************

*       check wether it is a valid field name (and no keyword)
            IF parse_check_fieldname(
                iv_word = lv_word
                it_keywords = lt_keywords ) = &apos;X&apos;.            &quot; 11 -&gt; 12
              lv_state = 12.
              CONTINUE.
            ELSE.                                               &quot; 11 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 12. &quot;***********************************************

            CASE lv_word.
              WHEN &apos;IS&apos;.                                      &quot; 12 -&gt; 13
                lv_state = 13.
                CONTINUE.
              WHEN &apos;BETWEEN&apos;.                                 &quot; 12 -&gt; 15
                lv_state = 15.
                CONTINUE.
            ENDCASE.

*       check wether it is an operator
            READ TABLE lt_operators WITH KEY table_line = lv_word
              TRANSPORTING NO FIELDS.

            IF sy-subrc = 0.                                  &quot; 12 -&gt; 18
              lv_state = 18.
              CONTINUE.
            ELSE.                                               &quot; 12 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 13. &quot;***********************************************

            IF lv_word = &apos;NOT&apos;.                               &quot; 13 -&gt; 14
              lv_state = 14.
              CONTINUE.
            ELSE.                                               &quot; 13 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 14. &quot;***********************************************

            IF lv_word = &apos;NULL&apos;.                              &quot; 14 -&gt; 19
              lv_state = 19.
              CONTINUE.
            ELSE.                                               &quot; 14 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 15. &quot;***********************************************

*       check wether it&apos;s a valid value
            IF parse_check_value( lv_word ) = &apos;X&apos;.            &quot; 15 -&gt; 16
              lv_state = 16.
              CONTINUE.
            ELSE.                                               &quot; 15 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 16. &quot;***********************************************

            IF lv_word = &apos;AND&apos;.                               &quot; 16 -&gt; 17
              lv_state = 17.
              CONTINUE.
            ELSE.                                               &quot; 16 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 17. &quot;***********************************************

*       check wether it&apos;s a valid value
            IF parse_check_value( lv_word ) = &apos;X&apos;.            &quot; 17 -&gt; 19
              lv_state = 19.
              CONTINUE.
            ELSE.                                               &quot; 17 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

          WHEN 18. &quot;***********************************************

*       check wether it is a valid field name (and no keyword)
            IF parse_check_fieldname(
                iv_word = lv_word
                it_keywords = lt_keywords ) = &apos;X&apos;.            &quot; 18 -&gt; 19
              lv_state = 19.
              CONTINUE.
            ELSE.
*         check wether it&apos;s a valid value
              IF parse_check_value( lv_word ) = &apos;X&apos;.          &quot; 18 -&gt; 19
                lv_state = 19.
                CONTINUE.
              ELSE.                                             &quot; 18 -&gt; error
                lv_error = &apos;X&apos;.
                EXIT.
              ENDIF.
            ENDIF.

          WHEN 19. &quot;***********************************************

            CASE lv_word.
              WHEN &apos;AND&apos;.                                     &quot; 19 -&gt; 11
                lv_state = 11.
                CONTINUE.
              WHEN &apos;INNER&apos;.                                   &quot; 19 -&gt; 6
                lv_state = 6.
                CONTINUE.
              WHEN &apos;LEFT&apos;.                                    &quot; 19 -&gt; 5
                lv_state = 5.
                CONTINUE.
              WHEN &apos;OUTER&apos;.                                   &quot; 19 -&gt; 6
                lv_state = 6.
                CONTINUE.
              WHEN &apos;JOIN&apos;.                                    &quot; 19 -&gt; 7
                lv_state = 7.
                CONTINUE.
            ENDCASE.

*       check wether it is a valid table name (and no keyword)
            IF parse_check_name(
                iv_word = lv_word
                it_keywords = lt_keywords ) = &apos;X&apos;.            &quot; 19 -&gt; 2
              lv_state = 2.
              ls_table_alias-table = lv_word.  &quot; store table name
              CONTINUE.
            ELSE.                                               &quot; 19 -&gt; error
              lv_error = &apos;X&apos;.
              EXIT.
            ENDIF.

        ENDCASE.

      ENDLOOP.

* ERROR state
      IF lv_error = &apos;X&apos;.
        IF mv_log_handle IS INITIAL.
*     Message: &apos;&amp;1&apos; was not expected in the FROM clause
          MESSAGE e008 WITH lv_word
            RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;008&apos; iv_msgv1 = lv_word ).
          RAISE parse_error.
        ENDIF.
      ENDIF.

* check END state
      IF lv_state &lt;&gt; 2  AND
         lv_state &lt;&gt; 4  AND
         lv_state &lt;&gt; 19.   &quot; an END state was not reached

        IF mv_log_handle IS INITIAL.
*     Message: FROM clause ended unexpectedly with &apos;&amp;1&apos;
          MESSAGE e009 WITH lv_word
            RAISING parse_error.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;009&apos; iv_msgv1 = lv_word ).
          RAISE parse_error.
        ENDIF.
      ENDIF.

      IF ls_table_alias IS NOT INITIAL.
*   an END state was reached -&gt; save last entry
        APPEND ls_table_alias TO mt_table_alias.
      ENDIF.

* get table fields from DDIC
      LOOP AT mt_table_alias INTO ls_table_alias.

        lv_tabix = sy-tabix.

*   check if already processed
        READ TABLE mt_table_fields
          WITH KEY table = ls_table_alias-table
          TRANSPORTING NO FIELDS.

        IF sy-subrc = 0.
          CONTINUE.
        ENDIF.

*   check if it is a transparent table
        SELECT tabname fieldname keyflag position
          FROM dd03vv
          APPENDING TABLE mt_table_fields
          WHERE tabname   = ls_table_alias-table    AND
                tabclass  = &apos;TRANSP&apos;                AND
                as4local  = &apos;A&apos;                     AND
                fieldname NOT LIKE &apos;.%&apos;             AND
                fieldname NOT LIKE &apos;*%&apos;             AND
                fieldname NOT LIKE &apos;$_%&apos; ESCAPE &apos;$&apos; AND
                fieldname NOT LIKE &apos;$%%&apos; ESCAPE &apos;$&apos;
          ORDER BY position.

*   not a transparent table
        IF sy-subrc EQ 4.

*     check if it is a view
*     viewfield instead of fieldname, field alias may be defined in a view!
          SELECT viewname AS tabname viewfield keyflag objpos AS position
            FROM dd27s
            APPENDING TABLE mt_table_fields
            WHERE viewname  = ls_table_alias-table AND
                  as4local  = &apos;A&apos; AND
*             possible to define * in views to include all fields from a table, and - to exclude a field
                  viewfield &lt;&gt; &apos;*&apos;                    AND
                  viewfield &lt;&gt; &apos;-&apos;                    AND
                  fieldname NOT LIKE &apos;.%&apos;             AND
                  fieldname NOT LIKE &apos;*%&apos;             AND
                  fieldname NOT LIKE &apos;$_%&apos; ESCAPE &apos;$&apos; AND
                  fieldname NOT LIKE &apos;$%%&apos; ESCAPE &apos;$&apos;
            ORDER BY position.

*     not a view
          IF sy-subrc EQ 4.

*       check if it is a Clustered table
            SELECT tabname fieldname keyflag position
              FROM dd03vv
              APPENDING TABLE mt_table_fields
              WHERE tabname   = ls_table_alias-table    AND
                    tabclass  = &apos;CLUSTER&apos;               AND
                    as4local  = &apos;A&apos;                     AND
                    fieldname NOT LIKE &apos;.%&apos;             AND
                    fieldname NOT LIKE &apos;*%&apos;             AND
                    fieldname NOT LIKE &apos;$_%&apos; ESCAPE &apos;$&apos; AND
                    fieldname NOT LIKE &apos;$%%&apos; ESCAPE &apos;$&apos;
              ORDER BY position.

*       not a Clustered table
            IF sy-subrc EQ 4.

*         check if it is a Pooled table
              SELECT tabname fieldname keyflag position
                FROM dd03vv
                APPENDING TABLE mt_table_fields
                WHERE tabname   = ls_table_alias-table    AND
                      tabclass  = &apos;POOL&apos;                  AND
                      as4local  = &apos;A&apos;                     AND
                      fieldname NOT LIKE &apos;.%&apos;             AND
                      fieldname NOT LIKE &apos;*%&apos;             AND
                      fieldname NOT LIKE &apos;$_%&apos; ESCAPE &apos;$&apos; AND
                      fieldname NOT LIKE &apos;$%%&apos; ESCAPE &apos;$&apos;
                ORDER BY position.

*         not a Pooled table
              IF sy-subrc EQ 4.
                IF mv_log_handle IS INITIAL.
*             Message: Table &apos;&amp;1&apos; does not exist
                  MESSAGE e014 WITH ls_table_alias-table
                    RAISING table_not_exist.
                ELSE.
                  CALL METHOD add_message( iv_msgty = &apos;W&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;014&apos; iv_msgv1 = ls_table_alias-table ).
                  RAISE table_not_exist.
                ENDIF.
*         it is a Pooled table
              ELSE.
                ls_table_alias-type = &apos;P&apos;.
                CLEAR mv_can_edit.
              ENDIF.

*       it is a Clustered table
            ELSE.
              ls_table_alias-type = &apos;C&apos;.
              CLEAR mv_can_edit.
            ENDIF.

*     it is a view
          ELSE.

            ls_table_alias-type = &apos;V&apos;.

            SELECT SINGLE viewgrant FROM dd25l INTO lv_viewgrant
              WHERE viewname = ls_table_alias-table AND
                    as4local = &apos;A&apos;.

            IF sy-subrc EQ 0.
              IF lv_viewgrant EQ &apos;R&apos;.
                CLEAR mv_can_edit.
              ENDIF.
            ENDIF.

          ENDIF.

*   it is a transparent table
        ELSE.
          ls_table_alias-type = &apos;T&apos;.
        ENDIF.

        MODIFY mt_table_alias FROM ls_table_alias INDEX lv_tabix.

      ENDLOOP.

* complete missing table types
      LOOP AT mt_table_alias ASSIGNING &lt;ls_table_alias&gt;
           WHERE table IS INITIAL.

*   read the first record with the same table name
        READ TABLE mt_table_alias
          WITH KEY table = &lt;ls_table_alias&gt;-table
          INTO ls_table_alias.

        &lt;ls_table_alias&gt;-type = ls_table_alias-type.
      ENDLOOP.

*  SORT mt_table_fields BY table field.
*  DELETE ADJACENT DUPLICATES FROM mt_table_fields COMPARING table field.

* parse other tables (subqueries in the WHERE clause)
      CALL METHOD parse_adt_tables
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc &lt;&gt; 0.
        IF mv_log_handle IS INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
                  RAISING parse_error.
        ELSE.
          CALL METHOD add_message(
              iv_msgty = &apos;E&apos;
              iv_msgid = sy-msgid
              iv_msgno = sy-msgno
              iv_msgv1 = sy-msgv1
              iv_msgv2 = sy-msgv2
              iv_msgv3 = sy-msgv3
              iv_msgv4 = sy-msgv4 ).
          RAISE parse_error.
        ENDIF.
      ENDIF.
    ELSE.
      v_comando = &apos;X&apos;.
    ENDIF.

  ENDMETHOD.                    &quot;

  METHOD prepare_from_text.
* remove each &apos;(&apos; and &apos;)&apos;

    DATA: lv_length  TYPE i,
          lv_shift   TYPE i,
          lv_pos     TYPE i,
          lv_char(1) TYPE c.

    SEARCH cv_string FOR &apos;%_HINT&apos;.

    IF sy-subrc EQ 0.
      lv_pos = sy-fdpos - 1.
      cv_string = cv_string(lv_pos).
    ENDIF.

    lv_shift = -1.
    lv_length = strlen( cv_string ).

    DO.
      lv_shift = lv_shift + 1.

      IF lv_shift = lv_length.
        EXIT.
      ENDIF.

      lv_char = cv_string+lv_shift(1).

      IF lv_char = &apos;(&apos; OR
         lv_char = &apos;)&apos;.
        lv_pos = lv_shift + 1.
        CONCATENATE cv_string(lv_shift) cv_string+lv_pos
          INTO cv_string SEPARATED BY space.
      ENDIF.
    ENDDO.

  ENDMETHOD.                    &quot;

  METHOD prepare_sel_text.
* put a SPACE after each &apos;(&apos; and before each &apos;)&apos; so the parser
* can parse the words

    DATA: lv_length  TYPE i,
          lv_shift   TYPE i,
          lv_pos     TYPE i,
          lv_char(1) TYPE c.


    lv_shift = -1.
    lv_length = strlen( cv_string ).

    DO.
      lv_shift = lv_shift + 1.

      IF lv_shift = lv_length.
        EXIT.
      ENDIF.

      lv_char = cv_string+lv_shift(1).

      IF lv_char = &apos;(&apos;.
        lv_pos   =  lv_shift + 1.
        CONCATENATE cv_string(lv_pos) cv_string+lv_pos INTO cv_string
          SEPARATED BY space.
        lv_length = lv_length + 1.
        lv_shift = lv_shift + 1.
      ENDIF.

      IF lv_char = &apos;)&apos;.
        CONCATENATE cv_string(lv_shift) cv_string+lv_shift INTO cv_string
          SEPARATED BY space.
        lv_length = lv_length + 1.
        lv_shift = lv_shift + 1.
      ENDIF.
    ENDDO.

  ENDMETHOD.                    &quot;


  METHOD rebuild_field_list.
* builds the field list of the SELECT clause into a string table

    DATA: ls_fieldinfo   LIKE LINE OF mt_fieldinfo,
          lv_string      TYPE string,
          lv_string2     TYPE string,
          ls_table_alias LIKE LINE OF mt_table_alias,
          lv_fieldname   TYPE fieldname.


    IF mt_fieldinfo IS INITIAL.
      MESSAGE e148 RAISING no_auth_for_columns.
    ENDIF.

* check that fields exist
    LOOP AT mt_fieldinfo INTO ls_fieldinfo WHERE orig_field NE &apos;*&apos;.

      READ TABLE mt_table_alias INTO ls_table_alias
        WITH KEY table = ls_fieldinfo-table.

      IF sy-subrc NE 0.
        IF mv_log_handle IS INITIAL.
*       Could not find field &amp;1 in table &amp;2 (type &amp;3)
          MESSAGE s038 DISPLAY LIKE &apos;E&apos; WITH ls_fieldinfo-field ls_fieldinfo-table &apos;?&apos; RAISING error.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;038&apos; iv_msgv1 = ls_fieldinfo-field iv_msgv2 = ls_fieldinfo-table ).
          RAISE error.
        ENDIF.
      ENDIF.

      CASE ls_table_alias-type.

        WHEN &apos;T&apos;.

          SELECT SINGLE fieldname
          INTO lv_fieldname
          FROM dd03l
          WHERE tabname   = ls_fieldinfo-table AND
                fieldname = ls_fieldinfo-field AND
                as4local  = &apos;A&apos; AND
                fieldname NOT LIKE &apos;.%&apos; AND
                fieldname NOT LIKE &apos;*%&apos; AND
                fieldname NOT LIKE &apos;$_%&apos; ESCAPE &apos;$&apos; AND
                fieldname NOT LIKE &apos;$%%&apos; ESCAPE &apos;$&apos;.

        WHEN &apos;V&apos;.

          SELECT SINGLE viewfield
          INTO lv_fieldname
          FROM dd27s
            WHERE viewname  = ls_fieldinfo-table AND
                  viewfield = ls_fieldinfo-field AND
                  as4local  = &apos;A&apos; AND
                  fieldname NOT LIKE &apos;.%&apos; AND
                  fieldname NOT LIKE &apos;*%&apos; AND
                  fieldname NOT LIKE &apos;$_%&apos; ESCAPE &apos;$&apos; AND
                  fieldname NOT LIKE &apos;$%%&apos; ESCAPE &apos;$&apos;.

*      WHEN &apos;P&apos;.
*
*        SELECT SINGLE fieldname
*        INTO lv_fieldname
*        FROM dd03vv
*          WHERE tabname   = ls_fieldinfo-table AND
*                fieldname = ls_fieldinfo-field AND
**                in view already
**                AS4LOCAL = &apos;A&apos; AND
*                fieldname NOT LIKE &apos;.%&apos; AND
*                fieldname NOT LIKE &apos;*%&apos; AND
*                fieldname NOT LIKE &apos;$_%&apos; ESCAPE &apos;$&apos; AND
*                fieldname NOT LIKE &apos;$%%&apos; ESCAPE &apos;$&apos;.

        WHEN &apos;C&apos; OR &apos;P&apos;.

*        SELECT SINGLE fieldname
*        INTO lv_fieldname
*        FROM dd16v
*          WHERE sqltab    = ls_fieldinfo-table AND
*                fieldname = ls_fieldinfo-field AND
**                in view already
**                AS4LOCAL = &apos;A&apos; AND
*                fieldname NOT LIKE &apos;.%&apos; AND
*                fieldname NOT LIKE &apos;*%&apos; AND
*                fieldname NOT LIKE &apos;$_%&apos; ESCAPE &apos;$&apos; AND
*                fieldname NOT LIKE &apos;$%%&apos; ESCAPE &apos;$&apos;.

          SELECT SINGLE fieldname
          INTO lv_fieldname
          FROM dd03l
          WHERE tabname   = ls_fieldinfo-table AND
                fieldname = ls_fieldinfo-field AND
                as4local  = &apos;A&apos; AND
                fieldname NOT LIKE &apos;.%&apos; AND
                fieldname NOT LIKE &apos;*%&apos; AND
                fieldname NOT LIKE &apos;$_%&apos; ESCAPE &apos;$&apos; AND
                fieldname NOT LIKE &apos;$%%&apos; ESCAPE &apos;$&apos;.


      ENDCASE.

      IF sy-subrc NE 0.
        IF mv_log_handle IS INITIAL.
*       Could not find field &amp;1 in table &amp;2 (type &amp;3)
          MESSAGE s038 DISPLAY LIKE &apos;E&apos; WITH ls_fieldinfo-field ls_fieldinfo-table ls_table_alias-type RAISING error.
        ELSE.
          CALL METHOD add_message( iv_msgty = &apos;E&apos; iv_msgid = &apos;ZSQL_FREE&apos; iv_msgno = &apos;038&apos; iv_msgv1 = ls_fieldinfo-field iv_msgv2 = ls_fieldinfo-table ).
          RAISE error.
        ENDIF.
      ENDIF.

    ENDLOOP.


    LOOP AT mt_fieldinfo INTO ls_fieldinfo.

      CLEAR: lv_string, lv_string2.

      IF ls_fieldinfo-agg_function IS INITIAL.    &quot; aggragate function
        IF ls_fieldinfo-table_alias IS NOT INITIAL.
          CONCATENATE ls_fieldinfo-table_alias &apos;~&apos; ls_fieldinfo-field INTO lv_string2.
        ELSE.
          MOVE ls_fieldinfo-orig_field TO lv_string2.
        ENDIF.

        CONCATENATE lv_string lv_string2 INTO lv_string SEPARATED BY &apos; &apos;.
      ELSE.
        CONCATENATE ls_fieldinfo-agg_function &apos;(&apos; INTO lv_string.

        IF ls_fieldinfo-distinctf = &apos;X&apos;.
          CONCATENATE lv_string &apos;DISTINCT&apos; INTO lv_string
            SEPARATED BY &apos; &apos;.
        ENDIF.

        IF ls_fieldinfo-field = &apos;*&apos;.
          CONCATENATE lv_string &apos;*&apos; &apos;)&apos; INTO lv_string SEPARATED BY &apos; &apos;.
        ELSE.
          IF ls_fieldinfo-table_alias IS NOT INITIAL.
            CONCATENATE ls_fieldinfo-table_alias &apos;~&apos; ls_fieldinfo-field INTO lv_string2.
          ELSE.
            MOVE ls_fieldinfo-orig_field TO lv_string2.
          ENDIF.
          CONCATENATE lv_string lv_string2 INTO lv_string SEPARATED BY &apos; &apos;.
          CONCATENATE lv_string  &apos;)&apos; INTO lv_string SEPARATED BY &apos; &apos;.
        ENDIF.
      ENDIF.

      CONCATENATE lv_string &apos;AS&apos; ls_fieldinfo-generated_field INTO lv_string SEPARATED BY &apos; &apos;.
      SHIFT lv_string RIGHT BY 3 PLACES.
      APPEND lv_string TO ct_srccode.

    ENDLOOP.

  ENDMETHOD.                    &quot;


  METHOD remove_duplicates.
* tackles with duplicates in the field list

    DATA: ls_fieldinfo      LIKE LINE OF mt_fieldinfo,
          ls_fieldinfo_copy LIKE LINE OF mt_fieldinfo,
          lv_same_cnt       TYPE i,
          lv_tabix          TYPE i,
          lv_string         TYPE string,
          lt_fieldinfo_copy LIKE mt_fieldinfo.


    LOOP AT mt_fieldinfo INTO ls_fieldinfo.
      IF ls_fieldinfo-field_alias IS NOT INITIAL.
        ls_fieldinfo-generated_field = ls_fieldinfo-field_alias.
      ELSEIF ls_fieldinfo-agg_function IS NOT INITIAL.
        CONCATENATE ls_fieldinfo-agg_function ls_fieldinfo-field
          INTO ls_fieldinfo-generated_field SEPARATED BY &apos;_&apos;.
      ELSE.
        ls_fieldinfo-generated_field = ls_fieldinfo-field.
      ENDIF.

*   CONNECTION is a reserved word, will cause a syntax error
      IF ls_fieldinfo-generated_field = &apos;CONNECTION&apos;.
        ls_fieldinfo-generated_field = &apos;CONNECTION_&apos;.
      ENDIF.

      TRANSLATE ls_fieldinfo-generated_field TO UPPER CASE.
      MODIFY mt_fieldinfo FROM ls_fieldinfo INDEX sy-tabix.
    ENDLOOP.

    lt_fieldinfo_copy[] = mt_fieldinfo[].

    LOOP AT mt_fieldinfo INTO ls_fieldinfo.

      CLEAR lv_same_cnt.
      lv_tabix = sy-tabix.

      LOOP AT lt_fieldinfo_copy INTO ls_fieldinfo_copy
           FROM lv_tabix
           WHERE generated_field = ls_fieldinfo-generated_field.

        IF lv_tabix &lt;&gt; sy-tabix.

          IF ls_fieldinfo_copy-table = ls_fieldinfo-table.
            lv_same_cnt                 = lv_same_cnt + 1.
            ls_fieldinfo_copy-samecount = lv_same_cnt.

            CONCATENATE ls_fieldinfo_copy-table ls_fieldinfo_copy-generated_field
              INTO ls_fieldinfo_copy-generated_field SEPARATED BY &apos;_&apos;.

            lv_string = lv_same_cnt.

            CONCATENATE ls_fieldinfo_copy-generated_field lv_string
              INTO ls_fieldinfo_copy-generated_field SEPARATED BY &apos;_&apos;.

            MODIFY lt_fieldinfo_copy FROM ls_fieldinfo_copy INDEX sy-tabix.
          ENDIF.

          IF ls_fieldinfo_copy-table &lt;&gt; ls_fieldinfo-table.
            IF ls_fieldinfo_copy-field_alias IS NOT INITIAL.
              ls_fieldinfo_copy-generated_field = ls_fieldinfo_copy-field_alias.
            ELSE.
              CONCATENATE ls_fieldinfo_copy-table ls_fieldinfo_copy-generated_field
                INTO lv_string SEPARATED BY &apos;_&apos;.
              ls_fieldinfo_copy-generated_field = lv_string.
            ENDIF.

            MODIFY lt_fieldinfo_copy FROM ls_fieldinfo_copy INDEX sy-tabix.
          ENDIF.

        ENDIF.

      ENDLOOP.

    ENDLOOP.

    mt_fieldinfo[] = lt_fieldinfo_copy[].

  ENDMETHOD.                    &quot;


  METHOD check_inserted_orgcritdep.

    FIELD-SYMBOLS: &lt;lt_inserted&gt; TYPE ANY TABLE.

    ASSIGN it_inserted-&gt;* TO &lt;lt_inserted&gt;.

    IF sy-subrc NE 0.
      RAISE assign_error.
    ENDIF.



*             AUTHORITY-CHECK OBJECT &apos;S_TABU_LIN&apos;
*             ID &apos;ORG_CRIT&apos; FIELD ls_orgcrit_tabdep-org_crit
*             ID &apos;ACTVT&apos; FIELD &apos;02&apos;
*             ID &apos;ORG_FIELD1&apos; FIELD &apos;__________&apos;
*             ID &apos;ORG_FIELD2&apos; FIELD &apos;__________&apos;
*             ID &apos;ORG_FIELD3&apos; FIELD &apos;__________&apos;
*             ID &apos;ORG_FIELD4&apos; FIELD &apos;__________&apos;
*             ID &apos;ORG_FIELD5&apos; FIELD &apos;__________&apos;
*             ID &apos;ORG_FIELD6&apos; FIELD &apos;__________&apos;
*             ID &apos;ORG_FIELD7&apos; FIELD &apos;__________&apos;
*             ID &apos;ORG_FIELD8&apos; FIELD &apos;__________&apos;.
*
*
*          IF sy-subrc = 1.
*            RAISE no_auth_for_inserted_records.
*          ENDIF.


  ENDMETHOD.                    &quot;CHECK_INSERTED_ORGCRITDEP


ENDCLASS.                    &quot;lcl_HTDB_CL_COMMAND_SELECT IMPLEMENTATION

*---------------------------------------------------------------------*
*       CLASS LCL_COMMAND DEFINITION
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
CLASS lcl_command DEFINITION ABSTRACT.

  PUBLIC SECTION.

    DATA: mo_pipacs_command     TYPE REF TO lcl_htdb_cl_command,
          mt_srccode            TYPE lty_zhtdbt_string_tab,

          mr_lock_argument      TYPE REF TO data,
          mr_lock_argument_temp TYPE REF TO data,

          mv_last_display       TYPE lty_last_display_mode,
          mv_grid_modified      TYPE c,

          mv_colmn_header       TYPE c,
          mv_key_colmn_type     TYPE c,
          mv_command_type(2)    TYPE n.

    METHODS: execute_parsed_sql
      IMPORTING
        po_grid           TYPE REF TO cl_gui_alv_grid OPTIONAL
        po_tree           TYPE REF TO cl_gui_alv_tree OPTIONAL
        iv_simulation     TYPE char1 OPTIONAL
        iv_bg_proc        TYPE char1 OPTIONAL
        iv_bg_date        TYPE btcsdate OPTIONAL
        iv_bg_time        TYPE btcstime OPTIONAL
        iv_read_from_file TYPE flag OPTIONAL
      EXPORTING
        er_exception      TYPE REF TO cx_root
        et_srccode        TYPE lty_zhtdbt_string_tab
      EXCEPTIONS
        table_not_found
        parse_error
        exec_error
        error_occurred
        unlock_error
        arg_to_long
        foreign_lock
        foreign_lock_all_clients
        job_submit_error
        field_list_changed
        file_open_error
        no_auth_for_table,

* sima GET/SET cuccok
      set_commandtext IMPORTING p_commandtext TYPE gty_commandtext,
      get_type EXPORTING VALUE(ep_command_type) TYPE lty_commandtype,

      parse_commandtext
        IMPORTING
          p_on_load TYPE c OPTIONAL
          p_bf_test TYPE c OPTIONAL
        EXCEPTIONS
          error_occurred,

      constructor
        IMPORTING
          p_copy_from TYPE REF TO lcl_command OPTIONAL.


* VRANGES
**** value range cuccok begin
    DATA:
      it_ranges TYPE lty_zhdb_vrange_tab,
      is_x030l  TYPE x030l.

    DATA: mt_alias_ranges TYPE TABLE OF gty_alias_ranges,
          mt_ranges       TYPE TABLE OF gty_ranges.

**** value range cuccok end

* a jobb oldali fa itabja (tablanevek, value rangek) es node_key referencia table
    DATA: mt_outtab_tb     TYPE TABLE OF lty_zhtdb_alv_tab,
          mt_tab_node_xref TYPE TABLE OF gty_tab_node_xref.


* command type: select/update/delete/LAWB/script/select fae
    DATA: command_type    TYPE lty_commandtype,
          command_id      TYPE lty_commandid,
* hany sort erintett a command
          mv_dbcnt        TYPE i,
          mv_rowlen       TYPE i,
          mv_bytes        TYPE i,
* tree hierarchianban melyik szinten van
          treelevel       TYPE i,

* where text kulon
          where_text      TYPE gty_commandtext,

* command text mint string
          commandtext     TYPE gty_commandtext,
* generalt command text mint string
          gen_commandtext TYPE gty_commandtext,

* generalt text, obsolete lesz
          gen_text        TYPE source_table,
* original text, obsolete lesz (?)
          text            TYPE source_table,
          table_alias_tb  TYPE lty_zhtdb_table_aliases_tt,

*    DATA:  mv_tot_upd TYPE i,
*           mv_tot_ins TYPE i,
*           mv_tot_del TYPE i,
*           mv_upd TYPE i,
*           mv_ins TYPE i,
*           mv_del TYPE i,
* hany byte volt a teljes athozott result set
          mv_filtered     TYPE i,
          mv_pos          TYPE i.

    DATA:  alv_state TYPE i.

    DATA: mv_locked        TYPE c,
*           mv_locked_count TYPE i,

          mv_ctext_changed TYPE c.

  PRIVATE SECTION.



ENDCLASS.                    &quot;LCL_COMMAND DEFINITION

CLASS lcl_select_command DEFINITION DEFERRED.

*----------------------------------------------------------------------*
*       CLASS lcl_application DEFINITION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_application DEFINITION.

  PUBLIC SECTION.


** brute force testing stuff

    TYPES: BEGIN OF mty_t_type,
             line(255),
*        LINE TYPE string,
           END OF mty_t_type.

    DATA:
      mv_log_handle TYPE balloghndl,
      ms_s_msg      TYPE bal_s_msg.

** brute force test end


    DATA: mv_tree_tb_width TYPE i,
          mv_result_height TYPE i.


    METHODS:

      remove_gen_programs,
      insert_stringtab_to_pos
        IMPORTING
          it_stringtab TYPE lty_zhtdbt_string_tab,

      check_s_tabu_dis
        IMPORTING
          iv_for_editing TYPE char1
          iv_tabname     TYPE tabname
        EXPORTING
          ev_auth        TYPE char1,

      issue_message
        IMPORTING
          iv_msgty        TYPE symsgty
          iv_msgno        TYPE symsgno
          iv_to_log       TYPE char1 DEFAULT &apos; &apos;
          iv_msgid        TYPE symsgid DEFAULT sy-msgid
          iv_display_like TYPE char1 OPTIONAL
          iv_msgv1        TYPE any OPTIONAL
          iv_msgv2        TYPE any OPTIONAL
          iv_msgv3        TYPE any OPTIONAL
          iv_msgv4        TYPE any OPTIONAL,

      constructor,

      get_selected_word
        EXPORTING
          ep_word TYPE string,

      show_abap_docu,
      show_syntax_diagram,

      read_checktables
        IMPORTING
          sender  TYPE c
          i_ucomm TYPE sy-ucomm,

      create_txt_toolbar,

      handle_lq_ctx_sel
        IMPORTING
          sender  TYPE c
          e_ucomm TYPE sy-ucomm,

      handle_context_menu
        FOR EVENT context_menu OF cl_gui_abapedit &quot;cl_gui_textedit
        IMPORTING menu sender,

      handle_f1_textedit
        FOR EVENT f1 OF cl_gui_abapedit, &quot;cl_gui_textedit,


      handle_context_menu_selected
        FOR EVENT context_menu_selected OF cl_gui_abapedit &quot;cl_gui_textedit
        IMPORTING fcode,

      handle_node_ctx_menu_sel_lq
        FOR EVENT node_context_menu_selected OF cl_gui_alv_tree
        IMPORTING fcode,

      handle_context_menu_tree_tb_n
        FOR EVENT node_context_menu_request OF cl_gui_alv_tree
        IMPORTING menu,

      handle_lq_context_menu
        IMPORTING
          sender   TYPE c
          e_object TYPE REF TO cl_ctmenu,


* tables tree
      handle_node_double_click
        FOR EVENT node_double_click OF cl_gui_alv_tree
        IMPORTING node_key,

*new*
      handle_dropdown_clicked
        FOR EVENT dropdown_clicked OF cl_gui_toolbar
        IMPORTING fcode posx posy.

    METHODS: refresh_status_indicators,
      display_table_grid,
      create_tb_tree_toolbar.

    METHODS:

      handle_function_selected
        FOR EVENT function_selected OF cl_gui_toolbar
        IMPORTING fcode,

      handle_function_selected_txt
        FOR EVENT function_selected OF cl_gui_toolbar
        IMPORTING fcode.
    METHODS:

      handle_context_menu_alv
        FOR EVENT context_menu_request OF cl_gui_alv_grid
        IMPORTING e_object sender,

      handle_menu_button
        FOR EVENT menu_button OF cl_gui_alv_grid
        IMPORTING e_object e_ucomm,

      handle_toolbar
        FOR EVENT toolbar OF cl_gui_alv_grid
        IMPORTING e_object e_interactive sender,

      handle_user_command
        FOR EVENT user_command OF cl_gui_alv_grid
        IMPORTING e_ucomm sender,

      handle_double_click
        FOR EVENT double_click OF cl_gui_alv_grid
        IMPORTING e_column e_row sender,

      handle_after_refresh
        FOR EVENT data_changed OF cl_gui_alv_grid.

    METHODS:
      set_column_settings IMPORTING p_mode TYPE sy-ucomm,
      set_key_field_settings IMPORTING p_mode TYPE sy-ucomm,
      set_column_headings,
      set_key_display_attributes,
      refresh_display.


ENDCLASS.                    &quot;lcl_application DEFINITION

*---------------------------------------------------------------------*
*       CLASS LCL_COMMANDS DEFINITION
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
CLASS lcl_commands DEFINITION.

  PUBLIC SECTION.

    TYPES: BEGIN OF gty_commands,
             seq_no     TYPE i,
             command_id TYPE lty_commandid,
             treelevel  TYPE i,
             command    TYPE REF TO lcl_command,
           END OF gty_commands.


    TYPES: BEGIN OF mty_ctypes_exclude,
             fcode TYPE rsmpe-func,
           END OF mty_ctypes_exclude.

    METHODS:
      transfer_text_to_command,

      generate_structure
        EXCEPTIONS
          empty_fieldinfo_tb
          command_is_not_select
          field_not_found,

      display
        IMPORTING
          po_grid TYPE REF TO cl_gui_alv_grid OPTIONAL
          po_tree TYPE REF TO cl_gui_alv_tree OPTIONAL,

      create_new_command
        IMPORTING
          p_command_type         TYPE lty_commandtype
          REFERENCE(p_copy_from) TYPE REF TO lcl_command OPTIONAL
          sql                    TYPE string OPTIONAL,
*                 p_during_initial_load TYPE c OPTIONAL,

      execute_command
        IMPORTING
          iv_mode           TYPE sy-ucomm
          iv_bg_proc        TYPE char1 OPTIONAL
          iv_bg_date        TYPE btcsdate OPTIONAL
          iv_bg_time        TYPE btcstime OPTIONAL
          iv_read_from_file TYPE flag OPTIONAL,

      parse_only_command
        IMPORTING
          p_on_load TYPE c OPTIONAL
        EXCEPTIONS
          no_id
          create_error
          no_parent
          parse_error,

      display_command,
      write_status_message.

    DATA:  command_count TYPE i VALUE 0.

    DATA: command_list    TYPE TABLE OF gty_commands,
          current_command TYPE REF TO lcl_command,
          prev_command    TYPE REF TO lcl_command.


ENDCLASS.                    &quot;LCL_COMMANDS DEFINITION





*---------------------------------------------------------------------*
*       CLASS LCL_SELECT_COMMAND DEFINITION
*---------------------------------------------------------------------*
*
*---------------------------------------------------------------------*
CLASS lcl_select_command DEFINITION INHERITING FROM lcl_command.

  PUBLIC SECTION.

* backup tablebol select
    DATA: mo_pipacs_select TYPE REF TO lcl_htdb_cl_command_select.

    METHODS: execute_parsed_sql REDEFINITION,

      parse_commandtext REDEFINITION.

    METHODS:

      calculate_mv_rowlen,

      constructor
        IMPORTING
          p_copy_from TYPE REF TO lcl_select_command OPTIONAL.

    METHODS:
      assign_field_symbols.

    METHODS: assign_field_symbol
      IMPORTING p_fs           TYPE c
      CHANGING  VALUE(p_table) TYPE REF TO data.


    DATA: fcat                 TYPE lvc_t_fcat,
          prev_fcat            TYPE lvc_t_fcat,
          fieldinfo_tb         TYPE TABLE OF gty_fieldinfo,
          ddic_references      TYPE TABLE OF gty_ddicref,
          can_edit             TYPE c,

*           lock_results TYPE c,
          has_table_alias      TYPE c,
          has_duplicate_fields TYPE c,
          selected_rows        TYPE lvc_t_row,
          selected_rows2       TYPE lvc_t_roid.


    DATA: select_text   TYPE gty_commandtext,
          from_text     TYPE gty_commandtext,
          group_by_text TYPE gty_commandtext,
          having_text   TYPE gty_commandtext,
          order_by_text TYPE gty_commandtext.
*          sort_text TYPE gty_commandtext.

    DATA: result_table     TYPE REF TO data,
          display_table    TYPE REF TO data,
          deleted_table    TYPE REF TO data,
          updated_table    TYPE REF TO data,
          inserted_table   TYPE REF TO data,
          tree_table       TYPE REF TO data,
          returned_table   TYPE REF TO data,
          temp_table       TYPE REF TO data,
          undo_table       TYPE REF TO data,
          lawb_table       TYPE REF TO data,
          selfae_table     TYPE REF TO data,
          result_structure TYPE REF TO data,
          temp_structure   TYPE REF TO data,
          undo_structure   TYPE REF TO data.

    DATA: mv_read_from_file TYPE c.

*  PRIVATE SECTION.


ENDCLASS.                    &quot;LCL_SELECT_COMMAND DEFINITION


DATA: g_application TYPE REF TO lcl_application,
      g_commands    TYPE REF TO lcl_commands.

DATA: gv_max_rowid TYPE i.

DATA: gt_dynpread TYPE TABLE OF dynpread.

DATA: gv_starttime TYPE i,
      gv_endtime   TYPE i,
      gv_deltatime TYPE i.

DATA: go_splitter_outer         TYPE REF TO cl_gui_splitter_container,
      go_splitter_inner         TYPE REF TO cl_gui_splitter_container,
      go_container_alv_tb       TYPE REF TO cl_gui_container,
      go_container_reklam       TYPE REF TO cl_gui_container,
      go_container_alv          TYPE REF TO cl_gui_container,
      go_container_textedit     TYPE REF TO cl_gui_container,
      go_container_for_inner_sp TYPE REF TO cl_gui_container.


*      g_html_viewer               TYPE REF TO cl_gui_html_viewer.


DATA: gt_selfae_jointext          TYPE source_table.
DATA: gc_nodekey_current_commands TYPE lvc_nkey.

DATA: gv_data_changed_finished TYPE c.

DATA: g_selected_nodekey TYPE lvc_nkey.

DATA: gv_autotest   TYPE c.

DATA: gt_outtab_tb                TYPE TABLE OF lty_zhtdb_alv_tab.


* changing the node style in the navtree
* tolnatej requirement
* must be global (in automation call)

*----------------------------------------------------------------------*
***INCLUDE ZHTDB_STATUS_0100O01 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Module  STATUS_0100  OUTPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE status_0100 OUTPUT.

  PERFORM status_0100.

ENDMODULE.                 &quot; STATUS_0100  OUTPUT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  STATUS_0100
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM status_0100.

  DATA: l_hierarchy_header TYPE treev_hhdr,
        lt_events          TYPE cntl_simple_events,
        ls_events          TYPE cntl_simple_event,

        events             TYPE cntl_simple_events,
        event              TYPE cntl_simple_event.


  IF gv_0100_first_run = &apos;X&apos;.  &quot; first call of the screen

    SET PF-STATUS &apos;100_MAIN&apos;.
    SET TITLEBAR  &apos;100_TITLE&apos; WITH &apos;SQL&apos;.

    gv_def_col_hdr = &apos;T&apos;.
    gv_def_keycol_type = &apos;F&apos;.

  ENDIF.

  IF g_application IS INITIAL.

    CREATE OBJECT g_application.

    CALL METHOD g_application-&gt;remove_gen_programs.

  ENDIF.


  IF go_splitter_outer IS INITIAL.

    g_application-&gt;mv_tree_tb_width = 25.
    g_application-&gt;mv_result_height = 50.



    CREATE OBJECT go_splitter_outer
      EXPORTING
        parent  = cl_gui_container=&gt;default_screen &quot; cl_gui_custom_container=&gt;screen0 &quot;go_container_main
        rows    = 2
        columns = 1.

    CALL METHOD go_splitter_outer-&gt;get_container
      EXPORTING
        row       = 1
        column    = 1
      RECEIVING
        container = go_container_for_inner_sp
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_outer-&gt;get_container
      EXPORTING
        row       = 2
        column    = 1
      RECEIVING
        container = go_container_alv
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CREATE OBJECT go_splitter_inner
      EXPORTING
        parent  = go_container_for_inner_sp
        rows    = 1
        columns = 3.

    CALL METHOD go_splitter_inner-&gt;get_container
      EXPORTING
        row       = 1
        column    = 1
      RECEIVING
        container = go_container_textedit
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_inner-&gt;get_container
      EXPORTING
        row       = 1
        column    = 2
      RECEIVING
        container = go_container_alv_tb
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


    CALL METHOD go_splitter_inner-&gt;get_container
      EXPORTING
        row       = 1
        column    = 3
      RECEIVING
        container = go_container_reklam
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_inner-&gt;set_column_width
      EXPORTING
        id    = 3
        width = 30.

    go_splitter_inner-&gt;set_row_mode( mode = go_splitter_inner-&gt;mode_absolute ).

    CALL METHOD go_splitter_inner-&gt;set_column_sash
      EXPORTING
        id                = 2
        type              = cl_gui_splitter_container=&gt;type_movable
        value             = cl_gui_splitter_container=&gt;false
*         IMPORTING
*       RESULT            =
      EXCEPTIONS
        cntl_error        = 1
        cntl_system_error = 2
        OTHERS            = 3.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_refresh.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_view_excel.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

*   gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_sum.
*   APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_check.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_undo.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_append_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_insert_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_delete_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_cut.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_paste_new_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_paste.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_loc_copy_row.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

*   gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_subtot.
*   APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_info.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_toolbar_exclude = cl_gui_alv_grid=&gt;mc_fc_help.
    APPEND gs_toolbar_exclude TO gt_toolbar_exclude.

    gs_layo-edit       = &apos;X&apos;.
    gs_layo-zebra      = &apos;X&apos;.
    gs_layo-stylefname = &apos;ZENITH_STYLE&apos;.
    gs_layo-cwidth_opt = &apos;X&apos;.
    gs_layo-ctab_fname = &apos;ZENITH_COLOR&apos;.
    gs_layo-sel_mode   = &apos;D&apos;.
    gs_layo-no_rowmove = &apos;X&apos;.
    gs_layo-no_rowins  = &apos;X&apos;.
    gs_layo-no_keyfix  = &apos;X&apos;.
    gs_layo-smalltitle = &apos;X&apos;.

    CREATE OBJECT g_alv
      EXPORTING
        i_parent = go_container_alv.

    CALL METHOD g_alv-&gt;set_ready_for_input
      EXPORTING
        i_ready_for_input = 0
      EXCEPTIONS
        OTHERS            = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    SET HANDLER g_application-&gt;handle_toolbar               FOR ALL INSTANCES.
    SET HANDLER g_application-&gt;handle_user_command          FOR ALL INSTANCES.
    SET HANDLER g_application-&gt;handle_menu_button           FOR g_alv.
*    SET HANDLER g_application-&gt;handle_data_changed          FOR g_alv.
*    SET HANDLER g_application-&gt;handle_data_changed_finished FOR g_alv.
    SET HANDLER g_application-&gt;handle_double_click          FOR g_alv.
    SET HANDLER g_application-&gt;handle_context_menu_alv      FOR g_alv.

    gs_layo_tb-edit       = &apos; &apos;.
    gs_layo_tb-cwidth_opt = &apos;X&apos;.
    gs_layo_tb-sel_mode   = &apos;B&apos;.

    CREATE OBJECT g_tree_tb
      EXPORTING
        parent                      = go_container_alv_tb
        node_selection_mode         = cl_gui_column_tree=&gt;node_sel_mode_single
        item_selection              = &apos; &apos;
        no_html_header              = &apos;X&apos;
        no_toolbar                  = &apos;&apos;
      EXCEPTIONS
        cntl_error                  = 1
        cntl_system_error           = 2
        create_error                = 3
        lifetime_error              = 4
        illegal_node_selection_mode = 5
        failed                      = 6
        illegal_column_name         = 7.

    IF sy-subrc &lt;&gt; 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_tree_tb-&gt;set_screen_update
      EXPORTING
        i_update = &apos; &apos;.


    DATA: ls_fcat_tb TYPE lvc_s_fcat.

    ls_fcat_tb-fieldname = &apos;DDTEXT&apos;.
    ls_fcat_tb-inttype = &apos;C&apos;.
    ls_fcat_tb-intlen  = &apos;255&apos;.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    ls_fcat_tb-fieldname = &apos;TABLENAME&apos;.
    ls_fcat_tb-rollname  = &apos;TABNAME&apos;.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    ls_fcat_tb-fieldname = &apos;FIELDNAME&apos;.
    ls_fcat_tb-rollname  = &apos;FIELDNAME&apos;.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    ls_fcat_tb-fieldname = &apos;ALIAS&apos;.
    ls_fcat_tb-rollname  = &apos;TABNAME&apos;.
    APPEND ls_fcat_tb TO gt_fcat_tb.

    LOOP AT gt_fcat_tb INTO gs_fcat_tb.
      IF gs_fcat_tb-fieldname = &apos;TABLENAME&apos; OR
         gs_fcat_tb-fieldname = &apos;FIELDNAME&apos; OR
         gs_fcat_tb-fieldname = &apos;ALIAS&apos;.
        gs_fcat_tb-tech   = &apos;X&apos;.
        gs_fcat_tb-no_out = &apos;X&apos;.
      ENDIF.

      IF gs_fcat_tb-fieldname = &apos;DDTEXT&apos;.
        gs_fcat_tb-coltext   = TEXT-145.
        gs_fcat_tb-tooltip   = TEXT-145.
        gs_fcat_tb-reptext   = TEXT-145.
        gs_fcat_tb-outputlen = 255.
        CLEAR: gs_fcat_tb-tech, gs_fcat_tb-no_out.
      ENDIF.

      MODIFY gt_fcat_tb FROM gs_fcat_tb.
    ENDLOOP.

    l_hierarchy_header-heading   = TEXT-137.
    l_hierarchy_header-width     = 40.
    l_hierarchy_header-width_pix = &apos;&apos;.

    CALL METHOD g_tree_tb-&gt;set_table_for_first_display
      EXPORTING
        is_hierarchy_header = l_hierarchy_header
      CHANGING
        it_fieldcatalog     = gt_fcat_tb
        it_outtab           = gt_outtab_tb
      EXCEPTIONS
        OTHERS              = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_tree_tb-&gt;get_registered_events
      IMPORTING
        events     = lt_events
      EXCEPTIONS
        cntl_error = 1
        OTHERS     = 2.

    IF sy-subrc &lt;&gt; 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    ls_events-appl_event = &apos; &apos;.
    ls_events-eventid = cl_gui_column_tree=&gt;eventid_node_context_menu_req.
    APPEND ls_events TO lt_events.
*
*   ls_events-eventid = cl_gui_column_tree=&gt;eventid_item_context_menu_req.
*   APPEND ls_events TO lt_events.

    ls_events-eventid = cl_gui_column_tree=&gt;eventid_node_double_click.
    APPEND ls_events TO lt_events.

    CALL METHOD g_tree_tb-&gt;set_registered_events
      EXPORTING
        events                    = lt_events
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3
        OTHERS                    = 4.

    IF sy-subrc &lt;&gt; 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

*   SET HANDLER g_application-&gt;handle_function_selected      FOR g_toolbar_tb_tree.
    SET HANDLER g_application-&gt;handle_node_double_click      FOR g_tree_tb.
    SET HANDLER g_application-&gt;handle_node_ctx_menu_sel_lq   FOR g_tree_tb.
    SET HANDLER g_application-&gt;handle_context_menu_tree_tb_n FOR g_tree_tb.

*    CREATE OBJECT g_html_viewer
*      EXPORTING
*        parent = go_container_reklam.
*
*    DATA: lv_url(255) TYPE c.
*
*    CONCATENATE &apos;http://www.hovitaga.com/&apos;
*    &apos;oe_free_edition_reklam_tidy_20111028.php?h=&apos;
*    gc_hash
*    INTO lv_url.
*
*    CONDENSE lv_url NO-GAPS.
*
*    g_html_viewer-&gt;show_url( url = lv_url ).
    CREATE OBJECT o_event
      EXPORTING
        boton_borrar = &apos;X&apos;.

    CREATE OBJECT o_alv
      EXPORTING
        o_container = go_container_reklam
        estructura  = &apos;ZTEMPS&apos;
        o_event     = o_event.

    o_alv-&gt;registrar_enter( ).
    o_alv-&gt;registrar_mod( ).

    SELECT * FROM ztemps
      INTO TABLE i_sql
     WHERE clave = &apos;ZSQL_APC&apos;
       AND ernam = sy-uname
     ORDER BY erdat DESCENDING erzet DESCENDING.

    o_alv-&gt;quitar_todos_botones_insercion( ).
    o_alv-&gt;set_field_text( campo = &apos;STRING&apos; valor = &apos;SQL&apos; ).
    o_alv-&gt;set_field_text( campo = &apos;SUBCLAVE&apos; valor = &apos;Tabla&apos; ).
    o_alv-&gt;set_field_text( campo = &apos;VALOR&apos; valor = &apos;Grupo&apos; ).
    o_alv-&gt;set_field_text( campo = &apos;TEXTO&apos; valor = &apos;Comentario&apos; ).
    o_alv-&gt;set_field_input( &apos;VALOR,TEXTO&apos; ).
    o_alv-&gt;set_field_noout( &apos;CLAVE,INDICE,TEXTO,PERMANENTE&apos; ).
    o_alv-&gt;set_orden( campo = &apos;ERDAT&apos; down = &apos;X&apos; ).
    o_alv-&gt;set_orden( campo = &apos;ERZET&apos; down = &apos;X&apos; ).

    o_alv-&gt;show( CHANGING tabla = i_sql ).

  ENDIF.

  IF g_textedit IS INITIAL.

    CREATE OBJECT g_textedit
      EXPORTING
        parent = go_container_textedit.

    SET HANDLER g_application-&gt;handle_context_menu FOR g_textedit.
    SET HANDLER g_application-&gt;handle_context_menu_selected FOR g_textedit.
    SET HANDLER g_application-&gt;handle_f1_textedit FOR g_textedit.

    event-eventid = cl_gui_textedit=&gt;event_f1.
    APPEND event TO events.

    event-eventid = cl_gui_textedit=&gt;event_context_menu_selected.
    APPEND event TO events.

    event-eventid = cl_gui_textedit=&gt;event_context_menu.
    APPEND event TO events.

*REGISTER_EVENT_F1 ?

    CALL METHOD g_textedit-&gt;set_registered_events
      EXPORTING
        events                    = events
      EXCEPTIONS
        cntl_error                = 1
        cntl_system_error         = 2
        illegal_event_combination = 3.

    IF sy-subrc &lt;&gt; 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDIF.

* ZMI?
**  IF gt_dynpread IS NOT INITIAL.
**
**    CALL FUNCTION &apos;DYNP_UPDATE_FIELDS&apos;
**      EXPORTING
**        dyname               = sy-repid
**        dynumb               = &apos;0100&apos;
**        request              = &apos;A&apos;
**      TABLES
**        dynpfields           = gt_dynpread
**      EXCEPTIONS
**        invalid_abapworkarea = 1
**        invalid_dynprofield  = 2
**        invalid_dynproname   = 3
**        invalid_dynpronummer = 4
**        invalid_request      = 5
**        no_fielddescription  = 6
**        undefind_error       = 7
**        OTHERS               = 8.
**
**    IF sy-subrc &lt;&gt; 0.
**      IF sy-msgno IS NOT INITIAL.
**        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
**                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
**      ENDIF.
**    ENDIF.
**
**    CLEAR gt_dynpread.
**
**  ENDIF.

  IF gv_data_changed_finished EQ &apos;X&apos;.

    CLEAR gv_data_changed_finished.

    CALL METHOD g_alv-&gt;set_focus
      EXPORTING
        control = g_alv
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ELSE.

    CALL METHOD g_textedit-&gt;set_focus
      EXPORTING
        control = g_textedit
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDIF.

  IF g_commands IS INITIAL.

    CREATE OBJECT g_commands.

    CALL METHOD g_application-&gt;create_tb_tree_toolbar.

    CALL METHOD g_commands-&gt;create_new_command
      EXPORTING
        p_command_type = 1.


  ENDIF.


ENDFORM.                    &quot; STATUS_0100


*----------------------------------------------------------------------*
*       CLASS lcl_event_grid IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_event_grid IMPLEMENTATION.

  METHOD double_click.
    READ TABLE i_sql INTO l_sql INDEX e_row-index.
    IF sy-subrc = 0.
      SELECT SINGLE string FROM ztemps
        INTO l_sql-string
       WHERE clave = &apos;ZSQL_APC&apos;
         AND subclave = l_sql-subclave
         AND indice = l_sql-indice.

      CLEAR i_lineas_sql.
      zcl_ap_string=&gt;string2tabla( EXPORTING string   = l_sql-string
                                             longitud = 255
                                   CHANGING  tabla    = i_lineas_sql ).

**            zcl_ap_string=&gt;string2tabla( EXPORTING string = l_sql-string
**                                         CHANGING tabla = l_select-&gt;text ).

*      CALL FUNCTION &apos;SWA_STRING_TO_TABLE&apos;
*        EXPORTING
*          character_string           = l_sql-string
**         APPEND                     = &apos; &apos;
*          LINE_SIZE                  = 255
**         CHECK_TABLE_TYPE           = &apos; &apos;
*        IMPORTING
*          character_table            = i_lineas_sql
**         TOTAL_LENGTH               = TOTAL_LENGTH
**         LINE_SIZE_USED             = LINE_SIZE_USED
**         LINES_FILLED               = LINES_FILLED
**         LAST_LINE_LENGTH           = LAST_LINE_LENGTH
*        EXCEPTIONS
*          no_flat_charlike_structure = 1.

      CALL METHOD g_commands-&gt;create_new_command
        EXPORTING
          p_command_type = 1
          sql            = &apos;*&apos;.
    ENDIF.

  ENDMETHOD.                                               &quot;double_click

  METHOD user_command.

    CASE e_ucomm .
      WHEN &apos;BORRAR&apos;.
        o_alv-&gt;set_marca_filas_sel( EXPORTING campo = &apos;MANDT&apos; CHANGING t_tabla = i_sql ).

        LOOP AT i_sql INTO l_sql WHERE mandt = &apos;X&apos;.
          DELETE FROM ztemps
           WHERE clave = l_sql-clave
             AND subclave = l_sql-subclave
             AND indice = l_sql-indice.
          DELETE i_sql.
        ENDLOOP.
        o_alv-&gt;refrescar_grid( ).
    ENDCASE .

  ENDMETHOD.                                               &quot;USER_COMMAND

  METHOD data_changed.
    DATA: ls_good     TYPE lvc_s_modi,
          i_cambios   TYPE lvc_t_modi,
          l_campo(40).
    FIELD-SYMBOLS &lt;fs&gt; TYPE any.

    i_cambios = er_data_changed-&gt;mt_good_cells.
    SORT i_cambios BY row_id.

    LOOP AT i_cambios INTO ls_good.
      AT NEW row_id.
        CLEAR l_sql.
        READ TABLE i_sql INTO l_sql INDEX ls_good-row_id.
      ENDAT.
      IF sy-subrc = 0.
        CONCATENATE &apos;L_SQL-&apos; ls_good-fieldname INTO l_campo.
        ASSIGN (l_campo) TO &lt;fs&gt;.
        IF sy-subrc = 0.
          &lt;fs&gt; = ls_good-value.
        ENDIF.
      ENDIF.
      AT END OF row_id.
        MODIFY ztemps FROM l_sql.
      ENDAT.
    ENDLOOP.

  ENDMETHOD.                    &quot;data_changed

ENDCLASS.                    &quot;lcl_event_grid IMPLEMENTATION
*----------------------------------------------------------------------*
***INCLUDE ZHTDB_USER_COMMAND_0100I01 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_0100  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*

MODULE user_command_0100 INPUT.

  PERFORM user_command_0100.

  CLEAR gv_0100_first_run.

ENDMODULE.                 &quot; USER_COMMAND_0100  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  USER_COMMAND_0100
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM user_command_0100.

  CASE ok_code.


    WHEN &apos;SYNTAXD&apos;.

*      PERFORM LOAD_DYNPRO USING &apos;0100&apos; sy-repid.
      CALL METHOD g_application-&gt;show_syntax_diagram.

    WHEN &apos;ABAPDOCU&apos;.

      CALL METHOD g_application-&gt;show_abap_docu.

    WHEN &apos;EXEC&apos; OR &apos;SIMULATE&apos; OR &apos;EXEC_BG&apos;.

      IF g_commands-&gt;current_command IS NOT INITIAL.


        CLEAR autotrace.
        CALL METHOD g_commands-&gt;execute_command
          EXPORTING
            iv_mode = ok_code.

      ELSE.
        CALL METHOD g_application-&gt;issue_message
          EXPORTING
            iv_msgty        = &apos;I&apos;
            iv_msgno        = &apos;061&apos;
            iv_display_like = &apos;E&apos;.
*          message i061 DISPLAY LIKE &apos;E&apos;.
      ENDIF.

  ENDCASE.

  CLEAR ok_code.

ENDFORM.                    &quot; USER_COMMAND

*----------------------------------------------------------------------*
***INCLUDE ZHTDB_USER_COMMAND_0100_EXITI1 .
*----------------------------------------------------------------------*
*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_0100_EXIT  INPUT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
MODULE user_command_0100_exit INPUT.

  PERFORM user_command_0100_exit.

ENDMODULE.                 &quot; USER_COMMAND_0100_EXIT  INPUT
*&amp;---------------------------------------------------------------------*
*&amp;      Form  USER_COMMAND_0100_EXIT
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*  --&gt;  p1        text
*  &lt;--  p2        text
*----------------------------------------------------------------------*
FORM user_command_0100_exit .

  CASE ok_code.

    WHEN &apos;BACK&apos; OR &apos;CANCEL&apos; OR &apos;EXIT&apos;.

      LEAVE TO SCREEN 0.

  ENDCASE.

ENDFORM.                    &quot; USER_COMMAND_0100_EXIT



*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZHTDB_LCLAPPLICATION_I                           *
*&amp;---------------------------------------------------------------------*


CLASS lcl_application IMPLEMENTATION.

  METHOD remove_gen_programs.

    DATA: lt_reports TYPE TABLE OF reposrc-progname,
          lv_report  TYPE reposrc-progname.

    SELECT progname
      INTO TABLE lt_reports
      FROM reposrc
      WHERE progname LIKE &apos;ZSQL_APC_TEMP%&apos;.

    LOOP AT lt_reports INTO lv_report.

      CALL FUNCTION &apos;ENQUEUE_ES_PROG&apos;
        EXPORTING
          mode_trdir     = &apos;E&apos;
          name           = lv_report
        EXCEPTIONS
          foreign_lock   = 1
          system_failure = 2
          OTHERS         = 3.

      IF sy-subrc EQ 0.

*     delete program from the repository
        CALL FUNCTION &apos;RS_DELETE_PROGRAM&apos;
          EXPORTING
            program            = lv_report
            suppress_checks    = &apos;X&apos;
            suppress_popup     = &apos;X&apos;
            with_includes      = &apos; &apos;
            with_cua           = &apos; &apos;
            with_documentation = &apos; &apos;
            with_dynpro        = &apos; &apos;
            with_textpool      = &apos; &apos;
            skip_progress_ind  = &apos;X&apos;
          EXCEPTIONS
            enqueue_lock       = 1
            object_not_found   = 2
            permission_failure = 3
            reject_deletion    = 4
            OTHERS             = 5.


        IF sy-subrc &lt;&gt; 0.

          CALL METHOD g_application-&gt;issue_message
            EXPORTING
              iv_msgty        = &apos;S&apos;
              iv_display_like = &apos;W&apos;
              iv_msgno        = sy-msgno
              iv_msgid        = sy-msgid.

        ENDIF.

        CALL FUNCTION &apos;DEQUEUE_ES_PROG&apos;
          EXPORTING
            mode_trdir = &apos;E&apos;
            name       = lv_report.

      ENDIF.

    ENDLOOP.


  ENDMETHOD.                    &quot;remove_gen_programs



  METHOD issue_message.

    IF iv_msgid IS INITIAL.
      ms_s_msg-msgid = &apos;ZSQL_FREE&apos;.
    ELSE.
      ms_s_msg-msgid = iv_msgid.
    ENDIF.

    IF iv_to_log EQ &apos;X&apos; OR gv_autotest = &apos;X&apos;.

      CLEAR ms_s_msg.

      IF iv_msgno IS INITIAL.
        RETURN.
      ENDIF.

      IF     iv_msgid = &apos;SD&apos; AND iv_msgno = 94.
        RETURN.
      ELSEIF iv_msgid = &apos;FL&apos; AND iv_msgno = 714.
        RETURN.
      ENDIF.

      ms_s_msg-msgno = iv_msgno.

      ms_s_msg-msgv1 = iv_msgv1.
      ms_s_msg-msgv2 = iv_msgv2.
      ms_s_msg-msgv3 = iv_msgv3.
      ms_s_msg-msgv4 = iv_msgv4.

      IF ms_s_msg-msgid IS INITIAL.
        ms_s_msg-msgid = &apos;ZSQL_FREE&apos;.
      ENDIF.

      CONDENSE: ms_s_msg-msgv1, ms_s_msg-msgv2, ms_s_msg-msgv3, ms_s_msg-msgv4.

      ms_s_msg-msgty = iv_msgty.
*      ms_s_msg-probclass = iv_probclass.

*      CALL FUNCTION &apos;BAL_LOG_MSG_CUMULATE&apos;
*       EXPORTING
*         I_LOG_HANDLE               = mv_log_handle
*         I_S_MSG                    = ms_s_msg
*  *       I_COMPARE_ATTRIBUTES       = &apos; &apos;
*  *       I_COMPARE_CONTEXT          = &apos; &apos;
*  *       I_COMPARE_PARAMETERS       = &apos; &apos;
*  *     IMPORTING
*  *       E_S_MSG_HANDLE             =
*  *       E_MSG_WAS_LOGGED           =
*  *       E_MSG_WAS_DISPLAYED        =
*       EXCEPTIONS
*         LOG_NOT_FOUND              = 1
*         MSG_INCONSISTENT           = 2
*         LOG_IS_FULL                = 3
*         OTHERS                     = 4
*                .
*      IF sy-subrc &lt;&gt; 0.
*       MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*               WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
*      ENDIF.
*

      CALL FUNCTION &apos;BAL_LOG_MSG_ADD&apos;
        EXPORTING
          i_log_handle = mv_log_handle
          i_s_msg      = ms_s_msg
        EXCEPTIONS
          OTHERS       = 1.
      IF sy-subrc &lt;&gt; 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                 WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.

    ELSE.

      IF iv_msgno IS NOT INITIAL.
        MESSAGE ID     ms_s_msg-msgid
          TYPE         &apos;S&apos;
          NUMBER       iv_msgno
          DISPLAY LIKE iv_msgty &quot; iv_display_like
          WITH         iv_msgv1 iv_msgv2 iv_msgv3 iv_msgv4 .
      ENDIF.

    ENDIF.

  ENDMETHOD.                    &quot;issue_message




  METHOD get_selected_word.

    DATA: l_from      TYPE i,
          l_to        TYPE i,
          l_from_line TYPE i,
          l_to_line   TYPE i,
          lt_text     TYPE source_table,
          l_text      LIKE LINE OF lt_text,
          lstr        TYPE string.
*          l_area      TYPE thead-tdname,


    CALL METHOD g_textedit-&gt;get_selection_pos
      IMPORTING
        from_line              = l_from_line
        from_pos               = l_from
        to_line                = l_to_line
        to_pos                 = l_to
      EXCEPTIONS
        error_cntl_call_method = 1
        OTHERS                 = 2.

    IF sy-subrc &lt;&gt; 0.

      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.

    ENDIF.

*abaped    CALL METHOD g_textedit-&gt;get_text_as_r3table
    CALL METHOD g_textedit-&gt;get_text
      IMPORTING
        table  = lt_text
      EXCEPTIONS
*abaped        potential_data_loss = 1.
        OTHERS = 1.

    IF sy-subrc = 1.
      CALL METHOD g_application-&gt;issue_message
        EXPORTING
          iv_msgty = &apos;I&apos;
          iv_msgno = &apos;025&apos;.
*      MESSAGE i025.
    ENDIF.

    READ TABLE lt_text INTO l_text INDEX l_from_line.

    lstr = l_text.

    CALL METHOD lcl_toolbox=&gt;get_word_at_pos
      EXPORTING
        iv_string   = lstr
        iv_position = l_from
      IMPORTING
        ev_word     = ep_word.

  ENDMETHOD.                    &quot;get_selected_word

  METHOD show_abap_docu.

    DATA: l_word      TYPE string.

    CALL METHOD get_selected_word
      IMPORTING
        ep_word = l_word.

    CHECK l_word IS NOT INITIAL.

    TRANSLATE l_word TO UPPER CASE.

    DATA: lt_search_results TYPE docu_search_abap,
          ls_search_results LIKE LINE OF lt_search_results.

    CALL FUNCTION &apos;ABAP_DOCU_SEARCH&apos;
      EXPORTING
        keyword_or_text = l_word
      IMPORTING
        result          = lt_search_results.

    IF lt_search_results IS NOT INITIAL.

      CALL METHOD g_application-&gt;issue_message
        EXPORTING
          iv_msgty = &apos;S&apos;
          iv_msgno = &apos;062&apos;
          iv_msgv1 = l_word.
*      MESSAGE s062 WITH l_word.

      DATA: l_name      TYPE thead-tdname.

      READ TABLE lt_search_results INTO ls_search_results INDEX 1.
      l_name = ls_search_results-object.

      CALL FUNCTION &apos;ABAP_DOCU_SHOW&apos;
        EXPORTING
          area  = l_name(4)
          name  = l_name+4
          langu = sy-langu.

    ELSE.
*      MESSAGE w063 WITH l_word.
      CALL METHOD g_application-&gt;issue_message
        EXPORTING
          iv_msgty = &apos;W&apos;
          iv_msgno = &apos;063&apos;
          iv_msgv1 = l_word.
    ENDIF.

  ENDMETHOD.                    &quot;show_abap_docu


  METHOD show_syntax_diagram.


    DATA: l_word      TYPE string.

    CALL METHOD get_selected_word
      IMPORTING
        ep_word = l_word.

    CHECK l_word IS NOT INITIAL.

    TRANSLATE l_word TO UPPER CASE.

    DATA: l_keyword TYPE sy-repid.

    l_keyword = l_word.

    CALL FUNCTION &apos;RS_DISPLAY_SYNTAX_DIAGRAM&apos;
      EXPORTING
        keyword = l_keyword.


  ENDMETHOD.                    &quot;show_syntax_diagram




  METHOD constructor.


  ENDMETHOD.                    &quot;lcl_application



  METHOD set_key_field_settings.

    DATA:           l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands-&gt;current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.


    CHECK l_select_command IS NOT INITIAL.

    IF p_mode = &apos;KEY_FIX&apos;.
      l_select_command-&gt;mv_key_colmn_type = &apos;F&apos;.
    ELSE.
      l_select_command-&gt;mv_key_colmn_type = &apos;N&apos;.
    ENDIF.

  ENDMETHOD.                    &quot;set_key_field_settings

  METHOD set_column_settings.

    DATA:
          l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands-&gt;current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.


    CHECK l_select_command IS NOT INITIAL.

    CASE p_mode.
      WHEN &apos;TXT_SHTXT&apos;.
        l_select_command-&gt;mv_colmn_header = &apos;S&apos;.
      WHEN &apos;TXT_GENFLD&apos;.
        l_select_command-&gt;mv_colmn_header = &apos;G&apos;.
      WHEN &apos;TXT_ALIAS&apos;.
        l_select_command-&gt;mv_colmn_header = &apos;A&apos;.
      WHEN &apos;TXT_FLD&apos;.
        l_select_command-&gt;mv_colmn_header = &apos;T&apos;.
    ENDCASE.

  ENDMETHOD.                    &quot;set_column_settings

  METHOD handle_f1_textedit.

    CALL METHOD show_abap_docu.

  ENDMETHOD.                    &quot;lcl_application



  METHOD handle_context_menu.

    CALL METHOD menu-&gt;add_function
      EXPORTING
        fcode  = &apos;PRETTY&apos;
        text   = TEXT-023
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD menu-&gt;add_function
      EXPORTING
        fcode  = &apos;ABAPDOCU&apos;
        text   = TEXT-116
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD menu-&gt;add_function
      EXPORTING
        fcode  = &apos;SYNTAXD&apos;
        text   = TEXT-117
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


  ENDMETHOD.                    &quot;lcl_application

  METHOD handle_context_menu_selected.

    CASE fcode.
      WHEN &apos;ABAPDOCU&apos;.

        CALL METHOD show_abap_docu.

      WHEN &apos;SYNTAXD&apos;.

        CALL METHOD show_syntax_diagram.

      WHEN &apos;PRETTY&apos;.

        DATA: &quot;l_text TYPE source_table,
              l_text TYPE rswsourcet.

*abaped    CALL METHOD g_textedit-&gt;get_text_as_r3table
        CALL METHOD g_textedit-&gt;get_text
          IMPORTING
            table  = l_text
          EXCEPTIONS
*abaped            potential_data_loss = 1.
            OTHERS = 1.

        IF sy-subrc = 1.
          CALL METHOD g_application-&gt;issue_message
            EXPORTING
              iv_msgty = &apos;E&apos;
              iv_msgno = &apos;025&apos;.
*          MESSAGE e025.
        ENDIF.

        IF l_text[] IS NOT INITIAL.


          CALL FUNCTION &apos;CREATE_PRETTY_PRINT_FORMAT&apos;
            EXPORTING
              mode          = &apos;HIKEY&apos;
            TABLES
              source        = l_text
            EXCEPTIONS
              syntax_errors = 1
              OTHERS        = 2.

          IF sy-subrc &lt;&gt; 0.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.


*abaped    CALL METHOD g_textedit-&gt;set_text_as_r3table
          CALL METHOD g_textedit-&gt;set_text
            EXPORTING
              table  = l_text[]
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

        ENDIF.

    ENDCASE.

  ENDMETHOD.                    &quot;lcl_application

  METHOD handle_context_menu_alv.


  ENDMETHOD.                    &quot;lcl_application


  METHOD handle_node_ctx_menu_sel_lq.

    CALL METHOD handle_lq_ctx_sel
      EXPORTING
        sender  = &apos;T&apos;
        e_ucomm = fcode
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;lcl_application

  METHOD handle_context_menu_tree_tb_n.

    CALL METHOD handle_lq_context_menu
      EXPORTING
        sender   = &apos;T&apos;
        e_object = menu
      EXCEPTIONS
        OTHERS   = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;lcl_application

  METHOD handle_lq_context_menu.

    DATA: lq_menu_inner               TYPE REF TO cl_ctmenu,
          lq_menu_outer               TYPE REF TO cl_ctmenu,
          lq_menu_selfae              TYPE REF TO cl_ctmenu,
          lq_menu_subquery            TYPE REF TO cl_ctmenu,
          lq_menu_table_i             TYPE REF TO cl_ctmenu,
          lq_menu_table_o             TYPE REF TO cl_ctmenu,
          lq_menu_table_selfae        TYPE REF TO cl_ctmenu,
          lq_menu_table_subquery      TYPE REF TO cl_ctmenu,
          lq_menu_table_i_prev        TYPE REF TO cl_ctmenu,
          lq_menu_table_o_prev        TYPE REF TO cl_ctmenu,
          lq_menu_table_selfae_prev   TYPE REF TO cl_ctmenu,
          lq_menu_table_subquery_prev TYPE REF TO cl_ctmenu,
          l_fcode                     TYPE ui_func,
          lt_dd08l                    TYPE TABLE OF dd08l,
          ls_table_alias              LIKE LINE OF g_commands-&gt;current_command-&gt;table_alias_tb,
          lstr(40)                    TYPE c,
          lstr4(40)                   TYPE c,
          lstr2                       TYPE string,
          lstr3                       TYPE string,
          lstr5                       TYPE string,
          lint                        TYPE i,
          ls_prev_linkedquery         LIKE gs_linkedquery,
          ls_linkedquery              LIKE gs_linkedquery,
*          l_prev_checktable TYPE dd08l-checktable,
*          l_prev_table TYPE dd08l-checktable,
*          l_prev_ddtext TYPE dd02t-ddtext,
*          l_prev_primpos TYPE dd05m-primpos,
          l_ddtext                    TYPE dd02t-ddtext.

    DATA: dd08v_ia    TYPE TABLE OF dd08v,
          dd05m_ia    TYPE TABLE OF dd05m,
          wa_dd05m_ia TYPE dd05m,
          state(1),
          l_tabname   TYPE dd08l-tabname.

*    CHECK g_commands-&gt;current_command-&gt;mv_locked IS INITIAL.

    CLEAR gt_linkedquery.
    CLEAR lint.

    CALL METHOD e_object-&gt;add_separator
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CHECK g_commands-&gt;current_command-&gt;command_type EQ gc_ctype_select OR
          g_commands-&gt;current_command-&gt;command_type EQ gc_ctype_selfae.

    LOOP AT g_commands-&gt;current_command-&gt;table_alias_tb INTO ls_table_alias.

      CLEAR lt_dd08l.

      l_tabname = ls_table_alias-table.

      CALL FUNCTION &apos;DD_TBFK_GET&apos;
        EXPORTING
*         FIELDNAME     = INCLFIELD
          get_state     = &apos;A&apos;
          tabl_name     = l_tabname
          withtext      = &apos;X&apos;
        IMPORTING
          got_state     = state
        TABLES
          dd05m_tab_a   = dd05m_ia
*         DD05M_TAB_N   = FK1_DD05M
          dd08v_tab_a   = dd08v_ia
*         DD08V_TAB_N   = FK1_DD08V
        EXCEPTIONS
          illegal_value = 01.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.

      ENDIF.

      LOOP AT dd05m_ia INTO wa_dd05m_ia WHERE checkfield NE &apos;MANDT&apos; OR checktable EQ &apos;T000&apos;.

        lint = lint + 1.

        SELECT SINGLE ddtext
        INTO l_ddtext
        FROM dd02t
        WHERE as4local = &apos;A&apos;
              AND tabname = wa_dd05m_ia-checktable
              AND ddlanguage = sy-langu.

        IF sy-subrc NE 0.

          SELECT SINGLE ddtext
          INTO l_ddtext
          FROM dd02t
          WHERE as4local = &apos;A&apos;
                AND tabname = wa_dd05m_ia-checktable.

          IF sy-subrc NE 0.
*            message &apos;ZENITH:sdfgdsf&apos; type &apos;E&apos;.
          ENDIF.

        ENDIF.

        CONCATENATE ls_table_alias-alias &apos;~&apos; wa_dd05m_ia-forkey INTO lstr2.
        CONDENSE lstr2 NO-GAPS.
        CONCATENATE wa_dd05m_ia-checktable &apos;~&apos; wa_dd05m_ia-checkfield INTO lstr3.
        CONDENSE lstr3 NO-GAPS.
        CONCATENATE &apos;ON&apos; lstr3 &apos;=&apos; lstr2 INTO lstr2 SEPARATED BY &apos; &apos;.

        MOVE lstr2 TO lstr.

        lstr2 = lint.
        CONCATENATE &apos;LA_&apos; lstr2 INTO l_fcode.
        CONDENSE l_fcode NO-GAPS.

        CLEAR gs_linkedquery.
        gs_linkedquery-fcode       = l_fcode.
        gs_linkedquery-tabname     = ls_table_alias-alias.
        gs_linkedquery-checktable  = wa_dd05m_ia-checktable.
        gs_linkedquery-fieldname   = wa_dd05m_ia-forkey.
        gs_linkedquery-checkfield  = wa_dd05m_ia-checkfield.
        gs_linkedquery-primpos     = wa_dd05m_ia-primpos.
        gs_linkedquery-text        = lstr.
        gs_linkedquery-longtext    = lstr.
        gs_linkedquery-ddtext      = l_ddtext.

        APPEND gs_linkedquery TO gt_linkedquery.

      ENDLOOP.

    ENDLOOP.


    DATA: l_comp_count TYPE i,
          lt_primpos   TYPE TABLE OF gty_linkedquery-primpos.

    CLEAR gt_linkedquery_comp.


    IF g_commands-&gt;current_command-&gt;mv_locked IS INITIAL.
      CREATE OBJECT lq_menu_inner.
      CREATE OBJECT lq_menu_outer.
      CREATE OBJECT lq_menu_subquery.
    ENDIF.

    CREATE OBJECT lq_menu_selfae.

    SORT gt_linkedquery BY checktable tabname primpos.

    LOOP AT gt_linkedquery INTO gs_linkedquery.

      IF ls_prev_linkedquery-checktable NE gs_linkedquery-checktable OR
           ls_prev_linkedquery-tabname NE gs_linkedquery-tabname.

        CLEAR: l_comp_count.
        CLEAR lt_primpos.
        CLEAR lstr2.

        lstr4 = &apos;* ON&apos;.

        LOOP AT gt_linkedquery INTO ls_linkedquery
          WHERE tabname         = ls_prev_linkedquery-tabname
                AND checktable  = ls_prev_linkedquery-checktable.
*                AND join_type   = ls_prev_linkedquery-join_type.


          READ TABLE lt_primpos TRANSPORTING NO FIELDS
            WITH KEY table_line = ls_linkedquery-primpos.

          IF sy-subrc EQ 4.

            CONCATENATE ls_linkedquery-tabname &apos;~&apos; ls_linkedquery-fieldname INTO lstr5.
            CONDENSE lstr5  NO-GAPS.

            CONCATENATE ls_linkedquery-checktable &apos;~&apos; ls_linkedquery-checkfield INTO lstr3.
            CONDENSE lstr3 NO-GAPS.

            CONCATENATE lstr4 lstr3 INTO lstr4 SEPARATED BY space.

            IF lstr2 IS INITIAL.
              CONCATENATE &apos;ON&apos; lstr3 &apos;=&apos; lstr5 INTO lstr2 SEPARATED BY &apos; &apos;.
            ELSE.
              CONCATENATE lstr2 &apos;AND&apos; lstr3 &apos;=&apos; lstr5 INTO lstr2 SEPARATED BY &apos; &apos;.
            ENDIF.

*              CONCATENATE ls_linkedquery-table &apos;~&apos; ls_linkedquery-field INTO lstr5.
*              CONDENSE lstr5  NO-GAPS.
*              CONCATENATE lstr4 lstr5 INTO lstr4 SEPARATED BY SPACE.
*
*              CONCATENATE ls_linkedquery-checktable &apos;~&apos; ls_linkedquery-checkfield INTO lstr3.
*              CONDENSE lstr3 NO-GAPS.
*
*              if lstr2 IS INITIAL.
*                CONCATENATE &apos;ON&apos; lstr3 &apos;=&apos; lstr5 INTO lstr2 SEPARATED BY &apos; &apos;.
*              else.
*                CONCATENATE lstr2 &apos;AND&apos; lstr3 &apos;=&apos; lstr5 INTO lstr2 SEPARATED BY &apos; &apos;.
*              endif.

            APPEND ls_linkedquery-primpos TO lt_primpos.

            l_comp_count = l_comp_count + 1.

          ENDIF.

        ENDLOOP.

        IF l_comp_count GT 1.

          READ TABLE gt_linkedquery_comp TRANSPORTING NO FIELDS
            WITH KEY tabname  = ls_linkedquery-tabname
                     checktable = ls_linkedquery-checktable
                     text   = lstr4.
*                     longtext   = lstr2.

          IF sy-subrc EQ 4.

            CONCATENATE gs_linkedquery-fcode &apos;_COMP&apos; INTO l_fcode.
*            CONCATENATE &apos;I_&apos; gs_linkedquery-fcode &apos;_COMP&apos; INTO l_fcode.
***            l_fcode = gs_linkedquery-fcode.

            gs_linkedquery_comp-fcode      = l_fcode.
            gs_linkedquery_comp-tabname    = ls_linkedquery-tabname.
            gs_linkedquery_comp-checktable = ls_linkedquery-checktable.
            gs_linkedquery_comp-text       = lstr4.
            gs_linkedquery_comp-longtext   = lstr2.
            gs_linkedquery_comp-join_type  = ls_linkedquery-join_type.
            gs_linkedquery_comp-ddtext     = ls_linkedquery-ddtext.

            APPEND gs_linkedquery_comp TO gt_linkedquery_comp.

            CONCATENATE &apos;I_&apos; gs_linkedquery-fcode &apos;_COMP&apos; INTO l_fcode.

            IF lq_menu_table_i_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_i_prev-&gt;add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CONCATENATE &apos;O_&apos; gs_linkedquery-fcode &apos;_COMP&apos; INTO l_fcode.

            IF lq_menu_table_o_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_o_prev-&gt;add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CONCATENATE &apos;S_&apos; gs_linkedquery-fcode &apos;_COMP&apos; INTO l_fcode.

            IF lq_menu_table_selfae_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_selfae_prev-&gt;add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CONCATENATE &apos;Q_&apos; gs_linkedquery-fcode &apos;_COMP&apos; INTO l_fcode.

            IF lq_menu_table_subquery_prev IS NOT INITIAL.

              CALL METHOD lq_menu_table_subquery_prev-&gt;add_function
                EXPORTING
                  fcode  = l_fcode
                  text   = gs_linkedquery_comp-text
                EXCEPTIONS
                  OTHERS = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

            CLEAR l_fcode.

          ENDIF.

        ENDIF.

      ENDIF.

      IF ls_prev_linkedquery-checktable NE gs_linkedquery-checktable.

        IF g_commands-&gt;current_command-&gt;mv_locked IS INITIAL.
          CREATE OBJECT lq_menu_table_i.
          CREATE OBJECT lq_menu_table_o.
          CREATE OBJECT lq_menu_table_subquery.
        ENDIF.

        CREATE OBJECT lq_menu_table_selfae.

        CONCATENATE &apos;(&apos; gs_linkedquery-ddtext &apos;)&apos; INTO l_ddtext.
        CONCATENATE gs_linkedquery-checktable l_ddtext INTO lstr SEPARATED BY &apos; &apos;.

        IF g_commands-&gt;current_command-&gt;mv_locked IS INITIAL.

          CALL METHOD lq_menu_inner-&gt;add_submenu
            EXPORTING
              menu   = lq_menu_table_i
              text   = lstr
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

          CALL METHOD lq_menu_outer-&gt;add_submenu
            EXPORTING
              menu   = lq_menu_table_o
              text   = lstr
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

          CALL METHOD lq_menu_subquery-&gt;add_submenu
            EXPORTING
              menu   = lq_menu_table_subquery
              text   = lstr
            EXCEPTIONS
              OTHERS = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

        ENDIF.

        CALL METHOD lq_menu_selfae-&gt;add_submenu
          EXPORTING
            menu   = lq_menu_table_selfae
            text   = lstr
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      ENDIF.

      IF g_commands-&gt;current_command-&gt;mv_locked IS INITIAL.

        CONCATENATE &apos;I_&apos; gs_linkedquery-fcode INTO l_fcode.

        CALL METHOD lq_menu_table_i-&gt;add_function
          EXPORTING
            fcode  = l_fcode
            text   = gs_linkedquery-text
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CONCATENATE &apos;O_&apos; gs_linkedquery-fcode INTO l_fcode.

        CALL METHOD lq_menu_table_o-&gt;add_function
          EXPORTING
            fcode  = l_fcode
            text   = gs_linkedquery-text
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CONCATENATE &apos;Q_&apos; gs_linkedquery-fcode INTO l_fcode.

        CALL METHOD lq_menu_table_subquery-&gt;add_function
          EXPORTING
            fcode  = l_fcode
            text   = gs_linkedquery-text
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      ENDIF.

      CONCATENATE &apos;S_&apos; gs_linkedquery-fcode INTO l_fcode.

      CALL METHOD lq_menu_table_selfae-&gt;add_function
        EXPORTING
          fcode  = l_fcode
          text   = gs_linkedquery-text
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      ls_prev_linkedquery = gs_linkedquery.

      IF g_commands-&gt;current_command-&gt;mv_locked IS INITIAL.
        lq_menu_table_i_prev        = lq_menu_table_i.
        lq_menu_table_o_prev        = lq_menu_table_o.
        lq_menu_table_subquery_prev = lq_menu_table_subquery.
      ENDIF.

      lq_menu_table_selfae_prev   = lq_menu_table_selfae.

    ENDLOOP.

    IF sender = &apos;T&apos;.

      IF g_commands-&gt;current_command-&gt;mv_locked IS INITIAL.

        CALL METHOD lq_menu_inner-&gt;add_function
          EXPORTING
            fcode  = &apos;RELAT_I&apos;
            text   = TEXT-028
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CALL METHOD lq_menu_outer-&gt;add_function
          EXPORTING
            fcode  = &apos;RELAT_O&apos;
            text   = TEXT-028
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CALL METHOD lq_menu_subquery-&gt;add_function
          EXPORTING
            fcode  = &apos;RELAT_Q&apos;
            text   = TEXT-028
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      ENDIF.

      CALL METHOD lq_menu_selfae-&gt;add_function
        EXPORTING
          fcode  = &apos;RELAT_S&apos;
          text   = TEXT-028
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.
    lstr = TEXT-024.

    IF g_commands-&gt;current_command-&gt;mv_locked IS INITIAL.

      CALL METHOD e_object-&gt;add_submenu
        EXPORTING
          menu   = lq_menu_inner
          text   = lstr
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      lstr = TEXT-025.

      CALL METHOD e_object-&gt;add_submenu
        EXPORTING
          menu   = lq_menu_outer
          text   = lstr
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      lstr = TEXT-149.

      CALL METHOD e_object-&gt;add_submenu
        EXPORTING
          menu   = lq_menu_subquery
          text   = lstr
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    &quot;lcl_application


  METHOD handle_function_selected_txt.

    CASE fcode.

      WHEN &apos;PRETTY&apos;.

        IF g_commands-&gt;current_command-&gt;text IS NOT INITIAL.

**          CALL METHOD LCL_TOOLBOX=&gt;pretty_printer
**            CHANGING
**              ct_source = g_commands-&gt;current_command-&gt;text.

          CALL FUNCTION &apos;PRETTY_PRINTER&apos;
            EXPORTING
              inctoo             = &apos; &apos;
            TABLES
              ntext              = g_commands-&gt;current_command-&gt;text
              otext              = g_commands-&gt;current_command-&gt;text
            EXCEPTIONS
              enqueue_table_full = 1
              include_enqueued   = 2
              include_readerror  = 3
              include_writeerror = 4
              OTHERS             = 5.
          IF sy-subrc &lt;&gt; 0.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.

        ENDIF.

    ENDCASE.

  ENDMETHOD.                    &quot;lcl_application


  METHOD handle_double_click.

    DATA: l_s_c   TYPE REF TO lcl_select_command,
          ls_fcat TYPE lvc_s_fcat.

    TRY.
        l_s_c ?= g_commands-&gt;current_command.

      CATCH cx_sy_move_cast_error.

    ENDTRY.

    READ TABLE l_s_c-&gt;fcat INTO ls_fcat
    WITH KEY fieldname = e_column.

    IF sy-subrc NE 0.
      EXIT.
    ENDIF.

    IF ls_fcat-rollname IS NOT INITIAL.
      CALL DIALOG &apos;RS_DD_DTEL_EDIT&apos;
        EXPORTING
          mode    FROM &apos;S&apos;
          objname FROM ls_fcat-rollname.
    ELSE.
      CALL METHOD g_application-&gt;issue_message
        EXPORTING
          iv_msgty        = &apos;S&apos;
          iv_msgno        = &apos;115&apos;
          iv_display_like = &apos;W&apos;.
    ENDIF.

  ENDMETHOD.                    &quot;lcl_application

*new*
  METHOD handle_dropdown_clicked.

    DATA: menu_dynamic TYPE REF TO cl_ctmenu.

    CREATE OBJECT menu_dynamic.

    CALL METHOD handle_lq_context_menu
      EXPORTING
        sender   = &apos;T&apos;
        e_object = menu_dynamic.

    CALL METHOD g_toolbar_tb_tree-&gt;track_context_menu
      EXPORTING
        context_menu = menu_dynamic
        posx         = posx
        posy         = posy.

  ENDMETHOD.                    &quot;lcl_my_event_handler

  METHOD handle_node_double_click.

    DATA: lstr           TYPE string,
          ls_table_alias TYPE lty_zhtdb_table_aliases.

    CALL METHOD g_tree_tb-&gt;get_outtab_line
      EXPORTING
        i_node_key     = node_key
      IMPORTING
        e_outtab_line  = gs_outtab_tb
      EXCEPTIONS
        node_not_found = 1
        OTHERS         = 2.

    IF sy-subrc EQ 0.
      IF gs_outtab_tb-fieldname IS INITIAL.
        EXIT.
      ENDIF.
    ELSE.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.

    ENDIF.

    READ TABLE g_commands-&gt;current_command-&gt;mt_ranges INTO gs_ranges
      WITH KEY table_alias = gs_outtab_tb-alias
               fieldname   = gs_outtab_tb-fieldname.

    IF sy-subrc NE 0.
*      MESSAGE e027.
      RETURN.
    ENDIF.

    CONCATENATE gs_ranges-fieldname &apos;IN&apos; gs_ranges-node_text INTO lstr SEPARATED BY &apos; &apos;.

    READ TABLE g_commands-&gt;current_command-&gt;table_alias_tb INTO ls_table_alias
      WITH KEY alias = gs_ranges-table_alias.

    IF sy-subrc EQ 0.
      IF ls_table_alias-alias IS NOT INITIAL.
        CONCATENATE ls_table_alias-alias &apos;~&apos; lstr INTO lstr.
      ENDIF.
    ELSE.
      CALL METHOD g_application-&gt;issue_message
        EXPORTING
          iv_msgty = &apos;E&apos;
          iv_msgno = &apos;027&apos;.
*      MESSAGE e027.
    ENDIF.


    DATA: lt_vrange_text TYPE lty_zhtdbt_string_tab.

**    IF g_commands-&gt;current_command-&gt;where_text IS INITIAL.
**      CONCATENATE &apos;WHERE&apos; lstr INTO lstr SEPARATED BY &apos; &apos;.
**    ELSE.
**      CONCATENATE &apos;and&apos; lstr INTO lstr SEPARATED BY &apos; &apos;.
**    ENDIF.

    APPEND lstr TO lt_vrange_text.

    CALL METHOD insert_stringtab_to_pos
      EXPORTING
        it_stringtab = lt_vrange_text.

**    APPEND lstr TO l_text.

*abaped    CALL METHOD g_textedit-&gt;set_text_as_r3table
    CALL METHOD g_textedit-&gt;set_text
      EXPORTING
        table  = g_commands-&gt;current_command-&gt;text
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


**
**    CALL METHOD cl_gui_cfw=&gt;dispatch
**      EXCEPTIONS
**        OTHERS = 1.
**
**    IF sy-subrc NE 0.
**      IF sy-msgno IS NOT INITIAL.
**        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
**WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
**      ENDIF.
**    ENDIF.

  ENDMETHOD.                    &quot;lcl_application


  METHOD insert_stringtab_to_pos.

    DATA: l_from            TYPE i,
          l_to              TYPE i,
          l_from_line       TYPE i,
          l_to_line         TYPE i,
          lv_lines          TYPE i,
          lv_middle_string  TYPE string,
          lt_text           TYPE source_table,
          lt_text_temp      TYPE source_table,
          l_text            LIKE LINE OF lt_text_temp,
          lstr              TYPE string,
          lstr2             TYPE string,
          lt_text_split     TYPE TABLE OF string,
          ls_sel_field_list TYPE string,
          lv_from_copy      TYPE i.

    CALL METHOD g_textedit-&gt;get_selection_pos
      IMPORTING
        from_line              = l_from_line
        from_pos               = l_from
        to_line                = l_to_line
        to_pos                 = l_to
      EXCEPTIONS
        error_cntl_call_method = 1
        OTHERS                 = 2.

    IF sy-subrc &lt;&gt; 0.

      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.

    ENDIF.

*abaped    CALL METHOD g_textedit-&gt;get_text_as_r3table
    CALL METHOD g_textedit-&gt;get_text
      IMPORTING
        table  = lt_text
      EXCEPTIONS
*abaped        potential_data_loss = 1.
        OTHERS = 1.

    IF sy-subrc = 1.
      CALL METHOD g_application-&gt;issue_message
        EXPORTING
          iv_msgty = &apos;I&apos;
          iv_msgno = &apos;025&apos;.
*      MESSAGE i025.
    ENDIF.

    DESCRIBE TABLE it_stringtab LINES lv_lines.
    READ TABLE lt_text INTO l_text INDEX l_from_line.
    READ TABLE it_stringtab INTO ls_sel_field_list INDEX 1.

    l_from = l_from - 1.

    IF l_from EQ 0.
      lstr2 = l_text.
      CLEAR lstr.
    ELSE.
      lstr  = l_text(l_from).
    ENDIF.

    l_text = l_text+l_from.
    lstr2  = l_text.

    IF lv_lines = 1.
      CONCATENATE lstr ls_sel_field_list lstr2 INTO lv_middle_string SEPARATED BY space.
    ELSE.
      CONCATENATE lstr ls_sel_field_list INTO lv_middle_string SEPARATED BY space.
    ENDIF.

    IF l_from_line &gt; 1.
      lv_from_copy = l_from_line - 1.

      LOOP AT lt_text INTO lstr FROM 1 TO lv_from_copy.
        l_text = lstr.
        APPEND l_text TO lt_text_temp.
      ENDLOOP.
    ENDIF.

    CALL METHOD lcl_toolbox=&gt;split_string
      EXPORTING
        iv_string     = lv_middle_string
        iv_maxlen     = gc_line_length
      IMPORTING
        et_string_tab = lt_text_split.

    LOOP AT lt_text_split INTO lstr.
      l_text = lstr.
      APPEND l_text TO lt_text_temp.
    ENDLOOP.

    LOOP AT it_stringtab INTO ls_sel_field_list FROM 2.

      CLEAR lt_text_split.

      IF sy-tabix = lv_lines.
        CONCATENATE ls_sel_field_list lstr2 INTO ls_sel_field_list
          SEPARATED BY space.
      ENDIF.

      CALL METHOD lcl_toolbox=&gt;split_string
        EXPORTING
          iv_string     = ls_sel_field_list
          iv_maxlen     = gc_line_length
        IMPORTING
          et_string_tab = lt_text_split.

      LOOP AT lt_text_split INTO lstr.
        l_text = lstr.
        APPEND l_text TO lt_text_temp.
      ENDLOOP.

    ENDLOOP.

    lv_from_copy = l_from_line + 1.

    LOOP AT lt_text INTO lstr FROM lv_from_copy.
      l_text = lstr.
      APPEND l_text TO lt_text_temp.
    ENDLOOP.

    g_commands-&gt;current_command-&gt;text[] = lt_text_temp[].


  ENDMETHOD.                    &quot;insert_stringtab_to_pos

  METHOD create_tb_tree_toolbar.

    DATA: lv_auth_ok TYPE c.

    CALL METHOD g_tree_tb-&gt;get_toolbar_object
      IMPORTING
        er_toolbar = g_toolbar_tb_tree
      EXCEPTIONS
        OTHERS     = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CHECK NOT g_toolbar_tb_tree IS INITIAL.

*new*
    SET HANDLER g_application-&gt;handle_dropdown_clicked  FOR g_toolbar_tb_tree.
    SET HANDLER g_application-&gt;handle_function_selected FOR g_toolbar_tb_tree.

    IF g_commands IS NOT INITIAL AND g_commands-&gt;current_command IS NOT INITIAL.

      lv_auth_ok = &apos;X&apos;.

    ENDIF.


    CALL METHOD g_toolbar_tb_tree-&gt;delete_all_buttons
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


***    IF g_commands IS NOT INITIAL AND g_commands-&gt;current_command IS NOT INITIAL.
***      CHECK g_commands-&gt;current_command-&gt;mv_locked IS INITIAL.
***    ENDIF.

    DATA: lv_icontext TYPE iconquick.

    IF lv_auth_ok = &apos;X&apos; AND ( g_commands-&gt;current_command-&gt;mv_locked = &apos; &apos; ).

      lv_icontext = TEXT-147.
      CALL METHOD g_toolbar_tb_tree-&gt;add_button
        EXPORTING
          fcode     = &apos;GET_TABLES&apos;
          icon      = &apos;@42@&apos;
          butn_type = cntb_btype_button
          text      = &apos;&apos;
          quickinfo = lv_icontext
        EXCEPTIONS
          OTHERS    = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.

    lv_icontext = TEXT-050.
    CALL METHOD g_toolbar_tb_tree-&gt;add_button
      EXPORTING
        fcode     = &apos;DISPLAY&apos;
        icon      = &apos;@B_DISP@&apos;
        butn_type = cntb_btype_button
        text      = &apos;&apos;
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-051.
    CALL METHOD g_toolbar_tb_tree-&gt;add_button
      EXPORTING
        fcode     = &apos;INDEXES&apos;
        icon      = &apos;@USEREL@&apos;
        butn_type = cntb_btype_button
        text      = &apos;&apos;
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-052.
    CALL METHOD g_toolbar_tb_tree-&gt;add_button
      EXPORTING
        fcode     = &apos;TECH&apos;
        icon      = &apos;@B_DETL@&apos;
        butn_type = cntb_btype_button
        text      = &apos;&apos;
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-053.
    CALL METHOD g_toolbar_tb_tree-&gt;add_button
      EXPORTING
        fcode     = &apos;GRAPH&apos;
        icon      = &apos;@56@&apos;
        butn_type = cntb_btype_button
        text      = &apos;&apos;
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-054.
    CALL METHOD g_toolbar_tb_tree-&gt;add_button
      EXPORTING
        fcode     = &apos;TEXTTAB&apos;
        icon      = &apos;@B_TXDP@&apos;
        butn_type = cntb_btype_button
        text      = &apos;&apos;
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-055.
    CALL METHOD g_toolbar_tb_tree-&gt;add_button
      EXPORTING
        fcode     = &apos;RUNTIMEOBJ&apos;
        icon      = &apos;@OBJELI@&apos;
        butn_type = cntb_btype_button
        text      = &apos;&apos;
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-056.
    CALL METHOD g_toolbar_tb_tree-&gt;add_button
      EXPORTING
        fcode     = &apos;WHERE&apos;
        icon      = &apos;@B_BOOK@&apos;
        butn_type = cntb_btype_button
        text      = &apos;&apos;
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    lv_icontext = TEXT-057.
    CALL METHOD g_toolbar_tb_tree-&gt;add_button
      EXPORTING
        fcode     = &apos;CONTENTS&apos;
        icon      = &apos;@B_LIST@&apos;
        butn_type = cntb_btype_button
        text      = &apos;&apos;
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    IF lv_auth_ok = &apos;X&apos; AND ( g_commands-&gt;current_command-&gt;mv_locked = &apos; &apos; ).
      lv_icontext = TEXT-058.
      CALL METHOD g_toolbar_tb_tree-&gt;add_button
        EXPORTING
          fcode     = &apos;VRANGES&apos;
          icon      = &apos;@BGMORE@&apos;
          butn_type = cntb_btype_button
          text      = &apos;&apos;
          quickinfo = lv_icontext
        EXCEPTIONS
          OTHERS    = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.
    ENDIF.

*new*

    lv_icontext = TEXT-169.
    CALL METHOD g_toolbar_tb_tree-&gt;add_button
      EXPORTING
        fcode     = &apos;LQA&apos;
        icon      = &apos;@B_TREE@&apos;
        butn_type = cntb_btype_dropdown
        text      = &apos;&apos;
        quickinfo = lv_icontext
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


  ENDMETHOD.                    &quot;lcl_application

  METHOD create_txt_toolbar.

* nincs ilyen vaze

  ENDMETHOD.                    &quot;lcl_application



  METHOD display_table_grid.

    DATA: ls_tb_alias_tb TYPE gty_table_aliases,
          l_command      TYPE REF TO lcl_command,
          ls_table       TYPE lty_zhtdb_alv_tab,
          l_node_text    TYPE lvc_value,
          l_new_node_key TYPE lvc_nkey,
          ls_node_style  TYPE lvc_s_layn,
          ls_rangename   TYPE lvc_value,
          ls_alias_range LIKE LINE OF l_command-&gt;mt_alias_ranges.


    l_command = g_commands-&gt;current_command.

*   CHECK l_command-&gt;mt_tab_node_xref IS INITIAL.
*   CLEAR l_command-&gt;mt_outtab_tb.

*   miert a where feltetel??
    DELETE l_command-&gt;mt_outtab_tb
      WHERE fieldname IS INITIAL.

*   CLEAR l_command-&gt;mt_outtab_tb.
    CLEAR l_command-&gt;mt_tab_node_xref.

    IF g_tree_tb IS INITIAL.
      RETURN.
    ENDIF.

    CALL METHOD g_tree_tb-&gt;delete_all_nodes
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    LOOP AT l_command-&gt;table_alias_tb INTO ls_tb_alias_tb.

      CLEAR ls_table.

      SELECT SINGLE ddtext
        INTO ls_table-ddtext
        FROM dd02t
        WHERE as4local   = &apos;A&apos;                  AND
              tabname    = ls_tb_alias_tb-table AND
              ddlanguage = sy-langu.

      IF sy-subrc EQ 4.

        SELECT SINGLE ddtext
          INTO ls_table-ddtext
          FROM dd02t
          WHERE as4local = &apos;A&apos;      AND
                tabname = ls_tb_alias_tb-table.

      ENDIF.

      IF ls_tb_alias_tb-alias IS NOT INITIAL.
        ls_table-alias     = ls_tb_alias_tb-alias.
      ELSE.
        ls_table-alias     = ls_tb_alias_tb-table.
      ENDIF.

      ls_table-tablename = ls_tb_alias_tb-table.

      APPEND ls_table TO l_command-&gt;mt_outtab_tb.

      READ TABLE l_command-&gt;mt_alias_ranges
      WITH KEY table_alias = ls_table-alias
      TRANSPORTING NO FIELDS.

      IF sy-subrc NE 0.
        CLEAR ls_alias_range.
        ls_alias_range-table_alias = ls_table-alias.

        APPEND ls_alias_range TO l_command-&gt;mt_alias_ranges.
      ENDIF.

    ENDLOOP.

*   add tables to tree
    LOOP AT l_command-&gt;mt_outtab_tb INTO gs_outtab_tb
         WHERE fieldname IS INITIAL.

      READ TABLE l_command-&gt;table_alias_tb INTO ls_tb_alias_tb
        WITH KEY alias = gs_outtab_tb-alias.

      IF ls_tb_alias_tb-table NE ls_tb_alias_tb-alias.
        CONCATENATE ls_tb_alias_tb-table &apos;as&apos; ls_tb_alias_tb-alias INTO l_node_text SEPARATED BY &apos; &apos;.
      ELSE.
        l_node_text = ls_tb_alias_tb-table.
      ENDIF.

*      SELECT SINGLE viewname
*      FROM dd25l
*      INTO ls_dd25l-viewname
*      WHERE AS4LOCAL = &apos;A&apos;
*            and viewname = ls_tb_alias_tb-table.

      CASE ls_tb_alias_tb-type.
        WHEN &apos;T&apos;.
          ls_node_style-exp_image = &apos;@PO@&apos;.
          ls_node_style-n_image = &apos;@PO@&apos;.
        WHEN &apos;V&apos;.
          ls_node_style-exp_image = &apos;@A2@&apos;.
          ls_node_style-n_image = &apos;@A2@&apos;.
        WHEN &apos;C&apos;.
          ls_node_style-exp_image = &apos;@AP@&apos;.
          ls_node_style-n_image = &apos;@AP@&apos;.
        WHEN &apos;P&apos;.
          ls_node_style-n_image = &apos;@AQ@&apos;.
          ls_node_style-exp_image = &apos;@AQ@&apos;.
      ENDCASE.

      CALL METHOD g_tree_tb-&gt;add_node
        EXPORTING
          i_relat_node_key = &apos;&apos;
          i_relationship   = cl_gui_column_tree=&gt;relat_last_child
          is_outtab_line   = gs_outtab_tb
          i_node_text      = l_node_text
          is_node_layout   = ls_node_style
        IMPORTING
          e_new_node_key   = l_new_node_key
        EXCEPTIONS
          OTHERS           = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      gs_tab_node_xref-tablename = gs_outtab_tb-tablename.
      gs_tab_node_xref-alias     = gs_outtab_tb-alias.
      gs_tab_node_xref-node_key  = l_new_node_key.
      APPEND gs_tab_node_xref TO l_command-&gt;mt_tab_node_xref.

    ENDLOOP.

    ls_node_style-n_image = &apos;@1E@&apos;.

*   add fields
    LOOP AT l_command-&gt;mt_outtab_tb INTO gs_outtab_tb
         WHERE fieldname IS NOT INITIAL.

      READ TABLE l_command-&gt;mt_tab_node_xref
        INTO gs_tab_node_xref
        WITH KEY alias = gs_outtab_tb-alias.
*      WITH KEY tablename = gs_outtab_tb-tablename.

      IF sy-subrc NE 0.
*        MESSAGE i027.
        CONTINUE.
      ENDIF.

      IF gs_outtab_tb-tablename NE gs_outtab_tb-alias.
        CONCATENATE &apos;R_&apos; gs_outtab_tb-alias &apos;_&apos; gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY &apos;&apos;.
      ELSE.
        CONCATENATE &apos;R_&apos; gs_outtab_tb-tablename &apos;_&apos; gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY &apos;&apos;.
      ENDIF.

*      CONCATENATE &apos;R_&apos; gs_outtab_tb-tablename &apos;_&apos; gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY &apos;&apos;.
      REPLACE &apos; &apos; WITH &apos;&apos; INTO ls_rangename.
      CONDENSE ls_rangename NO-GAPS.

      CALL METHOD g_tree_tb-&gt;add_node
        EXPORTING
          i_relat_node_key = gs_tab_node_xref-node_key
          i_relationship   = cl_gui_column_tree=&gt;relat_last_child
          is_outtab_line   = gs_outtab_tb
          i_node_text      = ls_rangename
          is_node_layout   = ls_node_style
        IMPORTING
          e_new_node_key   = l_new_node_key
        EXCEPTIONS
          OTHERS           = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD g_tree_tb-&gt;expand_node
        EXPORTING
          i_node_key = gs_tab_node_xref-node_key
        EXCEPTIONS
          OTHERS     = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDLOOP.

    CALL METHOD g_tree_tb-&gt;frontend_update
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;lcl_application

  METHOD refresh_status_indicators.

    DATA: lstr           TYPE string,
          l_command_type TYPE lty_commandtype.

*      try.
*        l_s_c ?= g_commands-&gt;current_command.
*
*      catch cx_sy_move_cast_error.
*        EXIT.
*      endtry.

    CALL METHOD g_commands-&gt;current_command-&gt;get_type
      IMPORTING
        ep_command_type = l_command_type
      EXCEPTIONS
        OTHERS          = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CASE l_command_type.
      WHEN gc_ctype_select OR
           gc_ctype_selfae OR
           gc_ctype_lawb.

      WHEN OTHERS.
        EXIT.
    ENDCASE.

    CLEAR gt_dynpread.

*      CLEAR: lstr, lstr2.
*
*      lstr2 = g_commands-&gt;current_command-&gt;mv_dbcnt.
*      CONCATENATE lstr &apos;Rows fetched:&apos; lstr2 INTO lstr SEPARATED BY &apos; &apos;.

    DATA: lv_cnt_updated  TYPE i,
          lv_cnt_inserted TYPE i,
          lv_cnt_deleted  TYPE i.

    MESSAGE i030 WITH g_commands-&gt;current_command-&gt;mv_dbcnt lv_cnt_updated lv_cnt_inserted lv_cnt_deleted INTO lstr.

****    MESSAGE i137 WITH lstr g_commands-&gt;current_command-&gt;mv_from g_commands-&gt;current_command-&gt;mv_to INTO lstr.

*new*
    DATA: lv_title TYPE lvc_title.

    lv_title = lstr.

    CALL METHOD g_alv-&gt;set_gridtitle
      EXPORTING
        i_gridtitle = lv_title.

*    gs_dynpread-fieldname = &apos;STATUS1&apos;.
*    gs_dynpread-fieldvalue = lstr.
*    APPEND gs_dynpread TO gt_dynpread.
*
*    IF g_alv IS NOT INITIAL AND g_commands-&gt;current_command-&gt;mv_grid_modified IS NOT INITIAL.
*      CALL METHOD g_alv-&gt;set_toolbar_interactive
*        EXCEPTIONS
*          OTHERS = 1.
*
*      IF sy-subrc NE 0.
*        IF sy-msgno IS NOT INITIAL.
*          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
*                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*        ENDIF.
*      ENDIF.
*    ENDIF.
*
*    CALL METHOD cl_gui_cfw=&gt;set_new_ok_code
*      EXPORTING
*        new_code = &apos;ENT&apos;
*      IMPORTING
*        rc       = l_int
*      EXCEPTIONS
*        OTHERS   = 1.
*
*    IF sy-subrc NE 0.
*      IF sy-msgno IS NOT INITIAL.
*        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
*                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*      ENDIF.
*    ENDIF.

  ENDMETHOD.                    &quot;lcl_application


  METHOD handle_after_refresh.

  ENDMETHOD.                    &quot;lcl_application

  METHOD check_s_tabu_dis.

    DATA: x030l_wa     TYPE x030l,
          activity(2)  TYPE c,
          client_indep TYPE c,
          lv_tddat     TYPE tddat,
          lv_tabname   TYPE tabname.

    CLEAR client_indep.

    lv_tabname = iv_tabname.
    TRANSLATE lv_tabname TO UPPER CASE.

*   determine activity
    IF iv_for_editing IS INITIAL.
      activity = &apos;03&apos;.
    ELSE.
      activity = &apos;02&apos;.
    ENDIF.

*   client independent?
    CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
      EXPORTING
        tabname        = lv_tabname
      IMPORTING
        x030l_wa       = x030l_wa
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.

    IF sy-subrc &lt;&gt; 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
         WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.

    IF x030l_wa-clpos = 0.
      client_indep = &apos;X&apos;.
    ENDIF.

*   check normal table maintenace authority
    SELECT SINGLE * FROM tddat INTO lv_tddat
                    WHERE tabname = lv_tabname.

    IF sy-subrc &lt;&gt; 0  OR lv_tddat-cclass IS INITIAL.
      lv_tddat-cclass = &apos;&amp;NC&amp;&apos;.        &quot; &apos;non classified table&apos;
    ENDIF.

    ev_auth = &apos;X&apos;.

    AUTHORITY-CHECK OBJECT &apos;S_TABU_DIS&apos;
                    ID     &apos;ACTVT&apos;      FIELD activity
                    ID     &apos;DICBERCLS&apos;  FIELD lv_tddat-cclass.

    IF sy-subrc &lt;&gt; 0.
      CLEAR ev_auth.
    ENDIF.

*   check authority for client independent changes
    IF client_indep   = &apos;X&apos; AND
       iv_for_editing = &apos;X&apos;.

      AUTHORITY-CHECK OBJECT &apos;S_TABU_CLI&apos;
                      ID     &apos;CLIIDMAINT&apos; FIELD &apos;X&apos;.

      IF sy-subrc &lt;&gt; 0.
        CLEAR ev_auth.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    &quot; check_s_tabu_dis


  METHOD handle_toolbar.

    DATA: ls_toolbar        TYPE stb_button,
          lv_not_modified   TYPE c,
          lv_display_only   TYPE c,
          lv_undo_not_empty TYPE c,
          lv_read_from_file TYPE c,
          l_select          TYPE REF TO lcl_select_command.


    IF sender NE g_alv.
      EXIT.
    ENDIF.

    TRY.
        l_select ?= g_commands-&gt;current_command.

        lv_read_from_file = l_select-&gt;mv_read_from_file.

        IF l_select-&gt;alv_state EQ 0.
          lv_display_only = &apos;X&apos;.
        ELSE.
          lv_display_only = &apos; &apos;.
        ENDIF.

      CATCH cx_sy_move_cast_error.
*      message &apos;ZENITH:Casting error5&apos; TYPE &apos;E&apos;.
    ENDTRY.

    IF &lt;gt_undo&gt; IS ASSIGNED AND &lt;gt_undo&gt; IS NOT INITIAL.
      lv_undo_not_empty = &apos;X&apos;.
    ENDIF.

    IF g_commands-&gt;current_command-&gt;mv_grid_modified EQ &apos;X&apos;.
      lv_not_modified = &apos; &apos;.
    ELSE.
      lv_not_modified = &apos;X&apos;.
    ENDIF.

    CLEAR ls_toolbar.
    MOVE 3 TO ls_toolbar-butn_type.
    INSERT ls_toolbar INTO e_object-&gt;mt_toolbar INDEX 1.

    CLEAR ls_toolbar.
    MOVE cl_gui_alv_grid=&gt;mc_fc_select_all TO ls_toolbar-function.
    MOVE icon_select_all TO ls_toolbar-icon.
    MOVE TEXT-061 TO ls_toolbar-quickinfo.
    APPEND ls_toolbar TO e_object-&gt;mt_toolbar.

    CLEAR ls_toolbar.
    MOVE cl_gui_alv_grid=&gt;mc_fc_deselect_all TO ls_toolbar-function.
    MOVE icon_deselect_all TO ls_toolbar-icon.
    MOVE TEXT-062 TO ls_toolbar-quickinfo.
    APPEND ls_toolbar TO e_object-&gt;mt_toolbar.

    CLEAR ls_toolbar.
    MOVE 3 TO ls_toolbar-butn_type.
    APPEND ls_toolbar TO e_object-&gt;mt_toolbar.

    CLEAR ls_toolbar.
    MOVE &apos;TXT_MENU&apos; TO ls_toolbar-function.
    MOVE icon_display_text TO ls_toolbar-icon.
    MOVE TEXT-063 TO ls_toolbar-quickinfo.
    MOVE 2 TO ls_toolbar-butn_type.
    MOVE space TO ls_toolbar-disabled.
    APPEND ls_toolbar TO e_object-&gt;mt_toolbar.

    CLEAR ls_toolbar.
    MOVE 3 TO ls_toolbar-butn_type.
    APPEND ls_toolbar TO e_object-&gt;mt_toolbar.



  ENDMETHOD.                    &quot;lcl_application


  METHOD handle_function_selected.

    DATA: l_tabname         TYPE tabname,
          l_aliasname       TYPE string,
          l_texttabname     TYPE dd08v-tabname,
          fpopup            TYPE c,
          l_ok_code         TYPE sy-ucomm,
          ls_selected_nodes TYPE lvc_s_nkey,
          lt_selected_nodes TYPE lvc_t_nkey,
          l_node_key        TYPE lvc_nkey,
          l_new_node_key    TYPE lvc_nkey,
          l_command         TYPE REF TO lcl_command,
          ls_table_alias_tb LIKE LINE OF l_command-&gt;table_alias_tb.


    CHECK g_commands-&gt;current_command IS NOT INITIAL.

*new*
    IF fcode+2(3) EQ &apos;LA_&apos; OR fcode(5) EQ &apos;RELAT&apos;.

      CALL METHOD handle_lq_ctx_sel
        EXPORTING
          sender  = &apos;T&apos;
          e_ucomm = fcode
        EXCEPTIONS
          OTHERS  = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ELSEIF fcode = &apos;GET_TABLES&apos;.

      CALL METHOD g_commands-&gt;parse_only_command
        EXCEPTIONS
          no_id        = 1
          create_error = 2
          no_parent    = 3
          parse_error  = 4
          OTHERS       = 5.

      CASE sy-subrc.
        WHEN 1.
*          message s077 DISPLAY LIKE &apos;E&apos;.
          CALL METHOD g_application-&gt;issue_message
            EXPORTING
              iv_msgty        = &apos;S&apos;
              iv_msgno        = &apos;077&apos;
              iv_display_like = &apos;E&apos;.
          RETURN.
        WHEN 2.
*          message s076 DISPLAY LIKE &apos;E&apos;.
          CALL METHOD g_application-&gt;issue_message
            EXPORTING
              iv_msgty        = &apos;S&apos;
              iv_msgno        = &apos;076&apos;
              iv_display_like = &apos;E&apos;.
          RETURN.
        WHEN 3.
*          MESSAGE s050 DISPLAY LIKE &apos;E&apos;.
          CALL METHOD g_application-&gt;issue_message
            EXPORTING
              iv_msgty        = &apos;S&apos;
              iv_msgno        = &apos;050&apos;
              iv_display_like = &apos;E&apos;.
          RETURN.
        WHEN 4.
*  this would override detailed information
*          message s079 DISPLAY LIKE &apos;E&apos;.
          RETURN.
        WHEN 5.
          RETURN.

      ENDCASE.

      RETURN.

    ENDIF.

    CALL METHOD g_tree_tb-&gt;get_selected_nodes
      CHANGING
        ct_selected_nodes = lt_selected_nodes
      EXCEPTIONS
        cntl_system_error = 1
        dp_error          = 2
        failed            = 3
        OTHERS            = 4.

    IF sy-subrc &lt;&gt; 0.
      CALL METHOD g_application-&gt;issue_message
        EXPORTING
          iv_msgty = &apos;E&apos;
          iv_msgno = &apos;031&apos;.
*      MESSAGE e031.
    ENDIF.

    READ TABLE lt_selected_nodes INTO ls_selected_nodes INDEX 1.

    IF sy-subrc EQ 0.

      l_node_key = ls_selected_nodes-node_key.

      CLEAR gs_outtab_tb.

      CALL METHOD g_tree_tb-&gt;get_outtab_line
        EXPORTING
          i_node_key     = l_node_key
        IMPORTING
*         E_NODE_TEXT    = l_nodetext
          e_outtab_line  = gs_outtab_tb
        EXCEPTIONS
          node_not_found = 1
          OTHERS         = 2.

      IF sy-subrc &lt;&gt; 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      IF gs_outtab_tb IS INITIAL AND fcode NE &apos;VRANGES&apos;.
        EXIT.
      ENDIF.

*     MOVE gs_outtab_tb-tablename TO l_aliasname.
*     MOVE ls_table_alias_tb-alias TO l_aliasname.
      MOVE gs_outtab_tb-alias TO l_aliasname.

      l_command = g_commands-&gt;current_command.

      READ TABLE l_command-&gt;table_alias_tb INTO ls_table_alias_tb
        WITH KEY alias = l_aliasname.

      IF sy-subrc NE 0.
        RETURN.
      ENDIF.

      IF fcode = &apos;VRANGES&apos;             AND
         ls_table_alias_tb-type NE &apos;T&apos; AND
         ls_table_alias_tb-type NE &apos;V&apos;.
        MESSAGE i121 DISPLAY LIKE &apos;W&apos; WITH ls_table_alias_tb-table.
        RETURN.
      ENDIF.

      MOVE ls_table_alias_tb-table TO l_tabname.

*      IF l_aliasname IS INITIAL AND fcode EQ &apos;VRANGES&apos;.
*        EXIT.
*      ENDIF.

    ELSE.
      RETURN.
    ENDIF.

    CASE fcode.

      WHEN &apos;GRAPH&apos;.

        TYPE-POOLS: sdg1.
        DATA: obj_tab TYPE sdg1_obj,
              obj_def TYPE sdg1_obj1.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        obj_def-obj_name = l_tabname.
        obj_def-type     = &apos;TABL&apos;.
        CLEAR obj_tab.
        APPEND obj_def TO obj_tab.

        CLEAR sy-msgno.
        CALL FUNCTION &apos;REPOSITORY_STRUCTURE_GRAPH&apos;
          EXPORTING
            type    = &apos;TABL&apos;
          TABLES
            objects = obj_tab
          EXCEPTIONS
            OTHERS  = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

      WHEN &apos;DISPLAY&apos;.

        DATA: lv_type TYPE string.

        CASE ls_table_alias_tb-type.

          WHEN &apos;T&apos;.
            lv_type = &apos;TABL&apos;.

          WHEN &apos;V&apos;.
            lv_type = &apos;VIEW&apos;.

          WHEN &apos;C&apos;.
            lv_type = &apos;SQLT&apos;.

          WHEN &apos;P&apos;.
            lv_type = &apos;SQLT&apos;.

        ENDCASE.

        CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
          EXPORTING
            operation           = &apos;SHOW&apos;
            object_name         = l_tabname
            object_type         = lv_type
*           ENCLOSING_OBJECT    =
*           POSITION            = &apos; &apos;
*           DEVCLASS            =
*           INCLUDE             =
*           VERSION             = &apos; &apos;
*           MONITOR_ACTIVATION  = &apos;X&apos;
*           WB_MANAGER          =
*           IN_NEW_WINDOW       =
*           WITH_OBJECTLIST     = &apos; &apos;
*           WITH_WORKLIST       = &apos; &apos;
*         IMPORTING
*           NEW_NAME            =
*           WB_TODO_REQUEST     =
*         TABLES
*           OBJLIST             =
          EXCEPTIONS
            not_executed        = 1
            invalid_object_type = 2
            OTHERS              = 3.
        IF sy-subrc &lt;&gt; 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.


      WHEN &apos;TECH&apos;.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        PERFORM mem_export.
        SET PARAMETER ID &apos;DTB&apos; FIELD l_tabname.
        CALL TRANSACTION &apos;SE13&apos; AND SKIP FIRST SCREEN.

      WHEN &apos;INDEXES&apos;.

*       if ddxx-tabclass ne &apos;TRANSP&apos;.
*         Indexpflege nur fr transparente Tabellen mglich
*         message s807.
*       else.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION &apos;DD_LIST_INDEX&apos;
          EXPORTING
            objname = l_tabname
          IMPORTING
            fcode   = l_ok_code.


      WHEN &apos;RUNTIMEOBJ&apos;.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        SUBMIT rutdbdsp AND RETURN WITH objname EQ l_tabname
                                   WITH display EQ 2.

*        SUBMIT rutntchk AND RETURN WITH tabname EQ l_tabname
*                                   WITH ttype   EQ &apos;TABL&apos;
*                                   WITH status  EQ &apos;A&apos;
*                                   WITH showonly EQ &apos;X&apos;.

      WHEN &apos;TEXTTAB&apos;.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION &apos;DDUT_TEXTTABLE_GET&apos;
          EXPORTING
            tabname   = l_tabname
          IMPORTING
            texttable = l_texttabname.

        IF l_texttabname IS INITIAL.
          CALL METHOD g_application-&gt;issue_message
            EXPORTING
              iv_msgty = &apos;I&apos;
              iv_msgno = &apos;032&apos;
              iv_msgv1 = l_tabname.
*          MESSAGE i032 WITH l_tabname.
        ELSE.
          CLEAR fpopup.
          CALL DIALOG &apos;RS_DD_FIEL_SHOW&apos;
            EXPORTING
              objname FROM l_texttabname.
        ENDIF.


      WHEN &apos;CONTENTS&apos;.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION &apos;RS_NAVIGATION_BREAK&apos;.

        CLEAR sy-msgno.
        CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
          EXPORTING
            operation   = &apos;TAB_CONT&apos;
            object_name = l_tabname
            object_type = &apos;TABL&apos;
                          EXCEPTIONS
                          not_executed.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.

        ENDIF.

        CALL FUNCTION &apos;RS_NAVIGATION_BREAK_RESET&apos;.


      WHEN &apos;WHERE&apos;.

        CHECK gs_outtab_tb-fieldname IS INITIAL.

        CALL FUNCTION &apos;RS_NAVIGATION_BREAK&apos;.

        CLEAR sy-msgno.
        CALL FUNCTION &apos;RS_TOOL_ACCESS&apos;
          EXPORTING
            operation          = &apos;CROSSREF&apos;
            object_name        = l_tabname
            object_type        = &apos;DT&apos;
            monitor_activation = &apos;X&apos;
          EXCEPTIONS
            OTHERS             = 01.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CALL FUNCTION &apos;RS_NAVIGATION_BREAK_RESET&apos;.
* VRANGES
      WHEN &apos;VRANGES&apos;.

        DATA: it_fdiff       TYPE TABLE OF field_dif,
              it_dfies       TYPE TABLE OF dfies,
              is_fdiff       TYPE field_dif,
              lt_tables      TYPE TABLE OF rsdstabs,
              is_tables      TYPE rsdstabs,
              lt_ranges      TYPE rsds_trange,
              ls_range2      LIKE LINE OF lt_ranges, &quot; TYPE rsds_range, &quot;lty_zhdb_vrange-rsds_range,
              it_ranges2     TYPE rsds_trange,
              is_ranges2     LIKE LINE OF it_ranges2,
              is_ranges      LIKE LINE OF l_command-&gt;it_ranges,
              l_tabix        TYPE i,
              it_frange      TYPE rsds_frange_t,
              is_frange      LIKE LINE OF it_frange,
              ls_frange2     LIKE LINE OF it_frange,
              l_where_text   TYPE string,
              ls_alias_range LIKE LINE OF l_command-&gt;mt_alias_ranges,
              ls_rangename   TYPE lvc_value,
              lt_where       TYPE rsds_twhere,
              ls_where       TYPE rsds_where,
              l_line         LIKE LINE OF ls_where-where_tab,
              ls_node_style  TYPE lvc_s_layn,

              lt_field_desc  TYPE TABLE OF fldconvert,

              lt_fields      TYPE TABLE OF rsdsfields,
              ls_fields      TYPE rsdsfields.

        CLEAR lt_tables.

        CHECK l_command IS NOT INITIAL.

        READ TABLE l_command-&gt;mt_alias_ranges INTO ls_alias_range
          WITH KEY table_alias = l_aliasname.

        IF sy-subrc EQ 0.

*          if ls_table_alias_tb-type = &apos;C&apos; or ls_table_alias_tb-type = &apos;P&apos;.
*
*            LOOP AT l
*
*          endif.

          l_tabix = sy-tabix.

          READ TABLE l_command-&gt;it_ranges INTO is_ranges
          WITH KEY alias = l_aliasname.

          IF sy-subrc EQ 0.

            CLEAR lt_ranges.

            APPEND is_ranges-rsds_range TO lt_ranges.

            CALL FUNCTION &apos;FREE_SELECTIONS_RANGE_2_EX&apos;
              EXPORTING
                field_ranges = lt_ranges
              IMPORTING
                expressions  = ls_alias_range-expr.

            LOOP AT lt_ranges INTO is_ranges2.

              LOOP AT is_ranges2-frange_t INTO is_frange.

                ls_fields-tablename = l_tabname.
                ls_fields-fieldname = is_frange-fieldname.

                APPEND ls_fields TO lt_fields.

              ENDLOOP.

            ENDLOOP.

          ENDIF.

        ENDIF.

        REFRESH: it_fdiff.
        is_fdiff-tabname = l_tabname.

        CLEAR it_dfies.
        CLEAR sy-msgno.

        CALL FUNCTION &apos;DDIF_NAMETAB_GET&apos;
          EXPORTING
            tabname   = l_tabname
          IMPORTING
            x030l_wa  = l_command-&gt;is_x030l
          TABLES
            dfies_tab = it_dfies
          EXCEPTIONS
            OTHERS    = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        IF l_command-&gt;is_x030l IS INITIAL.
          CALL METHOD g_application-&gt;issue_message
            EXPORTING
              iv_msgty = &apos;E&apos;
              iv_msgno = &apos;033&apos;
              iv_msgv1 = l_tabname.
*          MESSAGE e033 WITH l_tabname.
*       ELSEIF l_command-&gt;is_x030l-tabtype NE &apos;T&apos;.
*         message &apos;ZENITH:is not selectable&apos; TYPE &apos;E&apos;.
*       ELSEIF l_command-&gt;is_x030l-align NE 0.
*         message &apos;ZENITH:has alignment - cannot continue&apos; TYPE &apos;E&apos;.
        ENDIF.

        is_tables-prim_tab = ls_table_alias_tb-table.
        APPEND is_tables TO lt_tables.

        IF ls_alias_range-sel_id IS INITIAL.
*         Init free selection dialog
          CLEAR sy-msgno.
          CALL FUNCTION &apos;FREE_SELECTIONS_INIT&apos;
            EXPORTING
              expressions  = ls_alias_range-expr
            IMPORTING
              selection_id = ls_alias_range-sel_id
              expressions  = ls_alias_range-expr
            TABLES
              tables_tab   = lt_tables
              fields_tab   = lt_fields
              field_desc   = lt_field_desc
            EXCEPTIONS
              OTHERS       = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.
        ENDIF.

*       Display free selection dialog
        CLEAR sy-msgno.
        CALL FUNCTION &apos;FREE_SELECTIONS_DIALOG&apos;
          EXPORTING
            selection_id            = ls_alias_range-sel_id
            title                   = TEXT-077
            as_window               = &apos;X&apos;
          IMPORTING
            expressions             = ls_alias_range-expr
            field_ranges            = lt_ranges
            number_of_active_fields = ls_alias_range-active
          TABLES
            fields_tab              = ls_alias_range-fields
          EXCEPTIONS
            OTHERS                  = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
          EXIT.
        ENDIF.

        LOOP AT lt_ranges INTO ls_range2.
          DELETE l_command-&gt;it_ranges WHERE alias = l_aliasname.

          is_ranges-alias      = l_aliasname.
          is_ranges-rsds_range = ls_range2.
          APPEND is_ranges TO l_command-&gt;it_ranges.
        ENDLOOP.

        IF sy-subrc EQ 4.
          CLEAR l_command-&gt;it_ranges.
        ENDIF.

        ls_node_style-n_image = &apos;@1E@&apos;.

        MODIFY l_command-&gt;mt_alias_ranges FROM ls_alias_range INDEX l_tabix.

        READ TABLE lt_ranges INTO ls_range2 INDEX 1.

        it_frange = ls_range2-frange_t.

        LOOP AT l_command-&gt;mt_outtab_tb INTO gs_outtab_tb
             WHERE alias = l_aliasname    AND
                   fieldname IS NOT INITIAL.

          READ TABLE it_frange INTO is_frange
            WITH KEY fieldname = gs_outtab_tb-fieldname.

          IF sy-subrc NE 0.
            DELETE l_command-&gt;mt_outtab_tb
              WHERE alias     = l_aliasname              AND
                    fieldname = gs_outtab_tb-fieldname.

            DELETE l_command-&gt;mt_ranges
              WHERE table_alias = l_aliasname            AND
                    fieldname   = gs_outtab_tb-fieldname.
          ENDIF.

        ENDLOOP.

        LOOP AT it_frange INTO is_frange.

          CLEAR: it_ranges2, is_ranges2.
          is_ranges2-tablename = is_ranges-rsds_range-tablename.
          CLEAR ls_frange2.
          APPEND is_frange TO is_ranges2-frange_t.
          APPEND is_ranges2 TO it_ranges2.

          CALL FUNCTION &apos;FREE_SELECTIONS_RANGE_2_WHERE&apos;
            EXPORTING
              field_ranges  = it_ranges2
            IMPORTING
              where_clauses = lt_where.

          READ TABLE lt_where INTO ls_where INDEX 1.

          CLEAR l_where_text.
          LOOP AT ls_where-where_tab INTO l_line.
            CONCATENATE l_where_text l_line-line INTO l_where_text SEPARATED BY &apos; &apos;.
          ENDLOOP.

          CONDENSE l_where_text.

          IF l_where_text IS INITIAL.
            DELETE l_command-&gt;mt_outtab_tb
              WHERE alias       = l_aliasname AND
                    fieldname   = is_frange-fieldname.

            DELETE l_command-&gt;mt_ranges
              WHERE table_alias = l_aliasname AND
                    fieldname   = is_frange-fieldname.

            EXIT.
          ENDIF.

          READ TABLE l_command-&gt;mt_outtab_tb INTO gs_outtab_tb
            WITH KEY tablename = l_tabname
                     fieldname = is_frange-fieldname.

          IF sy-subrc NE 0.

            MOVE l_where_text TO gs_outtab_tb-ddtext.
*           CLEAR gs_outtab_tb-ddtext.
            gs_outtab_tb-alias     = l_aliasname.
            gs_outtab_tb-fieldname = is_frange-fieldname.

            CONCATENATE &apos;R_&apos; l_aliasname &apos;_&apos; gs_outtab_tb-fieldname INTO ls_rangename SEPARATED BY &apos;&apos;.
            REPLACE &apos; &apos; WITH &apos;&apos; INTO ls_rangename.
            CONDENSE ls_rangename NO-GAPS.

            APPEND gs_outtab_tb TO l_command-&gt;mt_outtab_tb.

            READ TABLE l_command-&gt;mt_tab_node_xref INTO gs_tab_node_xref
              WITH KEY alias = l_aliasname.
*              WITH KEY tablename = l_tabname.

            CLEAR l_new_node_key.
            CALL METHOD g_tree_tb-&gt;add_node
              EXPORTING
                i_relat_node_key = gs_tab_node_xref-node_key
                i_relationship   = cl_gui_column_tree=&gt;relat_last_child
                is_outtab_line   = gs_outtab_tb
                i_node_text      = ls_rangename
                is_node_layout   = ls_node_style
              IMPORTING
                e_new_node_key   = l_new_node_key
              EXCEPTIONS
                OTHERS           = 1.

            IF sy-subrc NE 0.
              IF sy-msgno IS NOT INITIAL.
                MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
              ENDIF.
            ENDIF.

*          READ TABLE l_command-&gt;mt_ranges INTO gs_ranges
*          WITH KEY tablename = is_ranges-tablename fieldname = is_frange-fieldname.
**            gs_ranges-node_text = ls_rangename.
*          MODIFY l_command-&gt;mt_ranges FROM gs_ranges INDEX sy-tabix.

*          CALL METHOD g_tree_tb-&gt;EXPAND_NODE
*            EXPORTING
*              I_NODE_KEY = gs_tab_node_xref-node_key.

          ELSE.
            MOVE l_where_text TO gs_outtab_tb-ddtext.
            MODIFY l_command-&gt;mt_outtab_tb FROM gs_outtab_tb INDEX sy-tabix.
          ENDIF.

          READ TABLE l_command-&gt;mt_ranges INTO gs_ranges
            WITH KEY table_alias = l_aliasname
                     fieldname   = is_frange-fieldname.

          IF sy-subrc EQ 0.
            gs_ranges-where_text = l_where_text.
            gs_ranges-range      = is_frange-selopt_t.

            MODIFY l_command-&gt;mt_ranges FROM gs_ranges INDEX sy-tabix.
          ELSE.
            CLEAR gs_ranges.
*           gs_ranges-node_key    = l_new_node_key.
            gs_ranges-table_alias = l_aliasname.
            gs_ranges-fieldname   = is_frange-fieldname.
            gs_ranges-where_text  = l_where_text.
            gs_ranges-node_text   = ls_rangename.
            gs_ranges-range       = is_frange-selopt_t.

            APPEND gs_ranges TO l_command-&gt;mt_ranges.
          ENDIF.

        ENDLOOP.

        CLEAR sy-msgno.
        CALL METHOD g_tree_tb-&gt;frontend_update
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        CLEAR sy-msgno.
        CALL METHOD cl_gui_cfw=&gt;dispatch
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ENDIF.

        CLEAR sy-msgno.
        CALL METHOD display_table_grid
          EXCEPTIONS
            OTHERS = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ENDIF.

    ENDCASE.

  ENDMETHOD.                    &quot;lcl_application



  METHOD handle_user_command.

    DATA: l_select_command TYPE REF TO lcl_select_command,
          l_select         TYPE REF TO lcl_select_command,
          lt_cells         TYPE lvc_t_cell,

          ls_row           TYPE lvc_s_row,
          ls_column_id     TYPE lvc_s_col,
          ls_row_no        TYPE lvc_s_roid.

    TRY.
        l_select_command ?= g_commands-&gt;current_command.
      CATCH cx_sy_move_cast_error.
*      message &apos;ZENITH:Casting error33&apos; TYPE &apos;E&apos;.
    ENDTRY.

    CALL METHOD g_alv-&gt;get_selected_cells
      IMPORTING
        et_cell = lt_cells
      EXCEPTIONS
        OTHERS  = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_alv-&gt;get_current_cell
      IMPORTING
        es_row_id = ls_row
        es_col_id = ls_column_id
        es_row_no = ls_row_no
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CASE e_ucomm.

      WHEN &apos;TXT_SHTXT&apos;  OR
           &apos;TXT_GENFLD&apos; OR
           &apos;TXT_ALIAS&apos;  OR
           &apos;TXT_FLD&apos;.

        CALL METHOD me-&gt;set_column_settings
          EXPORTING
            p_mode = e_ucomm.

        CALL METHOD me-&gt;set_column_headings.
        CALL METHOD me-&gt;refresh_display.

      WHEN &apos;KEY_NONE&apos; OR
           &apos;KEY_FIX&apos;.

        CALL METHOD me-&gt;set_key_field_settings
          EXPORTING
            p_mode = e_ucomm.

        CALL METHOD me-&gt;set_key_display_attributes.
        CALL METHOD me-&gt;refresh_display.

    ENDCASE.

    TRY.
        l_select ?= g_commands-&gt;current_command.

        IF l_select-&gt;mv_last_display EQ &apos;G&apos;.
          CALL METHOD g_alv-&gt;set_selected_cells
            EXPORTING
              it_cells = lt_cells
            EXCEPTIONS
              OTHERS   = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

          CALL METHOD g_alv-&gt;set_current_cell_via_id
            EXPORTING
              is_row_id    = ls_row
              is_column_id = ls_column_id
              is_row_no    = ls_row_no
            EXCEPTIONS
              OTHERS       = 1.

          IF sy-subrc NE 0.
            IF sy-msgno IS NOT INITIAL.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
            ENDIF.
          ENDIF.

        ENDIF.

      CATCH cx_sy_move_cast_error.
    ENDTRY.

  ENDMETHOD.                    &quot;lcl_application



  METHOD read_checktables.


    DATA: dd08v_ia            TYPE TABLE OF dd08v,
          dd05m_ia            TYPE TABLE OF dd05m,
          wa_dd05m_ia         TYPE dd05m,
          state(1),
          l_tabname           TYPE dd08l-tabname,
          lt_dd08l            TYPE TABLE OF dd08l,
          ls_table_alias      LIKE LINE OF g_commands-&gt;current_command-&gt;table_alias_tb,
          lstr(40)            TYPE c,
          lstr4(40)           TYPE c,
          lstr2               TYPE string,
          lstr3               TYPE string,
          lstr5               TYPE string,
          lint                TYPE i,
          ls_prev_linkedquery LIKE gs_linkedquery,
          ls_linkedquery      LIKE gs_linkedquery,
          l_ddtext            TYPE dd02t-ddtext.


    DATA: ls_info_tablf     TYPE lty_zhtdb_checktable_struc,
          lt_info_tablf     TYPE TABLE OF lty_zhtdb_checktable_struc,

          ls_info_tablf_out TYPE lty_zhtdb_checktable_struc_alv,
          lt_info_tablf_out TYPE TABLE OF lty_zhtdb_checktable_struc_alv,

          ls_selected_nodes TYPE lvc_s_nkey,
          lt_selected_nodes TYPE lvc_t_nkey,
          l_node_key        TYPE lvc_nkey.


    IF sender = &apos;T&apos;.

      CALL METHOD g_tree_tb-&gt;get_selected_nodes
        CHANGING
          ct_selected_nodes = lt_selected_nodes
        EXCEPTIONS
          cntl_system_error = 1
          dp_error          = 2
          failed            = 3
          OTHERS            = 4.
      IF sy-subrc &lt;&gt; 0.
        CALL METHOD g_application-&gt;issue_message
          EXPORTING
            iv_msgty = &apos;E&apos;
            iv_msgno = &apos;031&apos;.
*        MESSAGE e031.
      ENDIF.


      READ TABLE lt_selected_nodes INTO ls_selected_nodes INDEX 1.

      l_node_key = ls_selected_nodes-node_key.

      CALL METHOD g_tree_tb-&gt;get_outtab_line
        EXPORTING
          i_node_key     = l_node_key
        IMPORTING
*         E_NODE_TEXT    = l_nodetext
          e_outtab_line  = gs_outtab_tb
        EXCEPTIONS
          node_not_found = 1
          OTHERS         = 2.

      l_tabname = gs_outtab_tb-tablename.

    ELSEIF sender = &apos;G&apos;.
* obsolete
      RETURN.
    ENDIF.

    CLEAR gt_linkedquery.
    CLEAR lint.

    CLEAR lt_dd08l.

    READ TABLE g_commands-&gt;current_command-&gt;table_alias_tb INTO ls_table_alias
    WITH KEY table = l_tabname.

    SELECT info_tablf~tabname info_tablf~fieldname info_tablf~forkey info_tablf~primpos
    INTO CORRESPONDING FIELDS OF TABLE lt_info_tablf
    FROM info_tablf INNER JOIN dd02l ON info_tablf~tabname = dd02l~tabname
    WHERE info_tablf~checktable = l_tabname AND dd02l~tabclass = &apos;TRANSP&apos;.

    LOOP AT lt_info_tablf INTO ls_info_tablf.

      CLEAR: dd05m_ia, dd08v_ia.

      CALL FUNCTION &apos;DD_TBFK_GET&apos;
        EXPORTING
          fieldname     = &apos;*&apos;
          get_state     = &apos;A&apos;
          tabl_name     = ls_info_tablf-tabname
          withtext      = &apos;X&apos;
        IMPORTING
          got_state     = state
        TABLES
          dd05m_tab_a   = dd05m_ia
*         DD05M_TAB_N   = FK1_DD05M
          dd08v_tab_a   = dd08v_ia
*         DD08V_TAB_N   = FK1_DD08V
        EXCEPTIONS
          illegal_value = 01.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      LOOP AT dd05m_ia INTO wa_dd05m_ia WHERE checktable = l_tabname.

        lint = lint + 1.

        SELECT SINGLE ddtext
        INTO l_ddtext
        FROM dd02t
        WHERE tabname = wa_dd05m_ia-tabname
              AND ddlanguage = sy-langu.

        IF sy-subrc NE 0.

          SELECT SINGLE ddtext
          INTO l_ddtext
          FROM dd02t
          WHERE as4local = &apos;A&apos;
                AND tabname = wa_dd05m_ia-tabname.

          IF sy-subrc NE 0.
*            message &apos;ZENITH:sdfgdsf&apos; type &apos;E&apos;.
          ENDIF.

        ENDIF.

        CONCATENATE wa_dd05m_ia-tabname &apos;~&apos; wa_dd05m_ia-checkfield INTO lstr2.
        CONDENSE lstr2 NO-GAPS.
        CONCATENATE ls_table_alias-alias &apos;~&apos; wa_dd05m_ia-forkey INTO lstr3.
        CONDENSE lstr3 NO-GAPS.
        CONCATENATE &apos;ON&apos; lstr3 &apos;=&apos; lstr2 INTO lstr2 SEPARATED BY &apos; &apos;.

        MOVE lstr2 TO lstr.

        lstr2 = lint.

        CLEAR gs_linkedquery.
        gs_linkedquery-tabname     = ls_table_alias-alias.
        gs_linkedquery-checktable  = wa_dd05m_ia-tabname.
        gs_linkedquery-fieldname   = wa_dd05m_ia-forkey.
        gs_linkedquery-checkfield  = wa_dd05m_ia-checkfield.
        gs_linkedquery-primpos     = wa_dd05m_ia-primpos.
        gs_linkedquery-text        = lstr.
        gs_linkedquery-longtext    = lstr.
        gs_linkedquery-ddtext      = l_ddtext.

        APPEND gs_linkedquery TO gt_linkedquery.

      ENDLOOP.

    ENDLOOP.


    DATA: l_comp_count TYPE i,
          lt_primpos   TYPE TABLE OF gty_linkedquery-primpos.

    CLEAR gt_linkedquery_comp.

    SORT gt_linkedquery BY checktable tabname primpos fieldname checkfield .
    DELETE ADJACENT DUPLICATES FROM gt_linkedquery COMPARING checktable tabname primpos fieldname checkfield.

    LOOP AT gt_linkedquery INTO gs_linkedquery.

*      if ls_prev_linkedquery-checktable NE gs_linkedquery-checktable OR
*           ls_prev_linkedquery-tabname NE gs_linkedquery-tabname.

      AT END OF checktable.

        CLEAR: l_comp_count.
        CLEAR lt_primpos.
        CLEAR lstr2.

        lstr4 = &apos;* ON&apos;.

        LOOP AT gt_linkedquery INTO ls_linkedquery
          WHERE tabname         = ls_prev_linkedquery-tabname
                AND checktable  = ls_prev_linkedquery-checktable.
*                AND join_type   = ls_prev_linkedquery-join_type.


          READ TABLE lt_primpos TRANSPORTING NO FIELDS
            WITH KEY table_line = ls_linkedquery-primpos.

          IF sy-subrc EQ 4.

            CONCATENATE ls_linkedquery-tabname &apos;~&apos; ls_linkedquery-checkfield INTO lstr5.
            CONDENSE lstr5  NO-GAPS.

            CONCATENATE ls_linkedquery-checktable &apos;~&apos; ls_linkedquery-fieldname INTO lstr3.
            CONDENSE lstr3 NO-GAPS.

            CONCATENATE lstr4 lstr3 INTO lstr4 SEPARATED BY space.

            IF lstr2 IS INITIAL.
              CONCATENATE &apos;ON&apos; lstr3 &apos;=&apos; lstr5 INTO lstr2 SEPARATED BY &apos; &apos;.
            ELSE.
              CONCATENATE lstr2 &apos;AND&apos; lstr3 &apos;=&apos; lstr5 INTO lstr2 SEPARATED BY &apos; &apos;.
            ENDIF.

            APPEND ls_linkedquery-primpos TO lt_primpos.

            l_comp_count = l_comp_count + 1.

          ENDIF.

        ENDLOOP.

        IF l_comp_count GT 0.

          READ TABLE gt_linkedquery_comp TRANSPORTING NO FIELDS
            WITH KEY tabname    = ls_linkedquery-tabname
                     checktable = ls_linkedquery-checktable
                     text   = lstr4.
*                     longtext   = lstr2.

          IF sy-subrc EQ 4.

            gs_linkedquery_comp-tabname    = ls_linkedquery-tabname.
            gs_linkedquery_comp-checktable = ls_linkedquery-checktable.
            gs_linkedquery_comp-text       = lstr4.
            gs_linkedquery_comp-longtext   = lstr2.
            gs_linkedquery_comp-join_type  = ls_linkedquery-join_type.
            gs_linkedquery_comp-ddtext     = ls_linkedquery-ddtext.

            APPEND gs_linkedquery_comp TO gt_linkedquery_comp.

          ENDIF.

        ENDIF.

      ENDAT.

      ls_prev_linkedquery = gs_linkedquery.

*      if ls_prev_linkedquery-checktable NE gs_linkedquery-checktable.
*
*        CONCATENATE &apos;(&apos; gs_linkedquery-ddtext &apos;)&apos; INTO l_ddtext.
*        CONCATENATE gs_linkedquery-checktable l_ddtext INTO lstr SEPARATED BY &apos; &apos;.
*
*      endif.

    ENDLOOP.


    LOOP AT gt_linkedquery_comp INTO gs_linkedquery_comp.

      CLEAR ls_info_tablf_out.

      MOVE-CORRESPONDING gs_linkedquery_comp TO ls_info_tablf_out.

      ls_info_tablf_out-tabname = gs_linkedquery_comp-checktable.

      APPEND ls_info_tablf_out TO lt_info_tablf_out.

    ENDLOOP.

*    CONCATENATE &apos;Checktable Relationships for &apos; l_tabname INTO lstr SEPARATED BY &apos; &apos;.
    MESSAGE i037 WITH l_tabname INTO lstr.

    DELETE lt_info_tablf_out WHERE tabname = l_tabname.

    DATA: ls_selfield  TYPE slis_selfield,
          lt_fcat_slis TYPE slis_t_fieldcat_alv,
          ls_fcat_slis TYPE slis_fieldcat_alv.

    ls_fcat_slis-col_pos       = 1.
    ls_fcat_slis-fieldname     = &apos;TABNAME&apos;.
    ls_fcat_slis-rollname      = &apos;AS4TAB&apos;.
    ls_fcat_slis-reptext_ddic  = &apos;Table name&apos;.
    ls_fcat_slis-outputlen = 20.
    APPEND ls_fcat_slis TO lt_fcat_slis.

    ls_fcat_slis-col_pos       = 2.
    ls_fcat_slis-fieldname     = &apos;DDTEXT&apos;.
    ls_fcat_slis-rollname      = &apos;AS4TEXT&apos;.
    ls_fcat_slis-reptext_ddic  = &apos;Short text&apos;.
    ls_fcat_slis-outputlen = 50.
    APPEND ls_fcat_slis TO lt_fcat_slis.

    ls_fcat_slis-col_pos       = 3.
    ls_fcat_slis-fieldname     = &apos;LONGTEXT&apos;.
    ls_fcat_slis-rollname      = &apos;CHAR_512&apos;.
    ls_fcat_slis-reptext_ddic  = &apos;Join condition&apos;.
    ls_fcat_slis-outputlen = 512.
    APPEND ls_fcat_slis TO lt_fcat_slis.


    CALL FUNCTION &apos;REUSE_ALV_POPUP_TO_SELECT&apos;
      EXPORTING
        i_title               = lstr
*       I_SELECTION           = &apos;X&apos;
*       I_ALLOW_NO_SELECTION  =
        i_zebra               = &apos; &apos;
        i_screen_start_column = 3
        i_screen_start_line   = 2
        i_screen_end_column   = 200
        i_screen_end_line     = 30
*       I_CHECKBOX_FIELDNAME  =
*       I_LINEMARK_FIELDNAME  =
*       I_SCROLL_TO_SEL_LINE  = &apos;X&apos;
        it_fieldcat           = lt_fcat_slis
        i_tabname             = &apos;L+FASY&apos;
*       IT_EXCLUDING          =
*       I_CALLBACK_PROGRAM    =
*       I_CALLBACK_USER_COMMAND       =
*       IS_PRIVATE            =
      IMPORTING
        es_selfield           = ls_selfield
*       E_EXIT                =
      TABLES
        t_outtab              = lt_info_tablf_out
      EXCEPTIONS
        program_error         = 1
        OTHERS                = 2.
    IF sy-subrc &lt;&gt; 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    IF ls_selfield-tabindex IS NOT INITIAL.

      DATA:
        l_jointext          TYPE string,
        lt_jointext         TYPE lty_zhtdbt_string_tab,
*            lt_jointext TYPE source_table,
        l_tablename         TYPE gty_linkedquery-checktable,
        l_alias             TYPE gty_linkedquery-checktable,
        l_select            TYPE REF TO lcl_select_command,
        l_from_text         TYPE string,
        l_where_text        TYPE string,
        l_gb_text           TYPE string,
        l_ob_text           TYPE string,
        l_fdpos             TYPE i,
        l_tabix             TYPE i,
        l_selfae_alias      TYPE string,
        ls_linkedquery_comp LIKE gs_linkedquery_comp.


      READ TABLE lt_info_tablf_out INTO ls_info_tablf_out
      INDEX ls_selfield-tabindex.

      IF sy-subrc NE 0.
        CALL METHOD g_application-&gt;issue_message
          EXPORTING
            iv_msgty = &apos;I&apos;
            iv_msgno = &apos;027&apos;.
*        MESSAGE i027.
      ENDIF.

      READ TABLE gt_linkedquery_comp INTO ls_linkedquery_comp
      WITH KEY checktable = ls_info_tablf_out-tabname.

      IF sy-subrc NE 0.
        CALL METHOD g_application-&gt;issue_message
          EXPORTING
            iv_msgty = &apos;I&apos;
            iv_msgno = &apos;027&apos;.
*        MESSAGE i027.
      ELSE.
        l_tablename    = ls_linkedquery_comp-checktable.
        l_jointext     = ls_linkedquery_comp-longtext.
        l_selfae_alias = ls_linkedquery_comp-tabname.
      ENDIF.

      TRY.

          l_select ?= g_commands-&gt;current_command.

          l_from_text   = l_select-&gt;from_text.
          l_gb_text     = l_select-&gt;group_by_text.
          l_ob_text     = l_select-&gt;order_by_text.
          l_where_text  = l_select-&gt;where_text.

        CATCH cx_sy_move_cast_error.

      ENDTRY.

      CHECK l_from_text IS NOT INITIAL.

      IF l_where_text IS NOT INITIAL.

        SEARCH g_commands-&gt;current_command-&gt;text FOR l_where_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_gb_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands-&gt;current_command-&gt;text FOR l_gb_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_ob_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands-&gt;current_command-&gt;text FOR l_ob_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ENDIF.

*      LOOP AT g_commands-&gt;current_command-&gt;table_alias_tb INTO ls_table_alias_tb WHERE TABLE = L_TABLENAME.
*
*      ENDLOOP.
      READ TABLE g_commands-&gt;current_command-&gt;table_alias_tb TRANSPORTING NO FIELDS
      WITH KEY table = l_tablename.

      IF sy-subrc EQ 4.
        l_alias = l_tablename.
      ELSE.
        lstr = sy-tabix + 1.
        CONCATENATE l_tablename lstr INTO l_alias.

        CONCATENATE l_tablename &apos;~&apos; INTO lstr.
        CONCATENATE l_alias &apos;~&apos; INTO lstr2.
        REPLACE ALL OCCURRENCES OF lstr IN l_jointext WITH lstr2.
      ENDIF.

      CASE i_ucomm.

        WHEN &apos;RELAT_I&apos;.
          CONCATENATE &apos;INNER JOIN&apos; l_tablename &apos;AS&apos; l_alias l_jointext INTO l_jointext SEPARATED BY &apos; &apos;.

        WHEN &apos;RELAT_O&apos;.
          CONCATENATE &apos;LEFT OUTER JOIN&apos; l_tablename &apos;AS&apos; l_alias l_jointext INTO l_jointext SEPARATED BY &apos; &apos;.

        WHEN &apos;RELAT_Q&apos;.
          CONCATENATE &apos;( SELECT&apos; l_tablename &apos;AS&apos; l_alias l_jointext &apos;)&apos; INTO l_jointext SEPARATED BY &apos; &apos;.

        WHEN &apos;RELAT_S&apos;.

          MOVE l_jointext+3 TO l_jointext.

          CONCATENATE l_selfae_alias &apos;~&apos; INTO l_selfae_alias.
          CONDENSE l_selfae_alias NO-GAPS.

          REPLACE ALL OCCURRENCES OF l_selfae_alias IN l_jointext WITH &apos;ZSQL_OUTER_TABLE-&apos; IGNORING CASE.

          CONCATENATE &apos;SELECT * FROM&apos; l_tablename INTO lstr2 SEPARATED BY &apos; &apos;.
          APPEND lstr2 TO lt_jointext.

          lstr2 = &apos;FOR ALL ENTRIES IN ZSQL_OUTER_TABLE&apos;.
          APPEND lstr2 TO lt_jointext.

          DATA: lt_jointext_temp LIKE lt_jointext.

          CONCATENATE &apos;WHERE&apos; l_jointext INTO lstr2 SEPARATED BY &apos; &apos;.

          CALL METHOD lcl_toolbox=&gt;split_string
            EXPORTING
              iv_string     = lstr2
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext_temp.

*          CALL METHOD split_string_to_itab
*            EXPORTING
*              p_string = lstr2
*            IMPORTING
*              p_itab   = lt_jointext_temp.
*
          APPEND LINES OF lt_jointext_temp TO lt_jointext.

      ENDCASE.


      IF i_ucomm EQ &apos;RELAT_S&apos;.

        CALL METHOD cl_gui_cfw=&gt;set_new_ok_code
          EXPORTING
            new_code = &apos;NEWSELFOR&apos;
          EXCEPTIONS
            OTHERS   = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        gt_selfae_jointext[] = lt_jointext[].

        RETURN.

      ELSE.

        IF strlen( l_jointext ) &lt; gc_line_length.
          APPEND l_jointext TO lt_jointext.
        ELSE.

          CALL METHOD lcl_toolbox=&gt;split_string
            EXPORTING
              iv_string     = l_jointext
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext.

*          CALL METHOD split_string_to_itab
*            EXPORTING
*              p_string = l_jointext
*            IMPORTING
*              p_itab   = lt_jointext.
*
        ENDIF.

      ENDIF.

*      IF l_fdpos IS NOT INITIAL.
*
*        INSERT LINES OF lt_jointext INTO g_commands-&gt;current_command-&gt;text INDEX l_tabix.
*
*      ELSE.
*
*        APPEND LINES OF lt_jointext TO g_commands-&gt;current_command-&gt;text.
*
*      ENDIF.

      CALL METHOD insert_stringtab_to_pos
        EXPORTING
          it_stringtab = lt_jointext.

      CALL METHOD g_commands-&gt;display_command.

    ENDIF.



  ENDMETHOD.                    &quot;lcl_application


  METHOD handle_lq_ctx_sel.

    CALL METHOD g_commands-&gt;transfer_text_to_command.

    IF e_ucomm(5) EQ &apos;RELAT&apos;.

      CALL METHOD read_checktables
        EXPORTING
          sender  = sender
          i_ucomm = e_ucomm.


    ENDIF.

    IF e_ucomm+2(3) EQ &apos;LA_&apos;.

      DATA: lstr                TYPE string,
            lstr2               TYPE string,
            l_jointext          TYPE string,
            lt_jointext         TYPE lty_zhtdbt_string_tab,
*            lt_jointext TYPE source_table,
            l_tablename         TYPE gty_linkedquery-checktable,
            l_alias             TYPE gty_linkedquery-checktable,
            l_jointype(3)       TYPE c,
            l_select            TYPE REF TO lcl_select_command,
            l_from_text         TYPE string,
            l_where_text        TYPE string,
            l_gb_text           TYPE string,
            l_ob_text           TYPE string,
            l_fdpos             TYPE i,
            l_tabix             TYPE i,
            l_ucomm             TYPE sy-ucomm,
            l_selfae_alias      TYPE string,
            ls_linkedquery_comp LIKE gs_linkedquery_comp,
            ls_linkedquery      LIKE gs_linkedquery,
            ls_table_alias_tb   LIKE LINE OF g_commands-&gt;current_command-&gt;table_alias_tb.


      l_ucomm = e_ucomm.

**      SEARCH l_ucomm FOR &apos;_COMP&apos;.
**
**      IF sy-fdpos EQ 0.

      REPLACE ALL OCCURRENCES OF &apos;I_&apos; IN l_ucomm WITH &apos;&apos;.
      IF sy-subrc EQ 0.
        l_jointype = &apos;I&apos;.
      ENDIF.

      REPLACE ALL OCCURRENCES OF &apos;O_&apos; IN l_ucomm WITH &apos;&apos;.
      IF sy-subrc EQ 0.
        l_jointype = &apos;O&apos;.
      ENDIF.

      REPLACE ALL OCCURRENCES OF &apos;S_&apos; IN l_ucomm WITH &apos;&apos;.
      IF sy-subrc EQ 0.
        l_jointype = &apos;S&apos;.
      ENDIF.

      REPLACE ALL OCCURRENCES OF &apos;Q_&apos; IN l_ucomm WITH &apos;&apos;.
      IF sy-subrc EQ 0.
        l_jointype = &apos;Q&apos;.
      ENDIF.

      SEARCH l_ucomm FOR &apos;_COMP&apos;.

      IF sy-fdpos EQ 0.

        READ TABLE gt_linkedquery INTO ls_linkedquery
        WITH KEY fcode = l_ucomm.

        IF sy-subrc NE 0.
          CALL METHOD g_application-&gt;issue_message
            EXPORTING
              iv_msgty = &apos;I&apos;
              iv_msgno = &apos;027&apos;.
*            MESSAGE i027.
        ELSE.
          l_tablename    = ls_linkedquery-checktable.
          l_jointext     = ls_linkedquery-longtext.
          l_selfae_alias = ls_linkedquery-tabname.
        ENDIF.

      ELSE.

        READ TABLE gt_linkedquery_comp INTO ls_linkedquery_comp
        WITH KEY fcode = l_ucomm.

        IF sy-subrc NE 0.
          CALL METHOD g_application-&gt;issue_message
            EXPORTING
              iv_msgty = &apos;I&apos;
              iv_msgno = &apos;027&apos;.
*            MESSAGE i027.
        ELSE.
          l_tablename    = ls_linkedquery_comp-checktable.
          l_jointext     = ls_linkedquery_comp-longtext.
          l_selfae_alias = ls_linkedquery_comp-tabname.
        ENDIF.

      ENDIF.


      LOOP AT g_commands-&gt;current_command-&gt;table_alias_tb INTO ls_table_alias_tb WHERE table = l_tablename.

      ENDLOOP.

      IF sy-subrc EQ 4.
        l_alias = l_tablename.
      ELSE.
        lstr = sy-tabix + 1.
        CONCATENATE l_tablename lstr INTO l_alias.

        CONCATENATE l_tablename &apos;~&apos; INTO lstr.
        CONCATENATE l_alias &apos;~&apos; INTO lstr2.
        REPLACE ALL OCCURRENCES OF lstr IN l_jointext WITH lstr2.
      ENDIF.

      TRY.

          l_select ?= g_commands-&gt;current_command.

          l_from_text   = l_select-&gt;from_text.
          l_gb_text     = l_select-&gt;group_by_text.
          l_ob_text     = l_select-&gt;order_by_text.
          l_where_text  = l_select-&gt;where_text.

        CATCH cx_sy_move_cast_error.

      ENDTRY.

      CHECK l_from_text IS NOT INITIAL.

      IF l_where_text IS NOT INITIAL.

        SEARCH g_commands-&gt;current_command-&gt;text FOR l_where_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_gb_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands-&gt;current_command-&gt;text FOR l_gb_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ELSEIF l_ob_text IS NOT INITIAL AND l_fdpos IS INITIAL.

        SEARCH g_commands-&gt;current_command-&gt;text FOR l_ob_text.

        IF sy-fdpos GT 0.
          l_fdpos = sy-fdpos.
          l_tabix = sy-tabix.
        ENDIF.

      ENDIF.

      CASE l_jointype.

        WHEN &apos;I&apos;.
          CONCATENATE &apos;INNER JOIN&apos; l_tablename &apos;AS&apos; l_alias l_jointext INTO l_jointext SEPARATED BY &apos; &apos;.

        WHEN &apos;O&apos;.
          CONCATENATE &apos;LEFT OUTER JOIN&apos; l_tablename &apos;AS&apos; l_alias l_jointext INTO l_jointext SEPARATED BY &apos; &apos;.

        WHEN &apos;S&apos;.

          MOVE l_jointext+3 TO l_jointext.

          CONCATENATE l_selfae_alias &apos;~&apos; INTO l_selfae_alias.
          CONDENSE l_selfae_alias NO-GAPS.

          REPLACE ALL OCCURRENCES OF l_selfae_alias IN l_jointext WITH &apos;ZSQL_OUTER_TABLE-&apos; IGNORING CASE.

          CONCATENATE &apos;SELECT * FROM&apos; l_tablename INTO lstr2 SEPARATED BY &apos; &apos;.
          APPEND lstr2 TO lt_jointext.

          lstr2 = &apos;FOR ALL ENTRIES IN ZSQL_OUTER_TABLE&apos;.
          APPEND lstr2 TO lt_jointext.

          DATA: lt_jointext_temp LIKE lt_jointext.

          CONCATENATE &apos;WHERE&apos; l_jointext INTO lstr2 SEPARATED BY &apos; &apos;.

          CALL METHOD lcl_toolbox=&gt;split_string
            EXPORTING
              iv_string     = lstr2
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext_temp.

*          CALL METHOD split_string_to_itab
*            EXPORTING
*              p_string = lstr2
*            IMPORTING
*              p_itab   = lt_jointext_temp.
*
          APPEND LINES OF lt_jointext_temp TO lt_jointext.

        WHEN &apos;Q&apos;.

          MOVE l_jointext+3 TO l_jointext.

*          CONCATENATE l_selfae_alias &apos;~&apos; INTO l_selfae_alias.
*          CONDENSE l_selfae_alias NO-GAPS.
*
*          REPLACE ALL OCCURRENCES OF l_selfae_alias IN l_jointext WITH l_tablename IGNORING CASE.

          CONCATENATE &apos;( SELECT * FROM&apos; l_tablename &apos;WHERE&apos; l_jointext &apos;)&apos; INTO l_jointext SEPARATED BY &apos; &apos;.

      ENDCASE.

      IF l_jointype NE &apos;S&apos;.

        IF strlen( l_jointext ) &lt; gc_line_length.
          APPEND l_jointext TO lt_jointext.
        ELSE.

          CALL METHOD lcl_toolbox=&gt;split_string
            EXPORTING
              iv_string     = l_jointext
              iv_maxlen     = gc_line_length
            IMPORTING
              et_string_tab = lt_jointext.

        ENDIF.

      ELSE.

        CALL METHOD cl_gui_cfw=&gt;set_new_ok_code
          EXPORTING
            new_code = &apos;NEWSELFOR&apos;
          EXCEPTIONS
            OTHERS   = 1.

        IF sy-subrc NE 0.
          IF sy-msgno IS NOT INITIAL.
            MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
          ENDIF.
        ENDIF.

        gt_selfae_jointext[] = lt_jointext[].

        RETURN.

      ENDIF.

      CALL METHOD insert_stringtab_to_pos
        EXPORTING
          it_stringtab = lt_jointext.

      CALL METHOD g_commands-&gt;display_command.

    ENDIF.

  ENDMETHOD.                    &quot;lcl_application


  METHOD refresh_display.

    DATA: l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands-&gt;current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.

    CHECK l_select_command IS NOT INITIAL.
    CHECK &lt;gt_result&gt; IS ASSIGNED.

    CALL METHOD g_alv-&gt;set_frontend_fieldcatalog
      EXPORTING
        it_fieldcatalog = l_select_command-&gt;fcat
      EXCEPTIONS
        OTHERS          = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_alv-&gt;refresh_table_display
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;refresh_display


  METHOD set_column_headings.

    DATA: ls_fcat          TYPE lvc_s_fcat,
          ls_fieldinfo     TYPE gty_fieldinfo,
          lv_tabix         TYPE i,
          l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands-&gt;current_command.
      CATCH cx_sy_move_cast_error.
    ENDTRY.

    CHECK l_select_command IS NOT INITIAL.
    CHECK &lt;gt_result&gt; IS ASSIGNED.

    TRY.
        LOOP AT l_select_command-&gt;fcat INTO ls_fcat
             WHERE fieldname &lt;&gt; &apos;ZENITH_ROWID&apos;    AND
                   fieldname &lt;&gt; &apos;ZENITH_SELECTED&apos; AND
                   fieldname &lt;&gt; &apos;ZENITH_STYLE&apos;    AND
                   fieldname &lt;&gt; &apos;ZENITH_COLOR&apos;    AND
                   fieldname &lt;&gt; &apos;ZENITH_LOCKED_BY&apos;.

          lv_tabix = sy-tabix.

          READ TABLE l_select_command-&gt;fieldinfo_tb INTO ls_fieldinfo
            WITH KEY generated_field = ls_fcat-fieldname.

          IF sy-subrc NE 0.
            CALL METHOD g_application-&gt;issue_message
              EXPORTING
                iv_msgty = &apos;E&apos;
                iv_msgno = &apos;027&apos;.
          ENDIF.

          CASE l_select_command-&gt;mv_colmn_header.
            WHEN &apos;S&apos;.

              IF l_select_command-&gt;mv_last_display = &apos;G&apos;.
                CLEAR: ls_fcat-coltext,
                       ls_fcat-scrtext_l,
                       ls_fcat-scrtext_m,
                       ls_fcat-scrtext_s,
                       ls_fcat-reptext.
              ELSE.
                ls_fcat-coltext   = ls_fcat-reptext.
                ls_fcat-scrtext_l = ls_fcat-reptext.
                ls_fcat-scrtext_m = ls_fcat-reptext.
                ls_fcat-scrtext_s = ls_fcat-reptext.
                ls_fcat-reptext   = ls_fcat-reptext.
              ENDIF.

            WHEN &apos;G&apos;.
              ls_fcat-coltext = ls_fieldinfo-generated_field.

            WHEN &apos;A&apos;.

              IF ls_fieldinfo-field_alias IS NOT INITIAL.
                ls_fcat-coltext = ls_fieldinfo-field_alias.
              ELSE.
                ls_fcat-coltext = ls_fieldinfo-generated_field.
              ENDIF.

            WHEN &apos;T&apos;.
              ls_fcat-coltext = ls_fieldinfo-orig_field.

          ENDCASE.

          MODIFY l_select_command-&gt;fcat FROM ls_fcat INDEX lv_tabix.
        ENDLOOP.


      CATCH cx_sy_move_cast_error.

    ENDTRY.

  ENDMETHOD.                    &quot;lcl_application


  METHOD set_key_display_attributes.

    DATA: ls_fcat          TYPE lvc_s_fcat,
          l_select_command TYPE REF TO lcl_select_command.

    TRY.
        l_select_command ?= g_commands-&gt;current_command.

      CATCH cx_sy_move_cast_error.
        RETURN.
    ENDTRY.

    CHECK l_select_command IS NOT INITIAL.
    CHECK &lt;gt_result&gt; IS ASSIGNED.
    CHECK l_select_command-&gt;mv_last_display = &apos;G&apos;.

*   set this property so it can be saved with the command

*   modify field catalog
    LOOP AT l_select_command-&gt;fcat INTO ls_fcat WHERE key_sel EQ &apos;X&apos;.
      CASE l_select_command-&gt;mv_key_colmn_type.
        WHEN &apos;N&apos;.
          CLEAR ls_fcat-key.
        WHEN &apos;F&apos;.
          ls_fcat-key = &apos;X&apos;.
      ENDCASE.

      MODIFY l_select_command-&gt;fcat FROM ls_fcat.
    ENDLOOP.

    gs_layo-no_keyfix = &apos;X&apos;.

    CALL METHOD g_alv-&gt;set_frontend_layout
      EXPORTING
        is_layout = gs_layo
      EXCEPTIONS
        OTHERS    = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot; set_key_display_attributes


  METHOD handle_menu_button.

    DATA: lv_display_only TYPE c.


    IF g_alv-&gt;is_ready_for_input( ) EQ 0.
      lv_display_only = &apos;X&apos;.
    ELSE.
      lv_display_only = &apos; &apos;.
    ENDIF.


    IF e_ucomm = &apos;TXT_MENU&apos;.
      CALL METHOD e_object-&gt;add_function
        EXPORTING
          fcode  = &apos;TXT_ALIAS&apos;
          text   = TEXT-081
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object-&gt;add_function
        EXPORTING
          fcode  = &apos;TXT_FLD&apos;
          text   = TEXT-090
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object-&gt;add_function
        EXPORTING
          fcode  = &apos;TXT_GENFLD&apos;
          text   = TEXT-091
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object-&gt;add_function
        EXPORTING
          fcode  = &apos;TXT_SHTXT&apos;
          text   = TEXT-092
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object-&gt;add_separator
        EXCEPTIONS
          OTHERS = 1.

      CALL METHOD e_object-&gt;add_function
        EXPORTING
          fcode  = &apos;KEY_FIX&apos;
          text   = TEXT-089
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

      CALL METHOD e_object-&gt;add_function
        EXPORTING
          fcode  = &apos;KEY_NONE&apos;
          text   = TEXT-078
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
        ENDIF.
      ENDIF.

    ENDIF.

  ENDMETHOD.                    &quot;lcl_application

ENDCLASS.                    &quot;lcl_application IMPLEMENTATION

*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZHTDB_LCLCOMMAND_I                               *
*&amp;---------------------------------------------------------------------*


CLASS lcl_command IMPLEMENTATION.



  METHOD constructor.

    IF p_copy_from IS NOT INITIAL.

      it_ranges        = p_copy_from-&gt;it_ranges.
      is_x030l         = p_copy_from-&gt;is_x030l.

      mt_alias_ranges  = p_copy_from-&gt;mt_alias_ranges.
      mt_ranges        = p_copy_from-&gt;mt_ranges.
      mt_outtab_tb     = p_copy_from-&gt;mt_outtab_tb.
      mt_tab_node_xref = p_copy_from-&gt;mt_tab_node_xref.

      command_type     = p_copy_from-&gt;command_type.
      where_text       = p_copy_from-&gt;where_text.
      mv_dbcnt         = p_copy_from-&gt;mv_dbcnt.
      mv_bytes         = p_copy_from-&gt;mv_bytes.

      commandtext      = p_copy_from-&gt;commandtext.
      gen_commandtext  = p_copy_from-&gt;gen_commandtext.
      gen_text         = p_copy_from-&gt;gen_text.
      text             = p_copy_from-&gt;text.
      table_alias_tb   = p_copy_from-&gt;table_alias_tb.

    ENDIF.

  ENDMETHOD.                    &quot;LCL_COMMAND



  METHOD execute_parsed_sql.

  ENDMETHOD.                    &quot;LCL_COMMAND


  METHOD get_type.
    ep_command_type = me-&gt;command_type.
  ENDMETHOD.                    &quot;LCL_COMMAND


  METHOD parse_commandtext.

  ENDMETHOD.                    &quot;LCL_COMMAND


  METHOD set_commandtext.

    me-&gt;commandtext = p_commandtext.
    CONDENSE me-&gt;commandtext.
    CONCATENATE &apos;&apos; me-&gt;commandtext INTO me-&gt;commandtext SEPARATED BY &apos; &apos;.

  ENDMETHOD.                    &quot;LCL_COMMAND

ENDCLASS.                    &quot;LCL_COMMAND IMPLEMENTATION



*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZHTDB_LCLSELECT_I                                *
*&amp;---------------------------------------------------------------------*


CLASS lcl_select_command IMPLEMENTATION.


  METHOD calculate_mv_rowlen.

    DATA: ls_fcat TYPE lvc_s_fcat.

    CLEAR mv_rowlen.

    LOOP AT fcat INTO ls_fcat
         WHERE fieldname NE &apos;ZENITH_ROWID&apos;    AND
               fieldname NE &apos;ZENITH_SELECTED&apos; AND
               fieldname NE &apos;ZENITH_STYLE&apos;    AND
               fieldname NE &apos;ZENITH_COLOR&apos;    AND
               fieldname NE &apos;ZENITH_LOCKED_BY&apos;.
      mv_rowlen = mv_rowlen + ls_fcat-intlen.
    ENDLOOP.

  ENDMETHOD.                    &quot; calculate_mv_rowlen


  METHOD constructor.

    CALL METHOD super-&gt;constructor
      EXPORTING
        p_copy_from = p_copy_from.

    CREATE OBJECT mo_pipacs_select.
    mo_pipacs_command = mo_pipacs_select.

    IF p_copy_from IS NOT INITIAL.

      select_text = p_copy_from-&gt;select_text.
      from_text = p_copy_from-&gt;from_text.
      group_by_text = p_copy_from-&gt;group_by_text.
      having_text = p_copy_from-&gt;having_text.
      order_by_text = p_copy_from-&gt;order_by_text.

      can_edit = p_copy_from-&gt;can_edit.

      has_table_alias = p_copy_from-&gt;has_table_alias.
      group_by_text = p_copy_from-&gt;group_by_text.
      alv_state = p_copy_from-&gt;alv_state.
      has_duplicate_fields = p_copy_from-&gt;has_duplicate_fields.

      ddic_references = p_copy_from-&gt;ddic_references.
      fieldinfo_tb = p_copy_from-&gt;fieldinfo_tb.
      prev_fcat = p_copy_from-&gt;prev_fcat.
      fcat = p_copy_from-&gt;fcat.

    ENDIF.

  ENDMETHOD.                    &quot; constructor



  METHOD assign_field_symbols.

    UNASSIGN: &lt;gt_result&gt;,
              &lt;gt_temp&gt;,
              &lt;gt_undo&gt;,

              &lt;gs_result&gt;,
              &lt;gs_temp&gt;,
              &lt;gs_undo&gt;.

    CALL METHOD me-&gt;assign_field_symbol
      EXPORTING
        p_fs    = &apos;R&apos;
      CHANGING
        p_table = me-&gt;result_table.
****    CALL METHOD me-&gt;assign_field_symbol
****      EXPORTING
****        p_fs    = &apos;X&apos;
****      CHANGING
****        p_table = me-&gt;display_table.
    CALL METHOD me-&gt;assign_field_symbol
      EXPORTING
        p_fs    = &apos;D&apos;
      CHANGING
        p_table = me-&gt;deleted_table.
    CALL METHOD me-&gt;assign_field_symbol
      EXPORTING
        p_fs    = &apos;I&apos;
      CHANGING
        p_table = me-&gt;inserted_table.
    CALL METHOD me-&gt;assign_field_symbol
      EXPORTING
        p_fs    = &apos;U&apos;
      CHANGING
        p_table = me-&gt;updated_table.
    CALL METHOD me-&gt;assign_field_symbol
      EXPORTING
        p_fs    = &apos;T&apos;
      CHANGING
        p_table = me-&gt;temp_table.
    CALL METHOD me-&gt;assign_field_symbol
      EXPORTING
        p_fs    = &apos;N&apos;
      CHANGING
        p_table = me-&gt;undo_table.
    CALL METHOD me-&gt;assign_field_symbol
      EXPORTING
        p_fs    = &apos;L&apos;
      CHANGING
        p_table = me-&gt;lawb_table.
    CALL METHOD me-&gt;assign_field_symbol
      EXPORTING
        p_fs    = &apos;S&apos;
      CHANGING
        p_table = me-&gt;selfae_table.

  ENDMETHOD.                    &quot; assign_field_symbols


  METHOD assign_field_symbol.

    CASE p_fs.
****      WHEN &apos;X&apos;.
****        ASSIGN p_table-&gt;* TO &lt;gt_display&gt;.
*****        ASSIGN me-&gt;deleted_structure-&gt;* TO &lt;gs_deleted&gt;.

      WHEN &apos;R&apos;.
        ASSIGN p_table-&gt;* TO &lt;gt_result&gt;.
        ASSIGN me-&gt;result_structure-&gt;* TO &lt;gs_result&gt;.

      WHEN &apos;T&apos;.
        ASSIGN p_table-&gt;* TO &lt;gt_temp&gt;.
        ASSIGN me-&gt;temp_structure-&gt;* TO &lt;gs_temp&gt;.

      WHEN &apos;N&apos;.
        ASSIGN p_table-&gt;* TO &lt;gt_undo&gt;.
        ASSIGN me-&gt;undo_structure-&gt;* TO &lt;gs_undo&gt;.

    ENDCASE.

  ENDMETHOD.                    &quot; assign_field_symbol


  METHOD parse_commandtext.

    DATA: ls_table_alias LIKE LINE OF me-&gt;table_alias_tb.


    CALL METHOD super-&gt;parse_commandtext
      EXPORTING
        p_on_load      = p_on_load
      EXCEPTIONS
        error_occurred = 1
        OTHERS         = 2.

    CASE sy-subrc.
      WHEN 1.
        RAISE error_occurred.
      WHEN 2.
        RAISE error_occurred.
    ENDCASE.

    CLEAR table_alias_tb.

    CALL METHOD mo_pipacs_command-&gt;parse
      EXCEPTIONS
        parse_error = 1
        OTHERS      = 2.

    IF sy-subrc &lt;&gt; 0.
      IF sy-msgno IS NOT INITIAL AND p_on_load IS INITIAL.
        IF p_bf_test IS INITIAL.
          MESSAGE ID sy-msgid TYPE &apos;S&apos; NUMBER sy-msgno DISPLAY LIKE &apos;E&apos;
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ELSE.
*          CALL METHOD g_application-&gt;add_message( iv_msgty = &apos;E&apos; iv_msgid = sy-msgid iv_msgno = sy-msgno
*            iv_msgv1 = sy-msgv1 iv_msgv2 = sy-msgv2 iv_msgv3 = sy-msgv3 iv_msgv4 = sy-msgv4 ).
        ENDIF.

        RAISE error_occurred.
      ELSE.
        RAISE error_occurred.
      ENDIF.

    ENDIF.

    CALL METHOD mo_pipacs_select-&gt;get_texts
      IMPORTING
        ev_select_text   = select_text
        ev_from_text     = from_text
        ev_where_text    = where_text
        ev_group_by_text = group_by_text
        ev_having_text   = having_text
        ev_order_by_text = order_by_text.

    CALL METHOD mo_pipacs_select-&gt;get_fieldinfo
      IMPORTING
        et_fieldinfo = me-&gt;fieldinfo_tb.

    CALL METHOD mo_pipacs_select-&gt;get_table_alias
      IMPORTING
        et_table_alias = me-&gt;table_alias_tb.

    SORT me-&gt;table_alias_tb BY table alias.

    DELETE ADJACENT DUPLICATES FROM me-&gt;table_alias_tb COMPARING table alias.

    can_edit = mo_pipacs_select-&gt;can_edit( ).

    LOOP AT me-&gt;table_alias_tb INTO ls_table_alias.
      IF ls_table_alias-alias IS INITIAL.
        ls_table_alias-alias = ls_table_alias-table.

        MODIFY me-&gt;table_alias_tb FROM ls_table_alias INDEX sy-tabix.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    &quot; parse_commandtext



  METHOD execute_parsed_sql.

    DATA: lv_job_name  TYPE btcjob,
          lv_job_count TYPE btcjobcnt,
          lx_root      TYPE REF TO cx_root,
          ls_celltab   TYPE lvc_s_styl,
          ls_fcat      TYPE lvc_s_fcat.

    FIELD-SYMBOLS: &lt;lt_style&gt; TYPE lvc_t_styl.

    CALL METHOD super-&gt;execute_parsed_sql
      EXPORTING
        iv_simulation    = iv_simulation
        iv_bg_proc       = iv_bg_proc
        iv_bg_date       = iv_bg_date
        iv_bg_time       = iv_bg_time
      EXCEPTIONS
        table_not_found  = 1
        parse_error      = 2
        exec_error       = 3
        error_occurred   = 4
        unlock_error     = 5
        arg_to_long      = 6
        foreign_lock     = 7
        job_submit_error = 8
        OTHERS           = 9.

    CASE sy-subrc.
      WHEN 1.
        RAISE table_not_found.
      WHEN 2.
        RAISE parse_error.
      WHEN 3.
        RAISE exec_error.
      WHEN 4.
        RAISE error_occurred.
      WHEN 5.
        RAISE unlock_error.
      WHEN 6.
        RAISE arg_to_long.
      WHEN 7.
        RAISE foreign_lock.
      WHEN 8.
        RAISE job_submit_error.
      WHEN 9.
        RAISE error_occurred.
    ENDCASE.

    CALL METHOD mo_pipacs_command-&gt;execute
      EXPORTING
        iv_simulation    = iv_simulation
        iv_bg_proc       = iv_bg_proc
        iv_bg_date       = iv_bg_date
        iv_bg_time       = iv_bg_time
      IMPORTING
        er_result        = returned_table
        ev_dbcnt         = mv_dbcnt
        er_lock_argument = mr_lock_argument_temp
        er_exc           = lx_root
        ev_job_name      = lv_job_name
        ev_job_count     = lv_job_count
        et_srccode       = et_srccode
      EXCEPTIONS
        parse_error      = 1
        exec_error       = 2
        job_submit_error = 3
        OTHERS           = 4.

    CASE sy-subrc.
      WHEN 1.
        RAISE parse_error.
      WHEN 3.
        RAISE job_submit_error.
      WHEN 2 OR 4.
        er_exception = lx_root.
        RAISE exec_error.
    ENDCASE.

    IF iv_simulation IS INITIAL AND
       iv_bg_proc    IS INITIAL.

      FIELD-SYMBOLS: &lt;lt_returned&gt; TYPE ANY TABLE, &lt;ls_lock_arg&gt; TYPE any.

      ASSIGN mr_lock_argument_temp-&gt;* TO &lt;ls_lock_arg&gt;.

      IF sy-subrc EQ 0.
        CREATE DATA me-&gt;mr_lock_argument LIKE &lt;ls_lock_arg&gt;.
      ENDIF.

      ASSIGN returned_table-&gt;* TO &lt;lt_returned&gt;.
      IF sy-subrc = 0. &quot;APC20160419

        CREATE DATA me-&gt;result_table LIKE &lt;lt_returned&gt;.
        ASSIGN result_table-&gt;* TO &lt;gt_result&gt;.

        &lt;gt_result&gt;[] = &lt;lt_returned&gt;[].

        CREATE DATA me-&gt;display_table LIKE &lt;gt_result&gt;.
        ASSIGN display_table-&gt;* TO &lt;gt_display&gt;.

        CREATE DATA me-&gt;temp_table LIKE &lt;gt_result&gt;.
        ASSIGN temp_table-&gt;* TO &lt;gt_temp&gt;.

        CREATE DATA me-&gt;temp_table LIKE &lt;gt_result&gt;.
        ASSIGN temp_table-&gt;* TO &lt;gt_temp&gt;.

        CREATE DATA me-&gt;undo_table LIKE &lt;gt_result&gt;.
        ASSIGN undo_table-&gt;* TO &lt;gt_undo&gt;.

        CREATE DATA me-&gt;tree_table LIKE &lt;gt_result&gt;.
        ASSIGN tree_table-&gt;* TO &lt;gt_tree&gt;.


        CREATE DATA me-&gt;result_structure LIKE LINE OF &lt;gt_result&gt;.
        ASSIGN me-&gt;result_structure-&gt;* TO &lt;gs_result&gt;.

        CREATE DATA me-&gt;temp_structure LIKE LINE OF &lt;gt_temp&gt;.
        ASSIGN me-&gt;temp_structure-&gt;* TO &lt;gs_temp&gt;.

        CREATE DATA me-&gt;undo_structure LIKE LINE OF &lt;gt_undo&gt;.
        ASSIGN me-&gt;undo_structure-&gt;* TO &lt;gs_undo&gt;.

        ls_celltab-style = cl_gui_alv_grid=&gt;mc_style_disabled.

        LOOP AT &lt;gt_result&gt; ASSIGNING &lt;gs_result&gt;.
          ASSIGN COMPONENT &apos;ZENITH_ROWID&apos; OF STRUCTURE &lt;gs_result&gt; TO &lt;gf_result&gt;.
          &lt;gf_result&gt; = sy-tabix.

          ASSIGN COMPONENT &apos;ZENITH_STYLE&apos; OF STRUCTURE &lt;gs_result&gt; TO &lt;lt_style&gt;.
          CLEAR &lt;lt_style&gt;.

          LOOP AT me-&gt;fcat INTO ls_fcat
               WHERE fieldname &lt;&gt; &apos;ZENITH_ROWID&apos;    AND
                     fieldname &lt;&gt; &apos;ZENITH_SELECTED&apos; AND
                     fieldname &lt;&gt; &apos;ZENITH_STYLE&apos;    AND
                     fieldname &lt;&gt; &apos;ZENITH_COLOR&apos;    AND
                     fieldname &lt;&gt; &apos;ZENITH_LOCKED_BY&apos;.
            ls_celltab-fieldname = ls_fcat-fieldname.
            INSERT ls_celltab INTO TABLE &lt;lt_style&gt;.
          ENDLOOP.

          MODIFY &lt;gt_result&gt; FROM &lt;gs_result&gt;.
          gv_max_rowid = sy-tabix.
        ENDLOOP.
      ENDIF.

      CALL METHOD calculate_mv_rowlen.

      mv_bytes = mv_rowlen * mv_dbcnt.
    ENDIF.

  ENDMETHOD.                    &quot; execute_parsed_sql

ENDCLASS.                    &quot;LCL_SELECT_COMMAND IMPLEMENTATION




*&amp;---------------------------------------------------------------------*
*&amp;  Include           ZHTDB_LCLCOMMANDS_I                              *
*&amp;---------------------------------------------------------------------*


CLASS lcl_commands IMPLEMENTATION.


  METHOD generate_structure.

    DATA: ls_fcat           TYPE lvc_s_fcat,
          ls_fieldinfo      TYPE lty_zhtdb_fieldinfo,
          l_select          TYPE REF TO lcl_select_command,
          lstr              TYPE string,
          length            TYPE i,
          ls_ref            TYPE gty_ddicref,
          ls_table_alias_tb LIKE LINE OF l_select-&gt;table_alias_tb.

    TRY.
        l_select ?= current_command.

        CLEAR l_select-&gt;fcat.
        CLEAR l_select-&gt;ddic_references.

*       build fieldcatalog

*      CALL METHOD l_select-&gt;mo_pipacs-&gt;get_fieldinfo
*        IMPORTING
*          et_fieldinfo = l_select-&gt;fieldinfo_tb.
*
        LOOP AT l_select-&gt;fieldinfo_tb INTO ls_fieldinfo.

          READ TABLE l_select-&gt;table_alias_tb INTO ls_table_alias_tb
            WITH KEY table = ls_fieldinfo-table.

          CLEAR ls_fcat.

          ls_fcat-col_opt = &apos;X&apos;.

          IF ls_fieldinfo-agg_function IS NOT INITIAL.

            IF ls_fieldinfo-agg_function EQ &apos;COUNT&apos;.
              ls_fcat-rollname = &apos;INT4&apos;.
            ELSEIF ls_fieldinfo-agg_function EQ &apos;AVG&apos;.
              ls_fcat-rollname = &apos;FLTP&apos;.
            ENDIF.

            ls_fcat-fieldname = ls_fieldinfo-generated_field.
            TRANSLATE ls_fcat-fieldname TO UPPER CASE.

            IF ls_fieldinfo-field_alias IS NOT INITIAL.

              length = strlen( ls_fieldinfo-field_alias ) - 1.

              IF ls_fieldinfo-field_alias(1) = &apos;&apos;&apos;&apos; AND ls_fieldinfo-field_alias+length = &apos;&apos;&apos;&apos;.
                length = length - 1.
                MOVE ls_fieldinfo-field_alias+1(length) TO ls_fieldinfo-field_alias.
                MODIFY l_select-&gt;fieldinfo_tb FROM ls_fieldinfo INDEX sy-tabix.
              ENDIF.

              lstr = ls_fieldinfo-field_alias.
            ELSE.
              lstr = ls_fieldinfo-generated_field.
            ENDIF.

            TRANSLATE ls_fieldinfo-agg_function TO UPPER CASE.

            TRANSLATE ls_fieldinfo-field TO UPPER CASE.
            TRANSLATE ls_fieldinfo-table TO UPPER CASE.

            ls_fcat-ref_table = ls_fieldinfo-table.
            ls_fcat-ref_field = ls_fieldinfo-field.

          ELSE.    &quot; agg_function is not initial

            ls_fcat-fieldname = ls_fieldinfo-generated_field.
            TRANSLATE ls_fcat-fieldname TO UPPER CASE.

            IF ls_fieldinfo-field_alias IS NOT INITIAL.

              length = strlen( ls_fieldinfo-field_alias ) - 1.

              IF ls_fieldinfo-field_alias(1) = &apos;&apos;&apos;&apos; AND ls_fieldinfo-field_alias+length = &apos;&apos;&apos;&apos;.
                length = length - 1.
                MOVE ls_fieldinfo-field_alias+1(length) TO ls_fieldinfo-field_alias.
                MODIFY l_select-&gt;fieldinfo_tb FROM ls_fieldinfo INDEX sy-tabix.
              ENDIF.

              lstr = ls_fieldinfo-field_alias.
            ELSE.
              lstr = ls_fieldinfo-generated_field.
            ENDIF.

            TRANSLATE ls_fieldinfo-field TO UPPER CASE.
            TRANSLATE ls_fieldinfo-table TO UPPER CASE.

            ls_fcat-ref_field = ls_fieldinfo-field.
            ls_fcat-ref_table = ls_fieldinfo-table.
*           ls_fcat-f4availabl = &apos;X&apos;.

          ENDIF.   &quot; agg_function is not initial

          CASE l_select-&gt;mv_colmn_header.
            WHEN &apos;S&apos;.
              CLEAR: ls_fcat-coltext, ls_fcat-scrtext_l, ls_fcat-scrtext_m, ls_fcat-scrtext_s, ls_fcat-reptext.
            WHEN &apos;G&apos;.
              ls_fcat-coltext = ls_fieldinfo-generated_field.
            WHEN &apos;A&apos;.
              IF ls_fieldinfo-field_alias IS NOT INITIAL.
                ls_fcat-coltext = ls_fieldinfo-field_alias.
              ELSE.
                ls_fcat-coltext = ls_fieldinfo-generated_field.
              ENDIF.
            WHEN &apos;T&apos;.
              ls_fcat-coltext = ls_fieldinfo-orig_field.
          ENDCASE.

          IF ls_fcat-ref_field IS NOT INITIAL AND
             ls_fcat-ref_table IS NOT INITIAL.

            CASE ls_table_alias_tb-type.

              WHEN &apos;T&apos;.

                SELECT SINGLE keyflag AS fix_column keyflag AS key datatype intlen inttype domname rollname
                  INTO CORRESPONDING FIELDS OF ls_fcat
                  FROM dd03l
                  WHERE tabname   = ls_fcat-ref_table AND
                        fieldname = ls_fcat-ref_field AND
                        as4local  = &apos;A&apos;.

              WHEN &apos;V&apos;.

                SELECT SINGLE rollname keyflag AS fix_column keyflag AS key
                  INTO CORRESPONDING FIELDS OF ls_fcat
                  FROM dd27s
                    WHERE viewname  = ls_fcat-ref_table AND
                          viewfield = ls_fcat-ref_field AND
                          as4local  = &apos;A&apos;.
*                          fieldname NOT LIKE &apos;.%&apos; AND
*                          fieldname NOT LIKE &apos;*%&apos; AND
*                          fieldname NOT LIKE &apos;$_%&apos; ESCAPE &apos;$&apos; AND
*                          fieldname NOT LIKE &apos;$%%&apos; ESCAPE &apos;$&apos;

              WHEN &apos;C&apos; OR &apos;P&apos;.

*                SELECT SINGLE keyflag AS fix_column keyflag AS key datatype intlen inttype
*                INTO CORRESPONDING FIELDS OF ls_fcat
*                FROM dd16v
*                  WHERE sqltab    = ls_fcat-ref_table AND
*                        fieldname = ls_fcat-ref_field.

                SELECT SINGLE keyflag AS fix_column keyflag AS key datatype intlen inttype domname rollname
                  INTO CORRESPONDING FIELDS OF ls_fcat
                  FROM dd03l
                  WHERE tabname   = ls_fcat-ref_table AND
                        fieldname = ls_fcat-ref_field AND
                        as4local  = &apos;A&apos;.

*                        in view already
*                        AS4LOCAL = &apos;A&apos; AND
*                        fieldname NOT LIKE &apos;.%&apos; AND
*                        fieldname NOT LIKE &apos;*%&apos; AND
*                        fieldname NOT LIKE &apos;$_%&apos; ESCAPE &apos;$&apos; AND
*                        fieldname NOT LIKE &apos;$%%&apos; ESCAPE &apos;$&apos;

            ENDCASE.

            IF sy-subrc NE 0.
              MESSAGE s038 DISPLAY LIKE &apos;E&apos; WITH ls_fcat-ref_field ls_fcat-ref_table ls_table_alias_tb-type RAISING field_not_found.
            ENDIF.

            CONCATENATE TEXT-143 ls_fcat-domname TEXT-144 ls_fcat-intlen INTO lstr
              SEPARATED BY space.

            ls_fcat-tooltip = lstr.

            CLEAR ls_fcat-fix_column.

            ls_ref-fieldname  = ls_fcat-fieldname.
            ls_ref-checktable = ls_fcat-checktable.
            ls_ref-ref_table  = ls_fcat-ref_table.
            ls_ref-ref_field  = ls_fcat-ref_field.
            ls_ref-key        = ls_fcat-key.

            APPEND ls_ref TO l_select-&gt;ddic_references.

            DATA: ls_dfies TYPE dfies,
                  lt_dfies TYPE TABLE OF dfies.

            CALL FUNCTION &apos;DDIF_FIELDINFO_GET&apos;
              EXPORTING
                tabname        = ls_fcat-ref_table
                fieldname      = ls_fcat-ref_field
                langu          = sy-langu
              TABLES
                dfies_tab      = lt_dfies
              EXCEPTIONS
                not_found      = 1
                internal_error = 2
                OTHERS         = 3.

            IF sy-subrc &lt;&gt; 0.
              MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ELSE.
              READ TABLE lt_dfies INTO ls_dfies INDEX 1.

              IF sy-subrc EQ 0.
                MOVE ls_dfies-convexit TO ls_fcat-convexit.
                MOVE ls_dfies-scrtext_m TO ls_fcat-coltext.
                MOVE ls_dfies-scrtext_l TO  ls_fcat-scrtext_l.
                MOVE ls_dfies-scrtext_m TO  ls_fcat-scrtext_m.
                MOVE ls_dfies-scrtext_s TO  ls_fcat-scrtext_s.
                MOVE ls_dfies-reptext TO ls_fcat-reptext.
              ENDIF.

            ENDIF.

          ENDIF.

*        ls_fcat-no_convext = &apos;X&apos;.

          IF ls_fcat-key EQ &apos;X&apos;.
            ls_fcat-key_sel = &apos;X&apos;.
            ls_fcat-edit = &apos; &apos;.
          ENDIF.

          APPEND ls_fcat TO l_select-&gt;fcat.

        ENDLOOP.

        IF sy-subrc EQ 4.
          RAISE empty_fieldinfo_tb.
        ENDIF.

      CATCH cx_sy_move_cast_error.
        RAISE command_is_not_select.
    ENDTRY.

  ENDMETHOD.                    &quot; generate_structure



  METHOD display.

    DATA: l_select       TYPE REF TO lcl_select_command,
          lv_show_grid   TYPE c,
          lo_result_tree TYPE REF TO cl_gui_alv_tree,
          lo_alv         TYPE REF TO cl_gui_alv_grid.


    TRY.
        l_select ?= current_command.

      CATCH cx_sy_move_cast_error.
        RETURN.
    ENDTRY.

    IF po_grid IS INITIAL AND
       po_tree IS INITIAL.
      IF l_select-&gt;mv_last_display = &apos;T&apos;.
        lv_show_grid = &apos; &apos;.
      ELSE.
        lv_show_grid = &apos;X&apos;.
      ENDIF.
    ELSE.
      IF po_grid IS INITIAL.
        lv_show_grid = &apos; &apos;.
      ELSE.
        lv_show_grid = &apos;X&apos;.
      ENDIF.
    ENDIF.

    IF po_grid IS SUPPLIED.
      lo_alv = po_grid.
    ELSE.
      lo_alv = g_alv.
    ENDIF.

    IF &lt;gt_result&gt; IS ASSIGNED.

      CALL METHOD g_application-&gt;set_column_headings.
      CALL METHOD g_application-&gt;set_key_display_attributes.

      CALL METHOD lo_alv-&gt;set_table_for_first_display
        EXPORTING
          is_layout            = gs_layo
          it_toolbar_excluding = gt_toolbar_exclude
        CHANGING
          it_outtab            = &lt;gt_result&gt;
          it_fieldcatalog      = l_select-&gt;fcat
        EXCEPTIONS
          OTHERS               = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      ENDIF.
    ENDIF.

    IF lo_result_tree IS NOT INITIAL.
      CALL METHOD lo_result_tree-&gt;set_visible
        EXPORTING
          visible = &apos; &apos;
        EXCEPTIONS
          OTHERS  = 1.

      IF sy-subrc NE 0.
        IF sy-msgno IS NOT INITIAL.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      ENDIF.
    ENDIF.

    CALL METHOD lo_alv-&gt;set_ready_for_input
      EXPORTING
        i_ready_for_input = l_select-&gt;alv_state
      EXCEPTIONS
        OTHERS            = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

    CALL METHOD lo_alv-&gt;set_selected_rows
      EXPORTING
        it_index_rows = l_select-&gt;selected_rows
        it_row_no     = l_select-&gt;selected_rows2
      EXCEPTIONS
        OTHERS        = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;LCL_COMMANDS


  METHOD display_command.

    DATA: l_command_type     TYPE lty_commandtype,
          l_select_command   TYPE REF TO lcl_select_command,
          lv_tree_tb_width   TYPE i,
          lv_result_height   TYPE i,
          lv_tree_tb_visible TYPE c,
          lv_done            TYPE c.


    CHECK current_command IS NOT INITIAL.

    CALL METHOD current_command-&gt;get_type
      IMPORTING
        ep_command_type = l_command_type.


    IF l_command_type EQ gc_ctype_lawb.

      lv_tree_tb_width = 0.
      lv_result_height = g_application-&gt;mv_result_height.

      lv_tree_tb_visible = &apos; &apos;.

    ELSEIF l_command_type EQ gc_ctype_select OR l_command_type EQ gc_ctype_selfae.

      lv_tree_tb_width = g_application-&gt;mv_tree_tb_width.
      lv_result_height = g_application-&gt;mv_result_height.

      lv_tree_tb_visible = &apos;X&apos;.

    ENDIF.

    CALL METHOD go_splitter_inner-&gt;set_column_width
      EXPORTING
        id     = 2
        width  = lv_tree_tb_width
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD go_splitter_outer-&gt;set_row_height
      EXPORTING
        id     = 2
        height = lv_result_height
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

    CALL METHOD g_tree_tb-&gt;set_visible
      EXPORTING
        visible = lv_tree_tb_visible.

*abaped    CALL METHOD g_textedit-&gt;set_text_as_r3table
    CALL METHOD g_textedit-&gt;set_text
      EXPORTING
        table  = current_command-&gt;text[]
      EXCEPTIONS
        OTHERS = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.


    IF lv_done IS INITIAL.
      TRY.
          l_select_command ?= current_command.

          CALL METHOD l_select_command-&gt;assign_field_symbols.

          IF l_select_command-&gt;fcat[] IS NOT INITIAL AND &lt;gt_result&gt; IS ASSIGNED.

            CALL METHOD g_alv-&gt;set_visible
              EXPORTING
                visible = &apos;X&apos;
              EXCEPTIONS
                OTHERS  = 1.

            IF sy-subrc NE 0.
              IF sy-msgno IS NOT INITIAL.
                MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                        WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
              ENDIF.
            ENDIF.

            IF &lt;gt_result&gt; IS ASSIGNED.
              CALL METHOD me-&gt;display.
            ENDIF.

          ELSE.

            IF command_count NE 1.

              CALL METHOD g_alv-&gt;set_visible
                EXPORTING
                  visible = &apos; &apos;
                EXCEPTIONS
                  OTHERS  = 1.

              IF sy-subrc NE 0.
                IF sy-msgno IS NOT INITIAL.
                  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
                ENDIF.
              ENDIF.

            ENDIF.

          ENDIF.

        CATCH cx_sy_move_cast_error.
*        CALL METHOD l_select_command-&gt;display.
      ENDTRY.

    ENDIF.

    IF l_command_type NE gc_ctype_lawb AND l_command_type NE gc_ctype_script.
      CALL METHOD g_application-&gt;display_table_grid.
    ENDIF.

    CALL METHOD cl_gui_cfw=&gt;set_new_ok_code
      EXPORTING
        new_code = &apos;KAMU&apos;
      EXCEPTIONS
        OTHERS   = 1.

    IF sy-subrc NE 0.
      IF sy-msgno IS NOT INITIAL.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno DISPLAY LIKE &apos;I&apos;
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;LCL_COMMANDS


  METHOD create_new_command.

    DATA: l_select              TYPE REF TO lcl_select_command,
          ls_text               LIKE LINE OF l_select-&gt;text,
          ls_commands           TYPE gty_commands,

          l_copy_sc             TYPE REF TO lcl_select_command,
          l_command_id          TYPE lty_commandid,

          lv_command_id_str(10) TYPE n.

    IF sy-subrc NE 0.
      g_selected_nodekey = gc_nodekey_current_commands.
    ENDIF.

    CASE p_command_type.

      WHEN gc_ctype_select.

        TRY.

            l_copy_sc ?= p_copy_from.

            CREATE OBJECT l_select
              EXPORTING
                p_copy_from = l_copy_sc.

          CATCH cx_sy_move_cast_error.
            CREATE OBJECT l_select.
        ENDTRY.

        l_select-&gt;command_type = p_command_type.
        ls_commands-command = l_select.

        CLEAR g_selected_nodekey.


        IF sql IS INITIAL.
          READ TABLE i_sql INTO l_sql INDEX 1.
          IF sy-subrc = 0.
            zcl_ap_string=&gt;string2tabla( EXPORTING string = l_sql-string
                                         CHANGING  tabla  = l_select-&gt;text ).
          ELSE.
            ls_text =  &apos;SELECT *&apos;.
            APPEND ls_text TO l_select-&gt;text.
            ls_text =  &apos;FROM &apos;.
            APPEND ls_text TO l_select-&gt;text.
            ls_text =  &apos;UP TO 200 ROWS&apos;.
            APPEND ls_text TO l_select-&gt;text.
          ENDIF.
        ELSEIF sql = &apos;*&apos;.
          l_select-&gt;text = i_lineas_sql.
        ELSE.
          ls_text =  sql.
          APPEND ls_text TO l_select-&gt;text.
        ENDIF.


        l_select-&gt;mv_colmn_header   = gv_def_col_hdr.
        l_select-&gt;mv_key_colmn_type = gv_def_keycol_type.

        l_select-&gt;mv_last_display = &apos;G&apos;.
        current_command = l_select.

        l_select-&gt;mv_command_type = l_select-&gt;command_type.


    ENDCASE.

    CALL METHOD g_textedit-&gt;set_readonly_mode
      EXPORTING
        readonly_mode = &apos;0&apos;.

    current_command-&gt;command_id = l_command_id.
    ls_commands-command_id = l_command_id.

    command_count = command_count + 1.
    ls_commands-seq_no = command_count.
    ls_commands-treelevel = current_command-&gt;treelevel.
    APPEND ls_commands TO command_list.

    IF command_count EQ 1.

      CLEAR prev_command.
    ENDIF.

    CALL METHOD g_commands-&gt;display_command.
**    CALL METHOD g_application-&gt;refresh_status_indicators.

    CALL METHOD g_application-&gt;create_tb_tree_toolbar.

    lv_command_id_str = current_command-&gt;command_id.

  ENDMETHOD.                    &quot;LCL_COMMANDS


  METHOD execute_command.

    DATA: l_select_command  TYPE REF TO lcl_select_command,
          l_c_type          TYPE lty_commandtype,

          lo_tree           TYPE REF TO cl_gui_alv_tree,
          lx_root           TYPE REF TO cx_root,

          lv_message        TYPE string,
          lv_read_auth      TYPE c,
          ls_table_alias_tb LIKE LINE OF current_command-&gt;table_alias_tb.


    GET RUN TIME FIELD gv_starttime.

    IF sy-tcode = &apos;ZSQL_TEST&apos;.
      IF current_command-&gt;command_type NE gc_ctype_select.
        RETURN.
      ENDIF.
    ENDIF.

    CALL METHOD transfer_text_to_command.

    TRY.
        l_select_command ?= current_command.

*          message &apos;ZENITH:Casting error3&apos; TYPE &apos;E&apos;.

        DATA: lv_log_handle LIKE g_application-&gt;mv_log_handle.

        IF gv_autotest = &apos;X&apos;.
          lv_log_handle = g_application-&gt;mv_log_handle.
        ENDIF.

*CALL METHOD l_select_command-&gt;assign_field_symbols.
        CLEAR: v_es_report, v_comando.
        DATA: l_aux1      TYPE string, l_aux2 TYPE string,
              l_report(6).
        l_aux1 = current_command-&gt;commandtext.
        CONDENSE l_aux1 NO-GAPS.
        l_report = l_aux1.
        TRANSLATE l_report TO UPPER CASE.
        IF l_report = &apos;REPORT&apos;.
          v_es_report = v_comando = &apos;X&apos;.
          SPLIT l_aux1+6 AT &apos;.&apos; INTO l_aux1 l_aux2.
          CONDENSE l_aux1 NO-GAPS.
          v_nombre_report = l_aux1.
        ELSE.
          SPLIT current_command-&gt;commandtext AT &apos;FROM&apos; INTO l_aux1 l_aux2.
          CONDENSE l_aux2.
          SPLIT l_aux2 AT ` ` INTO l_aux1 l_aux2.
        ENDIF.

        IF zcl_c=&gt;existe( constante = &apos;USUARIO_AP&apos; valor = sy-uname ) = &apos;&apos;.
          CLEAR v_es_report.
        ENDIF.

        READ TABLE i_sql INTO l_sql WITH KEY string = current_command-&gt;commandtext.
        IF sy-subrc = 0.
          DELETE i_sql INDEX sy-tabix.
          DELETE FROM ztemps
           WHERE clave = l_sql-clave
             AND subclave = l_sql-subclave
             AND indice = l_sql-indice.
        ENDIF.

*current_command-&gt;text
        ztemps-string = zcl_ap_string=&gt;tabla2string( current_command-&gt;text ).

        SELECT indice string FROM ztemps
          INTO CORRESPONDING FIELDS OF *ztemps
         WHERE clave = l_sql-clave
           AND subclave = l_aux1.
          IF *ztemps-string = ztemps-string.
            DELETE FROM ztemps
             WHERE clave = l_sql-clave
               AND subclave = l_aux1
               AND indice = *ztemps-indice.
            DELETE i_sql WHERE clave = l_sql-clave
               AND subclave = l_aux1
               AND indice = *ztemps-indice.
          ENDIF.
        ENDSELECT.

        zcl_ap_temp=&gt;set_string_st( clave = &apos;ZSQL_APC&apos; subclave = l_aux1 string = ztemps-string permanente = &apos;X&apos; indice_auto = &apos;X&apos; ).

        CLEAR i_lineas.
*        l_linea = current_command-&gt;commandtext.
*        APPEND l_linea TO i_lineas.
*      zcl_ap_string=&gt;string2tabla( EXPORTING string = current_command-&gt;commandtext
*                                   CHANGING tabla = i_lineas ).
        i_lineas = current_command-&gt;text.

        l_sql-subclave = l_aux1.
        l_sql-string = current_command-&gt;commandtext.
        INSERT l_sql INTO i_sql INDEX 1.
        o_alv-&gt;refrescar_grid( ).


        CALL METHOD l_select_command-&gt;mo_pipacs_select-&gt;create_new
          EXPORTING
            iv_command_id = current_command-&gt;command_id
            iv_command    = current_command-&gt;commandtext
            it_vranges    = current_command-&gt;it_ranges
            iv_log_handle = lv_log_handle
          EXCEPTIONS
            no_id         = 1
            OTHERS        = 2.

        CASE sy-subrc.

          WHEN 1.
            CALL METHOD g_application-&gt;issue_message
              EXPORTING
                iv_msgty        = &apos;S&apos;
                iv_msgno        = &apos;077&apos;
                iv_display_like = &apos;E&apos;.
*                message s077 DISPLAY LIKE &apos;E&apos;.
            RETURN.
          WHEN 2.
            CALL METHOD g_application-&gt;issue_message
              EXPORTING
                iv_msgty        = &apos;S&apos;
                iv_msgno        = &apos;076&apos;
                iv_display_like = &apos;E&apos;.
*                message s076 DISPLAY LIKE &apos;E&apos;.
            RETURN.

        ENDCASE.

        l_select_command-&gt;mo_pipacs_command = l_select_command-&gt;mo_pipacs_select.


      CATCH cx_sy_move_cast_error.
*        message &apos;ZENITH:Casting error3&apos; TYPE &apos;E&apos;.
    ENDTRY.

    CALL METHOD current_command-&gt;parse_commandtext
      EXCEPTIONS
        error_occurred = 1
        OTHERS         = 2.

    CASE sy-subrc.

      WHEN 1.
*        message s079 DISPLAY LIKE &apos;E&apos;.
        RETURN.
      WHEN 2.
*        message s079 DISPLAY LIKE &apos;E&apos;.
        CALL METHOD g_application-&gt;issue_message
          EXPORTING
            iv_msgty        = &apos;S&apos;
            iv_msgno        = &apos;079&apos;
            iv_display_like = &apos;E&apos;.
        RETURN.

    ENDCASE.

    IF v_comando IS INITIAL. &quot;APC20160419
      TRY.
          l_select_command ?= current_command.

          CALL METHOD l_select_command-&gt;assign_field_symbols.

          CALL METHOD me-&gt;generate_structure
            EXCEPTIONS
              empty_fieldinfo_tb    = 1
              command_is_not_select = 2
              OTHERS                = 3.

          CASE sy-subrc.
            WHEN 1.
              CALL METHOD g_application-&gt;issue_message
                EXPORTING
                  iv_msgty        = &apos;S&apos;
                  iv_msgno        = &apos;078&apos;
                  iv_display_like = &apos;E&apos;.
*            message s078 DISPLAY LIKE &apos;E&apos;.
              RETURN.

            WHEN 2.
              CALL METHOD g_application-&gt;issue_message
                EXPORTING
                  iv_msgty        = &apos;S&apos;
                  iv_msgno        = &apos;080&apos;
                  iv_display_like = &apos;E&apos;.
*            message s080 DISPLAY LIKE &apos;E&apos;.
              RETURN.

            WHEN 3.
              CALL METHOD g_application-&gt;issue_message
                EXPORTING
                  iv_msgty        = &apos;S&apos;
                  iv_msgno        = &apos;081&apos;
                  iv_display_like = &apos;E&apos;.
*            message s081 DISPLAY LIKE &apos;E&apos;.
              RETURN.
          ENDCASE.

          CLEAR:

            l_select_command-&gt;mv_dbcnt,
            l_select_command-&gt;mv_bytes,
            l_select_command-&gt;mv_filtered,
            l_select_command-&gt;mv_pos,
            l_select_command-&gt;alv_state.

        CATCH cx_sy_move_cast_error.
      ENDTRY.
    ENDIF.

    LOOP AT current_command-&gt;table_alias_tb INTO ls_table_alias_tb.

      CALL METHOD g_application-&gt;check_s_tabu_dis
        EXPORTING
          iv_for_editing = &apos; &apos;
          iv_tabname     = ls_table_alias_tb-table
        IMPORTING
          ev_auth        = lv_read_auth.

      IF lv_read_auth IS INITIAL.
        MESSAGE s125 DISPLAY LIKE &apos;E&apos; WITH ls_table_alias_tb-table.
        RETURN.
      ENDIF.

    ENDLOOP.

    DATA: lv_simulation TYPE c.

    IF iv_mode = &apos;SIMULATE&apos;.
      lv_simulation = &apos;X&apos;.
    ELSE.
      CLEAR lv_simulation.
    ENDIF.



    CALL METHOD current_command-&gt;execute_parsed_sql
      EXPORTING
        po_grid                  = g_alv
        po_tree                  = lo_tree
        iv_simulation            = lv_simulation
        iv_bg_proc               = iv_bg_proc
        iv_bg_date               = iv_bg_date
        iv_bg_time               = iv_bg_time
        iv_read_from_file        = iv_read_from_file
      IMPORTING
        er_exception             = lx_root
        et_srccode               = current_command-&gt;mt_srccode
      EXCEPTIONS
        table_not_found          = 1
        parse_error              = 2
        exec_error               = 3
        error_occurred           = 4
        unlock_error             = 5
        arg_to_long              = 6
        foreign_lock             = 7
        foreign_lock_all_clients = 8
        job_submit_error         = 9
        field_list_changed       = 10
        file_open_error          = 11
        no_auth_for_table        = 12
        OTHERS                   = 13.

    CASE sy-subrc.
      WHEN 0.

      WHEN 1.
        CALL METHOD g_application-&gt;issue_message
          EXPORTING
            iv_msgty        = &apos;S&apos;
            iv_msgno        = &apos;082&apos;
            iv_display_like = &apos;E&apos;.
*          message s082 DISPLAY LIKE &apos;E&apos;.
        RETURN.

      WHEN 2.
        CALL METHOD g_application-&gt;issue_message
          EXPORTING
            iv_msgty        = &apos;S&apos;
            iv_msgno        = &apos;079&apos;
            iv_display_like = &apos;E&apos;.
*          message s079 DISPLAY LIKE &apos;E&apos;.
        RETURN.

      WHEN 3.
        IF lx_root IS INITIAL.
          CALL METHOD g_application-&gt;issue_message
            EXPORTING
              iv_msgty        = &apos;S&apos;
              iv_msgno        = &apos;083&apos;
              iv_display_like = &apos;E&apos;.
        ELSE.
          CALL METHOD lx_root-&gt;if_message~get_longtext
            RECEIVING
              result = lv_message.
          MESSAGE lv_message TYPE &apos;S&apos; DISPLAY LIKE &apos;E&apos;.
        ENDIF.

        RETURN.

      WHEN 4.
        CALL METHOD g_application-&gt;issue_message
          EXPORTING
            iv_msgty        = &apos;S&apos;
            iv_msgno        = &apos;083&apos;
            iv_display_like = &apos;E&apos;.
*          message s083 DISPLAY LIKE &apos;E&apos;.
        RETURN.

      WHEN 5.
        MESSAGE i073 DISPLAY LIKE &apos;W&apos; WITH sy-msgv1.
        RETURN.

      WHEN 6.
        MESSAGE i069 DISPLAY LIKE &apos;E&apos;.
        RETURN.

      WHEN 7.
        MESSAGE i071 DISPLAY LIKE &apos;E&apos; WITH sy-msgv1 sy-msgv2 sy-msgv3.
        RETURN.

      WHEN 8.
        MESSAGE i070 DISPLAY LIKE &apos;E&apos; WITH sy-msgv1 sy-msgv2.
        RETURN.

      WHEN 9.
        MESSAGE i134 DISPLAY LIKE &apos;E&apos;. &quot; WITH sy-msgv1 sy-msgv2.
        RETURN.

      WHEN 10.
        MESSAGE i144 DISPLAY LIKE &apos;E&apos;.
        RETURN.

      WHEN 11.
        MESSAGE i145 DISPLAY LIKE &apos;E&apos;.
        RETURN.

      WHEN 12.
        MESSAGE s125 DISPLAY LIKE &apos;E&apos; WITH sy-msgv1.
        RETURN.

      WHEN 13.
        CALL METHOD g_application-&gt;issue_message
          EXPORTING
            iv_msgty        = &apos;S&apos;
            iv_msgno        = &apos;084&apos;
            iv_display_like = &apos;W&apos;.
*          message s084 DISPLAY LIKE &apos;W&apos;.
    ENDCASE.

    TRY.
        l_select_command ?= current_command.

        IF lv_simulation IS INITIAL AND
           iv_bg_proc    IS INITIAL.
          CALL METHOD me-&gt;display.
        ENDIF.

        l_select_command-&gt;mv_read_from_file = iv_read_from_file.

        IF iv_read_from_file EQ &apos;X&apos;.
          CALL METHOD g_alv-&gt;set_toolbar_interactive.
        ENDIF.

        current_command-&gt;mv_grid_modified = &apos; &apos;.

        IF lv_simulation IS INITIAL.
          CALL METHOD g_application-&gt;refresh_status_indicators.
        ENDIF.

        IF lv_simulation = &apos;X&apos;.
          CLEAR l_select_command-&gt;fcat.
        ELSE.
          l_select_command-&gt;prev_fcat = l_select_command-&gt;fcat.
        ENDIF.

      CATCH cx_sy_move_cast_error.
*      message &apos;ZENITH:Casting error4&apos; TYPE &apos;E&apos;.
    ENDTRY.

    CALL METHOD current_command-&gt;get_type
      IMPORTING
        ep_command_type = l_c_type.

    IF l_c_type NE gc_ctype_lawb.
      CALL METHOD g_application-&gt;display_table_grid.
    ENDIF.

    IF iv_bg_proc IS INITIAL.
      IF lv_simulation = &apos;X&apos;.
        MESSAGE s120.
      ELSE.
        CALL METHOD me-&gt;write_status_message.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    &quot;LCL_COMMANDS


  METHOD write_status_message.

    DATA: lstr2            TYPE string,
          lv_float         TYPE f,
          lv_p             TYPE p DECIMALS 3,
          l_select_command TYPE REF TO lcl_select_command.


    GET RUN TIME FIELD gv_endtime.
    gv_deltatime = ( gv_endtime - gv_starttime ) DIV 1000.

    lv_float = gv_deltatime / 1000.

    lv_p = lv_float.
    MOVE lv_p TO lstr2.

    TRY.
        l_select_command ?= current_command.

        CALL METHOD g_application-&gt;issue_message
          EXPORTING
            iv_msgty = &apos;S&apos;
            iv_msgno = &apos;047&apos;
            iv_msgv1 = l_select_command-&gt;mv_dbcnt
            iv_msgv2 = lstr2
            iv_msgv3 = l_select_command-&gt;mv_bytes.

      CATCH cx_sy_move_cast_error.
    ENDTRY.

  ENDMETHOD.                    &quot; write_status_message


  METHOD transfer_text_to_command.

    DATA: l_text  TYPE source_table,
          ls_text LIKE LINE OF l_text,
          l_str   TYPE string.

    IF sy-tcode = &apos;ZSQL_TEST&apos;.
      l_text[] = current_command-&gt;text[].
    ELSE.
      CALL METHOD g_textedit-&gt;get_text
        IMPORTING
          table  = l_text[]
        EXCEPTIONS
          OTHERS = 1.

      IF sy-subrc = 1.
*        MESSAGE i025.
      ENDIF.
    ENDIF.

    IF current_command-&gt;text[] NE l_text[].
      IF current_command-&gt;mv_ctext_changed IS INITIAL.
        current_command-&gt;mv_ctext_changed = &apos;X&apos;.
      ENDIF.
    ENDIF.

    current_command-&gt;text[] = l_text[].

    IF l_text IS NOT INITIAL.
      CALL METHOD lcl_toolbox=&gt;pretty_printer
        CHANGING
          ct_source = l_text.

      LOOP AT l_text INTO ls_text.
        IF ls_text(1) NE &apos;*&apos;.
          CONCATENATE l_str ls_text INTO l_str SEPARATED BY &apos; &apos;.
        ENDIF.
      ENDLOOP.

      CALL METHOD current_command-&gt;set_commandtext
        EXPORTING
          p_commandtext = l_str.
    ENDIF.

  ENDMETHOD.                    &quot;transfer_text_to_command

  METHOD parse_only_command.

    DATA: l_select_command TYPE REF TO lcl_select_command.

    IF p_on_load EQ &apos; &apos;.
      CALL METHOD transfer_text_to_command.
    ENDIF.
    TRY.
        l_select_command ?= current_command.

        DATA: lv_log_handle LIKE g_application-&gt;mv_log_handle.

        IF gv_autotest = &apos;X&apos;.
          lv_log_handle = g_application-&gt;mv_log_handle.
        ENDIF.

        CALL METHOD l_select_command-&gt;mo_pipacs_select-&gt;create_new
          EXPORTING
            iv_command_id = current_command-&gt;command_id
            iv_command    = current_command-&gt;commandtext
            it_vranges    = current_command-&gt;it_ranges
            iv_log_handle = lv_log_handle
          EXCEPTIONS
            no_id         = 1
            OTHERS        = 2.

        CASE sy-subrc.
          WHEN 1.
            RAISE no_id.
          WHEN 2.
            RAISE create_error.
        ENDCASE.

        l_select_command-&gt;mo_pipacs_command = l_select_command-&gt;mo_pipacs_select.


      CATCH cx_sy_move_cast_error.

    ENDTRY.

    IF p_on_load EQ &apos; &apos;.
****      CALL METHOD g_application-&gt;refresh_curr_tree_node_caption.
    ENDIF.

    CALL METHOD current_command-&gt;parse_commandtext
      EXPORTING
        p_on_load      = p_on_load
      EXCEPTIONS
        error_occurred = 1
        OTHERS         = 2.

    CASE sy-subrc.
      WHEN 1.
        RAISE parse_error.
      WHEN 2.
        RAISE parse_error.
    ENDCASE.

    IF p_on_load EQ &apos; &apos;.
      CALL METHOD g_application-&gt;display_table_grid.
    ENDIF.

  ENDMETHOD.                    &quot; parse_only_command

ENDCLASS.                    &quot;LCL_COMMANDS IMPLEMENTATION

*&amp;---------------------------------------------------------------------*
*&amp;      Form  mem_export
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM mem_export .

  DATA: BEGIN OF mode,                 &quot; Schnittstelle fr SE13
          show(1),
          edit(1),
        END OF mode.

  mode-show = &apos;X&apos;.
  mode-edit = &apos; &apos;.
  EXPORT mode TO MEMORY ID &apos;MOD&apos;.


ENDFORM.                    &quot; mem_export</source>
</PROG>

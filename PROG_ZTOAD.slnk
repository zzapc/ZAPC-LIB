<?xml version="1.0" encoding="utf-8"?>
<PROG NAME="ZTOAD" VARCL="X" SUBC="1" RSTAT="T" RMAND="130" RLOAD="F" FIXPT="X" UCCHECK="X">
 <textPool>
  <language SPRAS="E">
   <textElement ID="I" KEY="M01" ENTRY="Delete" LENGTH="40 "/>
   <textElement ID="I" KEY="M02" ENTRY="Query deleted" LENGTH="50 "/>
   <textElement ID="I" KEY="M03" ENTRY="Error when deleting the query" LENGTH="50 "/>
   <textElement ID="I" KEY="M04" ENTRY="String found" LENGTH="50 "/>
   <textElement ID="I" KEY="M05" ENTRY="Close Grid" LENGTH="30 "/>
   <textElement ID="I" KEY="M06" ENTRY="Close" LENGTH="40 "/>
   <textElement ID="I" KEY="M07" ENTRY="Cannot parse the query" LENGTH="50 "/>
   <textElement ID="I" KEY="M08" ENTRY="Cannot parse the unioned query" LENGTH="50 "/>
   <textElement ID="I" KEY="M09" ENTRY="Query executed in" LENGTH="50 "/>
   <textElement ID="I" KEY="M10" ENTRY="seconds." LENGTH="20 "/>
   <textElement ID="I" KEY="M11" ENTRY="entries found" LENGTH="50 "/>
   <textElement ID="I" KEY="M12" ENTRY="entries affected" LENGTH="50 "/>
   <textElement ID="I" KEY="M13" ENTRY="No authorisation for table" LENGTH="50 "/>
   <textElement ID="I" KEY="M14" ENTRY="Action cancelled" LENGTH="50 "/>
   <textElement ID="I" KEY="M15" ENTRY="No valid table found" LENGTH="50 "/>
   <textElement ID="I" KEY="M16" ENTRY="My queries" LENGTH="100 "/>
   <textElement ID="I" KEY="M17" ENTRY="Shared queries" LENGTH="100 "/>
   <textElement ID="I" KEY="M18" ENTRY="History" LENGTH="100 "/>
   <textElement ID="I" KEY="M19" ENTRY="Personal" LENGTH="80 "/>
   <textElement ID="I" KEY="M20" ENTRY="User group" LENGTH="80 "/>
   <textElement ID="I" KEY="M21" ENTRY="All" LENGTH="80 "/>
   <textElement ID="I" KEY="M22" ENTRY="Current query is not saved. Do you want" LENGTH="50 "/>
   <textElement ID="I" KEY="M23" ENTRY="Exit" LENGTH="12 "/>
   <textElement ID="I" KEY="M24" ENTRY="Save &amp; exit" LENGTH="12 "/>
   <textElement ID="I" KEY="M25" ENTRY="SQL command not allowed :" LENGTH="50 "/>
   <textElement ID="I" KEY="M26" ENTRY="Error in INSERT syntax : VALUES / SET required" LENGTH="50 "/>
   <textElement ID="I" KEY="M27" ENTRY="pasted to SQL Editor" LENGTH="50 "/>
   <textElement ID="I" KEY="M28" ENTRY="(line" LENGTH="20 "/>
   <textElement ID="I" KEY="M29" ENTRY=",word" LENGTH="20 "/>
   <textElement ID="I" KEY="M30" ENTRY=")" LENGTH="20 "/>
   <textElement ID="I" KEY="M31" ENTRY="Are you sure you want to do a" LENGTH="50 "/>
   <textElement ID="I" KEY="M32" ENTRY="on table" LENGTH="50 "/>
   <textElement ID="I" KEY="M33" ENTRY="?" LENGTH="50 "/>
   <textElement ID="I" KEY="M34" ENTRY="Only fields can be drag&amp;drop to editor" LENGTH="50 "/>
   <textElement ID="I" KEY="M35" ENTRY="Cannot get cursor position" LENGTH="50 "/>
   <textElement ID="I" KEY="M36" ENTRY="Delete All" LENGTH="40 "/>
   <textElement ID="I" KEY="M37" ENTRY="All history entries deleted" LENGTH="50 "/>
   <textElement ID="I" KEY="M40" ENTRY="Refresh" LENGTH="40 "/>
   <textElement ID="I" KEY="M41" ENTRY="Refresh DDIC tree" LENGTH="30 "/>
   <textElement ID="I" KEY="M42" ENTRY="Find" LENGTH="40 "/>
   <textElement ID="I" KEY="M43" ENTRY="Search in DDIC tree" LENGTH="30 "/>
   <textElement ID="I" KEY="M44" ENTRY="Property" LENGTH="20 "/>
   <textElement ID="I" KEY="M45" ENTRY="Value" LENGTH="20 "/>
   <textElement ID="I" KEY="M46" ENTRY="Add break line after pasting ddic field into sql editor" LENGTH="100 "/>
   <textElement ID="I" KEY="M47" ENTRY="Line Break" LENGTH="20 "/>
   <textElement ID="I" KEY="M48" ENTRY="Default max number of displayed lines for SELECT" LENGTH="100 "/>
   <textElement ID="I" KEY="M49" ENTRY="Max Rows" LENGTH="20 "/>
   <textElement ID="I" KEY="M50" ENTRY="No more run available. Please restart program" LENGTH="50 "/>
   <textElement ID="I" KEY="M51" ENTRY="CSV File (*.csv)|*.csv" LENGTH="30 "/>
   <textElement ID="I" KEY="M52" ENTRY="Display technical name in query result display" LENGTH="100 "/>
   <textElement ID="I" KEY="M53" ENTRY="Technical name" LENGTH="20 "/>
   <textElement ID="I" KEY="M54" ENTRY="Display values of sel. field" LENGTH="30 "/>
   <textElement ID="I" KEY="M55" ENTRY="Value list" LENGTH="40 "/>
   <textElement ID="I" KEY="M56" ENTRY="to exit without saving or save into history then exit ?" LENGTH="100 "/>
   <textElement ID="I" KEY="M57" ENTRY="Choose file to create" LENGTH="50 "/>
   <textElement ID="I" KEY="M58" ENTRY="XML File (*.xml)|*.xml" LENGTH="50 "/>
   <textElement ID="I" KEY="M59" ENTRY="Choose file to import" LENGTH="50 "/>
   <textElement ID="I" KEY="M60" ENTRY="Error when opening the input XML file" LENGTH="50 "/>
   <textElement ID="I" KEY="M61" ENTRY="Error when parsing the input XML file" LENGTH="50 "/>
   <textElement ID="I" KEY="M62" ENTRY="Incorrect syntax in Case statement" LENGTH="50 "/>
   <textElement ID="I" KEY="M63" ENTRY="Download results into file" LENGTH="50 "/>
   <textElement ID="I" KEY="M64" ENTRY="You cannot open more than 30 tabs" LENGTH="50 "/>
   <textElement ID="I" KEY="M65" ENTRY="Empty tab" LENGTH="30 "/>
   <textElement ID="I" KEY="T01" ENTRY="Generated code for current query" LENGTH="50 "/>
   <textElement ID="I" KEY="T02" ENTRY="SAP Table/Fields" LENGTH="132 "/>
   <textElement ID="I" KEY="T03" ENTRY="Description" LENGTH="132 "/>
   <textElement ID="I" KEY="T04" ENTRY="Warning : critical operation" LENGTH="36 "/>
   <textElement ID="R" ENTRY="Test de requete ABAP SQL" LENGTH="24 "/>
  </language>
 </textPool>
 <dynpros>
  <dynpro PROG="ZTOAD" DNUM="0010" FNUM="0010" BZMX="99 " BZBR="255 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="99 " NOCO="255 " VALP="0 " CUAN="G" SPRA="E" DTEXT="Tabs">
   <dynprofield FNAM="W_TABSTRIP" DIDX="0063" FLG1="08" FLG2="30" FLG3="00" FILL="I" FMB1="00" FMB2="00" LENG="FF" LINE="01" COLN="02" LTYP="J" LANF="65" LBLK="01" LREP="01" AGLT="06" ADEZ="0A"/>
   <dynprofield FNAM="S_TAB-TITLE1" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="00" FMB2="00" LENG="1E" LINE="01" COLN="01" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="102" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB1"/>
   <dynprofield FNAM="S_TAB-TITLE2" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="02" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="103" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB2"/>
   <dynprofield FNAM="S_TAB-TITLE3" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="03" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="104" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB3"/>
   <dynprofield FNAM="S_TAB-TITLE4" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="04" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="105" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB4"/>
   <dynprofield FNAM="S_TAB-TITLE5" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="05" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="106" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB5"/>
   <dynprofield FNAM="S_TAB-TITLE6" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="06" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="107" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB6"/>
   <dynprofield FNAM="S_TAB-TITLE7" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="07" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="108" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB7"/>
   <dynprofield FNAM="S_TAB-TITLE8" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="08" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="109" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB8"/>
   <dynprofield FNAM="S_TAB-TITLE9" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="09" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="110" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB9"/>
   <dynprofield FNAM="S_TAB-TITLE10" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0A" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="111" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB10"/>
   <dynprofield FNAM="S_TAB-TITLE11" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0B" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="112" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB11"/>
   <dynprofield FNAM="S_TAB-TITLE12" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0C" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="113" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                                                                                                                                                        TAB12"/>
   <dynprofield FNAM="S_TAB-TITLE13" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0D" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="114" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB13"/>
   <dynprofield FNAM="S_TAB-TITLE14" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0E" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="115" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB14"/>
   <dynprofield FNAM="S_TAB-TITLE15" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="0F" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="116" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB15"/>
   <dynprofield FNAM="S_TAB-TITLE16" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="10" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="117" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB16"/>
   <dynprofield FNAM="S_TAB-TITLE17" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="11" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="118" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB17"/>
   <dynprofield FNAM="S_TAB-TITLE18" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="12" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="119" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB18"/>
   <dynprofield FNAM="S_TAB-TITLE19" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="13" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="120" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB19"/>
   <dynprofield FNAM="S_TAB-TITLE20" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="34" FMB2="00" LENG="1E" LINE="01" COLN="14" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="121" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB20"/>
   <dynprofield FNAM="S_TAB-TITLE21" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="15" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="122" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB21"/>
   <dynprofield FNAM="S_TAB-TITLE22" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="16" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="123" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB22"/>
   <dynprofield FNAM="S_TAB-TITLE23" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="17" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="124" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB23"/>
   <dynprofield FNAM="S_TAB-TITLE24" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="18" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="125" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB24"/>
   <dynprofield FNAM="S_TAB-TITLE25" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="19" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="126" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB25"/>
   <dynprofield FNAM="S_TAB-TITLE26" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="1A" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="127" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB26"/>
   <dynprofield FNAM="S_TAB-TITLE27" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="1B" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="128" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB27"/>
   <dynprofield FNAM="S_TAB-TITLE28" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="1C" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="129" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB28"/>
   <dynprofield FNAM="S_TAB-TITLE29" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="1D" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="130" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB29"/>
   <dynprofield FNAM="S_TAB-TITLE30" DIDX="001E" FLG1="80" FLG2="00" FLG3="80" FILL="P" FMB1="04" FMB2="00" LENG="1E" LINE="01" COLN="1E" LTYP="I" LANF="65" LBLK="01" LREP="01" TYPE="CHAR" AUTH="131" WNAM="SUB" AGLT="00" ADEZ="00" STXT="______________________________" RES1="                                       00                                                                                                                               TAB30"/>
   <dynprofield FNAM="SUB" DIDX="0060" FLG1="00" FLG2="F0" FLG3="00" FILL="B" FMB1="30" FMB2="00" LENG="FD" LINE="03" COLN="03" LTYP="I" LANF="65" LBLK="00" LREP="00" AUTH="132" AGLT="03" ADEZ="03"/>
   <dynprofield FNAM="W_OKCODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
   <dynproflowsource>PROCESS BEFORE OUTPUT.
  MODULE STATUS_0010.
  CALL SUBSCREEN SUB INCLUDING SY-REPID &apos;0100&apos;.

PROCESS AFTER INPUT.
  CALL SUBSCREEN SUB.
  module user_command_0010.</dynproflowsource>
  </dynpro>
  <dynpro PROG="ZTOAD" DNUM="0100" TYPE="I" FNUM="0100" BZMX="99 " BZBR="255 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="99 " NOCO="255 " VALP="0 " CUAN="G" SPRA="E" DTEXT="main screen">
   <dynprofield FNAM="CUSTCONT" DIDX="0063" FLG1="00" FLG2="30" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="FF" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="05" ADEZ="14"/>
   <dynprofield DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________" RES1="                                       00"/>
   <dynproflowsource>PROCESS BEFORE OUTPUT.
 &quot;MODULE STATUS_0100.

PROCESS AFTER INPUT.
 &quot;MODULE USER_COMMAND_0100.</dynproflowsource>
  </dynpro>
  <dynpro PROG="ZTOAD" DNUM="0200" TYPE="M" FNUM="0200" BZMX="3 " BZBR="52 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="3 " NOCO="52 " VALP="0 " CUAN="G" SPRA="E" DTEXT="Save options">
   <dynprofield FNAM="S_OPTIONS-NAME_LBL" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="11" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Name of the query" RES1="                                                                                                                                                                                                                                                        X"/>
   <dynprofield FNAM="S_OPTIONS-NAME" DIDX="0000" FLG1="80" FLG2="02" FLG3="A0" FMB1="00" FMB2="00" LENG="1E" LINE="01" COLN="18" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______________________________"/>
   <dynprofield FNAM="S_OPTIONS-VISIBILITY_LBL" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0A" LINE="02" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="Visibility" RES1="                                                                                                                                                                                                                                                        X"/>
   <dynprofield FNAM="S_OPTIONS-VISIBILITY" DIDX="000F" FLG1="80" FLG2="00" FLG3="A0" FMB1="00" FMB2="00" LENG="01" LINE="02" COLN="18" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" RES1=" DL"/>
   <dynprofield FNAM="S_OPTIONS-VISIBILITYGRP_LBL" DIDX="0000" FLG1="00" FLG2="00" FLG3="00" FMB1="30" FMB2="00" LENG="0A" LINE="03" COLN="02" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="0" AGLT="00" ADEZ="00" STXT="User group" RES1="                                                                                                                                                                                                                                                        X"/>
   <dynprofield FNAM="S_OPTIONS-VISIBILITYGRP" DIDX="0000" FLG1="80" FLG2="00" FLG3="A0" FMB1="00" FMB2="00" LENG="0E" LINE="03" COLN="18" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" ITYP="C" AGLT="00" ADEZ="00" STXT="______________"/>
   <dynprofield FNAM="W_OKCODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
   <dynproflowsource>PROCESS BEFORE OUTPUT.
 MODULE STATUS_0200.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0200 at EXIT-COMMAND.
 MODULE USER_COMMAND_0200.</dynproflowsource>
  </dynpro>
  <dynpro PROG="ZTOAD" DNUM="0300" FNUM="0300" BZMX="27 " BZBR="120 " MILI="192 " MICO="37 " MALI="0 " MACO="0 " NOLI="27 " NOCO="120 " VALP="0 " CUAN="G" SPRA="E" DTEXT="Option panel">
   <dynprofield FNAM="CUSTCONT2" DIDX="001B" FLG1="00" FLG2="30" FLG3="00" FILL="U" FMB1="30" FMB2="00" LENG="78" LINE="01" COLN="02" LANF="00" LBLK="00" LREP="00" AUTH="101" AGLT="02" ADEZ="02"/>
   <dynprofield FNAM="W_OKCODE" DIDX="0000" FLG1="80" FLG2="10" FLG3="00" FMB1="00" FMB2="00" LENG="14" LINE="FF" COLN="01" LTYP="O" LANF="00" LBLK="00" LREP="00" TYPE="CHAR" AGLT="00" ADEZ="00" STXT="____________________"/>
   <dynproflowsource>PROCESS BEFORE OUTPUT.
 MODULE STATUS_0300.
*
PROCESS AFTER INPUT.
 MODULE USER_COMMAND_0300.</dynproflowsource>
  </dynpro>
 </dynpros>
 <pfstatus>
  <pfstatus_sta CODE="STATUS010" MODAL="D" ACTCODE="000001" PFKCODE="000001" BUTCODE="0001" INT_NOTE="Main status"/>
  <pfstatus_sta CODE="STATUS200" MODAL="P" PFKCODE="000002" BUTCODE="0001" INT_NOTE="Save Option"/>
  <pfstatus_sta CODE="STATUS300" MODAL="P" PFKCODE="000003" BUTCODE="0001" INT_NOTE="Options panel"/>
  <pfstatus_fun CODE="CLOSE" TEXTNO="001" TYPE="E" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Interrupt"/>
  <pfstatus_fun CODE="DOWNLOAD" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXPORT" ICON_ID="@49@" FUN_TEXT="Execute into file" ICON_TEXT="Execute into file"/>
  <pfstatus_fun CODE="EXECUTE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXECUTE_OBJECT" ICON_ID="@15@" FUN_TEXT="Execute" ICON_TEXT="Execute"/>
  <pfstatus_fun CODE="EXIT" TEXTNO="001" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Back"/>
  <pfstatus_fun CODE="EXIT" TEXTNO="002" TYPE="E" TEXT_TYPE="S" FUN_TEXT="Exit"/>
  <pfstatus_fun CODE="EXIT" TEXTNO="003" TYPE="E" TEXT_TYPE="S" TEXT_NAME="ICON_CANCEL" ICON_ID="@0W@" FUN_TEXT="Cancel"/>
  <pfstatus_fun CODE="HELP" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_INFORMATION" ICON_ID="@0S@" FUN_TEXT="Help" ICON_TEXT="Help"/>
  <pfstatus_fun CODE="NEW" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_CREATE" ICON_ID="@0Y@" FUN_TEXT="New tab" ICON_TEXT="New tab"/>
  <pfstatus_fun CODE="OK" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_OKAY" ICON_ID="@0V@" FUN_TEXT="Continue"/>
  <pfstatus_fun CODE="OPTIONS" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_TOOLS" ICON_ID="@45@" FUN_TEXT="Options" ICON_TEXT="Options"/>
  <pfstatus_fun CODE="SAVE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_SYSTEM_SAVE" ICON_ID="@2L@" FUN_TEXT="Save"/>
  <pfstatus_fun CODE="SHOWCODE" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_ABAP" ICON_ID="@9U@" FUN_TEXT="Display generated program" ICON_TEXT="Generated program"/>
  <pfstatus_fun CODE="XML" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_EXPORT" ICON_ID="@49@" FUN_TEXT="Export XML" ICON_TEXT="Export Saved Queries"/>
  <pfstatus_fun CODE="XMLI" TEXTNO="001" TEXT_TYPE="S" TEXT_NAME="ICON_IMPORT" ICON_ID="@48@" FUN_TEXT="Import XML" ICON_TEXT="Import Queries"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="01" PFNO="08"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="02" PFNO="18"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="03" PFNO="06"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="04" PFNO="05"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="05" PFNO="07"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="06" PFNO="17"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="07" PFNO="19"/>
  <pfstatus_but PFK_CODE="000001" CODE="0001" NO="08" PFNO="13"/>
  <pfstatus_but PFK_CODE="000002" CODE="0001" NO="01" PFNO="00"/>
  <pfstatus_but PFK_CODE="000002" CODE="0001" NO="02" PFNO="12"/>
  <pfstatus_but PFK_CODE="000003" CODE="0001" NO="01" PFNO="00"/>
  <pfstatus_but PFK_CODE="000003" CODE="0001" NO="02" PFNO="12"/>
  <pfstatus_pfk CODE="000001" PFNO="03" FUNCODE="EXIT" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="05" FUNCODE="NEW" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="06" FUNCODE="SHOWCODE" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="07" FUNCODE="OPTIONS" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="08" FUNCODE="EXECUTE" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="11" FUNCODE="SAVE" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="12" FUNCODE="EXIT" FUNNO="003"/>
  <pfstatus_pfk CODE="000001" PFNO="13" FUNCODE="HELP" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="15" FUNCODE="EXIT" FUNNO="002"/>
  <pfstatus_pfk CODE="000001" PFNO="17" FUNCODE="XML" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="18" FUNCODE="DOWNLOAD" FUNNO="001"/>
  <pfstatus_pfk CODE="000001" PFNO="19" FUNCODE="XMLI" FUNNO="001"/>
  <pfstatus_pfk CODE="000002" PFNO="00" FUNCODE="OK" FUNNO="001"/>
  <pfstatus_pfk CODE="000002" PFNO="12" FUNCODE="CLOSE" FUNNO="001"/>
  <pfstatus_pfk CODE="000003" PFNO="00" FUNCODE="OK" FUNNO="001"/>
  <pfstatus_pfk CODE="000003" PFNO="12" FUNCODE="CLOSE" FUNNO="001"/>
  <pfstatus_set STATUS="STATUS010" FUNCTION="DOWNLOAD"/>
  <pfstatus_set STATUS="STATUS010" FUNCTION="EXECUTE"/>
  <pfstatus_set STATUS="STATUS010" FUNCTION="EXIT"/>
  <pfstatus_set STATUS="STATUS010" FUNCTION="HELP"/>
  <pfstatus_set STATUS="STATUS010" FUNCTION="NEW"/>
  <pfstatus_set STATUS="STATUS010" FUNCTION="OPTIONS"/>
  <pfstatus_set STATUS="STATUS010" FUNCTION="SAVE"/>
  <pfstatus_set STATUS="STATUS010" FUNCTION="SHOWCODE"/>
  <pfstatus_set STATUS="STATUS010" FUNCTION="XML"/>
  <pfstatus_set STATUS="STATUS010" FUNCTION="XMLI"/>
  <pfstatus_set STATUS="STATUS200" FUNCTION="CLOSE"/>
  <pfstatus_set STATUS="STATUS200" FUNCTION="OK"/>
  <pfstatus_set STATUS="STATUS300" FUNCTION="CLOSE"/>
  <pfstatus_set STATUS="STATUS300" FUNCTION="OK"/>
  <pfstatus_doc OBJ_TYPE="A" OBJ_CODE="000001" MODAL="D" INT_NOTE="Main status"/>
  <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000001" MODAL="D" INT_NOTE="Main status"/>
  <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000001" SUB_CODE="0001" MODAL="D" INT_NOTE="Main status"/>
  <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000002" MODAL="P" INT_NOTE="Save Option"/>
  <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000002" SUB_CODE="0001" MODAL="P" INT_NOTE="Save Option"/>
  <pfstatus_doc OBJ_TYPE="P" OBJ_CODE="000003" MODAL="P" INT_NOTE="Options panel"/>
  <pfstatus_doc OBJ_TYPE="B" OBJ_CODE="000003" SUB_CODE="0001" MODAL="P" INT_NOTE="Options panel"/>
  <pfstatus_tit CODE="STATUS010" TEXT="ABAP SQL Editor"/>
  <pfstatus_tit CODE="STATUS200" TEXT="Save Query"/>
  <pfstatus_tit CODE="STATUS300" TEXT="Options panel"/>
 </pfstatus>
 <source>*&amp;---------------------------------------------------------------------*
*&amp; Program : ZTOAD
*&amp; Author  : S. Hermann
*&amp; Date    : 01.04.2017
*&amp; Version : 4.0.1
*&amp; Required: Table ZTOAD
*&amp;---------------------------------------------------------------------*
*&amp; This program allow you to execute query directly on the server
*&amp; 1/ Write your query in the editor window (ABAP SQL)
*&amp; 2/ View the result in ALV window (in case of SELECT query)
*&amp;
*3 Features :
*&amp; The top center pane allow you to write your query in ABAP SQL format.
*= Query can be complex with JOIN, UNION and subqueries. You can write
*= query on several lines. You could also add spaces.
*= To add comment, start the line by * or prefix your comment by &quot;
*&amp;
*&amp; You could write several queries in the query editor, separated by
*= dot &quot;.&quot;. To execute one of them, highlight all the wanted query,
*= or just put the cursor anywhere inside the wanted query.
*= By default, the last query is executed.
*&amp;
*&amp; In case of error, you can display generated code to help you to
*= correct your query (only if you have S_DEVELOP access)
*&amp;
*&amp; F1 Help is managed to help you on ABAP SQL Syntax
*&amp; Code completion is also available :
*&amp; - TAB to autocomplete with tooltip word
*&amp; - CTRL + ESPACE to display list of available words
*&amp; Be carefull to not use with INSERT statement (see below)
*&amp;
*&amp; The top left pane allow you to store your query :
*&amp; - You could save your query to reuse it later
*&amp; - You could share your query : define users, usergroup, all
*&amp; - You could export query into file to reuse it on another server
*&amp;
*&amp; The top right pane display ddic object that is currently used to help
*= you to write the proper query
*&amp; Synergy with ZSPRO program : display tables defined in ZSPRO in the
*= ddic tree
*&amp; Tips : You can search a table in the tree using header clic
*&amp;
*3 Managed queries
*&amp; SELECT, INSERT, UPDATE, DELETE, Any native SQL command
*&amp;
*3 About New SQL Query Syntax
*&amp; You could use new syntax (if your SAP system manage it)
*&amp; ZTOAD autmatically detect if you are using new sytax when:
*&amp; - You separated your selected fields with comma
*&amp; - You prefixed your variable with @ in the INTO TABLE statement
*&amp;
*3 Select Clause managed
*&amp; SELECT [DISTINCT / SINGLE] select clause
*&amp; FROM from clause
*&amp; [UP TO x ROWS]
*&amp; [WHERE cond1]
*&amp; [GROUP BY fields1]
*&amp; [HAVING cond2]
*&amp; [ORDER BY fields2]
*&amp; [UNION SELECT...]
*&amp;
*&amp; UP TO (Default max rows) ROWS added at end of query if omitted
*&amp; You could force select without limits by adding UP TO 0 ROWS
*&amp;
*&amp; COUNT, AVG, MAX, MIN, SUM are managed
*&amp; DO NOT FORGET SPACE in ( ) of aggregat
*&amp;
*3 Insert special syntax
*&amp; In ABAP, insert query is always used with given structure
*&amp; In this SQL editor, you have 2 ways to do an INSERT :
*&amp; - By passing each value, 1 by 1
*E INSERT SEOCLASSTX VALUES ( &apos;ZZMACLASS&apos;, &apos; &apos;, &apos;Test claSS&apos; )
*&amp;
*&amp; - By passing value of used fields only
*E INSERT SEOCLASSTX SET CLSNAME = &apos;ZZMACLASS&apos; DESCRIPT = &apos;TeSt class&apos;
*&amp;
*3 Native SQL special syntax
*&amp; To execute a native SQL command, please add the prefix NATIVE
*&amp; before your query
*&amp; NATIVE CREATE INDEX &apos;TESTINDEX&apos; ON T001 (MANDT, WAERS, BUKRS)
*&amp; NATIVE DROP INDEX &apos;TESTINDEX&apos;
*&amp;
*3 Sample of query :
*&amp;
*E SELECT SINGLE * FROM VBAP WHERE VBELN = &apos;00412345678&apos;
*&amp;
*E SELECT COUNT( * ) SUBC MAX( PROG ) FROM TRDIR GROUP BY SUBC
*&amp;
*E SELECT VBAK~* from VBAK UP TO 3 ROWS ORDER BY VKORG.
*&amp;
*E SELECT T1~VBELN T2~POSNR FROM VBAk AS T1
*E        JOIN VBAP AS T2 ON T1~VBELN = T2~VBELN
*&amp;
*E INSERT SEOCLASSTX VALUES ( &apos;ZZMACLASS&apos;, &apos; &apos;, &apos;Test claSS&apos; )
*&amp;
*E INSERT SEOCLASSTX SET CLSNAME = &apos;ZZMACLASS&apos; DESCRIPT = &apos;TeSt class&apos;
*&amp;
*E UPDATE SEOCLASSTX SET DESCRIPT = &apos;txt&apos; WHERE CLSNAME = &apos;ZZMACLASS&apos;
*&amp;
*E DELETE SEOCLASSTX WHERE CLSNAME = &apos;ZZMACLASS&apos;
*&amp;
*&amp; Please send comment &amp; improvements to http://quelquepart.biz
*&amp;---------------------------------------------------------------------*
*&amp; History :
*&amp; 2017.04.01 v4.0  :Fix new Tab dump
*&amp; 2016.12.17 v4.0  :Add Tab management. You can have up to 30 tabs
*&amp;                   Fix Status corruption
*&amp;                   Add Import/Export function for saved queries
*&amp;                   Mod Code cleaning
*&amp; 2016.09.10 v3.6  :Add New syntax management of &quot;case&quot;
*&amp; 2016.07.06 v3.5.1:Fix Auth issue
*&amp;                   Fix Dump on select with no empty selection part
*&amp; 2016.03.28 v3.5  :Add Value Help on DDIC field. Select a value to
*&amp;                       paste in editor
*&amp;                   Add Button Execute into file to download results
*&amp;                       instead of display it in ALV
*&amp;                   Mod Use class CL_RSAWB_SPLITTER_FOR_TOOLBAR for
*&amp;                       creation of DDIC toolbar
*&amp;                   Add Refresh the DDIC tree when executing a query
*&amp;                       even if error found
*&amp; Thanks to Patrick Prime Reinoso for the following changes :
*&amp;                   Fix Remove confirmation popup on display code for
*&amp;                       no select statement
*&amp;                   Add Option to display technical name in ALV
*&amp;                   Mod Move option button to main toolbar
*&amp;                   Mod Rename subroutines (code cleaning)
*&amp;                   Mod Allow save on exit popup
*&amp;                   Add New query button
*&amp;                   Mod New query template changed
*&amp; 2015.11.07 v3.4.3:Fix dump if cursor on first position
*&amp;                   Fix prevent dump on too many sql run
*&amp; 2015.11.07 v3.4.2:Fix cancel of save query popup
*&amp;                   Fix Allow usage of &quot; and . inside &apos;&apos;
*&amp; 2015.11.01 v3.4.1:Fix issue with delete all history context menu
*&amp; 2015.09.19 v3.4  :Add Code completion on SQL editor
*&amp;                   Thanks to Benjamin Krencker for his code
*&amp;                   Add Remove useless APPENDING TABLE statement in qry
*&amp; 2015.09.13 v3.3  :Add New Options panel to save user preferences
*&amp;                   Add Delete all history entries context menu
*&amp;                   Add option to add linebreak after paste field from
*&amp;                       ddic tree
*&amp;                   Add Count column in alv grid display
*&amp;                   Thanks again to Shai Sinai for his suggestions
*&amp; 2015.09.06 v3.2.1:Mod Default limit to 100 rows is now optional
*&amp; 2015.08.30 v3.2  :Add Manage new SQL Syntax introduced by NW7.40 SP5
*&amp;                   Add Remove useless INTO TABLE statement in query
*&amp;                   Add All NATIVE Sql commands
*&amp;                   Mod Auth object use now the sap standard way
*&amp;                   Fix Dump in case of up to xx rows in unioned query
*&amp;                   Fix Dump at activation if ZSPRO does not exist
*&amp;                   Fix Compatibility issues with older sap system
*&amp; 2015.08.05 v3.1  :Add Manage drag&amp;drop from DDIC tree to SQL Editor
*&amp;                   Mod Double clic on field in DDIC tree paste field
*&amp;                       in editor instead of filling clipboard
*&amp;                   Thanks to Shai Sinai for his suggestions
*&amp; 2015.06.13 v3.0  :Add INSERT, UPDATE, DELETE command
*&amp;                   Add Authorization management
*&amp;                   Add History tree display first query line if it
*&amp;                       is a comment line
*&amp;                   Mod Code cleaning
*&amp; 2015.03.05 v2.1.1:Mod grid size is no more changed before display
*&amp;                       query result
*&amp; 2015.01.11 v2.1  :Add UNION instruction managed to merge 2 queries
*&amp;                   Mod Do not refresh result grid for count(*)
*&amp;                   Mod Back close the grid instead of leave program if
*&amp;                       result grid is displayed
*&amp;                   Add Display program header as default help
*&amp;                   Add Run highlighted query
*&amp;                   Mod Documentation rewritten
*&amp; 2014.10.23 v2.0.2:Add Display number of entries found
*&amp;                   Add Confirmation before exit for unsaved queries
*&amp; 2014.10.19 v2.0.1:Fix bug on search ddic function
*&amp; 2014.08.03 v2.0 : Completely rewritten version
*&amp;                   - Save and share queries with colaborators
*&amp;                   - Queries are now saved in database
*&amp;                   - Display tables (+ fields) of the where clause
*&amp;                   - Display ZSPRO entries in ddic tree
*&amp;                   - Allow direct change in query after execution
*&amp;                   - Count( * ) allowed
*&amp;                   - Can display generated code
*&amp;                   - Display query execution time
*&amp;                   - Allow write of several queries (but 1 executed)
*&amp; 2013.12.03 v1.3 : Allow case sensitive constant in where clause
*&amp; 2012.08.30 v1.2 : Rewrite data definition to avoid dump on too long
*&amp;                   fieldname
*&amp; 2012.04.01 v1.1 : Updated to work also on BW system
*&amp; 2009.10.26 v1.0 : Initial release
*&amp;---------------------------------------------------------------------*

REPORT ztoad.
TYPE-POOLS abap.

*######################################################################*
*
*                        CUSTOMIZATION SECTION
*
*######################################################################*
DATA : BEGIN OF s_customize,                                &quot;#EC NEEDED
* Default number of lines to return for SELECT if no &quot;up to xxx rows&quot;
* defined in the query.
* Set to 0 if you dont want default limit.
         default_rows    TYPE i VALUE 100,

* When you dblclic on a field in the ddic tree, field is pasted to
* editor at the cursor position
* You could choose to add a linebreak after the field pasted
         paste_break(1)  TYPE c VALUE space, &quot;abap_true to break

* In ALV grid result, display technical name instead of column label
         techname(1)     TYPE c VALUE space, &quot;abap_true for technical

* You could define your authorization object to restrict
* function usage by user
* If you dont define auth object, all users will have same access as
* defined bellow
* The auth object have 2 fields TABLE and ACTVT
* ACTVT can take 5 values that you could define here. By default :
* 01 for INSERT command
* 02 for UPDATE command
* 03 for SELECT command
* 06 for DELETE command
* 16 for EXECUTE NATIVE SQL command
* TABLE contain allowed table name pattern
* &apos;*&apos; to allow all table, &apos;Z*&apos; to allow all specific tables...
         auth_object(20) TYPE c VALUE &apos;&apos;, &quot;&apos;ZTOAD_AUTH&apos;,
         actvt_select    TYPE tactt-actvt VALUE &apos;03&apos;,
         actvt_insert    TYPE tactt-actvt VALUE &apos;01&apos;,
         actvt_update    TYPE tactt-actvt VALUE &apos;02&apos;,
         actvt_delete    TYPE tactt-actvt VALUE &apos;06&apos;,
         actvt_native    TYPE tactt-actvt VALUE &apos;16&apos;,

* Bellow is default AUTH used if no auth_object is defined
* Allow SELECT query on SAP table (restricted by given pattern)
         auth_select     TYPE string VALUE &apos;*&apos;,
* Allow INSERT query on SAP table (restricted by given pattern)
         auth_insert     TYPE string VALUE space, &quot;&apos;*&apos;,
* Allow UPDATE query on SAP table (restricted by given pattern)
         auth_update     TYPE string VALUE space, &quot;&apos;*&apos;,
* Allow DELETE query on SAP table (restricted by given pattern)
         auth_delete     TYPE string VALUE space, &quot;&apos;*&apos;,
* Allow any native sql command (set value to space to disable)
         auth_native(1)  TYPE c VALUE space, &quot;abap_true,

       END OF s_customize.


*######################################################################*
*
*                             DATA SECTION
*
*######################################################################*
* Objects
CLASS lcl_application DEFINITION DEFERRED.

* Screen objects
DATA : o_handle_event         TYPE REF TO lcl_application,
       o_container            TYPE REF TO cl_gui_custom_container,
       o_splitter             TYPE REF TO cl_gui_splitter_container,
       o_splitter_top         TYPE REF TO cl_gui_splitter_container,
       o_splitter_top_right   TYPE REF TO cl_rsawb_splitter_for_toolbar,
       o_container_top        TYPE REF TO cl_gui_container,
       o_container_top_right  TYPE REF TO cl_gui_container,
       o_container_repository TYPE REF TO cl_gui_container,
       o_container_options    TYPE REF TO cl_gui_custom_container,
       o_container_query      TYPE REF TO cl_gui_container,
       o_container_ddic       TYPE REF TO cl_gui_container,
       o_container_result     TYPE REF TO cl_gui_container,

* Tabs objects (editor, ddic, alv)
       BEGIN OF s_tab_active,
         o_textedit             TYPE REF TO cl_gui_abapedit,
         o_tree_ddic            TYPE REF TO cl_gui_column_tree,
         t_node_ddic            TYPE treev_ntab,
         t_item_ddic            TYPE TABLE OF mtreeitm,
         o_alv_result           TYPE REF TO cl_gui_alv_grid,
         row_height             TYPE i,
       END OF s_tab_active,
       t_tabs LIKE TABLE OF s_tab_active,

* Repository data
       o_tree_repository      TYPE REF TO cl_gui_simple_tree,
       BEGIN OF s_node_repository.
        INCLUDE TYPE treev_node. &quot;mtreesnode.
DATA :  text(100) TYPE c,
        edit(1)   TYPE c,
        queryid   TYPE ztoad-queryid,
        END OF s_node_repository,
        t_node_repository      LIKE TABLE OF s_node_repository,

* DDIC data
        w_dragdrop_handle_tree TYPE i,
* DDIC toolbar
        o_toolbar              TYPE REF TO cl_gui_toolbar,
* Option panel
        o_options              TYPE REF TO cl_wdy_wb_property_box,
* ZSPRO data
        t_node_zspro           LIKE s_tab_active-t_node_ddic,
        t_item_zspro           LIKE s_tab_active-t_item_ddic,

* Save option
        BEGIN OF s_options,
          name          TYPE ztoad-text,
          visibility    TYPE ztoad-visibility,
          visibilitygrp TYPE usr02-class,
        END OF s_options,

* Keep last loaded id
        w_last_loaded_query TYPE ztoad-queryid,

* Count number of runs
        w_run               TYPE i.

DATA : w_okcode LIKE sy-ucomm,
       BEGIN OF s_tab,
         title1 TYPE string VALUE &apos;Tab 1&apos;,                  &quot;#EC NOTEXT
         title2 TYPE string VALUE &apos;Tab 2&apos;,                  &quot;#EC NOTEXT
         title3 TYPE string VALUE &apos;Tab 3&apos;,                  &quot;#EC NOTEXT
         title4 TYPE string VALUE &apos;Tab 4&apos;,                  &quot;#EC NOTEXT
         title5 TYPE string VALUE &apos;Tab 5&apos;,                  &quot;#EC NOTEXT
         title6 TYPE string VALUE &apos;Tab 6&apos;,                  &quot;#EC NOTEXT
         title7 TYPE string VALUE &apos;Tab 7&apos;,                  &quot;#EC NOTEXT
         title8 TYPE string VALUE &apos;Tab 8&apos;,                  &quot;#EC NOTEXT
         title9 TYPE string VALUE &apos;Tab 9&apos;,                  &quot;#EC NOTEXT
         title10 TYPE string VALUE &apos;Tab 10&apos;,                &quot;#EC NOTEXT
         title11 TYPE string VALUE &apos;Tab 11&apos;,                &quot;#EC NOTEXT
         title12 TYPE string VALUE &apos;Tab 12&apos;,                &quot;#EC NOTEXT
         title13 TYPE string VALUE &apos;Tab 13&apos;,                &quot;#EC NOTEXT
         title14 TYPE string VALUE &apos;Tab 14&apos;,                &quot;#EC NOTEXT
         title15 TYPE string VALUE &apos;Tab 15&apos;,                &quot;#EC NOTEXT
         title16 TYPE string VALUE &apos;Tab 16&apos;,                &quot;#EC NOTEXT
         title17 TYPE string VALUE &apos;Tab 17&apos;,                &quot;#EC NOTEXT
         title18 TYPE string VALUE &apos;Tab 18&apos;,                &quot;#EC NOTEXT
         title19 TYPE string VALUE &apos;Tab 19&apos;,                &quot;#EC NOTEXT
         title20 TYPE string VALUE &apos;Tab 20&apos;,                &quot;#EC NOTEXT
         title21 TYPE string VALUE &apos;Tab 21&apos;,                &quot;#EC NOTEXT
         title22 TYPE string VALUE &apos;Tab 22&apos;,                &quot;#EC NOTEXT
         title23 TYPE string VALUE &apos;Tab 23&apos;,                &quot;#EC NOTEXT
         title24 TYPE string VALUE &apos;Tab 24&apos;,                &quot;#EC NOTEXT
         title25 TYPE string VALUE &apos;Tab 25&apos;,                &quot;#EC NOTEXT
         title26 TYPE string VALUE &apos;Tab 26&apos;,                &quot;#EC NOTEXT
         title27 TYPE string VALUE &apos;Tab 27&apos;,                &quot;#EC NOTEXT
         title28 TYPE string VALUE &apos;Tab 28&apos;,                &quot;#EC NOTEXT
         title29 TYPE string VALUE &apos;Tab 29&apos;,                &quot;#EC NOTEXT
         title30 TYPE string VALUE &apos;Tab 30&apos;,                &quot;#EC NOTEXT
       END OF s_tab.
CONTROLS w_tabstrip TYPE TABSTRIP.

* Global types
TYPES : BEGIN OF ty_fieldlist,
          field     TYPE string,
          ref_table TYPE string,
          ref_field TYPE string,
        END OF ty_fieldlist,
        ty_fieldlist_table TYPE STANDARD TABLE OF ty_fieldlist.

* Constants
CONSTANTS : c_ddic_col1            TYPE mtreeitm-item_name
                        VALUE &apos;col1&apos;,                       &quot;#EC NOTEXT
            c_ddic_col2            TYPE mtreeitm-item_name
                        VALUE &apos;col2&apos;,                       &quot;#EC NOTEXT
            c_visibility_all       TYPE ztoad-visibility VALUE &apos;2&apos;,
            c_visibility_shared    TYPE ztoad-visibility VALUE &apos;1&apos;,
            c_visibility_my        TYPE ztoad-visibility VALUE &apos;0&apos;,
            c_nodekey_repo_my      TYPE mtreesnode-node_key VALUE &apos;MY&apos;,
            c_nodekey_repo_shared  TYPE mtreesnode-node_key
                                  VALUE &apos;SHARED&apos;,
            c_nodekey_repo_history TYPE mtreesnode-node_key
                                   VALUE &apos;HISTO&apos;,
            c_line_max             TYPE i VALUE 255,
            c_msg_success          TYPE c VALUE &apos;S&apos;,
            c_msg_error            TYPE c VALUE &apos;E&apos;,
            c_vers_active          TYPE as4local VALUE &apos;A&apos;,
            c_ddic_dtelm           TYPE comptype VALUE &apos;E&apos;,
            c_native_command       TYPE string VALUE &apos;NATIVE&apos;,
            c_query_max_exec       TYPE i VALUE 36,

            c_xmlnode_root TYPE string VALUE &apos;root&apos;,        &quot;#EC NOTEXT
            c_xmlnode_file TYPE string VALUE &apos;query&apos;,       &quot;#EC NOTEXT
            c_xmlattr_visibility TYPE string VALUE &apos;visibility&apos;, &quot;#EC NOTEXT
            c_xmlattr_text TYPE string VALUE &apos;description&apos;. &quot;#EC NOTEXT

*######################################################################*
*
*                             CLASS SECTION
*
*######################################################################*

*----------------------------------------------------------------------*
*       CLASS lcl_drag_object DEFINITION
*----------------------------------------------------------------------*
*       Class to store object on drag &amp; drop from DDIC to sql editor
*----------------------------------------------------------------------*
CLASS lcl_drag_object DEFINITION FINAL.
  PUBLIC SECTION.
    DATA field TYPE string.
ENDCLASS.&quot;lcl_drag_object DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_application DEFINITION
*----------------------------------------------------------------------*
*       Class to handle application events
*----------------------------------------------------------------------*
CLASS lcl_application DEFINITION FINAL.
  PUBLIC SECTION.
    METHODS :
* Handle F1 call on ABAP editor
      hnd_editor_f1
         FOR EVENT f1 OF cl_gui_abapedit,
* Handle Node double clic on ddic tree
      hnd_ddic_item_dblclick
                    FOR EVENT item_double_click OF cl_gui_column_tree
        IMPORTING node_key,
* Handle context menu display on repository tree
      hnd_repo_context_menu
      FOR EVENT node_context_menu_request
                    OF cl_gui_simple_tree
        IMPORTING menu,
* Handle context menu clic on repository tree
      hnd_repo_context_menu_sel
      FOR EVENT node_context_menu_select
                    OF cl_gui_simple_tree
        IMPORTING fcode,
* Handle Node double clic on repository tree
      hnd_repo_dblclick
                    FOR EVENT node_double_click OF cl_gui_simple_tree
        IMPORTING node_key,
* Handle toolbar display on ALV result
      hnd_result_toolbar
                    FOR EVENT toolbar OF cl_gui_alv_grid
        IMPORTING e_object,
* Handle toolbar clic on ALV result
      hnd_result_user_command
                    FOR EVENT user_command OF cl_gui_alv_grid
        IMPORTING e_ucomm,
* Handle DDIC tree drag
      hnd_ddic_drag
                    FOR EVENT on_drag OF cl_gui_column_tree
        IMPORTING node_key drag_drop_object,
* Handle editor drop
      hnd_editor_drop
                    FOR EVENT on_drop OF cl_gui_abapedit
        IMPORTING line pos dragdrop_object,
* Handle ddic toolbar clic
      hnd_ddic_toolbar_clic
                    FOR EVENT function_selected OF cl_gui_toolbar
        IMPORTING fcode.
ENDCLASS.                    &quot;lcl_application DEFINITION

*----------------------------------------------------------------------*
*       CLASS LCL_APPLICATION IMPLEMENTATION
*----------------------------------------------------------------------*
*       Class to handle application events                             *
*----------------------------------------------------------------------*
CLASS lcl_application IMPLEMENTATION.
*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD hnd_repo_context_menu
*&amp;---------------------------------------------------------------------*
*       Handle context menu display on repository tree
*----------------------------------------------------------------------*
  METHOD hnd_repo_context_menu.
    DATA l_node_key TYPE tv_nodekey.

    CALL METHOD o_tree_repository-&gt;get_selected_node
      IMPORTING
        node_key = l_node_key.
* For History node, add a &quot;delete all&quot; entry
* Only if there is at least 1 history entry
    IF l_node_key = &apos;HISTO&apos;.
      READ TABLE t_node_repository TRANSPORTING NO FIELDS
        WITH KEY relatkey = &apos;HISTO&apos;.
      IF sy-subrc = 0.
        CALL METHOD menu-&gt;add_function
          EXPORTING
            text  = &apos;Delete All&apos;(m36)
            icon  = &apos;@02@&apos;
            fcode = &apos;DELETE_HIST&apos;.
      ENDIF.
      RETURN.
    ENDIF.

* Add Delete option only for own queries
    READ TABLE t_node_repository INTO s_node_repository
               WITH KEY node_key = l_node_key.
    IF sy-subrc NE 0 OR s_node_repository-edit = space.
      RETURN.
    ENDIF.

    CALL METHOD menu-&gt;add_function
      EXPORTING
        text  = &apos;Delete&apos;(m01)
        icon  = &apos;@02@&apos;
        fcode = &apos;DELETE_QUERY&apos;.
  ENDMETHOD.                    &quot;hnd_repo_context_menu

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD hnd_repo_context_menu_sel
*&amp;---------------------------------------------------------------------*
*       Handle context menu clic on repository tree
*----------------------------------------------------------------------*
  METHOD hnd_repo_context_menu_sel.
    DATA : l_node_key TYPE tv_nodekey,
           l_subrc    TYPE i,
           ls_histo   LIKE s_node_repository,
           lw_queryid LIKE ls_histo-queryid.
* Delete stored query
    CASE fcode.
      WHEN &apos;DELETE_QUERY&apos;.
        CALL METHOD o_tree_repository-&gt;get_selected_node
          IMPORTING
            node_key = l_node_key.
        PERFORM repo_delete_history USING l_node_key
                                    CHANGING l_subrc.
        IF l_subrc = 0.
          MESSAGE &apos;Query deleted&apos;(m02) TYPE c_msg_success.
        ELSE.
          MESSAGE &apos;Error when deleting the query&apos;(m03)
                  TYPE c_msg_success DISPLAY LIKE c_msg_error.
          RETURN.
        ENDIF.

      WHEN &apos;DELETE_HIST&apos;.
        CONCATENATE sy-uname &apos;+++&apos; INTO lw_queryid.
        LOOP AT t_node_repository INTO ls_histo
                WHERE queryid CP lw_queryid.
          PERFORM repo_delete_history USING ls_histo-node_key
                                      CHANGING l_subrc.
          IF l_subrc NE 0.
            MESSAGE &apos;Error when deleting the query&apos;(m03)
                    TYPE c_msg_success DISPLAY LIKE c_msg_error.
            RETURN.
          ENDIF.
        ENDLOOP.
        MESSAGE &apos;All history entries deleted&apos;(m37) TYPE c_msg_success.
    ENDCASE.
  ENDMETHOD.                    &quot;hnd_repo_context_menu_sel

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD hnd_editor_f1
*&amp;---------------------------------------------------------------------*
*       Handle F1 call on ABAP editor
*----------------------------------------------------------------------*
  METHOD hnd_editor_f1.
    DATA : lw_cursor_line_from TYPE i,
           lw_cursor_line_to   TYPE i,
           lw_cursor_pos_from  TYPE i,
           lw_cursor_pos_to    TYPE i,
           lw_offset           TYPE i,
           lw_length           TYPE i,
           lt_query            TYPE soli_tab,
           ls_query            LIKE LINE OF lt_query,
           lw_sel              TYPE string.

* Find active query
    CALL METHOD s_tab_active-o_textedit-&gt;get_selection_pos
      IMPORTING
        from_line = lw_cursor_line_from
        from_pos  = lw_cursor_pos_from
        to_line   = lw_cursor_line_to
        to_pos    = lw_cursor_pos_to.

* If nothing selected, no help to display
    IF lw_cursor_line_from = lw_cursor_line_to
    AND lw_cursor_pos_to = lw_cursor_pos_from.
      RETURN.
    ENDIF.

* Get content of abap edit box
    CALL METHOD s_tab_active-o_textedit-&gt;get_text
      IMPORTING
        table  = lt_query[]
      EXCEPTIONS
        OTHERS = 1.


    READ TABLE lt_query INTO ls_query INDEX lw_cursor_line_from.
    IF lw_cursor_line_from = lw_cursor_line_to.
      lw_length = lw_cursor_pos_to - lw_cursor_pos_from.
      lw_offset = lw_cursor_pos_from - 1.
      lw_sel = ls_query+lw_offset(lw_length).
    ELSE.
      lw_offset = lw_cursor_pos_from - 1.
      lw_sel = ls_query+lw_offset.
    ENDIF.
    CALL FUNCTION &apos;ABAP_DOCU_START&apos;
      EXPORTING
        word = lw_sel.
  ENDMETHOD.                    &quot;hnd_editor_f1

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD hnd_ddic_item_dblclick
*&amp;---------------------------------------------------------------------*
*       Handle Node double clic on ddic tree
*----------------------------------------------------------------------*
  METHOD hnd_ddic_item_dblclick.
    DATA : ls_node       LIKE LINE OF s_tab_active-t_node_ddic,
           lw_line_start TYPE i,
           lw_pos_start  TYPE i,
           lw_line_end   TYPE i,
           lw_pos_end    TYPE i,
           lw_data       TYPE string.

* Check clicked node is valid
    READ TABLE s_tab_active-t_node_ddic INTO ls_node
               WITH KEY node_key = node_key.
    IF sy-subrc NE 0 OR ls_node-isfolder = abap_true.
      RETURN.
    ENDIF.

* Get text for the node selected
    PERFORM ddic_get_field_from_node USING node_key ls_node-relatkey
                                     CHANGING lw_data.

* Get current cursor position/selection in editor
    CALL METHOD s_tab_active-o_textedit-&gt;get_selection_pos
      IMPORTING
        from_line = lw_line_start
        from_pos  = lw_pos_start
        to_line   = lw_line_end
        to_pos    = lw_pos_end
      EXCEPTIONS
        OTHERS    = 4.
    IF sy-subrc NE 0.
      MESSAGE &apos;Cannot get cursor position&apos;(m35) TYPE c_msg_error.
    ENDIF.

*   If text is selected/highlighted, delete it
    IF lw_line_start NE lw_line_end
    OR lw_pos_start NE lw_pos_end.
      CALL METHOD s_tab_active-o_textedit-&gt;delete_text
        EXPORTING
          from_line = lw_line_start
          from_pos  = lw_pos_start
          to_line   = lw_line_end
          to_pos    = lw_pos_end.
    ENDIF.

    PERFORM editor_paste USING lw_data lw_line_start lw_pos_start.
  ENDMETHOD.                    &quot;hnd_ddic_item_dblclick

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD hnd_repo_dblclick
*&amp;---------------------------------------------------------------------*
*       Handle Node double clic on repository tree
*----------------------------------------------------------------------*
  METHOD hnd_repo_dblclick.
    DATA lt_query TYPE TABLE OF string.
    READ TABLE t_node_repository INTO s_node_repository
               WITH KEY node_key = node_key.
    IF sy-subrc = 0 AND NOT s_node_repository-relatkey IS INITIAL.
      PERFORM query_load USING s_node_repository-queryid
                         CHANGING lt_query.

      CALL METHOD s_tab_active-o_textedit-&gt;set_text
        EXPORTING
          table  = lt_query
        EXCEPTIONS
          OTHERS = 0.

      PERFORM ddic_refresh_tree.
    ENDIF.
  ENDMETHOD. &quot;hnd_repo_dblclick

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD hnd_result_toolbar
*&amp;---------------------------------------------------------------------*
*       Handle grid toolbar to add specific button
*----------------------------------------------------------------------*
  METHOD hnd_result_toolbar.
    DATA: ls_toolbar  TYPE stb_button.

* Add Separator
    CLEAR ls_toolbar.
    ls_toolbar-function = &apos;&amp;&amp;SEP99&apos;.
    ls_toolbar-butn_type = 3.
    APPEND ls_toolbar TO e_object-&gt;mt_toolbar.

* Add button to close the grid
    CLEAR ls_toolbar.
    ls_toolbar-function = &apos;CLOSE_GRID&apos;.
    ls_toolbar-icon = &apos;@3X@&apos;.
    ls_toolbar-quickinfo = &apos;Close Grid&apos;(m05).
    ls_toolbar-text = &apos;Close&apos;(m06).
    ls_toolbar-butn_type = 0.
    ls_toolbar-disabled = space.
    APPEND ls_toolbar TO e_object-&gt;mt_toolbar.
  ENDMETHOD.                    &quot;hnd_result_toolbar

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD hnd_result_user_command
*&amp;---------------------------------------------------------------------*
*       Handle grid user command to manage specific fcode
*       (menus &amp; toolbar)
*----------------------------------------------------------------------*
  METHOD hnd_result_user_command.
    IF e_ucomm = &apos;CLOSE_GRID&apos;.
      CALL METHOD o_splitter-&gt;set_row_height
        EXPORTING
          id     = 1
          height = 100.
    ENDIF.
  ENDMETHOD. &quot;hnd_result_user_command

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD hnd_ddic_drag
*&amp;---------------------------------------------------------------------*
*       Handle drag on DDIC field (store fieldname)
*----------------------------------------------------------------------*
  METHOD hnd_ddic_drag.
    DATA : lo_drag_object TYPE REF TO lcl_drag_object,
           ls_node        LIKE LINE OF s_tab_active-t_node_ddic,
           lw_text        TYPE string.

    READ TABLE s_tab_active-t_node_ddic INTO ls_node
               WITH KEY node_key = node_key.
    IF sy-subrc NE 0 OR ls_node-isfolder = abap_true. &quot;may not append
      MESSAGE &apos;Only fields can be drag&amp;drop to editor&apos;(m34)
               TYPE c_msg_success DISPLAY LIKE c_msg_error.
      RETURN.
    ENDIF.

* Get text for the node selected
    PERFORM ddic_get_field_from_node USING node_key ls_node-relatkey
                                     CHANGING lw_text.

* Store the node text
    CREATE OBJECT lo_drag_object.
    lo_drag_object-&gt;field = lw_text.
    drag_drop_object-&gt;object = lo_drag_object.

  ENDMETHOD.&quot;hnd_ddic_drag

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD hnd_editor_drop
*&amp;---------------------------------------------------------------------*
*       Handle drop on SQL Editor : paste fieldname at cursor position
*----------------------------------------------------------------------*
  METHOD hnd_editor_drop.
    DATA lo_drag_object TYPE REF TO lcl_drag_object.

    lo_drag_object ?= dragdrop_object-&gt;object.
    IF lo_drag_object IS INITIAL OR lo_drag_object-&gt;field IS INITIAL.
      RETURN.
    ENDIF.

* Paste fieldname to editor at drop position
    PERFORM editor_paste USING lo_drag_object-&gt;field line pos.

  ENDMETHOD.&quot;hnd_editor_drop

*&amp;---------------------------------------------------------------------*
*&amp;      CLASS lcl_application
*&amp;      METHOD hnd_ddic_toolbar_clic
*&amp;---------------------------------------------------------------------*
*       Handle DDIC toolbar button clic
*----------------------------------------------------------------------*
  METHOD hnd_ddic_toolbar_clic.

    CASE fcode.
      WHEN &apos;REFRESH&apos;.
        PERFORM ddic_refresh_tree.
      WHEN &apos;FIND&apos;.
        PERFORM ddic_find_in_tree.
      WHEN &apos;F4&apos;.
        PERFORM ddic_f4.
    ENDCASE.
  ENDMETHOD.                    &quot;hnd_ddic_toolbar_clic

ENDCLASS.                    &quot;lcl_application IMPLEMENTATION


*######################################################################*
*
*                             MAIN SECTION
*
*######################################################################*
START-OF-SELECTION.
  CALL SCREEN 10.


*######################################################################*
*
*                             PBO SECTION
*
*######################################################################*
*&amp;---------------------------------------------------------------------*
*&amp;      Module  STATUS_0010  OUTPUT
*&amp;---------------------------------------------------------------------*
*       Set status for main screen
*       and initialize custom container at first run
*----------------------------------------------------------------------*
MODULE status_0010 OUTPUT.
* Initialization of object screen
  IF o_container IS INITIAL.
    PERFORM screen_init.
    APPEND s_tab_active TO t_tabs.
  ENDIF.

  perform set_status_010.

ENDMODULE.                 &quot; STATUS_0010  OUTPUT

*&amp;---------------------------------------------------------------------*
*&amp;      Module  STATUS_0200  OUTPUT
*&amp;---------------------------------------------------------------------*
*       Set status for modal box (save query)
*----------------------------------------------------------------------*
MODULE status_0200 OUTPUT.

* Fill dropdown listbox with values
  PERFORM screen_init_listbox_0200.

  SET PF-STATUS &apos;STATUS200&apos;.
  SET TITLEBAR &apos;STATUS200&apos;.

ENDMODULE.                 &quot; STATUS_0200  OUTPUT

*&amp;---------------------------------------------------------------------*
*&amp;      Module  STATUS_0300  OUTPUT
*&amp;---------------------------------------------------------------------*
*       Set status for modal box (options)
*----------------------------------------------------------------------*
MODULE status_0300 OUTPUT.

* Create option screen
  IF o_container_options IS INITIAL.
    PERFORM options_init.
  ENDIF.

  SET PF-STATUS &apos;STATUS300&apos;.
  SET TITLEBAR &apos;STATUS300&apos;.

ENDMODULE.                 &quot; STATUS_0200  OUTPUT

*######################################################################*
*
*                             PAI SECTION
*
*######################################################################*

*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_0010  INPUT
*&amp;---------------------------------------------------------------------*
*       User command for main screen
*----------------------------------------------------------------------*
MODULE user_command_0010 INPUT.
  CASE w_okcode.
    WHEN &apos;EXIT&apos;.
      PERFORM screen_exit.
    WHEN &apos;EXECUTE&apos;.
      PERFORM query_process USING space space.
    WHEN &apos;DOWNLOAD&apos;.
      PERFORM query_process USING space abap_true.
    WHEN &apos;SAVE&apos;.
      PERFORM repo_save_query.
    WHEN &apos;SHOWCODE&apos;.
      PERFORM query_process USING abap_true space.
    WHEN &apos;HELP&apos;.
      PERFORM screen_display_help.
    WHEN &apos;OPTIONS&apos;.
      PERFORM options_display.
    WHEN &apos;NEW&apos;.
      PERFORM tab_new.
    WHEN &apos;XML&apos;.
      PERFORM export_xml.
    WHEN &apos;XMLI&apos;.
      PERFORM import_xml.
    WHEN OTHERS.
      IF w_okcode(3) = &apos;TAB&apos; AND w_tabstrip-activetab NE w_okcode.
        PERFORM leave_current_tab.

        READ TABLE t_tabs INTO s_tab_active INDEX w_okcode+3.
* Display editor / ddic / alv
        CALL METHOD s_tab_active-o_textedit-&gt;set_visible
          EXPORTING
            visible = abap_true.
        CALL METHOD s_tab_active-o_tree_ddic-&gt;set_visible
          EXPORTING
            visible = abap_true.
        IF NOT s_tab_active-o_alv_result IS INITIAL.
          CALL METHOD s_tab_active-o_alv_result-&gt;set_visible
            EXPORTING
              visible = abap_true.
        ENDIF.
        CALL METHOD o_splitter-&gt;set_row_height
          EXPORTING
            id     = 1
            height = s_tab_active-row_height.
        w_tabstrip-activetab = w_okcode.
      ENDIF.
  ENDCASE.
ENDMODULE.                 &quot; USER_COMMAND_0010  INPUT

*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_0200  INPUT
*&amp;---------------------------------------------------------------------*
*       PAI module for modal box (save query)
*----------------------------------------------------------------------*
MODULE user_command_0200 INPUT.
  CASE w_okcode.
    WHEN &apos;CLOSE&apos;.
      CLEAR s_options.
      LEAVE TO SCREEN 0.
    WHEN &apos;OK&apos;.
      LEAVE TO SCREEN 0.
  ENDCASE.
ENDMODULE.                 &quot; USER_COMMAND_0200  INPUT

*&amp;---------------------------------------------------------------------*
*&amp;      Module  USER_COMMAND_0300  INPUT
*&amp;---------------------------------------------------------------------*
*       PAI module for modal box (options)
*----------------------------------------------------------------------*
MODULE user_command_0300 INPUT.
  CASE w_okcode.
    WHEN &apos;CLOSE&apos; OR &apos;OK&apos;.
      LEAVE TO SCREEN 0.
  ENDCASE.
ENDMODULE.                 &quot; USER_COMMAND_0200  INPUT

*######################################################################*
*
*                             FORM SECTION
*
*######################################################################*

*&amp;---------------------------------------------------------------------*
*&amp;      Form  SCREEN_INIT
*&amp;---------------------------------------------------------------------*
*       Initialize all objects on the screen
*----------------------------------------------------------------------*
FORM screen_init.
* Get user default values
  PERFORM options_load.

* Create the handle object (required to catch events)
  CREATE OBJECT o_handle_event.

* Split the screen into 4 parts
  PERFORM screen_init_splitter.

* Init History Tree
  PERFORM repo_init.

* Init DDIC toolbar
  PERFORM ddic_toolbar_init.

* Init DDic tree
  PERFORM ddic_init.

* Init Query editor
  PERFORM editor_init.

* Init ALV result object
  PERFORM result_init.

ENDFORM.                    &quot; SCREEN_INIT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  SCREEN_INIT_SPLITTER
*&amp;---------------------------------------------------------------------*
*       Split the main screen in 2 lines
* 1 line with 3 columns : Repository tree / Query code / Ddic tree
* 1 line with ALV result
*----------------------------------------------------------------------*
FORM screen_init_splitter.

* Create the custom container
  CREATE OBJECT o_container
    EXPORTING
      container_name = &apos;CUSTCONT&apos;.

* Insert splitter into this container
  CREATE OBJECT o_splitter
    EXPORTING
      parent  = o_container
      rows    = 2
      columns = 1.

* Get the first row of the main splitter
  CALL METHOD o_splitter-&gt;get_container
    EXPORTING
      row       = 1
      column    = 1
    RECEIVING
      container = o_container_top.

*  Spliter for the high part (first row)
  CREATE OBJECT o_splitter_top
    EXPORTING
      parent  = o_container_top
      rows    = 1
      columns = 3.

* Get the right part of the top part
  CALL METHOD o_splitter_top-&gt;get_container
    EXPORTING
      row       = 1
      column    = 3
    RECEIVING      &quot;container = o_container_ddic.
      container = o_container_top_right.

* Add a toolbar to the DDIC container
  CREATE OBJECT o_splitter_top_right
    EXPORTING
      i_r_container = o_container_top_right.

* Affect an object to each &quot;cell&quot; of the high sub splitter
  CALL METHOD o_splitter_top-&gt;get_container
    EXPORTING
      row       = 1
      column    = 1
    RECEIVING
      container = o_container_repository.

  CALL METHOD o_splitter_top-&gt;get_container
    EXPORTING
      row       = 1
      column    = 2
    RECEIVING
      container = o_container_query.

  CALL METHOD o_splitter_top_right-&gt;get_controlcontainer
    RECEIVING
      e_r_container_control = o_container_ddic.

  CALL METHOD o_splitter-&gt;get_container
    EXPORTING
      row       = 2
      column    = 1
    RECEIVING
      container = o_container_result.

* Initial repartition :
*   line 1 = 100% (code+repo+ddic)
*   line 2 = 0% (result)
*   line 1 col 1 &amp; 3 = 20% (repo &amp; ddic)
*   line 1 col 2 = 60% (code)
  CALL METHOD o_splitter-&gt;set_row_height
    EXPORTING
      id     = 1
      height = 100.

  CALL METHOD o_splitter_top-&gt;set_column_width
    EXPORTING
      id    = 1
      width = 20.
  CALL METHOD o_splitter_top-&gt;set_column_width
    EXPORTING
      id    = 3
      width = 20.

ENDFORM.                    &quot; SCREEN_INIT_SPLITTER

*&amp;---------------------------------------------------------------------*
*&amp;      Form  ddic_toolbar_init
*&amp;---------------------------------------------------------------------*
*       Initialize DDIC Toolbar
*
*----------------------------------------------------------------------*
FORM ddic_toolbar_init.
  DATA: lt_button TYPE ttb_button,
        ls_button LIKE LINE OF lt_button,
        lt_events TYPE cntl_simple_events,
        ls_events LIKE LINE OF lt_events.

*  Toolbar already created by class CL_RSAWB_SPLITTER_FOR_TOOLBAR
  o_toolbar = o_splitter_top_right-&gt;get_toolbar( ).

* Add buttons to toolbar
  CLEAR ls_button.
  ls_button-function = &apos;REFRESH&apos;.
  ls_button-icon = &apos;@42@&apos;.
  ls_button-quickinfo = &apos;Refresh DDIC tree&apos;(m41).
  ls_button-text = &apos;Refresh&apos;(m40).
  ls_button-butn_type = 0.
  APPEND ls_button TO lt_button.

  CLEAR ls_button.
  ls_button-function = &apos;FIND&apos;.
  ls_button-icon = &apos;@13@&apos;.
  ls_button-quickinfo = &apos;Search in DDIC tree&apos;(m43).
  ls_button-text = &apos;Find&apos;(m42).
  ls_button-butn_type = 0.
  APPEND ls_button TO lt_button.

  CLEAR ls_button.
  ls_button-function = &apos;F4&apos;.
  ls_button-icon = &apos;@6T@&apos;.
  ls_button-quickinfo = &apos;Display values of sel. field&apos;(m54).
  ls_button-text = &apos;Value list&apos;(m55).
  ls_button-butn_type = 0.
  APPEND ls_button TO lt_button.

  CALL METHOD o_toolbar-&gt;add_button_group
    EXPORTING
      data_table = lt_button.

* Register events
  ls_events-eventid = cl_gui_toolbar=&gt;m_id_function_selected.
  ls_events-appl_event = space.
  APPEND ls_events TO lt_events.
  CALL METHOD o_toolbar-&gt;set_registered_events
    EXPORTING
      events = lt_events.

  SET HANDLER o_handle_event-&gt;hnd_ddic_toolbar_clic FOR o_toolbar.

ENDFORM.                    &quot;ddic_toolbar_init

*&amp;---------------------------------------------------------------------*
*&amp;      Form  EDITOR_INIT
*&amp;---------------------------------------------------------------------*
*       Initialize the sql editor object
*       Fill it with last query, or template if no previous query
*----------------------------------------------------------------------*
FORM editor_init.
  DATA : lt_events     TYPE cntl_simple_events,
         ls_event      TYPE cntl_simple_event,
         lt_default    TYPE TABLE OF string,
         lw_queryid    TYPE ztoad-queryid,
         lo_dragrop    TYPE REF TO cl_dragdrop,
         lw_dummy_date TYPE timestamp.                      &quot;#EC NEEDED

* For first tab, Get last query used
  IF t_tabs IS INITIAL.
    CONCATENATE sy-uname &apos;#%&apos; INTO lw_queryid.
* aedat is not used but added in select for compatibility reason
    SELECT queryid aedat
           INTO (lw_queryid, lw_dummy_date)
           FROM ztoad
           UP TO 1 ROWS
           WHERE queryid LIKE lw_queryid
           AND owner = sy-uname
           ORDER BY aedat DESCENDING.
    ENDSELECT.
    IF sy-subrc = 0.
      PERFORM query_load USING lw_queryid
                         CHANGING lt_default.
      PERFORM repo_focus_query USING lw_queryid.
    ENDIF.
  ENDIF.

* If no last query found, use default template
  IF lt_default IS INITIAL.
    PERFORM editor_get_default_query CHANGING lt_default.
  ENDIF.

* Create the sql editor
*  CREATE OBJECT s_tab_active-o_container_query
*    EXPORTING
*      parent = o_container_query.

  CREATE OBJECT s_tab_active-o_textedit
    EXPORTING
      parent = o_container_query.

* Register events
  SET HANDLER o_handle_event-&gt;hnd_editor_f1 FOR s_tab_active-o_textedit.
  SET HANDLER o_handle_event-&gt;hnd_editor_drop FOR s_tab_active-o_textedit.

  ls_event-eventid = cl_gui_textedit=&gt;event_f1.
  APPEND ls_event TO lt_events.

  CALL METHOD s_tab_active-o_textedit-&gt;set_registered_events
    EXPORTING
      events                    = lt_events
    EXCEPTIONS
      cntl_error                = 1
      cntl_system_error         = 2
      illegal_event_combination = 3.
  IF sy-subrc &lt;&gt; 0.
    IF sy-msgno IS NOT INITIAL.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              DISPLAY LIKE c_msg_error
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 .
    ENDIF.
  ENDIF.

* Activate Code Completion and Quickinfo
* Comment the paragraph if CL_ABAP_PARSER doesnt exists on your system
* BEGIN OF ABAP PARSER
  DATA lo_completer TYPE REF TO cl_abap_parser.
  CALL METHOD s_tab_active-o_textedit-&gt;(&apos;INIT_COMPLETER&apos;).
  CALL METHOD s_tab_active-o_textedit-&gt;(&apos;GET_COMPLETER&apos;)
    RECEIVING
      m_parser = lo_completer.
  SET HANDLER lo_completer-&gt;handle_completion_request FOR s_tab_active-o_textedit.
  SET HANDLER lo_completer-&gt;handle_insertion_request FOR s_tab_active-o_textedit.
  SET HANDLER lo_completer-&gt;handle_quickinfo_request FOR s_tab_active-o_textedit.
  s_tab_active-o_textedit-&gt;register_event_completion( ).
  s_tab_active-o_textedit-&gt;register_event_quick_info( ).
  s_tab_active-o_textedit-&gt;register_event_insert_pattern( ).
* END OF ABAP PARSER

* Manage Drop on SQL editor
  CREATE OBJECT lo_dragrop.
  CALL METHOD lo_dragrop-&gt;add
    EXPORTING
      flavor     = &apos;EDIT_INSERT&apos;
      dragsrc    = space
      droptarget = abap_true
      effect     = cl_dragdrop=&gt;copy.
  CALL METHOD s_tab_active-o_textedit-&gt;set_dragdrop
    EXPORTING
      dragdrop = lo_dragrop.

* Set Default template
  CALL METHOD s_tab_active-o_textedit-&gt;set_text
    EXPORTING
      table  = lt_default
    EXCEPTIONS
      OTHERS = 0.

* Set focus
  CALL METHOD cl_gui_control=&gt;set_focus
    EXPORTING
      control = s_tab_active-o_textedit
    EXCEPTIONS
      OTHERS  = 0.

  PERFORM ddic_refresh_tree.
ENDFORM.                    &quot; EDITOR_INIT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  query_process
*&amp;---------------------------------------------------------------------*
*       Process selected query : execute or display code
*----------------------------------------------------------------------*
*      --&gt;FW_DISPLAY : Flag abap_true to display code
*      --&gt;FW_DOWNLOAD: Flag abap_true to save results into file
*----------------------------------------------------------------------*
FORM query_process USING fw_display TYPE c
                         fw_download TYPE c.
  DATA : lw_query         TYPE string,
         lw_select        TYPE string,
         lw_from          TYPE string,
         lw_where         TYPE string,
         lw_union         TYPE string,
         lw_query2        TYPE string,
         lw_command       TYPE string,
         lw_rows(6)       TYPE n,
         lw_program       TYPE sy-repid,
         lo_result        TYPE REF TO data,
         lo_result2       TYPE REF TO data,
         lt_fieldlist     TYPE ty_fieldlist_table,
         lt_fieldlist2    TYPE ty_fieldlist_table,
         lw_count_only(1) TYPE c,
         lw_time          TYPE p LENGTH 8 DECIMALS 2,
         lw_time2         LIKE lw_time,
         lw_count         TYPE i,
         lw_count2        LIKE lw_count,
         lw_charnumb(12)  TYPE c,
         lw_msg           TYPE string,
         lw_noauth(1)     TYPE c,
         lw_newsyntax(1)  TYPE c,
         lw_answer(1)     TYPE c,
         lw_from_concat   LIKE lw_from,
         lw_error(1)      TYPE c.

  FIELD-SYMBOLS : &lt;lft_data&gt;  TYPE STANDARD TABLE,
                  &lt;lft_data2&gt; TYPE STANDARD TABLE.

* Get only usefull code for current query
  PERFORM editor_get_query USING space CHANGING lw_query.

* Parse SELECT Query
  PERFORM query_parse USING lw_query
                      CHANGING lw_select lw_from lw_where
                               lw_union lw_rows lw_noauth
                               lw_newsyntax lw_error.
  IF lw_error NE space.
    MESSAGE &apos;Cannot parse the query&apos;(m07) TYPE c_msg_error.
  ENDIF.

* Not a select query
  IF lw_select IS INITIAL.
    PERFORM query_parse_noselect USING    lw_query
                                 CHANGING lw_noauth
                                          lw_command
                                          lw_from
                                          lw_where.
    IF lw_noauth NE space.
      PERFORM ddic_set_tree USING lw_from.
      RETURN.
    ENDIF.

* For native sql command, execute it directly
    IF lw_command = c_native_command.
      PERFORM ddic_set_tree USING lw_from.
      PERFORM query_process_native USING lw_where.
      RETURN.
    ENDIF.

* For other no select command, generate program
    IF w_run LT c_query_max_exec.
      PERFORM query_generate_noselect USING lw_command lw_from
                                            lw_where fw_display
                                      CHANGING lw_program.
      w_run = w_run + 1.
    ELSE.
      MESSAGE &apos;No more run available. Please restart program&apos;(m50)
              TYPE c_msg_error.
    ENDIF.
    IF fw_display IS INITIAL.
      PERFORM ddic_set_tree USING lw_from.
      CONCATENATE &apos;Are you sure you want to do a&apos;(m31) lw_command
                  &apos;on table&apos;(m32) lw_from &apos;?&apos;(m33)
                  INTO lw_msg SEPARATED BY space.
      CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
        EXPORTING
          titlebar              = &apos;Warning : critical operation&apos;(t04)
          text_question         = lw_msg
          default_button        = &apos;2&apos;
          display_cancel_button = space
        IMPORTING
          answer                = lw_answer
        EXCEPTIONS
          text_not_found        = 1
          OTHERS                = 2.
      IF sy-subrc NE 0 OR lw_answer NE &apos;1&apos;.
        RETURN.
      ENDIF.
    ENDIF.
    lw_count_only = abap_true. &quot;no result grid to display
  ELSEIF lw_noauth NE space.
    PERFORM ddic_set_tree USING lw_from.
    RETURN.
  ELSEIF lw_from IS INITIAL.
    PERFORM ddic_set_tree USING lw_from.
    MESSAGE &apos;Cannot parse the query&apos;(m07) TYPE c_msg_error.
  ELSE.
* Generate SELECT subroutine
    IF w_run LT c_query_max_exec.
      PERFORM query_generate USING lw_select lw_from
                                   lw_where fw_display
                                   lw_newsyntax
                             CHANGING lw_program lw_rows
                                      lt_fieldlist lw_count_only.
      IF lw_program IS INITIAL.
        PERFORM ddic_set_tree USING lw_from.
        RETURN.
      ENDIF.
      w_run = w_run + 1.
    ELSE.
      MESSAGE &apos;No more run available. Please restart program&apos;(m50)
              TYPE c_msg_error.
    ENDIF.
  ENDIF.


* Call the generated subroutine
  IF NOT lw_program IS INITIAL.
    PERFORM run_sql IN PROGRAM (lw_program)
                    CHANGING lo_result lw_time lw_count.
    lw_from_concat = lw_from.
* For union, process second (and further) query
    WHILE NOT lw_union IS INITIAL.
* Parse Query
      lw_query2 = lw_union.
      PERFORM query_parse USING lw_query2
                          CHANGING lw_select lw_from lw_where
                                   lw_union lw_rows lw_noauth
                                   lw_newsyntax lw_error.
      CONCATENATE lw_from_concat &apos;JOIN&apos; lw_from INTO lw_from_concat.
      IF lw_noauth NE space.
        PERFORM ddic_set_tree USING lw_from_concat.
        RETURN.
      ELSEIF lw_select IS INITIAL OR lw_from IS INITIAL
      OR lw_error = abap_true.
        PERFORM ddic_set_tree USING lw_from_concat.
        MESSAGE &apos;Cannot parse the unioned query&apos;(m08) TYPE c_msg_error.
        EXIT. &quot;exit while
      ENDIF.
* Generate subroutine
      IF w_run LT c_query_max_exec.
        PERFORM query_generate USING lw_select lw_from
                                     lw_where fw_display
                                     lw_newsyntax
                               CHANGING lw_program lw_rows
                                        lt_fieldlist2 lw_count_only.
        IF lw_program IS INITIAL.
          PERFORM ddic_set_tree USING lw_from_concat.
          RETURN.
        ENDIF.
        w_run = w_run + 1.
      ELSE.
        MESSAGE &apos;No more run available. Please restart program&apos;(m50)
                TYPE c_msg_error.
      ENDIF.
* Call the generated subroutine
      PERFORM run_sql IN PROGRAM (lw_program)
                      CHANGING lo_result2 lw_time2 lw_count2.

* Append lines of the further queries to the first query
      ASSIGN lo_result-&gt;* TO &lt;lft_data&gt;.
      ASSIGN lo_result2-&gt;* TO &lt;lft_data2&gt;.
      APPEND LINES OF &lt;lft_data2&gt; TO &lt;lft_data&gt;.
      REFRESH &lt;lft_data2&gt;.
      lw_time = lw_time + lw_time2.
      lw_count = lw_count + lw_count2.
    ENDWHILE.

    PERFORM ddic_set_tree USING lw_from_concat.

* Display message
    lw_charnumb = lw_time.
    CONCATENATE &apos;Query executed in&apos;(m09) lw_charnumb INTO lw_msg
                SEPARATED BY space.
    lw_charnumb = lw_count.
    IF NOT lw_select IS INITIAL.
      CONCATENATE lw_msg &apos;seconds.&apos;(m10)
                  lw_charnumb &apos;entries found&apos;(m11)
                  INTO lw_msg SEPARATED BY space.
    ELSE.
      CONCATENATE lw_msg &apos;seconds.&apos;(m10)
                  lw_charnumb &apos;entries affected&apos;(m12)
                  INTO lw_msg SEPARATED BY space.
    ENDIF.
    CONDENSE lw_msg.
    MESSAGE lw_msg TYPE c_msg_success.


* Display result except for count(*)
    IF lw_count_only IS INITIAL.
      IF fw_download = space.
        PERFORM result_display USING lo_result lt_fieldlist lw_query.
      ELSE.
        PERFORM result_save_file USING lo_result lt_fieldlist.
      ENDIF.
    ENDIF.

    PERFORM repo_save_current_query.
  ENDIF.
ENDFORM.                    &quot; QUERY_PROCESS

*&amp;---------------------------------------------------------------------*
*&amp;      Form  EDITOR_GET_QUERY
*&amp;---------------------------------------------------------------------*
*       Return active query without comment
*----------------------------------------------------------------------*
*      --&gt;FW_FORCE_LAST  Keep last request
*      &lt;--FW_QUERY       Query code
*----------------------------------------------------------------------*
FORM editor_get_query USING fw_force_last TYPE c
                      CHANGING fw_query TYPE string.
  DATA : lt_query         TYPE soli_tab,
         ls_query         LIKE LINE OF lt_query,
         ls_find          TYPE match_result,
         lt_find          TYPE match_result_tab,
         lt_find_sub      TYPE match_result_tab,
         lw_lines         TYPE i,
         lw_cursor_line   TYPE i,
         lw_cursor_pos    TYPE i,
         lw_delto_line    TYPE i,
         lw_delto_pos     TYPE i,
         lw_cursor_offset TYPE i,
         lw_last          TYPE c.

  CLEAR fw_query.

* Get selected content
  CALL METHOD s_tab_active-o_textedit-&gt;get_selected_text_as_table
    IMPORTING
      table = lt_query[].

* if no selected content, get complete content of abap edit box
  IF lt_query[] IS INITIAL.
    CALL METHOD s_tab_active-o_textedit-&gt;get_text
      IMPORTING
        table  = lt_query[]
      EXCEPTIONS
        OTHERS = 1.
  ENDIF.

* Remove * comment
  LOOP AT lt_query INTO ls_query WHERE line(1) = &apos;*&apos;.
    CLEAR ls_query-line.
    MODIFY lt_query FROM ls_query.
  ENDLOOP.

* Remove &quot; comment
  LOOP AT lt_query INTO ls_query WHERE line CS &apos;&quot;&apos;.
*    condense ls_query-line.
    FIND ALL OCCURRENCES OF &apos;&quot;&apos; IN ls_query-line RESULTS lt_find.
    IF sy-subrc NE 0. &quot;may not occurs
      CONTINUE.
    ENDIF.
    LOOP AT lt_find INTO ls_find.
      IF ls_find-offset GT 0.
* Search open &apos;
        FIND ALL OCCURRENCES OF &apos;&apos;&apos;&apos; IN ls_query-line(ls_find-offset)
             RESULTS lt_find_sub.
        IF sy-subrc = 0.
          DESCRIBE TABLE lt_find_sub LINES lw_lines.
          lw_lines = lw_lines MOD 2.
          IF lw_lines = 1.
            CONTINUE.
          ENDIF.
        ENDIF.
        ls_query-line = ls_query-line(ls_find-offset).
        EXIT. &quot;exit loop
      ELSE.
        CLEAR ls_query-line.
        EXIT. &quot;exit loop
      ENDIF.
    ENDLOOP.
    MODIFY lt_query FROM ls_query.
  ENDLOOP.

* Find active query
  CALL METHOD s_tab_active-o_textedit-&gt;get_selection_pos
    IMPORTING
      from_line = lw_cursor_line
      from_pos  = lw_cursor_pos.
  lw_cursor_offset = lw_cursor_pos - 1.

  FIND ALL OCCURRENCES OF &apos;.&apos; IN TABLE lt_query RESULTS lt_find.
  CLEAR : lw_delto_line,
          lw_delto_pos,
          lw_last.
  LOOP AT lt_find INTO ls_find.
    AT LAST.
      lw_last = abap_true.
    ENDAT.
* Search for open &apos;
    IF ls_find-offset GT 0.
      READ TABLE lt_query INTO ls_query INDEX ls_find-line.
      FIND ALL OCCURRENCES OF &apos;&apos;&apos;&apos; IN ls_query(ls_find-offset)
           RESULTS lt_find_sub.
      DESCRIBE TABLE lt_find_sub LINES lw_lines.
      lw_lines = lw_lines MOD 2.
* If open &apos; found, ignore the dot
      IF lw_lines = 1.
        CONTINUE.
      ENDIF.
    ENDIF.

* Active Query
    IF ls_find-line GT lw_cursor_line
    OR ( ls_find-line = lw_cursor_line
         AND ls_find-offset GE lw_cursor_offset )
    OR ( lw_last = abap_true AND fw_force_last = abap_true ).
* Delete all query after query active
      ls_find-line = ls_find-line + 1.
      DELETE lt_query FROM ls_find-line.
      ls_find-line = ls_find-line - 1.
* Do not keep the . for active query
      IF ls_find-offset = 0.
        DELETE lt_query FROM ls_find-line.
      ELSE.
        ls_query-line = ls_query-line(ls_find-offset).
        MODIFY lt_query FROM ls_query INDEX ls_find-line.
      ENDIF.
      EXIT.
* Query before active
    ELSE.
      lw_delto_line = ls_find-line.
      lw_delto_pos = ls_find-offset + 1.
    ENDIF.
  ENDLOOP.

* Delete all query before query active
  IF NOT lw_delto_line IS INITIAL.
    IF lw_delto_line GT 1.
      lw_delto_line = lw_delto_line - 1.
      DELETE lt_query FROM 1 TO lw_delto_line.
    ENDIF.
    READ TABLE lt_query INTO ls_query INDEX 1.
    ls_query-line(lw_delto_pos) = &apos;&apos;.
    MODIFY lt_query FROM ls_query INDEX 1.
  ENDIF.

* Delete empty lines
  DELETE lt_query WHERE line CO &apos; .&apos;.

* Build query string &amp; Remove unnessential spaces
  LOOP AT lt_query INTO ls_query.
    CONDENSE ls_query-line.
    SHIFT ls_query-line LEFT DELETING LEADING space.
    CONCATENATE fw_query ls_query-line INTO fw_query SEPARATED BY space.
  ENDLOOP.
  IF NOT fw_query IS INITIAL.
    fw_query = fw_query+1.
  ENDIF.

* If no query selected, try to get the last one
  IF lt_query IS INITIAL AND fw_force_last = space.
    PERFORM editor_get_query USING abap_true
                             CHANGING fw_query.
  ENDIF.
ENDFORM.                    &quot; EDITOR_GET_QUERY

*&amp;---------------------------------------------------------------------*
*&amp;      Form  QUERY_PARSE
*&amp;---------------------------------------------------------------------*
*       Split the query into 3 parts : Select / From / Where
*       - Select : List of the fields to extract
*       - From   : List of the tables - with join condition
*       - Where  : List of filters + group, order, having clauses
*----------------------------------------------------------------------*
*      --&gt;FW_QUERY   Query to parse
*      &lt;--FW_SELECT  Select part of the query
*      &lt;--FW_FROM    From part of the query
*      &lt;--FW_WHERE   Where part of the query
*      &lt;--FW_ROWS    Number of rows to display
*      &lt;--FW_UNION   Union part of the query
*      &lt;--FW_NOAUTH  Unallowed table entered
*      &lt;--FW_NEWSYNTAX Use new SQL syntax introduced with NW7.40 SP5
*      &lt;--FW_ERROR   Cannot parse the query
*----------------------------------------------------------------------*
FORM query_parse  USING    fw_query TYPE string
                  CHANGING fw_select TYPE string
                           fw_from TYPE string
                           fw_where TYPE string
                           fw_union TYPE string
                           fw_rows TYPE n
                           fw_noauth TYPE c
                           fw_newsyntax TYPE c
                           fw_error TYPE c.

  DATA : ls_find_select TYPE match_result,
         ls_find_from   TYPE match_result,
         ls_find_where  TYPE match_result,
         ls_sub         LIKE LINE OF ls_find_select-submatches,
         lw_offset      TYPE i,
         lw_length      TYPE i,
         lw_query       TYPE string,
         lo_regex       TYPE REF TO cl_abap_regex,
         lt_split       TYPE TABLE OF string,
         lw_string      TYPE string,
         lw_tabix       TYPE i,
         lw_table       TYPE tabname.

  CLEAR : fw_select,
          fw_from,
          fw_where,
          fw_rows,
          fw_union,
          fw_noauth,
          fw_newsyntax.

  lw_query = fw_query.

* Search union
  FIND FIRST OCCURRENCE OF &apos; UNION SELECT &apos; IN lw_query
       RESULTS ls_find_select IGNORING CASE.
  IF sy-subrc = 0.
    lw_offset = ls_find_select-offset + 7.
    fw_union = lw_query+lw_offset.
    lw_query = lw_query(ls_find_select-offset).
  ENDIF.

* Search UP TO xxx ROWS.
* Catch the number of rows, delete command in query
  CREATE OBJECT lo_regex
    EXPORTING
      pattern     = &apos;UP TO ([0-9]+) ROWS&apos;
      ignore_case = abap_true.
  FIND FIRST OCCURRENCE OF REGEX lo_regex
       IN lw_query RESULTS ls_find_select.
  IF sy-subrc = 0.
    READ TABLE ls_find_select-submatches INTO ls_sub INDEX 1.
    IF sy-subrc = 0.
      fw_rows = lw_query+ls_sub-offset(ls_sub-length).
    ENDIF.
    REPLACE FIRST OCCURRENCE OF REGEX lo_regex IN lw_query WITH &apos;&apos;.
  ELSE.
* Set default number of rows
    fw_rows = s_customize-default_rows.
  ENDIF.

* Remove unused INTO (CORRESPONDING FIELDS OF)(TABLE)
* Detect new syntax in internal table name
  CONCATENATE &apos;(INTO|APPENDING)( TABLE&apos;
              &apos;| CORRESPONDING FIELDS OF TABLE |&apos;
              &apos;CORRESPONDING FIELDS OF | )(\S*)&apos;
              INTO lw_string SEPARATED BY space.
  CREATE OBJECT lo_regex
    EXPORTING
      pattern     = lw_string
      ignore_case = abap_true.
  FIND FIRST OCCURRENCE OF REGEX lo_regex
       IN lw_query RESULTS ls_find_select.
  IF sy-subrc = 0.
    IF ls_find_select-length NE 0
    AND fw_query+ls_find_select-offset(ls_find_select-length) CS &apos;@&apos;.
      fw_newsyntax = abap_true.
    ENDIF.
    REPLACE FIRST OCCURRENCE OF REGEX lo_regex IN lw_query WITH &apos;&apos;.
  ENDIF.

* Search SELECT
  FIND FIRST OCCURRENCE OF &apos;SELECT &apos; IN lw_query
       RESULTS ls_find_select IGNORING CASE.
  IF sy-subrc NE 0.
    RETURN.
  ENDIF.

* Search FROM
  FIND FIRST OCCURRENCE OF &apos; FROM &apos;
       IN SECTION OFFSET ls_find_select-offset OF lw_query
       RESULTS ls_find_from IGNORING CASE.
  IF sy-subrc NE 0.
    fw_error = abap_true.
    RETURN.
  ENDIF.

* Search WHERE / GROUP BY / HAVING / ORDER BY
  FIND FIRST OCCURRENCE OF &apos; WHERE &apos;
       IN SECTION OFFSET ls_find_from-offset OF lw_query
       RESULTS ls_find_where IGNORING CASE.
  IF sy-subrc NE 0.
    FIND FIRST OCCURRENCE OF &apos; GROUP BY &apos; IN lw_query
         RESULTS ls_find_where IGNORING CASE.
  ENDIF.
  IF sy-subrc NE 0.
    FIND FIRST OCCURRENCE OF &apos; HAVING &apos; IN lw_query
         RESULTS ls_find_where IGNORING CASE.
  ENDIF.
  IF sy-subrc NE 0.
    FIND FIRST OCCURRENCE OF &apos; ORDER BY &apos; IN lw_query
         RESULTS ls_find_where IGNORING CASE.
  ENDIF.

  lw_offset = ls_find_select-offset + 7.
  lw_length = ls_find_from-offset - ls_find_select-offset - 7.
  IF lw_length LE 0.
    fw_error = abap_true.
    RETURN.
  ENDIF.
  fw_select = lw_query+lw_offset(lw_length).

* Detect new syntax in comma field select separator
  IF fw_select CS &apos;,&apos;.
    fw_newsyntax = abap_true.
  ENDIF.

  lw_offset = ls_find_from-offset + 6.
  IF ls_find_where IS INITIAL.
    fw_from = lw_query+lw_offset.
    fw_where = &apos;&apos;.
  ELSE.
    lw_length = ls_find_where-offset - ls_find_from-offset - 6.
    fw_from = lw_query+lw_offset(lw_length).
    lw_offset = ls_find_where-offset.
    fw_where = lw_query+lw_offset.
  ENDIF.

* Authority-check on used select tables
  IF s_customize-auth_object NE space OR s_customize-auth_select NE &apos;*&apos;.
    CONCATENATE &apos;JOIN&apos; fw_from INTO lw_string SEPARATED BY space.
    TRANSLATE lw_string TO UPPER CASE.
    SPLIT lw_string AT space INTO TABLE lt_split.
    LOOP AT lt_split INTO lw_string.
      lw_tabix = sy-tabix + 1.
      CHECK lw_string = &apos;JOIN&apos;.
* Read next line (table name)
      READ TABLE lt_split INTO lw_table INDEX lw_tabix.
      CHECK sy-subrc = 0.

      IF s_customize-auth_object NE space.
        AUTHORITY-CHECK OBJECT s_customize-auth_object
                 ID &apos;TABLE&apos; FIELD lw_table
                 ID &apos;ACTVT&apos; FIELD s_customize-actvt_select.
      ELSEIF s_customize-auth_select NE &apos;*&apos;
      AND NOT lw_table CP s_customize-auth_select.
        sy-subrc = 4.
      ENDIF.
      sy-subrc = 0. &quot;APC!
      IF sy-subrc NE 0.
        CONCATENATE &apos;No authorisation for table&apos;(m13) lw_table
                    INTO lw_string SEPARATED BY space.
        MESSAGE lw_string TYPE c_msg_success DISPLAY LIKE c_msg_error.
        CLEAR fw_from.
        fw_noauth = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.
  ENDIF.

ENDFORM.                    &quot; QUERY_PARSE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  add_line_to_table
*&amp;---------------------------------------------------------------------*
*       Add a string line in a table
*       Break line at 255 char, respecting words if possible
*----------------------------------------------------------------------*
*      --&gt;FW_LINE    Line to add in table
*      &lt;--FT_TABLE   Table to append
*----------------------------------------------------------------------*
FORM add_line_to_table USING fw_line TYPE string
                       CHANGING ft_table TYPE table.
  DATA : lw_length TYPE i,
         lw_offset TYPE i,
         ls_find   TYPE match_result.

  lw_length = strlen( fw_line ).
  lw_offset = 0.
  DO.
    IF lw_length LE c_line_max.
      APPEND fw_line+lw_offset(lw_length) TO ft_table.
      EXIT. &quot;exit do
    ELSE.
      FIND ALL OCCURRENCES OF REGEX &apos;\s&apos; &quot;search space
           IN SECTION OFFSET lw_offset LENGTH c_line_max
           OF fw_line RESULTS ls_find.
      IF sy-subrc NE 0.
        APPEND fw_line+lw_offset(c_line_max) TO ft_table.
        lw_length = lw_length - c_line_max.
        lw_offset = lw_offset + c_line_max.
      ELSE.
        ls_find-length = ls_find-offset - lw_offset.
        APPEND fw_line+lw_offset(ls_find-length) TO ft_table.
        lw_length = lw_length + lw_offset - ls_find-offset - 1.
        lw_offset = ls_find-offset + 1.
      ENDIF.
    ENDIF.
  ENDDO.

ENDFORM.                    &quot;add_line_to_table

*&amp;---------------------------------------------------------------------*
*&amp;      Form  QUERY_GENERATE
*&amp;---------------------------------------------------------------------*
*       Create SELECT SQL query in a new generated temp program
*----------------------------------------------------------------------*
*      --&gt;FW_SELECT    Select part of the query
*      --&gt;FW_FROM      From part of the query
*      --&gt;FW_WHERE     Where part of the query
*      --&gt;FW_DISPLAY   Display code instead of generated routine
*      --&gt;FW_NEWSYNTAX Use new SQL syntax introduced with NW7.40 SP5
*      &lt;--FW_PROGRAM   Name of the generated program
*      &lt;--FW_ROWS      Number of rows to display
*      &lt;--FT_FIELDLIST List of fields to display
*      &lt;--FW_COUNT     = true if query is only count( * )
*----------------------------------------------------------------------*
FORM query_generate  USING    fw_select TYPE string
                              fw_from TYPE string
                              fw_where TYPE string
                              fw_display TYPE c
                              fw_newsyntax TYPE c
                     CHANGING fw_program TYPE sy-repid
                              fw_rows TYPE n
                              ft_fieldlist TYPE ty_fieldlist_table
                              fw_count TYPE c.

  DATA : lt_code_string TYPE TABLE OF string,
         lt_split       TYPE TABLE OF string,
         lw_string      TYPE string,
         lw_string2     TYPE string,
         BEGIN OF ls_table_alias,
           table(50) TYPE c,
           alias(50) TYPE c,
         END OF ls_table_alias,
         lt_table_alias      LIKE TABLE OF ls_table_alias,
         lw_select           TYPE string,
         lw_from             TYPE string,
         lw_index            TYPE i,
         lw_select_distinct  TYPE c,
         lw_select_length    TYPE i,
         lw_char_10(10)      TYPE c,
         lw_field_number(6)  TYPE n,
         lw_current_line     TYPE i,
         lw_current_length   TYPE i,
         lw_struct_line      TYPE string,
         lw_struct_line_type TYPE string,
         lw_select_table     TYPE string,
         lw_select_field     TYPE string,
         lw_dd03l_fieldname  TYPE dd03l-fieldname,
         lw_position_dummy   TYPE dd03l-position,
         lw_mess(255),
         lw_line             TYPE i,
         lw_word(30),
         ls_fieldlist        TYPE ty_fieldlist,
         lw_strlen_string    TYPE string,
         lw_explicit         TYPE string.

  DEFINE c.
    lw_strlen_string = &amp;1.
    perform add_line_to_table using lw_strlen_string
                              changing lt_code_string.
  END-OF-DEFINITION.

  CLEAR : lw_select_distinct,
          fw_count.

* Write Header
  c &apos;PROGRAM SUBPOOL.&apos;.
  c &apos;** GENERATED PROGRAM * DO NOT CHANGE IT **&apos;.
  c &apos;TYPE-POOLS: slis.&apos;.                                    &quot;#EC NOTEXT
  c &apos;&apos;.

  lw_select = fw_select.
  TRANSLATE lw_select TO UPPER CASE.

  lw_from = fw_from.
  TRANSLATE lw_from TO UPPER CASE.

* Search special term &quot;single&quot; or &quot;distinct&quot;
  lw_select_length = strlen( lw_select ).
  IF lw_select_length GE 7.
    lw_char_10 = lw_select(7).
    IF lw_char_10 = &apos;SINGLE&apos;.
* Force rows number = 1 for select single
      fw_rows = 1.
      lw_select = lw_select+7.
      lw_select_length = lw_select_length - 7.
    ENDIF.
  ENDIF.
  IF lw_select_length GE 9.
    lw_char_10 = lw_select(9).
    IF lw_char_10 = &apos;DISTINCT&apos;.
      lw_select_distinct = abap_true.
      lw_select = lw_select+9.
      lw_select_length = lw_select_length - 9.
    ENDIF.
  ENDIF.

* Search for special syntax &quot;count( * )&quot;
  IF lw_select = &apos;COUNT( * )&apos;.
    fw_count = abap_true.
  ENDIF.

* Create alias table mapping
  SPLIT lw_from AT space INTO TABLE lt_split.
  LOOP AT lt_split INTO lw_string.
    IF lw_string IS INITIAL OR lw_string CO space.
      DELETE lt_split.
    ENDIF.
  ENDLOOP.
  DO.
    READ TABLE lt_split TRANSPORTING NO FIELDS WITH KEY = &apos;AS&apos;.
    IF sy-subrc NE 0.
      EXIT. &quot;exit do
    ENDIF.
    lw_index = sy-tabix - 1.
    READ TABLE lt_split INTO lw_string INDEX lw_index.
    ls_table_alias-table = lw_string.
    DELETE lt_split INDEX lw_index. &quot;delete table field
    DELETE lt_split INDEX lw_index. &quot;delete keywork AS
    READ TABLE lt_split INTO lw_string INDEX lw_index.
    ls_table_alias-alias = lw_string.
    DELETE lt_split INDEX lw_index. &quot;delete alias field
    APPEND ls_table_alias TO lt_table_alias.
  ENDDO.
* If no alias table found, create just an entry for &quot;*&quot;
  IF lt_table_alias[] IS INITIAL.
    READ TABLE lt_split INTO lw_string INDEX 1.
    ls_table_alias-table = lw_string.
    ls_table_alias-alias = &apos;*&apos;.
    APPEND ls_table_alias TO lt_table_alias.
  ENDIF.
  SORT lt_table_alias BY alias.

* Write Data declaration
  c &apos;***************************************&apos;.              &quot;#EC NOTEXT
  c &apos;*      Begin of data declaration      *&apos;.              &quot;#EC NOTEXT
  c &apos;*   Used to store lines of the query  *&apos;.              &quot;#EC NOTEXT
  c &apos;***************************************&apos;.              &quot;#EC NOTEXT
  c &apos;DATA: BEGIN OF s_result&apos;.                              &quot;#EC NOTEXT
  lw_field_number = 1.

  lw_string = lw_select.
  IF fw_newsyntax = abap_true.
    TRANSLATE lw_string USING &apos;, &apos;.
    CONDENSE lw_string.
  ENDIF.
  SPLIT lw_string AT space INTO TABLE lt_split.

  LOOP AT lt_split INTO lw_string.
    lw_current_line = sy-tabix.
    IF lw_string IS INITIAL OR lw_string CO space.
      CONTINUE.
    ENDIF.
    IF lw_string = &apos;AS&apos;.
      DELETE lt_split INDEX lw_current_line. &quot;delete AS
      DELETE lt_split INDEX lw_current_line. &quot;delete the alias name
      CONTINUE.
    ENDIF.
    lw_current_length = strlen( lw_string ).

    CLEAR ls_fieldlist.
    ls_fieldlist-ref_field = lw_string.

* Manage new syntax &quot;Case&quot;
    IF fw_newsyntax = abap_true AND lw_string = &apos;CASE&apos;.
      lw_index = lw_current_line.
      DO.
        lw_index = lw_index + 1.
        READ TABLE lt_split INTO lw_string INDEX lw_index.
        IF sy-subrc NE 0.
          MESSAGE &apos;Incorrect syntax in Case statement&apos;(m62)
                   TYPE c_msg_success DISPLAY LIKE c_msg_error.
          RETURN.
        ENDIF.
        IF lw_string = &apos;END&apos;.
          lw_index = lw_index + 1.
          READ TABLE lt_split INTO lw_string INDEX lw_index.
          IF lw_string NE &apos;AS&apos;.
            lw_index = lw_index - 1.
            CONTINUE.
          ENDIF.
          lw_index = lw_index + 1.
          READ TABLE lt_split INTO lw_string INDEX lw_index.

          CLEAR ls_fieldlist.
          CONCATENATE &apos;F&apos; lw_field_number INTO ls_fieldlist-field.
          CONCATENATE &apos;,&apos; ls_fieldlist-field INTO lw_struct_line.
          CONCATENATE lw_struct_line &apos;TYPE string&apos;          &quot;#EC NOTEXT
                      INTO lw_struct_line SEPARATED BY space.
          c lw_struct_line.
          ls_fieldlist-ref_table = &apos;&apos;.
          ls_fieldlist-ref_field = lw_string.
          APPEND ls_fieldlist TO ft_fieldlist.
          lw_field_number = lw_field_number + 1.

          lw_index = lw_index - lw_current_line + 1.
          DO lw_index TIMES.
            DELETE lt_split INDEX lw_current_line. &quot;delete the case element
          ENDDO.
          EXIT.
        ENDIF.
      ENDDO.
      CONTINUE.
    ENDIF.

* Manage &quot;Count&quot;
    IF lw_current_length GE 6.
      lw_char_10 = lw_string(6).
    ELSE.
      CLEAR lw_char_10.
    ENDIF.
    IF lw_char_10 = &apos;COUNT(&apos;.
      CONCATENATE &apos;F&apos; lw_field_number INTO ls_fieldlist-field.
      CONCATENATE &apos;,&apos; ls_fieldlist-field INTO lw_struct_line.

      lw_index = lw_current_line + 1.
      DO.
        SEARCH lw_string FOR &apos;)&apos;.
        IF sy-subrc = 0.
          EXIT.
        ELSE.
* If there is space in the &quot;count()&quot;, delete next lines
          READ TABLE lt_split INTO lw_string INDEX lw_index.
          IF sy-subrc NE 0.
            EXIT.
          ENDIF.
          CONCATENATE ls_fieldlist-ref_field lw_string
                      INTO ls_fieldlist-ref_field SEPARATED BY space.
          DELETE lt_split INDEX lw_index.
        ENDIF.
      ENDDO.
      CONCATENATE lw_struct_line &apos;TYPE i&apos;                   &quot;#EC NOTEXT
                  INTO lw_struct_line SEPARATED BY space.
      c lw_struct_line.
      APPEND ls_fieldlist TO ft_fieldlist.
      lw_field_number = lw_field_number + 1.
      CONTINUE.
    ENDIF.

* Manage Agregate AVG
    IF lw_current_length GE 4.
      lw_char_10 = lw_string(4).
    ELSE.
      CLEAR lw_char_10.
    ENDIF.
    IF lw_char_10 = &apos;AVG(&apos;.
      CONCATENATE &apos;F&apos; lw_field_number INTO ls_fieldlist-field.
      CONCATENATE &apos;,&apos; ls_fieldlist-field INTO lw_struct_line.

      lw_index = lw_current_line + 1.
      DO.
        SEARCH lw_string FOR &apos;)&apos;.
        IF sy-subrc = 0.
          EXIT.
        ELSE.
* If there is space in the agregate, delete next lines
          READ TABLE lt_split INTO lw_string INDEX lw_index.
          IF sy-subrc NE 0.
            EXIT.
          ENDIF.
          CONCATENATE ls_fieldlist-ref_field lw_string
                      INTO ls_fieldlist-ref_field SEPARATED BY space.
          DELETE lt_split INDEX lw_index.
        ENDIF.
      ENDDO.
      CONCATENATE lw_struct_line &apos;TYPE f&apos;                   &quot;#EC NOTEXT
                  INTO lw_struct_line SEPARATED BY space.
      c lw_struct_line.
      APPEND ls_fieldlist TO ft_fieldlist.
      lw_field_number = lw_field_number + 1.
      CONTINUE.
    ENDIF.

* Manage agregate SUM, MAX, MIN
    IF lw_current_length GE 4.
      lw_char_10 = lw_string(4).
    ELSE.
      CLEAR lw_char_10.
    ENDIF.
    IF lw_char_10 = &apos;SUM(&apos; OR lw_char_10 = &apos;MAX(&apos;
    OR lw_char_10 = &apos;MIN(&apos;.
      lw_index = lw_current_line + 1.
      DO.
        SEARCH lw_string FOR &apos;)&apos;.
        IF sy-subrc = 0.
          EXIT.
        ELSE.
* Search name of the field in next lines.
          READ TABLE lt_split INTO lw_string INDEX lw_index.
          IF sy-subrc NE 0.
            EXIT.
          ENDIF.
          CONCATENATE ls_fieldlist-ref_field lw_string
                      INTO ls_fieldlist-ref_field SEPARATED BY space.
          IF lw_string2 IS INITIAL.
            lw_string2 = lw_string.
          ENDIF.
* Delete lines of agregage in field table
          DELETE lt_split INDEX lw_index.
        ENDIF.
      ENDDO.
      lw_string = lw_string2.
    ENDIF.

* Now lw_string contain a field name.
* We have to find the field description
    SPLIT lw_string AT &apos;~&apos; INTO lw_select_table lw_select_field.
    IF lw_select_field IS INITIAL.
      lw_select_field = lw_select_table.
      lw_select_table = &apos;*&apos;.
    ENDIF.
* Search if alias table used
    CLEAR ls_table_alias.
    READ TABLE lt_table_alias INTO ls_table_alias
               WITH KEY alias = lw_select_table             &quot;#EC WARNOK
               BINARY SEARCH.
    IF sy-subrc = 0.
      lw_select_table = ls_table_alias-table.
    ENDIF.
    ls_fieldlist-ref_table = lw_select_table.
    IF lw_string = &apos;*&apos; OR lw_select_field = &apos;*&apos;. &quot; expansion table~*
      CLEAR lw_explicit.
      SELECT fieldname position
      INTO   (lw_dd03l_fieldname,lw_position_dummy)
      FROM   dd03l
      WHERE  tabname    = lw_select_table
      AND    fieldname &lt;&gt; &apos;MANDT&apos;
      AND    as4local   = c_vers_active
      AND    as4vers    = space
      AND (  comptype   = c_ddic_dtelm
          OR comptype   = space )
      ORDER BY position.

        lw_select_field = lw_dd03l_fieldname.

        CONCATENATE &apos;F&apos; lw_field_number INTO ls_fieldlist-field.
        ls_fieldlist-ref_field = lw_select_field.
        APPEND ls_fieldlist TO ft_fieldlist.
        CONCATENATE &apos;,&apos; ls_fieldlist-field INTO lw_struct_line.

        CONCATENATE lw_select_table &apos;-&apos; lw_select_field
                    INTO lw_struct_line_type.
        CONCATENATE lw_struct_line &apos;TYPE&apos; lw_struct_line_type
                    INTO lw_struct_line
                    SEPARATED BY space.
        c lw_struct_line.
        lw_field_number = lw_field_number + 1.
* Explicit list of fields instead of *
* Generate longer query but mandatory in case of T1~* or MARA~*
* Required also in some special cases, for example if table use include
        IF ls_table_alias-alias = space OR ls_table_alias-alias = &apos;*&apos;.
          CONCATENATE lw_explicit lw_select_table
                      INTO lw_explicit SEPARATED BY space.
        ELSE.
          CONCATENATE lw_explicit ls_table_alias-alias
                      INTO lw_explicit SEPARATED BY space.
        ENDIF.
        CONCATENATE lw_explicit &apos;~&apos; lw_select_field INTO lw_explicit.
      ENDSELECT.
      IF sy-subrc NE 0.
        MESSAGE e701(1r) WITH lw_select_table. &quot;table does not exist
      ENDIF.
      IF NOT lw_explicit IS INITIAL.
        REPLACE FIRST OCCURRENCE OF lw_string
                IN lw_select WITH lw_explicit.
      ENDIF.

    ELSE. &quot;Simple field
      CONCATENATE &apos;F&apos; lw_field_number INTO ls_fieldlist-field.
      ls_fieldlist-ref_field = lw_select_field.
      APPEND ls_fieldlist TO ft_fieldlist.

      CONCATENATE &apos;,&apos; ls_fieldlist-field INTO lw_struct_line.

      CONCATENATE lw_select_table &apos;-&apos; lw_select_field
                  INTO lw_struct_line_type.
      CONCATENATE lw_struct_line &apos;TYPE&apos; lw_struct_line_type
                  INTO lw_struct_line
                  SEPARATED BY space.
      c lw_struct_line.
      lw_field_number = lw_field_number + 1.
    ENDIF.
  ENDLOOP.

* Add a count field
  CLEAR ls_fieldlist.
  ls_fieldlist-field = &apos;COUNT&apos;.
  ls_fieldlist-ref_table = &apos;&apos;.
  ls_fieldlist-ref_field = &apos;Count&apos;.                         &quot;#EC NOTEXT
  APPEND ls_fieldlist TO ft_fieldlist.
  c &apos;, COUNT type i&apos;.                                       &quot;#EC NOTEXT

* End of data definition
  c &apos;, END OF s_result&apos;.                                    &quot;#EC NOTEXT
  c &apos;, t_result like table of s_result&apos;.                    &quot;#EC NOTEXT
  c &apos;, w_timestart type timestampl&apos;.                        &quot;#EC NOTEXT
  c &apos;, w_timeend type timestampl.&apos;.                         &quot;#EC NOTEXT

* Write the dynamic subroutine that run the SELECT
  c &apos;FORM run_sql CHANGING fo_result TYPE REF TO data&apos;.     &quot;#EC NOTEXT
  c &apos;                      fw_time type p&apos;.                 &quot;#EC NOTEXT
  c &apos;                      fw_count type i.&apos;.               &quot;#EC NOTEXT
  c &apos;field-symbols &lt;fs_result&gt; like s_result.&apos;.             &quot;#EC NOTEXT
  c &apos;***************************************&apos;.              &quot;#EC NOTEXT
  c &apos;*            Begin of query           *&apos;.              &quot;#EC NOTEXT
  c &apos;***************************************&apos;.              &quot;#EC NOTEXT
  c &apos;get TIME STAMP FIELD w_timestart.&apos;.                    &quot;#EC NOTEXT
  IF fw_count = abap_true.
    CONCATENATE &apos;SELECT SINGLE&apos; lw_select                   &quot;#EC NOTEXT
                INTO lw_select SEPARATED BY space.
    c lw_select.
    IF fw_newsyntax = abap_true.
      c &apos;INTO @s_result-f000001&apos;.                           &quot;#EC NOTEXT
    ELSE.
      c &apos;INTO s_result-f000001&apos;.                            &quot;#EC NOTEXT
    ENDIF.
  ELSE.
    IF lw_select_distinct NE space.
      CONCATENATE &apos;SELECT DISTINCT&apos; lw_select               &quot;#EC NOTEXT
                  INTO lw_select SEPARATED BY space.
    ELSE.
      CONCATENATE &apos;SELECT&apos; lw_select                        &quot;#EC NOTEXT
                  INTO lw_select SEPARATED BY space.
    ENDIF.
    c lw_select.
    IF fw_newsyntax = abap_true.
      c &apos;INTO TABLE @t_result&apos;.                             &quot;#EC NOTEXT
    ELSE.
      c &apos;INTO TABLE t_result&apos;.                              &quot;#EC NOTEXT
    ENDIF.

* Add UP TO xxx ROWS
    IF NOT fw_rows IS INITIAL.
      c &apos;UP TO&apos;.                                            &quot;#EC NOTEXT
      c fw_rows.
      c &apos;ROWS&apos;.                                             &quot;#EC NOTEXT
    ENDIF.
  ENDIF.

  c &apos;FROM&apos;.                                                 &quot;#EC NOTEXT
  c lw_from.

* Where, group by, having, order by
  IF NOT fw_where IS INITIAL.
    c fw_where.
  ENDIF.
  c &apos;.&apos;.

* Display query execution time
  c &apos;get TIME STAMP FIELD w_timeend.&apos;.                      &quot;#EC NOTEXT
  c &apos;fw_time = w_timeend - w_timestart.&apos;.                   &quot;#EC NOTEXT
  c &apos;fw_count = sy-dbcnt.&apos;.                                 &quot;#EC NOTEXT

* If select count( * ), display number of results
  IF fw_count NE space.
    c &apos;MESSAGE i753(TG) WITH s_result-f000001.&apos;.            &quot;#EC NOTEXT
  ENDIF.
  c &apos;loop at t_result assigning &lt;fs_result&gt;.&apos;.              &quot;#EC NOTEXT
  c &apos; &lt;fs_result&gt;-count = 1.&apos;.                              &quot;#EC NOTEXT
  c &apos;endloop.&apos;.                                             &quot;#EC NOTEXT
  c &apos;GET REFERENCE OF t_result INTO fo_result.&apos;.            &quot;#EC NOTEXT
  c &apos;ENDFORM.&apos;.                                             &quot;#EC NOTEXT
  CLEAR : lw_line,
          lw_word,
          lw_mess.
  SYNTAX-CHECK FOR lt_code_string PROGRAM sy-repid
               MESSAGE lw_mess LINE lw_line WORD lw_word.
  IF sy-subrc NE 0 AND fw_display = space.
    MESSAGE lw_mess TYPE c_msg_success DISPLAY LIKE c_msg_error.
    CLEAR fw_program.
    RETURN.
  ENDIF.

  IF fw_display = space.
    GENERATE SUBROUTINE POOL lt_code_string NAME fw_program.
  ELSE.
    IF lw_mess IS NOT INITIAL.
      lw_explicit = lw_line.
      CONCATENATE lw_mess &apos;(line&apos;(m28) lw_explicit &apos;,word&apos;(m29)
                  lw_word &apos;)&apos;(m30)
                  INTO lw_mess SEPARATED BY space.
      MESSAGE lw_mess TYPE c_msg_success DISPLAY LIKE c_msg_error.
    ENDIF.
    EDITOR-CALL FOR lt_code_string DISPLAY-MODE
                TITLE &apos;Generated code for current query&apos;(t01).
  ENDIF.

ENDFORM.                    &quot; QUERY_GENERATE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  RESULT_DISPLAY
*&amp;---------------------------------------------------------------------*
*       Display data table in the bottom ALV part of the screen
*----------------------------------------------------------------------*
*      --&gt;FO_RESULT    Reference to data to display
*      --&gt;FT_FIELDLIST List of fields to display
*      --&gt;FW_TITLE     Title of the ALV
*----------------------------------------------------------------------*
FORM result_display  USING fo_result TYPE REF TO data
                           ft_fieldlist TYPE ty_fieldlist_table
                           fw_title TYPE string.
*  TYPE-POOLS lvc. &quot;for older sap system only

  DATA : ls_layout    TYPE lvc_s_layo,
         lt_fieldcat  TYPE lvc_t_fcat,
         ls_fieldlist TYPE ty_fieldlist,
         ls_fieldcat  LIKE LINE OF lt_fieldcat.
  DATA : lo_descr_table TYPE REF TO cl_abap_tabledescr,
         lo_descr_line  TYPE REF TO cl_abap_structdescr,
         ls_compx       TYPE abap_compdescr,
         lw_height      TYPE i.

  FIELD-SYMBOLS: &lt;lft_data&gt; TYPE ANY TABLE.

  ASSIGN fo_result-&gt;* TO &lt;lft_data&gt;.

* Get data type for COUNT &amp; AVG fields
  lo_descr_table ?=
    cl_abap_typedescr=&gt;describe_by_data_ref( fo_result ).
  lo_descr_line ?= lo_descr_table-&gt;get_table_line_type( ).

  LOOP AT ft_fieldlist INTO ls_fieldlist.
    CLEAR ls_fieldcat.
    ls_fieldcat-fieldname = ls_fieldlist-field.

    IF NOT ls_fieldlist-ref_table IS INITIAL.
      ls_fieldcat-ref_field = ls_fieldlist-ref_field.
      ls_fieldcat-ref_table = ls_fieldlist-ref_table.
      IF s_customize-techname = space.
        ls_fieldcat-reptext = ls_fieldlist-ref_field.
      ELSE.
        ls_fieldcat-reptext = ls_fieldlist-ref_field.
        ls_fieldcat-scrtext_s = ls_fieldlist-ref_field.
        ls_fieldcat-scrtext_m = ls_fieldlist-ref_field.
        ls_fieldcat-scrtext_l = ls_fieldlist-ref_field.
      ENDIF.
    ELSE. &quot;COUNT &amp; AVG field
      CLEAR ls_compx.
      READ TABLE lo_descr_line-&gt;components INTO ls_compx
                 WITH KEY name = ls_fieldlist-field.        &quot;#EC WARNOK
      ls_fieldcat-intlen = ls_compx-length.
      ls_fieldcat-decimals = ls_compx-decimals.
      ls_fieldcat-inttype = ls_compx-type_kind.
      ls_fieldcat-reptext = ls_fieldlist-ref_field.
      ls_fieldcat-scrtext_s = ls_fieldlist-ref_field.
      ls_fieldcat-scrtext_m = ls_fieldlist-ref_field.
      ls_fieldcat-scrtext_l = ls_fieldlist-ref_field.
    ENDIF.
    APPEND ls_fieldcat TO lt_fieldcat.
  ENDLOOP.

  ls_layout-smalltitle = abap_true.
  ls_layout-zebra = abap_true.
  ls_layout-cwidth_opt = abap_true.
  ls_layout-grid_title = fw_title.
  ls_layout-countfname = &apos;COUNT&apos;.

* Set the grid config and content
  CALL METHOD s_tab_active-o_alv_result-&gt;set_table_for_first_display
    EXPORTING
      is_layout       = ls_layout
    CHANGING
      it_outtab       = &lt;lft_data&gt;
      it_fieldcatalog = lt_fieldcat.

* Search if grid is currently displayed
  CALL METHOD o_splitter-&gt;get_row_height
    EXPORTING
      id     = 1
    IMPORTING
      result = lw_height.
  CALL METHOD cl_gui_cfw=&gt;flush.

* If grid is hidden, display it
  IF lw_height = 100.
    CALL METHOD o_splitter-&gt;set_row_height
      EXPORTING
        id     = 1
        height = 20.
  ENDIF.
ENDFORM.                    &quot; RESULT_DISPLAY

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DDIC_INIT
*&amp;---------------------------------------------------------------------*
*       Initialize ddic tree
*----------------------------------------------------------------------*
FORM ddic_init.
  DATA : ls_header   TYPE treev_hhdr,
         ls_event    TYPE cntl_simple_event,
         lt_events   TYPE cntl_simple_events,
         lo_dragdrop TYPE REF TO cl_dragdrop,
         lw_mode     TYPE i.

  ls_header-heading = &apos;SAP Table/Fields&apos;(t02).
  ls_header-width = 30.
  lw_mode = cl_gui_column_tree=&gt;node_sel_mode_single.

  CREATE OBJECT s_tab_active-o_tree_ddic
    EXPORTING
      parent                      = o_container_ddic
      node_selection_mode         = lw_mode
      item_selection              = abap_true
      hierarchy_column_name       = c_ddic_col1
      hierarchy_header            = ls_header
    EXCEPTIONS
      cntl_system_error           = 1
      create_error                = 2
      failed                      = 3
      illegal_node_selection_mode = 4
      illegal_column_name         = 5
      lifetime_error              = 6.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE a000(tree_control_msg).
  ENDIF.

* Column2
  CALL METHOD s_tab_active-o_tree_ddic-&gt;add_column
    EXPORTING
      name                         = c_ddic_col2
      width                        = 21
      header_text                  = &apos;Description&apos;(t03)
    EXCEPTIONS
      column_exists                = 1
      illegal_column_name          = 2
      too_many_columns             = 3
      illegal_alignment            = 4
      different_column_types       = 5
      cntl_system_error            = 6
      failed                       = 7
      predecessor_column_not_found = 8.

* Manage Item clic event to copy value in clipboard
  ls_event-eventid = cl_gui_column_tree=&gt;eventid_item_double_click.
  ls_event-appl_event = abap_true.
  APPEND ls_event TO lt_events.

  CALL METHOD s_tab_active-o_tree_ddic-&gt;set_registered_events
    EXPORTING
      events                    = lt_events
    EXCEPTIONS
      cntl_error                = 1
      cntl_system_error         = 2
      illegal_event_combination = 3.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE a000(tree_control_msg).
  ENDIF.

* Manage Drag from DDIC editor
  CREATE OBJECT lo_dragdrop.
  CALL METHOD lo_dragdrop-&gt;add
    EXPORTING
      flavor     = &apos;EDIT_INSERT&apos;
      dragsrc    = abap_true
      droptarget = space
      effect     = cl_dragdrop=&gt;copy.
  CALL METHOD lo_dragdrop-&gt;get_handle
    IMPORTING
      handle = w_dragdrop_handle_tree.

  SET HANDLER o_handle_event-&gt;hnd_ddic_item_dblclick FOR s_tab_active-o_tree_ddic.
  SET HANDLER o_handle_event-&gt;hnd_ddic_drag FOR s_tab_active-o_tree_ddic.

* Calculate ZSPRO nodes to add at the bottom of the ddic tree
*  PERFORM ddic_add_tree_zspro IN PROGRAM (sy-repid) IF FOUND.

ENDFORM.                    &quot; DDIC_INIT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DDIC_SET_TREE
*&amp;---------------------------------------------------------------------*
*       Refresh query with list of table/fields of the given query
*       Add User defined tree from ZSPRO (if relevant)
*----------------------------------------------------------------------*
*      --&gt;FW_FROM  From part of the query
*----------------------------------------------------------------------*
FORM ddic_set_tree USING fw_from TYPE string.

  DATA : lw_from   TYPE string,
         lt_split  TYPE TABLE OF string,
         lw_string TYPE string,
         lw_tabix  TYPE i,
         BEGIN OF ls_table_list,
           table(30),
           alias(30),
         END OF ls_table_list,
         lt_table_list     LIKE TABLE OF ls_table_list,
         lw_node_number(6) TYPE n,
         ls_node           LIKE LINE OF s_tab_active-t_node_ddic,
         ls_item           LIKE LINE OF s_tab_active-t_item_ddic,
         lw_parent_node    LIKE ls_node-node_key,
         BEGIN OF ls_ddic_fields,
           tabname   TYPE dd03l-tabname,
           fieldname TYPE dd03l-fieldname,
           position  TYPE dd03l-position,
           keyflag   TYPE dd03l-keyflag,
           ddtext1   TYPE dd03t-ddtext,
           ddtext2   TYPE dd04t-ddtext,
         END OF ls_ddic_fields,
         lt_ddic_fields LIKE TABLE OF ls_ddic_fields.

  CONCATENATE &apos;FROM&apos; fw_from INTO lw_from SEPARATED BY space.

  TRANSLATE lw_from TO UPPER CASE.

  SPLIT lw_from AT space INTO TABLE lt_split.
  LOOP AT lt_split INTO lw_string.
    lw_tabix = sy-tabix + 1.
    CHECK sy-tabix = 1 OR lw_string = &apos;JOIN&apos;.
* Read next line (table name)
    READ TABLE lt_split INTO lw_string INDEX lw_tabix.
    CHECK sy-subrc = 0.

    CLEAR ls_table_list.
    ls_table_list-table = lw_string.

    lw_tabix = lw_tabix + 1.
* Read next line (search alias)
    READ TABLE lt_split INTO lw_string INDEX lw_tabix.
    IF sy-subrc = 0 AND lw_string = &apos;AS&apos;.
      lw_tabix = lw_tabix + 1.
      READ TABLE lt_split INTO lw_string INDEX lw_tabix.
      IF sy-subrc = 0.
        ls_table_list-alias = lw_string.
      ENDIF.
    ENDIF.
    APPEND ls_table_list TO lt_table_list.
  ENDLOOP.

* Get list of fields for selected tables
  IF NOT lt_table_list IS INITIAL.
    SELECT dd03l~tabname dd03l~fieldname dd03l~position
           dd03l~keyflag dd03t~ddtext dd04t~ddtext
           INTO TABLE lt_ddic_fields
           FROM dd03l
           LEFT OUTER JOIN dd03t
           ON dd03l~tabname = dd03t~tabname
           AND dd03l~fieldname = dd03t~fieldname
           AND dd03l~as4local = dd03t~as4local
           AND dd03t~ddlanguage = sy-langu
           LEFT OUTER JOIN dd04t
           ON dd03l~rollname = dd04t~rollname
           AND dd03l~as4local = dd04t~as4local
           AND dd04t~ddlanguage = sy-langu
           FOR ALL ENTRIES IN lt_table_list
           WHERE dd03l~tabname = lt_table_list-table
           AND dd03l~as4local = c_vers_active
           AND dd03l~as4vers = space
           AND ( dd03l~comptype = c_ddic_dtelm
           OR    dd03l~comptype = space ).
    SORT lt_ddic_fields BY tabname keyflag DESCENDING position.
    DELETE ADJACENT DUPLICATES FROM lt_ddic_fields
                               COMPARING tabname fieldname.
  ENDIF.

* Build Node &amp; Item tree
  REFRESH : s_tab_active-t_node_ddic,
            s_tab_active-t_item_ddic.
  lw_node_number = 0.
  LOOP AT lt_table_list INTO ls_table_list.
* Check table exists (has at least one field)
    READ TABLE lt_ddic_fields TRANSPORTING NO FIELDS
               WITH KEY tabname = ls_table_list-table.
    IF sy-subrc NE 0.
      DELETE lt_table_list.
      CONTINUE.
    ENDIF.

    lw_node_number = lw_node_number + 1.
    CLEAR ls_node.
    ls_node-node_key = lw_node_number.
    ls_node-isfolder = abap_true.
    ls_node-n_image = &apos;@PO@&apos;.
    ls_node-exp_image = &apos;@PO@&apos;.
    ls_node-expander = abap_true.
    APPEND ls_node TO s_tab_active-t_node_ddic.

    CLEAR ls_item.
    ls_item-node_key = lw_node_number.
    ls_item-class = cl_gui_column_tree=&gt;item_class_text.
    ls_item-item_name = c_ddic_col1.
    IF ls_table_list-alias IS INITIAL.
      ls_item-text = ls_table_list-table.
    ELSE.
      CONCATENATE ls_table_list-table &apos;AS&apos; ls_table_list-alias
                   INTO ls_item-text SEPARATED BY space.
    ENDIF.
    APPEND ls_item TO s_tab_active-t_item_ddic.
    ls_item-item_name = c_ddic_col2.
    SELECT SINGLE ddtext INTO ls_item-text
           FROM dd02t
           WHERE tabname = ls_table_list-table
           AND ddlanguage = sy-langu
           AND as4local = c_vers_active
           AND as4vers = space.
    IF sy-subrc NE 0.
      ls_item-text = ls_table_list-table.
    ENDIF.
    APPEND ls_item TO s_tab_active-t_item_ddic.

* Display list of fields
    lw_parent_node = ls_node-node_key.
    LOOP AT lt_ddic_fields INTO ls_ddic_fields
            WHERE tabname = ls_table_list-table.
      CLEAR ls_node.
      lw_node_number = lw_node_number + 1.
      ls_node-node_key = lw_node_number.
      ls_node-relatkey = lw_parent_node.
      ls_node-relatship = cl_gui_column_tree=&gt;relat_last_child.
      IF ls_ddic_fields-keyflag = space.
        ls_node-n_image = &apos;@3W@&apos;.
        ls_node-exp_image = &apos;@3W@&apos;.
      ELSE.
        ls_node-n_image = &apos;@3V@&apos;.
        ls_node-exp_image = &apos;@3V@&apos;.
      ENDIF.
      ls_node-dragdropid = w_dragdrop_handle_tree.
      APPEND ls_node TO s_tab_active-t_node_ddic.

      CLEAR ls_item.
      ls_item-node_key = lw_node_number.
      ls_item-class = cl_gui_column_tree=&gt;item_class_text.
      ls_item-item_name = c_ddic_col1.
      ls_item-text = ls_ddic_fields-fieldname.
      APPEND ls_item TO s_tab_active-t_item_ddic.
      ls_item-item_name = c_ddic_col2.
      IF NOT ls_ddic_fields-ddtext1 IS INITIAL.
        ls_item-text = ls_ddic_fields-ddtext1.
      ELSE.
        ls_item-text = ls_ddic_fields-ddtext2.
      ENDIF.
      APPEND ls_item TO s_tab_active-t_item_ddic.
    ENDLOOP.
  ENDLOOP.

* Add User defined tree from ZSPRO (if relevant)
  IF NOT t_node_zspro IS INITIAL.
    APPEND LINES OF t_node_zspro TO s_tab_active-t_node_ddic.
    APPEND LINES OF t_item_zspro TO s_tab_active-t_item_ddic.
  ENDIF.

  CALL METHOD s_tab_active-o_tree_ddic-&gt;delete_all_nodes.

  CALL METHOD s_tab_active-o_tree_ddic-&gt;add_nodes_and_items
    EXPORTING
      node_table                     = s_tab_active-t_node_ddic
      item_table                     = s_tab_active-t_item_ddic
      item_table_structure_name      = &apos;MTREEITM&apos;
    EXCEPTIONS
      failed                         = 1
      cntl_system_error              = 3
      error_in_tables                = 4
      dp_error                       = 5
      table_structure_name_not_found = 6.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE a000(tree_control_msg).
  ENDIF.

  DESCRIBE TABLE lt_table_list LINES lw_tabix.

* If no table found, display message
  IF lw_tabix = 0.
    MESSAGE &apos;No valid table found&apos;(m15) TYPE c_msg_success
            DISPLAY LIKE c_msg_error.
* If 1 table found, expand it
  ELSEIF lw_tabix = 1.
    s_tab_active-o_tree_ddic-&gt;expand_root_nodes( ).
  ENDIF.
ENDFORM.                    &quot; DDIC_SET_TREE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  REPO_SAVE_QUERY
*&amp;---------------------------------------------------------------------*
*       Save query
*----------------------------------------------------------------------*
FORM repo_save_query.
  DATA : lt_query         TYPE soli_tab,
         ls_query         LIKE LINE OF lt_query,
         lw_query_with_cr TYPE string,
         lw_guid          TYPE guid_32,
         ls_ztoad         TYPE ztoad,
         lw_timestamp(14) TYPE c.

* Set default options
  SELECT SINGLE class INTO s_options-visibilitygrp
         FROM usr02
         WHERE bname = sy-uname.
  s_options-visibility = &apos;0&apos;.

* Ask for options / query name
  CALL SCREEN 0200 STARTING AT 10 5
                   ENDING AT 60 7.
  IF s_options IS INITIAL.
    MESSAGE &apos;Action cancelled&apos;(m14) TYPE c_msg_success
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

* Get content of abap edit box
  CALL METHOD s_tab_active-o_textedit-&gt;get_text
    IMPORTING
      table  = lt_query[]
    EXCEPTIONS
      OTHERS = 1.

* Serialize query into a string
  CLEAR lw_query_with_cr.
  LOOP AT lt_query INTO ls_query.
    CONCATENATE lw_query_with_cr ls_query cl_abap_char_utilities=&gt;cr_lf
                INTO lw_query_with_cr.
  ENDLOOP.

* Generate new GUID
  DO 100 TIMES.
* Old function to get an unique id
    CALL FUNCTION &apos;GUID_CREATE&apos;
      IMPORTING
        ev_guid_32 = lw_guid.
* New function to get an unique id (do not work on older sap system)
*    TRY.
*        lw_guid = cl_system_uuid=&gt;create_uuid_c32_static( ).
*      CATCH cx_uuid_error.
*        EXIT. &quot;exit do
*    ENDTRY.

* Check that this uid is not already used
    SELECT SINGLE queryid INTO ls_ztoad-queryid
           FROM ztoad
           WHERE queryid = lw_guid.
    IF sy-subrc NE 0.
      EXIT. &quot;exit do
    ENDIF.
  ENDDO.

  ls_ztoad-queryid = lw_guid.
  ls_ztoad-owner = sy-uname.
  lw_timestamp(8) = sy-datum.
  lw_timestamp+8 = sy-uzeit.
  ls_ztoad-aedat = lw_timestamp.
  ls_ztoad-text = s_options-name.
  ls_ztoad-visibility = s_options-visibility.
  ls_ztoad-visibility_group = s_options-visibilitygrp.
  ls_ztoad-query = lw_query_with_cr.
  INSERT ztoad FROM ls_ztoad.
  IF sy-subrc = 0.
    MESSAGE s031(r9). &quot;Query saved
  ELSE.
    MESSAGE e220(iqapi). &quot;Error when saving the query
  ENDIF.

* Reset the modified status
  s_tab_active-o_textedit-&gt;set_textmodified_status( ).

* Refresh repository to display new saved query
  PERFORM repo_fill.

* Focus repository on new saved query
  PERFORM repo_focus_query USING lw_guid.
ENDFORM.                    &quot; REPO_SAVE_QUERY

*&amp;---------------------------------------------------------------------*
*&amp;      Form  REPO_INIT
*&amp;---------------------------------------------------------------------*
*       Initialize repository tree
*----------------------------------------------------------------------*
FORM repo_init.
  DATA: lt_event TYPE cntl_simple_events,
        ls_event TYPE cntl_simple_event.

* Create a tree control
  CREATE OBJECT o_tree_repository
    EXPORTING
      parent              = o_container_repository
      node_selection_mode = cl_gui_simple_tree=&gt;node_sel_mode_single
    EXCEPTIONS
      lifetime_error      = 1
      cntl_system_error   = 2
      create_error        = 3
      failed              = 4
      OTHERS              = 5.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE a000(tree_control_msg).
  ENDIF.

* Catch double clic to open query
  ls_event-eventid = cl_gui_simple_tree=&gt;eventid_node_double_click.
  ls_event-appl_event = abap_true. &quot; no PAI if event occurs
  APPEND ls_event TO lt_event.

* Catch context menu call
  ls_event-eventid = cl_gui_simple_tree=&gt;eventid_node_context_menu_req.
  ls_event-appl_event = abap_true. &quot; no PAI if event occurs
  APPEND ls_event TO lt_event.

  CALL METHOD o_tree_repository-&gt;set_registered_events
    EXPORTING
      events                    = lt_event
    EXCEPTIONS
      cntl_error                = 1
      cntl_system_error         = 2
      illegal_event_combination = 3.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE a000(tree_control_msg).
  ENDIF.

* Assign event handlers in the application class to each desired event
  SET HANDLER o_handle_event-&gt;hnd_repo_dblclick
      FOR o_tree_repository.
  SET HANDLER o_handle_event-&gt;hnd_repo_context_menu
      FOR o_tree_repository.
  SET HANDLER o_handle_event-&gt;hnd_repo_context_menu_sel
      FOR o_tree_repository.

  PERFORM repo_fill.

ENDFORM.                    &quot; REPO_INIT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  REPO_FILL
*&amp;---------------------------------------------------------------------*
*       Fill repository tree with all allowed queries
*----------------------------------------------------------------------*
FORM repo_fill.
  DATA : lw_usergroup TYPE usr02-class,
         BEGIN OF ls_query,
           queryid    TYPE ztoad-queryid,
           aedat      TYPE ztoad-aedat,
           visibility TYPE ztoad-visibility,
           text       TYPE ztoad-text,
           query      TYPE ztoad-query,
         END OF ls_query,
         lt_query_my     LIKE TABLE OF ls_query,
         lt_query_shared LIKE TABLE OF ls_query,
         lw_node_key(6)  TYPE n,
         lw_queryid      TYPE ztoad-queryid,
         lw_dummy(1)     TYPE c.                            &quot;#EC NEEDED

* Get usergroup
  SELECT SINGLE class INTO lw_usergroup
         FROM usr02
         WHERE bname = sy-uname.

* Get all my queries
  SELECT queryid aedat visibility text query INTO TABLE lt_query_my
         FROM ztoad
         WHERE owner = sy-uname.

* Get all queries that i can use
  SELECT queryid aedat visibility text INTO TABLE lt_query_shared
         FROM ztoad
         WHERE owner NE sy-uname
         AND ( visibility = c_visibility_all
               OR ( visibility = c_visibility_shared
                    AND visibility_group = lw_usergroup )
             ).
  REFRESH t_node_repository.

  CALL METHOD o_tree_repository-&gt;delete_all_nodes.

  CLEAR s_node_repository.
  s_node_repository-node_key = c_nodekey_repo_my.
  s_node_repository-isfolder = abap_true.
  s_node_repository-text = &apos;My queries&apos;(m16).
  APPEND s_node_repository TO t_node_repository.

  CLEAR lw_node_key.
  CONCATENATE sy-uname &apos;+++&apos; INTO lw_queryid.
  LOOP AT lt_query_my INTO ls_query WHERE queryid NP lw_queryid.
    lw_node_key = lw_node_key + 1.
    CLEAR s_node_repository.
    s_node_repository-node_key = lw_node_key.
    s_node_repository-relatkey = c_nodekey_repo_my.
    s_node_repository-relatship = cl_gui_simple_tree=&gt;relat_last_child.
    IF ls_query-visibility = c_visibility_my.
      s_node_repository-n_image = s_node_repository-exp_image = &apos;@LC@&apos;.
    ELSE.
      s_node_repository-n_image = s_node_repository-exp_image = &apos;@L9@&apos;.
    ENDIF.
    s_node_repository-text = ls_query-text.
    s_node_repository-queryid = ls_query-queryid.
    s_node_repository-edit = abap_true.
    APPEND s_node_repository TO t_node_repository.
  ENDLOOP.

  CLEAR s_node_repository.
  s_node_repository-node_key = c_nodekey_repo_shared.
  s_node_repository-isfolder = abap_true.
  s_node_repository-text = &apos;Shared queries&apos;(m17).
  APPEND s_node_repository TO t_node_repository.

  LOOP AT lt_query_shared INTO ls_query.
    lw_node_key = lw_node_key + 1.
    CLEAR s_node_repository.
    s_node_repository-node_key = lw_node_key.
    s_node_repository-relatkey = c_nodekey_repo_shared.
    s_node_repository-relatship = cl_gui_simple_tree=&gt;relat_last_child.
    s_node_repository-n_image = s_node_repository-exp_image = &apos;@L9@&apos;.
    s_node_repository-text = ls_query-text.
    s_node_repository-queryid = ls_query-queryid.
    s_node_repository-edit = space.
    APPEND s_node_repository TO t_node_repository.
  ENDLOOP.

* Add history node
  CLEAR s_node_repository.
  s_node_repository-node_key = c_nodekey_repo_history.
  s_node_repository-isfolder = abap_true.
  s_node_repository-text = &apos;History&apos;(m18).
  APPEND s_node_repository TO t_node_repository.

  DELETE lt_query_my WHERE queryid NP lw_queryid.
  SORT lt_query_my BY aedat DESCENDING.
  LOOP AT lt_query_my INTO ls_query.
    lw_node_key = lw_node_key + 1.
    CLEAR s_node_repository.
    s_node_repository-node_key = lw_node_key.
    s_node_repository-relatkey = c_nodekey_repo_history.
    s_node_repository-relatship = cl_gui_simple_tree=&gt;relat_last_child.
    s_node_repository-n_image = s_node_repository-exp_image = &apos;@LC@&apos;.
    s_node_repository-text = ls_query-text.
    s_node_repository-queryid = ls_query-queryid.
    s_node_repository-edit = abap_true.
    IF ls_query-query(1) = &apos;*&apos;.
      SPLIT ls_query-query+1 AT cl_abap_char_utilities=&gt;cr_lf
            INTO ls_query-query lw_dummy.
      CONCATENATE s_node_repository-text &apos;:&apos; ls_query-query
                  INTO s_node_repository-text SEPARATED BY space.
    ENDIF.
    APPEND s_node_repository TO t_node_repository.
  ENDLOOP.

  CALL METHOD o_tree_repository-&gt;add_nodes
    EXPORTING
      table_structure_name           = &apos;MTREESNODE&apos;
      node_table                     = t_node_repository
    EXCEPTIONS
      failed                         = 1
      error_in_node_table            = 2
      dp_error                       = 3
      table_structure_name_not_found = 4
      OTHERS                         = 5.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE a000(tree_control_msg).
  ENDIF.

* Exand all root nodes (my, shared, history)
  CALL METHOD o_tree_repository-&gt;expand_root_nodes.
ENDFORM.                    &quot; REPO_FILL

*&amp;---------------------------------------------------------------------*
*&amp;      Form  REPO_SAVE_CURRENT_QUERY
*&amp;---------------------------------------------------------------------*
*       Save query in the history area
*       Keep only 100 last queries
*----------------------------------------------------------------------*
FORM repo_save_current_query.
  DATA : lt_query         TYPE soli_tab,
         ls_query         LIKE LINE OF lt_query,
         lw_query_with_cr TYPE string,
         ls_ztoad         TYPE ztoad,
         lw_number(2)     TYPE n,
         lw_timestamp(14) TYPE c,
         lw_dummy(1)      TYPE c,                           &quot;#EC NEEDED
         lw_query_last    TYPE string,
         lw_date(10)      TYPE c,
         lw_time(8)       TYPE c,
         lw_dummy_date    TYPE timestamp.                   &quot;#EC NEEDED

* Get content of abap edit box
  CALL METHOD s_tab_active-o_textedit-&gt;get_text
    IMPORTING
      table  = lt_query[]
    EXCEPTIONS
      OTHERS = 1.

* Serialize query into a string
  CLEAR lw_query_with_cr.
  LOOP AT lt_query INTO ls_query.
    CONCATENATE lw_query_with_cr ls_query cl_abap_char_utilities=&gt;cr_lf
                INTO lw_query_with_cr.
  ENDLOOP.

* Define timestamp
  lw_timestamp(8) = sy-datum.
  lw_timestamp+8 = sy-uzeit.
  ls_ztoad-aedat = lw_timestamp.

* Search if query is same as last loaded
  SELECT SINGLE query INTO lw_query_last
         FROM ztoad
         WHERE queryid = w_last_loaded_query.
  IF sy-subrc = 0 AND lw_query_last = lw_query_with_cr.
    RETURN.
  ENDIF.

* Get usergroup
  SELECT SINGLE class INTO ls_ztoad-visibility_group
         FROM usr02
         WHERE bname = sy-uname.

  CLEAR lw_number.

* Get last query from history
  CONCATENATE sy-uname &apos;#%&apos; INTO ls_ztoad-queryid.
* aedat is not used but added in select for compatibility reason
  SELECT queryid aedat
         INTO (ls_ztoad-queryid, lw_dummy_date)
         FROM ztoad
         UP TO 1 ROWS
         WHERE queryid LIKE ls_ztoad-queryid
         AND owner = sy-uname
         ORDER BY aedat DESCENDING.
  ENDSELECT.
  IF sy-subrc = 0.
    SPLIT ls_ztoad-queryid AT &apos;#&apos; INTO lw_dummy lw_number.
  ENDIF.

  lw_number = lw_number + 1.

* For history query, guid = &lt;sy-uname&gt;#NN
  CONCATENATE sy-uname &apos;#&apos; lw_number INTO ls_ztoad-queryid.
  ls_ztoad-owner = sy-uname.
  ls_ztoad-visibility = c_visibility_my.

* Define text for query as timestamp
  WRITE sy-datlo TO lw_date.
  WRITE sy-timlo TO lw_time.
  CONCATENATE lw_date lw_time INTO ls_ztoad-text SEPARATED BY space.

  ls_ztoad-query = lw_query_with_cr.
  MODIFY ztoad FROM ls_ztoad.

  w_last_loaded_query = ls_ztoad-queryid.

* Reset the modified status
  s_tab_active-o_textedit-&gt;set_textmodified_status( ).

* Refresh repository
  PERFORM repo_fill.

* Focus on new query
  PERFORM repo_focus_query USING ls_ztoad-queryid.
ENDFORM.                    &quot; REPO_SAVE_CURRENT_QUERY

*&amp;---------------------------------------------------------------------*
*&amp;      Form  QUERY_LOAD
*&amp;---------------------------------------------------------------------*
*       Load query
*----------------------------------------------------------------------*
*      --&gt;FW_QUERYID QueryID to load
*      &lt;--FT_QUERY   Saved query
*----------------------------------------------------------------------*
FORM query_load USING fw_queryid TYPE ztoad-queryid
                CHANGING ft_query TYPE table.
  DATA lw_query_with_cr TYPE string.
  REFRESH ft_query.

  SELECT SINGLE query INTO lw_query_with_cr
         FROM ztoad
         WHERE queryid = fw_queryid.
  IF sy-subrc = 0.
    SPLIT lw_query_with_cr AT cl_abap_char_utilities=&gt;cr_lf
                           INTO TABLE ft_query.
  ENDIF.
  w_last_loaded_query = fw_queryid.
ENDFORM.                    &quot; QUERY_LOAD

*&amp;---------------------------------------------------------------------*
*&amp;      Form  REPO_FOCUS_QUERY
*&amp;---------------------------------------------------------------------*
*       Focus repository tree on a given queryid
*----------------------------------------------------------------------*
*      --&gt;FW_QUERYID  ID of the query to focus
*----------------------------------------------------------------------*
FORM repo_focus_query USING fw_queryid TYPE ztoad-queryid.

  READ TABLE t_node_repository INTO s_node_repository
             WITH KEY queryid = fw_queryid.
  IF sy-subrc NE 0.
    RETURN.
  ENDIF.

  CALL METHOD o_tree_repository-&gt;set_selected_node
    EXPORTING
      node_key = s_node_repository-node_key.

ENDFORM.                    &quot; FOCUS_REPOSITORY

*&amp;---------------------------------------------------------------------*
*&amp;      Form  RESULT_INIT
*&amp;---------------------------------------------------------------------*
*       Initialize ALV grid
*----------------------------------------------------------------------*
FORM result_init.

* Create ALV
  CREATE OBJECT s_tab_active-o_alv_result
    EXPORTING
      i_parent = o_container_result.

* Register event toolbar to add button
  SET HANDLER o_handle_event-&gt;hnd_result_toolbar FOR s_tab_active-o_alv_result.
  SET HANDLER o_handle_event-&gt;hnd_result_user_command FOR s_tab_active-o_alv_result.

ENDFORM.                    &quot; RESULT_INIT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  SCREEN_INIT_LISTBOX_0200
*&amp;---------------------------------------------------------------------*
*       Fill dropdown listbox with value on screen 200
*----------------------------------------------------------------------*
FORM screen_init_listbox_0200.
  TYPE-POOLS vrm.
  DATA : lt_visibility TYPE vrm_values,
         ls_visibility LIKE LINE OF lt_visibility.

  REFRESH lt_visibility.

  ls_visibility-key = c_visibility_my.
  ls_visibility-text = &apos;Personal&apos;(m19).
  APPEND ls_visibility TO lt_visibility.

  ls_visibility-key = c_visibility_shared.
  ls_visibility-text = &apos;User group&apos;(m20).
  APPEND ls_visibility TO lt_visibility.

  ls_visibility-key = c_visibility_all.
  ls_visibility-text = &apos;All&apos;(m21).
  APPEND ls_visibility TO lt_visibility.

  CALL FUNCTION &apos;VRM_SET_VALUES&apos;
    EXPORTING
      id     = &apos;S_OPTIONS-VISIBILITY&apos;
      values = lt_visibility.

ENDFORM.                    &quot; SCREEN_INIT_LISTBOX_0200

*&amp;---------------------------------------------------------------------*
*&amp;      Form  SCREEN_EXIT
*&amp;---------------------------------------------------------------------*
*       Close the grid. If grid is closed, leave program
*       If sql text area is modified, ask confirmation before leave
*----------------------------------------------------------------------*
FORM screen_exit.
  DATA : lw_status    TYPE i,
         lw_answer(1) TYPE c,
         lw_size      TYPE i,
         lw_string    TYPE string.

* Check if grid is displayed
  CALL METHOD o_splitter-&gt;get_row_height
    EXPORTING
      id     = 1
    IMPORTING
      result = lw_size.
  CALL METHOD cl_gui_cfw=&gt;flush.

* If grid is displayed, BACK action is only to close the grid
  IF lw_size &lt; 100.
    CALL METHOD o_splitter-&gt;set_row_height
      EXPORTING
        id     = 1
        height = 100.
    RETURN.
  ENDIF.

* Check if textedit is modified
  CALL METHOD s_tab_active-o_textedit-&gt;get_textmodified_status
    IMPORTING
      status = lw_status.
  IF lw_status NE 0.
    CONCATENATE &apos;Current query is not saved. Do you want&apos;(m22)
&apos;to exit without saving or save into history then exit ?&apos;(m56)
                INTO lw_string SEPARATED BY space.
    CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
      EXPORTING
        text_question         = lw_string
        text_button_1         = &apos;Exit&apos;(m23)
        icon_button_1         = &apos;@2M@&apos;
        text_button_2         = &apos;Save &amp; exit&apos;(m24)
        icon_button_2         = &apos;@2L@&apos;
        default_button        = &apos;2&apos;
        display_cancel_button = space
      IMPORTING
        answer                = lw_answer.
    IF lw_answer = &apos;2&apos;.
      PERFORM repo_save_current_query.
    ENDIF.
  ENDIF.

  LEAVE TO SCREEN 0.
ENDFORM.                    &quot; SCREEN_EXIT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  SCREEN_DISPLAY_HELP
*&amp;---------------------------------------------------------------------*
*       Display help for this program
*----------------------------------------------------------------------*
FORM screen_display_help.
  DATA : l_report          TYPE string,
         l_report_char1(1) TYPE c,
         l_report_char3(3) TYPE c,
         l_comment_found   TYPE i,
         lt_report         LIKE TABLE OF l_report,
         lt_lines          TYPE rcl_bag_tline,
         ls_line           LIKE LINE OF lt_lines,
         ls_help           TYPE help_info,
         lt_exclude        TYPE STANDARD TABLE OF string.

* Get program source code
  READ REPORT sy-repid INTO lt_report.

  ls_line-tdformat = &apos;U1&apos;.
  ls_line-tdline = sy-title.
  APPEND ls_line TO lt_lines.

  ls_line-tdformat = &apos;U3&apos;.
  ls_line-tdline = &apos;&amp;PURPOSE&amp;&apos;.
  APPEND ls_line TO lt_lines.

  LOOP AT lt_report INTO l_report.
    l_report_char1 = l_report.
    CHECK l_report_char1 = &apos;*&apos;.

* Keep only the second block of comment
* (first block is technical info, third is history)
    l_report_char3 = l_report.
    IF l_report_char3 = &apos;*&amp;-&apos;.
      l_comment_found = l_comment_found + 1.
      IF l_comment_found LE 2.
        CONTINUE.
      ELSE. &quot;l_comment_found &gt; 2
        EXIT.
      ENDIF.
    ENDIF.
    IF l_comment_found = 2.
      l_report = l_report+1.
      l_report_char1 = l_report.
      CASE l_report_char1.
        WHEN &apos;=&apos;.
          ls_line-tdformat = &apos;=&apos;.
        WHEN &apos;3&apos;.
          ls_line-tdformat = &apos;U3&apos;.
        WHEN &apos;E&apos;.
          ls_line-tdformat = &apos;PE&apos;.
        WHEN OTHERS.
          ls_line-tdformat = &apos;*&apos;.
      ENDCASE.
      IF NOT l_report_char1 IS INITIAL.
        l_report = l_report+1.
      ENDIF.
      IF l_report IS INITIAL.
        ls_line-tdformat = &apos;LZ&apos;.
      ENDIF.
      ls_line-tdline = l_report.
      APPEND ls_line TO lt_lines.
    ENDIF.
  ENDLOOP.

  CALL FUNCTION &apos;HELP_DOCULINES_SHOW&apos;
    EXPORTING
      help_infos = ls_help
    TABLES
      excludefun = lt_exclude
      helplines  = lt_lines.

ENDFORM.                    &quot; SCREEN_DISPLAY_HELP

*&amp;---------------------------------------------------------------------*
*&amp;      Form  QUERY_PARSE_NOSELECT
*&amp;---------------------------------------------------------------------*
*       Check if query is a known SQL command and if user is allowed
*----------------------------------------------------------------------*
*      --&gt;FW_QUERY   Query to check
*      &lt;--FW_NOAUTH  Unallowed table or command entered
*      &lt;--FW_COMMAND Command to execute (INSERT, DELETE, ...)
*      &lt;--FW_TABLE   Target table of the query
*      &lt;--FW_PARAM   Parameters for the command (WHERE, SET, ...)
*----------------------------------------------------------------------*
FORM query_parse_noselect  USING    fw_query TYPE string
                           CHANGING fw_noauth TYPE c
                                    fw_command TYPE string
                                    fw_table TYPE string
                                    fw_param TYPE string.
  DATA : lw_query TYPE string,
         lw_table TYPE tabname.

  CLEAR : fw_noauth,
          fw_table,
          fw_command,
          fw_param.

  lw_query = fw_query.
  SPLIT lw_query AT space INTO fw_command lw_query.
  TRANSLATE fw_command TO UPPER CASE.
  CASE fw_command.
    WHEN &apos;INSERT&apos;.
      SPLIT lw_query AT space INTO fw_table fw_param.
      TRANSLATE fw_table TO UPPER CASE.
      CLEAR sy-subrc.
      IF s_customize-auth_object NE space.
        lw_table = fw_table.
        AUTHORITY-CHECK OBJECT s_customize-auth_object
                 ID &apos;TABLE&apos; FIELD lw_table
                 ID &apos;ACTVT&apos; FIELD s_customize-actvt_insert.
      ELSEIF s_customize-auth_insert NE &apos;*&apos;
      AND fw_table NP s_customize-auth_insert.
        sy-subrc = 4.
      ENDIF.
      sy-subrc = 0. &quot;APC!
      IF sy-subrc NE 0.
        CONCATENATE &apos;No authorisation for table&apos;(m13) fw_table
                    INTO lw_query SEPARATED BY space.
        MESSAGE lw_query TYPE c_msg_success DISPLAY LIKE c_msg_error.
        fw_noauth = abap_true.
        RETURN.
      ENDIF.

    WHEN &apos;UPDATE&apos;.
      SPLIT lw_query AT space INTO fw_table fw_param.
      TRANSLATE fw_table TO UPPER CASE.
      CLEAR sy-subrc.
      IF s_customize-auth_object NE space.
        lw_table = fw_table.
        AUTHORITY-CHECK OBJECT s_customize-auth_object
                 ID &apos;TABLE&apos; FIELD lw_table
                 ID &apos;ACTVT&apos; FIELD s_customize-actvt_update.
      ELSEIF s_customize-auth_update NE &apos;*&apos;
      AND fw_table NP s_customize-auth_update.
        sy-subrc = 4.
      ENDIF.
      sy-subrc = 0. &quot;APC!
      IF sy-subrc NE 0.
        CONCATENATE &apos;No authorisation for table&apos;(m13) fw_table
                    INTO lw_query SEPARATED BY space.
        MESSAGE lw_query TYPE c_msg_success DISPLAY LIKE c_msg_error.
        fw_noauth = abap_true.
        RETURN.
      ENDIF.

    WHEN &apos;DELETE&apos;.
      SPLIT lw_query AT space INTO fw_table fw_param.
      TRANSLATE fw_table TO UPPER CASE.
      IF fw_table = &apos;FROM&apos;.
        SPLIT fw_param AT space INTO fw_table fw_param.
        TRANSLATE fw_table TO UPPER CASE.
      ENDIF.
      CLEAR sy-subrc.
      IF s_customize-auth_object NE space.
        lw_table = fw_table.
        AUTHORITY-CHECK OBJECT s_customize-auth_object
                 ID &apos;TABLE&apos; FIELD lw_table
                 ID &apos;ACTVT&apos; FIELD s_customize-actvt_delete.
      ELSEIF s_customize-auth_delete NE &apos;*&apos;
      AND NOT fw_table CP s_customize-auth_delete.
        sy-subrc = 4.
      ENDIF.
      sy-subrc = 0. &quot;APC!
      IF sy-subrc NE 0.
        CONCATENATE &apos;No authorisation for table&apos;(m13) fw_table
                    INTO lw_query SEPARATED BY space.
        MESSAGE lw_query TYPE c_msg_success DISPLAY LIKE c_msg_error.
        fw_noauth = abap_true.
        RETURN.
      ENDIF.

    WHEN c_native_command.
      IF s_customize-auth_object NE space.
        AUTHORITY-CHECK OBJECT s_customize-auth_object
                 ID &apos;ACTVT&apos; FIELD s_customize-actvt_native.
      ELSEIF s_customize-auth_native NE abap_true.
        sy-subrc = 4.
      ENDIF.
      IF sy-subrc NE 0.
        CONCATENATE &apos;SQL command not allowed :&apos;(m25) fw_command
                    INTO lw_query.
        MESSAGE lw_query TYPE c_msg_success DISPLAY LIKE c_msg_error.
        fw_noauth = abap_true.
        RETURN.
      ENDIF.
* For native command, replace &apos; by &quot;
      TRANSLATE lw_query USING &apos;&apos;&apos;&quot;&apos;.
      fw_param = lw_query.

    WHEN OTHERS.
      CONCATENATE &apos;SQL command not allowed :&apos;(m25) fw_command
                  INTO lw_query.
      MESSAGE lw_query TYPE c_msg_success DISPLAY LIKE c_msg_error.
      fw_noauth = abap_true.
      RETURN.
  ENDCASE.
ENDFORM.                    &quot; QUERY_PARSE_NOSELECT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  QUERY_GENERATE_NOSELECT
*&amp;---------------------------------------------------------------------*
*       Create all other than SELECT SQL query in a new generated
*       temp program
*----------------------------------------------------------------------*
*      --&gt;FW_COMMAND Query type
*      --&gt;FW_TABLE   Target table of the query
*      --&gt;FW_PARAM   Parameters of the query
*      --&gt;FW_DISPLAY   Display code instead of generated routine
*      &lt;--FW_PROGRAM Name of the generated program
*----------------------------------------------------------------------*
FORM query_generate_noselect  USING    fw_command TYPE string
                                       fw_table TYPE string
                                       fw_param TYPE string
                                       fw_display TYPE c
                              CHANGING fw_program TYPE sy-repid.

  DATA : lt_code_string      TYPE TABLE OF string,
         lw_mess(255),
         lw_line             TYPE i,
         lw_word(30),
         lw_strlen_string    TYPE string,
         lw_explicit         TYPE string,
         lw_length           TYPE i,
         lw_pos              TYPE i,
         lw_fieldnum         TYPE i,
         lw_fieldval         TYPE string,
         lw_fieldname        TYPE string,
         lw_wait_name(1)     TYPE c,
         lw_char(1)          TYPE c,
         lw_started(1)       TYPE c,
         lw_started_field(1) TYPE c.

  DEFINE c.
    lw_strlen_string = &amp;1.
    perform add_line_to_table using lw_strlen_string
                              changing lt_code_string.
  END-OF-DEFINITION.

* Write Header
  c &apos;PROGRAM SUBPOOL.&apos;.                                     &quot;#EC NOTEXT
  c &apos;** GENERATED PROGRAM * DO NOT CHANGE IT **&apos;.           &quot;#EC NOTEXT
  c &apos;type-pools: slis.&apos;.                                    &quot;#EC NOTEXT
  c &apos;DATA : w_timestart type timestampl,&apos;.                  &quot;#EC NOTEXT
  c &apos;       w_timeend type timestampl.&apos;.                    &quot;#EC NOTEXT
  c &apos;&apos;.
  IF fw_command = &apos;INSERT&apos;.
    c &apos;DATA s_insert type&apos;.                                 &quot;#EC NOTEXT
    c fw_table.
    c &apos;.&apos;.                                                  &quot;#EC NOTEXT
    c &apos;FIELD-SYMBOLS &lt;fs&gt; TYPE ANY.&apos;.                       &quot;#EC NOTEXT
    c &apos;.&apos;.                                                  &quot;#EC NOTEXT
  ENDIF.

* Write the dynamic subroutine that run the SELECT
  c &apos;FORM run_sql CHANGING fo_result TYPE REF TO data&apos;.     &quot;#EC NOTEXT
  c &apos;                      fw_time TYPE p&apos;.                 &quot;#EC NOTEXT
  c &apos;                      fw_count TYPE i.&apos;.               &quot;#EC NOTEXT
  c &apos;***************************************&apos;.              &quot;#EC NOTEXT
  c &apos;*            Begin of query           *&apos;.              &quot;#EC NOTEXT
  c &apos;***************************************&apos;.              &quot;#EC NOTEXT
  c &apos;CLEAR fw_count.&apos;.                                      &quot;#EC NOTEXT
  c &apos;GET TIME STAMP FIELD w_timestart.&apos;.                    &quot;#EC NOTEXT

  CASE fw_command.
    WHEN &apos;UPDATE&apos;.
      c fw_command.
      c fw_table.
      c fw_param.
      c &apos;.&apos;.
    WHEN &apos;DELETE&apos;.
      c fw_command.
      c &apos;FROM&apos;.                                             &quot;#EC NOTEXT
      c fw_table.
      c fw_param.
      c &apos;.&apos;.
    WHEN &apos;INSERT&apos;.

      IF fw_param(6) = &apos;VALUES&apos;.
        lw_length = strlen( fw_param ).
        lw_pos = 6.
        lw_fieldnum = 0.
        WHILE lw_pos &lt; lw_length.
          lw_char = fw_param+lw_pos(1).
          lw_pos = lw_pos + 1.
          IF lw_started = space.
            IF lw_char NE &apos;(&apos;. &quot;begin of the list
              CONTINUE.
            ENDIF.
            lw_started = abap_true.
            CONTINUE.
          ENDIF.
          IF lw_started_field = space.
            IF lw_char = &apos;)&apos;. &quot;end of the list
              EXIT. &quot;exit while
            ENDIF.

            IF lw_char NE &apos;&apos;&apos;&apos;. &quot;field value must start by &apos;
              CONTINUE.
            ENDIF.
            lw_started_field = abap_true.
            lw_fieldval = lw_char.
            lw_fieldnum = lw_fieldnum + 1.
            CONTINUE.
          ENDIF.
          IF lw_char = space.
            CONCATENATE lw_fieldval lw_char INTO lw_fieldval
                        SEPARATED BY space.
          ELSE.
            CONCATENATE lw_fieldval lw_char INTO lw_fieldval.
          ENDIF.
          IF lw_char = &apos;&apos;&apos;&apos;. &quot;end of a field ?
            IF lw_pos &lt; lw_length.
              lw_char = fw_param+lw_pos(1).
            ELSE.
              CLEAR lw_char.
            ENDIF.
            IF lw_char = &apos;&apos;&apos;&apos;. &quot;not end !
              CONCATENATE lw_fieldval lw_char INTO lw_fieldval.
              lw_pos = lw_pos + 1.
              CONTINUE.
            ELSE. &quot;end of a field!
              c &apos;ASSIGN COMPONENT&apos;.                         &quot;#EC NOTEXT
              c lw_fieldnum.
              c &apos;OF STRUCTURE s_insert TO &lt;fs&gt;.&apos;.           &quot;#EC NOTEXT
              c &apos;&lt;fs&gt; = &apos;.                                  &quot;#EC NOTEXT
              c lw_fieldval.
              c &apos;.&apos;.                                        &quot;#EC NOTEXT
              lw_started_field = space.
            ENDIF.
          ENDIF.
        ENDWHILE.
      ELSEIF fw_param(3) = &apos;SET&apos;.


        lw_length = strlen( fw_param ).
        lw_pos = 3.
        lw_fieldnum = 0.
        lw_wait_name = abap_true.
        WHILE lw_pos &lt; lw_length.
          lw_char = fw_param+lw_pos(1).
          lw_pos = lw_pos + 1.
          IF lw_wait_name = abap_true.
            TRANSLATE lw_char TO UPPER CASE.
            IF lw_char = space OR NOT sy-abcde CS lw_char.
              CONTINUE. &quot;not a begin of fieldname
            ENDIF.
            lw_wait_name = space.
            lw_started = abap_true.
            CONCATENATE &apos;s_insert-&apos; lw_char
                        INTO lw_fieldname.                  &quot;#EC NOTEXT
            CONTINUE.
          ENDIF.

          IF lw_started = abap_true.
            IF lw_char = space.
              CONCATENATE lw_fieldname lw_char INTO lw_fieldname
                          SEPARATED BY space.
            ELSE.
              CONCATENATE lw_fieldname lw_char INTO lw_fieldname.
            ENDIF.
            IF lw_char = &apos;=&apos;. &quot;end of the field name
              lw_started = space.
            ENDIF.

            CONTINUE.
          ENDIF.

          IF lw_started_field NE abap_true.
            IF lw_char NE &apos;&apos;&apos;&apos;. &quot;field value must start by &apos;
              CONTINUE.
            ENDIF.
            lw_started_field = abap_true.
            lw_fieldval = lw_char.
            CONTINUE.
          ENDIF.

          IF lw_char = space.
            CONCATENATE lw_fieldval lw_char INTO lw_fieldval
                        SEPARATED BY space.
          ELSE.
            CONCATENATE lw_fieldval lw_char INTO lw_fieldval.
          ENDIF.
          IF lw_char = &apos;&apos;&apos;&apos;. &quot;end of a field ?
            IF lw_pos &lt; lw_length.
              lw_char = fw_param+lw_pos(1).
            ELSE.
              CLEAR lw_char.
            ENDIF.
            IF lw_char = &apos;&apos;&apos;&apos;. &quot;not end !
              CONCATENATE lw_fieldval lw_char INTO lw_fieldval.
              lw_pos = lw_pos + 1.
              CONTINUE.
            ELSE. &quot;end of a field!
              c lw_fieldname.
              c lw_fieldval.
              c &apos;.&apos;.
              lw_started_field = space.
              lw_wait_name = abap_true.
            ENDIF.
          ENDIF.
        ENDWHILE.
      ELSE.
        MESSAGE &apos;Error in INSERT syntax : VALUES / SET required&apos;(m26)
                TYPE c_msg_error.
      ENDIF. &quot;if fw_param(6) = &apos;VALUES&apos;.
      c fw_command.
      c &apos;INTO&apos;.                                             &quot;#EC NOTEXT
      c fw_table.
      c &apos;VALUES s_insert.&apos;.                                 &quot;#EC NOTEXT
  ENDCASE.

* Get query execution time &amp; affected lines
  c &apos;IF sy-subrc = 0.&apos;.                                     &quot;#EC NOTEXT
  c &apos;  fw_count = sy-dbcnt.&apos;.                               &quot;#EC NOTEXT
  c &apos;ENDIF.&apos;.                                               &quot;#EC NOTEXT
  c &apos;GET TIME STAMP FIELD w_timeend.&apos;.                      &quot;#EC NOTEXT
  c &apos;fw_time = w_timeend - w_timestart.&apos;.                   &quot;#EC NOTEXT
  c &apos;ENDFORM.&apos;.                                             &quot;#EC NOTEXT

  CLEAR : lw_line,
          lw_word,
          lw_mess.
  SYNTAX-CHECK FOR lt_code_string PROGRAM sy-repid
               MESSAGE lw_mess LINE lw_line WORD lw_word.
  IF sy-subrc NE 0 AND fw_display = space.
    MESSAGE lw_mess TYPE c_msg_error.
  ENDIF.

  IF fw_display = space.
    GENERATE SUBROUTINE POOL lt_code_string NAME fw_program.
  ELSE.
    IF lw_mess IS NOT INITIAL.
      lw_explicit = lw_line.
      CONCATENATE lw_mess &apos;(line&apos;(m28) lw_explicit &apos;,word&apos;(m29)
                  lw_word &apos;)&apos;(m30)
                  INTO lw_mess SEPARATED BY space.
      MESSAGE lw_mess TYPE c_msg_success DISPLAY LIKE c_msg_error.
    ENDIF.
    EDITOR-CALL FOR lt_code_string DISPLAY-MODE
                TITLE &apos;Generated code for current query&apos;(t01).
  ENDIF.
ENDFORM.                    &quot; QUERY_GENERATE_NOSELECT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DDIC_GET_FIELD_FROM_NODE
*&amp;---------------------------------------------------------------------*
*       Get text for a DDIC node
*       Format of the text : tablename~fieldname
*----------------------------------------------------------------------*
*      --&gt;FW_NODE_KEY   DDIC node key
*      --&gt;FW_RELAT_KEY  DDIC parent node key
*      --&gt;FW_TEXT       Text
*----------------------------------------------------------------------*
FORM ddic_get_field_from_node  USING    fw_node_key TYPE tv_nodekey
                                        fw_relat_key TYPE tv_nodekey
                               CHANGING fw_text TYPE string.
  DATA : ls_item        LIKE LINE OF s_tab_active-t_item_ddic,
         ls_item_parent LIKE LINE OF s_tab_active-t_item_ddic,
         lw_table       TYPE string,
         lw_alias       TYPE string.

* Get field name
  READ TABLE s_tab_active-t_item_ddic INTO ls_item
             WITH KEY node_key = fw_node_key
                      item_name = c_ddic_col1.

* Get table name
  READ TABLE s_tab_active-t_item_ddic INTO ls_item_parent
             WITH KEY node_key = fw_relat_key
                      item_name = c_ddic_col1.

* Search for alias
  SPLIT ls_item_parent-text AT &apos; AS &apos; INTO lw_table lw_alias.
  IF NOT lw_alias IS INITIAL.
    lw_table = lw_alias.
  ENDIF.

* Build tablename~fieldname
  CONCATENATE lw_table &apos;~&apos; ls_item-text INTO fw_text.
  CONCATENATE space fw_text space INTO fw_text RESPECTING BLANKS.

ENDFORM.                    &quot; DDIC_GET_FIELD_FROM_NODE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  EDITOR_PASTE
*&amp;---------------------------------------------------------------------*
*       Paste given text to SQL editor at given position
*----------------------------------------------------------------------*
*      --&gt;FW_TEXT Text to paste in editor
*      --&gt;FW_LINE Line in editor to paste
*      --&gt;FW_POS  Position in the line in editor
*----------------------------------------------------------------------*
FORM editor_paste  USING fw_text TYPE string
                         fw_line TYPE i
                         fw_pos TYPE i.
  DATA : lt_text    TYPE TABLE OF string,
         lw_pos     TYPE i,
         lw_line    TYPE i,
         lw_message TYPE string.

*   Set text with new line
  APPEND fw_text TO lt_text.
  IF s_customize-paste_break = abap_true.
    lw_pos = fw_pos - 1.
    CLEAR lw_message.
    DO lw_pos TIMES.
      CONCATENATE lw_message space INTO lw_message RESPECTING BLANKS.
    ENDDO.
    APPEND lw_message TO lt_text.
  ENDIF.

  CALL METHOD s_tab_active-o_textedit-&gt;insert_block_at_position
    EXPORTING
      line     = fw_line
      pos      = fw_pos
      text_tab = lt_text
    EXCEPTIONS
      OTHERS   = 0.

* Set cursor at end of pasted field
  IF s_customize-paste_break = abap_true.
    lw_pos = fw_pos.
    lw_line = fw_line + 1.
  ELSE.
    lw_pos = strlen( fw_text ).
    lw_pos = lw_pos + fw_pos.
    lw_line = fw_line.
  ENDIF.

  CALL METHOD s_tab_active-o_textedit-&gt;set_selection_pos_in_line
    EXPORTING
      line   = lw_line
      pos    = lw_pos
    EXCEPTIONS
      OTHERS = 0.

* Focus on editor
  CALL METHOD cl_gui_control=&gt;set_focus
    EXPORTING
      control = s_tab_active-o_textedit
    EXCEPTIONS
      OTHERS  = 0.

  CONCATENATE fw_text &apos;pasted to SQL Editor&apos;(m27)
              INTO lw_message SEPARATED BY space.
  MESSAGE lw_message TYPE c_msg_success.
ENDFORM.                    &quot; EDITOR_PASTE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  QUERY_PROCESS_NATIVE
*&amp;---------------------------------------------------------------------*
*       Execute a given native sql command
*----------------------------------------------------------------------*
*      --&gt;FW_COMMAND Native SQL Command to execute
*----------------------------------------------------------------------*
FORM query_process_native USING fw_command TYPE string.
  DATA : lw_lines        TYPE i,
         lw_sql_code     TYPE i,
         lw_sql_msg(255) TYPE c,
         lw_row_num      TYPE i,
         lw_command(255) TYPE c,
         lw_msg          TYPE string,
         lw_timestart    TYPE timestampl,
         lw_timeend      TYPE timestampl,
         lw_time         TYPE p LENGTH 8 DECIMALS 2,
         lw_charnumb(12) TYPE c,
         lw_answer(1)    TYPE c.

* Have a user confirmation before execute Native SQL Command
  CONCATENATE &apos;Are you sure you want to do a&apos;(m31) fw_command
              &apos;?&apos;(m33)
              INTO lw_msg SEPARATED BY space.
  CALL FUNCTION &apos;POPUP_TO_CONFIRM&apos;
    EXPORTING
      titlebar              = &apos;Warning : critical operation&apos;(t04)
      text_question         = lw_msg
      default_button        = &apos;2&apos;
      display_cancel_button = space
    IMPORTING
      answer                = lw_answer
    EXCEPTIONS
      text_not_found        = 1
      OTHERS                = 2.
  IF sy-subrc NE 0 OR lw_answer NE &apos;1&apos;.
    RETURN.
  ENDIF.

  lw_command = fw_command.
  lw_lines = strlen( lw_command ).
  GET TIME STAMP FIELD lw_timestart.
  CALL &apos;C_DB_EXECUTE&apos;
       ID &apos;STATLEN&apos; FIELD lw_lines
       ID &apos;STATTXT&apos; FIELD lw_command
       ID &apos;SQLERR&apos;  FIELD lw_sql_code
       ID &apos;ERRTXT&apos;  FIELD lw_sql_msg
       ID &apos;ROWNUM&apos;  FIELD lw_row_num.
  IF sy-subrc NE 0.
    MESSAGE lw_sql_msg TYPE c_msg_success DISPLAY LIKE c_msg_error.
    RETURN.
  ELSE.
    GET TIME STAMP FIELD lw_timeend.
    lw_time = cl_abap_tstmp=&gt;subtract(
                tstmp1 = lw_timeend
                tstmp2 = lw_timestart
              ).
    lw_charnumb = lw_time.
    CONCATENATE &apos;Query executed in&apos;(m09) lw_charnumb &apos;seconds.&apos;(m10)
                INTO lw_msg SEPARATED BY space.
    CONDENSE lw_msg.
    MESSAGE lw_msg TYPE c_msg_success.
  ENDIF.
ENDFORM.                    &quot; QUERY_PROCESS_NATIVE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  ddic_add_tree_zspro
*&amp;---------------------------------------------------------------------*
*       Add nodes from table ZSPRO
*       You can delete this form if not use ZSPRO or dont have a table
*       hierarchy in ZSPRO
*----------------------------------------------------------------------*
FORM ddic_add_tree_zspro.
  DATA : lo_zspro   TYPE REF TO data,
         ls_node    LIKE LINE OF s_tab_active-t_node_ddic,
         ls_item    LIKE LINE OF s_tab_active-t_item_ddic,
         lw_nodekey TYPE tv_nodekey,
         BEGIN OF ls_ddic_fields,
           tabname   TYPE dd03l-tabname,
           fieldname TYPE dd03l-fieldname,
           position  TYPE dd03l-position,
           keyflag   TYPE dd03l-keyflag,
           ddtext1   TYPE dd03t-ddtext,
           ddtext2   TYPE dd04t-ddtext,
         END OF ls_ddic_fields,
         lt_ddic_fields     LIKE TABLE OF ls_ddic_fields,
         lw_node_number(11) TYPE n,
         lw_found(1)        TYPE c.
  CONSTANTS lc_zspro(30) TYPE c VALUE &apos;ZSPRO&apos;.
  FIELD-SYMBOLS : &lt;ft_zspro&gt; TYPE standard table,
                  &lt;fs_zspro&gt; TYPE any,
                  &lt;fw_zspro&gt; TYPE any.
  REFRESH : t_node_zspro, t_item_zspro.

* Try to create zspro internal table
  TRY.
      CREATE DATA lo_zspro TYPE TABLE OF (lc_zspro).
    CATCH cx_sy_create_data_error.
* If ZSPRO does not exist, leave the subroutine
      RETURN.
  ENDTRY.
  ASSIGN lo_zspro-&gt;* TO &lt;ft_zspro&gt;.

* Get all data from ZSPRO (node or table entry)
  SELECT * FROM (lc_zspro)
           INTO TABLE &lt;ft_zspro&gt;
           WHERE nodetype = 0
           OR nodetype = 1
           OR nodetype = space
           ORDER BY relatkey sort.
* If ZSPRO does not contain any valuable data, leave the subroutine
  IF sy-subrc NE 0.
    RETURN.
  ENDIF.

* Get field list for each table
  LOOP AT &lt;ft_zspro&gt; ASSIGNING &lt;fs_zspro&gt;.
    ASSIGN COMPONENT &apos;NODETYPE&apos; OF STRUCTURE &lt;fs_zspro&gt; TO &lt;fw_zspro&gt;.
    IF sy-subrc NE 0 OR &lt;fw_zspro&gt; NE 1.
      CONTINUE.
    ENDIF.
    ASSIGN COMPONENT &apos;NODEPARAM&apos; OF STRUCTURE &lt;fs_zspro&gt; TO &lt;fw_zspro&gt;.
    IF sy-subrc = 0.
      ls_ddic_fields-tabname = &lt;fw_zspro&gt;.
      APPEND ls_ddic_fields TO lt_ddic_fields.
    ENDIF.
  ENDLOOP.
  IF NOT lt_ddic_fields IS INITIAL.
    SELECT dd03l~tabname dd03l~fieldname dd03l~position
           dd03l~keyflag dd03t~ddtext dd04t~ddtext
           INTO TABLE lt_ddic_fields
           FROM dd03l
           LEFT OUTER JOIN dd03t
           ON dd03l~tabname = dd03t~tabname
           AND dd03l~fieldname = dd03t~fieldname
           AND dd03l~as4local = dd03t~as4local
           AND dd03t~ddlanguage = sy-langu
           LEFT OUTER JOIN dd04t
           ON dd03l~rollname = dd04t~rollname
           AND dd03l~as4local = dd04t~as4local
           AND dd04t~ddlanguage = sy-langu
           FOR ALL ENTRIES IN lt_ddic_fields
           WHERE dd03l~tabname = lt_ddic_fields-tabname
           AND dd03l~as4local = c_vers_active
           AND dd03l~as4vers = space
           AND ( dd03l~comptype = c_ddic_dtelm
           OR    dd03l~comptype = space ).
    SORT lt_ddic_fields BY tabname keyflag DESCENDING position.
    DELETE ADJACENT DUPLICATES FROM lt_ddic_fields
           COMPARING tabname fieldname.
  ENDIF.

  CLEAR ls_node.
  ls_node-node_key = &apos;ZSPRO&apos;.
  ls_node-isfolder = abap_true.
  ls_node-expander = abap_true.
  APPEND ls_node TO t_node_zspro.

  CLEAR ls_item.
  ls_item-node_key = &apos;ZSPRO&apos;.
  ls_item-class = cl_gui_column_tree=&gt;item_class_text.
  ls_item-item_name = c_ddic_col1.
  ls_item-text = &apos;ZSPRO&apos;.
  APPEND ls_item TO t_item_zspro.

  ls_item-item_name = c_ddic_col2.
  ls_item-text = space.
  APPEND ls_item TO t_item_zspro.

  LOOP AT &lt;ft_zspro&gt; ASSIGNING &lt;fs_zspro&gt;.
    ASSIGN COMPONENT &apos;NODE_KEY&apos; OF STRUCTURE &lt;fs_zspro&gt; TO &lt;fw_zspro&gt;.
    CONCATENATE &apos;Z&apos; &lt;fw_zspro&gt;+1 INTO lw_nodekey.
    CLEAR ls_node.
    ls_node-node_key = lw_nodekey.

    ASSIGN COMPONENT &apos;RELATKEY&apos; OF STRUCTURE &lt;fs_zspro&gt; TO &lt;fw_zspro&gt;.
    IF &lt;fw_zspro&gt; IS INITIAL.
      ls_node-relatkey = &apos;ZSPRO&apos;.
    ELSE.
      CONCATENATE &apos;Z&apos; &lt;fw_zspro&gt;+1 INTO ls_node-relatkey.
    ENDIF.
    ls_node-isfolder = abap_true.

    ASSIGN COMPONENT &apos;NODETYPE&apos; OF STRUCTURE &lt;fs_zspro&gt; TO &lt;fw_zspro&gt;.
    IF &lt;fw_zspro&gt; = 1. &quot;table entry
      ls_node-n_image = &apos;@PO@&apos;.
      ls_node-exp_image = &apos;@PO@&apos;.
    ENDIF.
    ls_node-expander = abap_true.
    APPEND ls_node TO t_node_zspro.

    CLEAR ls_item.
    ls_item-node_key = lw_nodekey.
    ls_item-class = cl_gui_column_tree=&gt;item_class_text.
    ls_item-item_name = c_ddic_col1.
    IF &lt;fw_zspro&gt; = 1. &quot;table entry
      ASSIGN COMPONENT &apos;NODEPARAM&apos; OF STRUCTURE &lt;fs_zspro&gt; TO &lt;fw_zspro&gt;.
      ls_item-text = &lt;fw_zspro&gt;.
    ELSE.
      ASSIGN COMPONENT &apos;TEXT&apos; OF STRUCTURE &lt;fs_zspro&gt; TO &lt;fw_zspro&gt;.
      ls_item-text = &lt;fw_zspro&gt;.
    ENDIF.
    APPEND ls_item TO t_item_zspro.

    ls_item-item_name = c_ddic_col2.
    ASSIGN COMPONENT &apos;NODETYPE&apos; OF STRUCTURE &lt;fs_zspro&gt; TO &lt;fw_zspro&gt;.
    IF &lt;fw_zspro&gt; = 1. &quot;table entry
      ASSIGN COMPONENT &apos;TEXT&apos; OF STRUCTURE &lt;fs_zspro&gt; TO &lt;fw_zspro&gt;.
      ls_item-text = &lt;fw_zspro&gt;.
    ELSE.
      ls_item-text = space.
    ENDIF.
    APPEND ls_item TO t_item_zspro.

* For each table entry, add all fields
    ASSIGN COMPONENT &apos;NODETYPE&apos; OF STRUCTURE &lt;fs_zspro&gt; TO &lt;fw_zspro&gt;.
    IF &lt;fw_zspro&gt; = 1.
      ASSIGN COMPONENT &apos;NODEPARAM&apos; OF STRUCTURE &lt;fs_zspro&gt;
                                   TO &lt;fw_zspro&gt;.
      LOOP AT lt_ddic_fields INTO ls_ddic_fields
                             WHERE tabname = &lt;fw_zspro&gt;.
        CLEAR ls_node.
        lw_node_number = lw_node_number + 1.
        CONCATENATE &apos;F&apos; lw_node_number INTO ls_node-node_key.
        ls_node-relatkey = lw_nodekey.
        ls_node-relatship = cl_gui_column_tree=&gt;relat_last_child.
        IF ls_ddic_fields-keyflag = space.
          ls_node-n_image = &apos;@3W@&apos;.
          ls_node-exp_image = &apos;@3W@&apos;.
        ELSE.
          ls_node-n_image = &apos;@3V@&apos;.
          ls_node-exp_image = &apos;@3V@&apos;.
        ENDIF.
        ls_node-dragdropid = w_dragdrop_handle_tree.
        APPEND ls_node TO t_node_zspro.

        CLEAR ls_item.
        ls_item-node_key = ls_node-node_key.
        ls_item-class = cl_gui_column_tree=&gt;item_class_text.
        ls_item-item_name = c_ddic_col1.
        ls_item-text = ls_ddic_fields-fieldname.
        APPEND ls_item TO t_item_zspro.
        ls_item-item_name = c_ddic_col2.
        IF NOT ls_ddic_fields-ddtext1 IS INITIAL.
          ls_item-text = ls_ddic_fields-ddtext1.
        ELSE.
          ls_item-text = ls_ddic_fields-ddtext2.
        ENDIF.
        APPEND ls_item TO t_item_zspro.
      ENDLOOP.
    ENDIF.
  ENDLOOP.

* Clean Empty nodes
  DO.
    lw_found = space.
    LOOP AT t_node_zspro INTO ls_node WHERE isfolder = abap_true.
      READ TABLE t_node_zspro WITH KEY relatkey = ls_node-node_key
                 TRANSPORTING NO FIELDS.
      IF sy-subrc NE 0.
        lw_found = abap_true.
        DELETE t_node_zspro.
        DELETE t_item_zspro WHERE node_key = ls_node-node_key.
      ENDIF.
    ENDLOOP.
    IF lw_found = space.
      EXIT.
    ENDIF.
  ENDDO.
ENDFORM.                    &quot;ddic_add_tree_zspro

*&amp;---------------------------------------------------------------------*
*&amp;      Form  REPO_DELETE_HISTORY
*&amp;---------------------------------------------------------------------*
*       Delete given history entry
*----------------------------------------------------------------------*
*      --&gt;FW_NODE_KEY Node key of history to delete
*      &lt;--FW_SUBRC    Return code
*----------------------------------------------------------------------*
FORM repo_delete_history USING fw_node_key TYPE tv_nodekey
                         CHANGING fw_subrc TYPE i.
  DATA ls_histo LIKE s_node_repository.

  READ TABLE t_node_repository INTO ls_histo
             WITH KEY node_key = fw_node_key.
  IF sy-subrc = 0 AND ls_histo-edit NE space.
    DELETE FROM ztoad WHERE queryid = ls_histo-queryid.
    IF sy-subrc = 0.
      CALL METHOD o_tree_repository-&gt;delete_node
        EXPORTING
          node_key = fw_node_key.
    ENDIF.
  ENDIF.
  fw_subrc = sy-subrc.
ENDFORM.                    &quot; REPO_DELETE_HISTORY

*&amp;---------------------------------------------------------------------*
*&amp;      Form  options_load
*&amp;---------------------------------------------------------------------*
*       Get saved options from user parameters table
*----------------------------------------------------------------------*
FORM options_load.
  DATA : lw_options  TYPE usr05-parva,
         lw_rows(10) TYPE c.
  GET PARAMETER ID &apos;ZTOAD&apos; FIELD lw_options.                &quot;#EC EXISTS
  IF sy-subrc = 0.
    SPLIT lw_options AT &apos;;&apos; INTO lw_rows
                                 s_customize-paste_break
                                 s_customize-techname
                                 lw_options. &quot;dummy
    s_customize-default_rows = lw_rows.
  ENDIF.
ENDFORM.                    &quot; options_load

*&amp;---------------------------------------------------------------------*
*&amp;      Form  options_save
*&amp;---------------------------------------------------------------------*
*       Save user options in standard user parameters table
*----------------------------------------------------------------------*
FORM options_save.
  DATA : lw_options  TYPE usr05-parva,
         lw_rows(10) TYPE c.

  lw_rows =   s_customize-default_rows.
  CONDENSE lw_rows NO-GAPS.
  CONCATENATE lw_rows
              s_customize-paste_break
              s_customize-techname
              INTO lw_options
              SEPARATED BY &apos;;&apos;.

  CALL FUNCTION &apos;SMAN_SET_USER_PARAMETER&apos;
    EXPORTING
      parameter_id    = &apos;ZTOAD&apos;
      parameter_value = lw_options
    EXCEPTIONS
      OTHERS          = 2.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE e082(s1). &quot;Error saving parameter changes
  ENDIF.

ENDFORM.                    &quot;options_save

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DDIC_REFRESH_TREE
*&amp;---------------------------------------------------------------------*
*       Refresh DDIC tree with current query
*----------------------------------------------------------------------*
FORM ddic_refresh_tree.
  DATA : lw_query        TYPE string,
         lw_query2       TYPE string,
         lw_select       TYPE string,
         lw_from         TYPE string,
         lw_from2        TYPE string,
         lw_where        TYPE string,
         lw_union        TYPE string,
         lw_rows(6)      TYPE n,
         lw_noauth(1)    TYPE c,
         lw_newsyntax(1) TYPE c,
         lw_error(1)     TYPE c.

* Get only usefull code for current query
  PERFORM editor_get_query USING space CHANGING lw_query.

* Parse Query
  PERFORM query_parse USING lw_query
                      CHANGING lw_select lw_from lw_where
                               lw_union lw_rows lw_noauth
                               lw_newsyntax lw_error.

  IF lw_noauth NE space OR lw_error NE space.
    RETURN.
  ELSEIF lw_select IS INITIAL.
    PERFORM query_parse_noselect USING lw_query
                                 CHANGING lw_noauth lw_select
                                          lw_from lw_where.
    IF lw_noauth NE space OR lw_select = c_native_command.
      RETURN.
    ENDIF.
  ENDIF.
* Manage unioned queries
  WHILE NOT lw_union IS INITIAL.
* Parse Query
    lw_query2 = lw_union.
    PERFORM query_parse USING lw_query2
                        CHANGING lw_select lw_from2 lw_where
                                 lw_union lw_rows lw_noauth
                                 lw_newsyntax lw_error.
    IF NOT lw_from2 IS INITIAL.
      CONCATENATE lw_from &apos;JOIN&apos; lw_from2
                  INTO lw_from SEPARATED BY space.
    ENDIF.
    IF lw_noauth NE space OR lw_error NE space.
      RETURN.
    ENDIF.
  ENDWHILE.

  PERFORM tab_update_title USING lw_query.

* Refresh ddic tree with list of table/fields of the actual query
  PERFORM ddic_set_tree USING lw_from.
ENDFORM.                    &quot; DDIC_REFRESH_TREE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DDIC_FIND_IN_TREE
*&amp;---------------------------------------------------------------------*
*       Display popup to search a table in DDIC tree
*----------------------------------------------------------------------*
FORM ddic_find_in_tree.
  DATA : ls_sval        TYPE sval,
         lt_sval        LIKE TABLE OF ls_sval,
         lw_returncode  TYPE c,
         lw_search      TYPE string,
         lt_search      LIKE TABLE OF lw_search,
         ls_item_ddic   LIKE LINE OF s_tab_active-t_item_ddic,
         lw_search_term TYPE string,
         lw_search_line TYPE i,
         lw_rest        TYPE i,
         lw_node_key    TYPE tv_nodekey,
         lt_nodekey     TYPE TABLE OF tv_nodekey.

* Build search table
  REFRESH lt_search.
  LOOP AT s_tab_active-t_item_ddic INTO ls_item_ddic.
    lw_search = ls_item_ddic-text.
    APPEND lw_search TO lt_search.
    APPEND ls_item_ddic-node_key TO lt_nodekey.
  ENDLOOP.

* Ask for selection search
  ls_sval-tabname = &apos;RSDXX&apos;.
  ls_sval-fieldname = &apos;FINDSTR&apos;.
  ls_sval-value = space.
  APPEND ls_sval TO lt_sval.
  DO.
    CALL FUNCTION &apos;POPUP_GET_VALUES&apos;
      EXPORTING
        popup_title     = space
      IMPORTING
        returncode      = lw_returncode
      TABLES
        fields          = lt_sval
      EXCEPTIONS
        error_in_fields = 1
        OTHERS          = 2.
    IF sy-subrc NE 0 OR lw_returncode NE space.
      EXIT. &quot;exit do
    ENDIF.
    READ TABLE lt_sval INTO ls_sval INDEX 1.
    IF ls_sval-value = space.
      EXIT. &quot;exit do
    ENDIF.

* For new search, start from line 1
    IF lw_search_term NE ls_sval-value.
      lw_search_term = ls_sval-value.
      lw_search_line = 1.
* For next result of same search, start from next line
    ELSE.
      lw_rest = lw_search_line MOD 2.
      lw_search_line = lw_search_line + 1 + lw_rest.
    ENDIF.

    FIND FIRST OCCURRENCE OF ls_sval-value IN TABLE lt_search
         FROM lw_search_line
         IN CHARACTER MODE IGNORING CASE
         MATCH LINE lw_search_line.

* Search string &amp;1 not found
    IF sy-subrc NE 0 AND lw_search_line = 1.
      MESSAGE s065(0k) WITH lw_search_term DISPLAY LIKE c_msg_error.
      CLEAR lw_search_line.
      CLEAR lw_search_term.

* Last selected entry reached
    ELSEIF sy-subrc NE 0.
      MESSAGE s066(0k) DISPLAY LIKE c_msg_error.
      CLEAR lw_search_line.
      CLEAR lw_search_term.

* Found
    ELSE.
      MESSAGE &apos;String found&apos;(m04) TYPE c_msg_success.
      READ TABLE lt_nodekey INTO lw_node_key INDEX lw_search_line.
      CALL METHOD s_tab_active-o_tree_ddic-&gt;set_selected_node
        EXPORTING
          node_key = lw_node_key.
      CALL METHOD s_tab_active-o_tree_ddic-&gt;ensure_visible
        EXPORTING
          node_key = lw_node_key.
    ENDIF.

  ENDDO.
ENDFORM.                    &quot; DDIC_FIND_IN_TREE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  OPTIONS_INIT
*&amp;---------------------------------------------------------------------*
*       Create option panel
*----------------------------------------------------------------------*
FORM options_init.
  DATA : lt_ptab TYPE wdy_wb_property_tab,
         ls_ptab TYPE wdy_wb_property.

* Create a custom container linked to the custom controm on screen 300
  CREATE OBJECT o_container_options
    EXPORTING
      container_name              = &apos;CUSTCONT2&apos;
    EXCEPTIONS
      cntl_error                  = 1
      cntl_system_error           = 2
      create_error                = 3
      lifetime_error              = 4
      lifetime_dynpro_dynpro_link = 5
      OTHERS                      = 6.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

* Create the property object and link it to the custom controm
  CREATE OBJECT o_options
    EXPORTING
      parent                    = o_container_options
    EXCEPTIONS
      cntl_error                = 1
      cntl_system_error         = 2
      illegal_event_combination = 3
      OTHERS                    = 4.
  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

* Define Column title of the property object
  CALL METHOD o_options-&gt;initialize
    EXPORTING
      property_column_title = &apos;Property&apos;(m44)
      value_column_title    = &apos;Value&apos;(m45)
      focus_row             = 1
      scrollable            = abap_true.

  o_options-&gt;set_enabled( abap_true ).

* paste_break
  ls_ptab-name = &apos;PB&apos;.
  ls_ptab-type = cl_wdy_wb_property_box=&gt;property_type_boolean.
  ls_ptab-enabled = abap_true.
  ls_ptab-value = s_customize-paste_break.
  CONCATENATE &apos;@74\Q&apos;
    &apos;Add break line after pasting ddic field into sql editor&apos;(m46)
    &apos;@&apos; &apos;Line Break&apos;(m47) INTO ls_ptab-display_name.
  APPEND ls_ptab TO lt_ptab.

* default up to xxx rows
  ls_ptab-name = &apos;MAXROWS&apos;.
  ls_ptab-type = cl_wdy_wb_property_box=&gt;property_type_integer.
  ls_ptab-enabled = abap_true.
  ls_ptab-value = s_customize-default_rows.
  CONCATENATE &apos;@3W\Q&apos;
    &apos;Default max number of displayed lines for SELECT&apos;(m48)
    &apos;@&apos; &apos;Max Rows&apos;(m49) INTO ls_ptab-display_name.
  APPEND ls_ptab TO lt_ptab.

* default up to xxx rows
  ls_ptab-name = &apos;TECH&apos;.
  ls_ptab-type = cl_wdy_wb_property_box=&gt;property_type_boolean.
  ls_ptab-enabled = abap_true.
  ls_ptab-value = s_customize-techname.
  CONCATENATE &apos;@AJ\Q&apos;
    &apos;Display technical name in query result display&apos;(m52)
    &apos;@&apos; &apos;Technical name&apos;(m53) INTO ls_ptab-display_name.
  APPEND ls_ptab TO lt_ptab.

* Fill properties/values
  CALL METHOD o_options-&gt;set_properties
    EXPORTING
      properties = lt_ptab
      refresh    = abap_true.
ENDFORM.                    &quot; OPTIONS_INIT

*&amp;---------------------------------------------------------------------*
*&amp;      Form  OPTIONS_DISPLAY
*&amp;---------------------------------------------------------------------*
*       Display options panel
*----------------------------------------------------------------------*
FORM options_display.
  DATA : lt_ptab TYPE wdy_wb_property_tab,
         ls_ptab TYPE wdy_wb_property.

* If not first display, refresh properties values
  IF NOT o_options IS INITIAL.
    lt_ptab = o_options-&gt;get_properties( ).
    LOOP AT lt_ptab INTO ls_ptab.
      CASE ls_ptab-name.
        WHEN &apos;PB&apos;.
          ls_ptab-value = s_customize-paste_break.
        WHEN &apos;MAXROWS&apos;.
          ls_ptab-value = s_customize-default_rows.
        WHEN &apos;TECH&apos;.
          ls_ptab-value = s_customize-techname.
      ENDCASE.
      CALL METHOD o_options-&gt;update_property
        EXPORTING
          property = ls_ptab.
    ENDLOOP.
  ENDIF.

* Display properties panel
  CALL SCREEN 300 STARTING AT 60 10
                  ENDING AT 90 16.
  IF w_okcode NE &apos;OK&apos;.
    RETURN.
  ENDIF.

* Update values if not well refreshed in o_options
  CALL METHOD o_options-&gt;dispatch
    EXPORTING
      cargo             = w_okcode
      eventid           = 18
      is_shellevent     = space
      is_systemdispatch = space
    EXCEPTIONS
      OTHERS            = 0.

* Update values in s_customize
  lt_ptab = o_options-&gt;get_properties( ).
  LOOP AT lt_ptab INTO ls_ptab.
    CASE ls_ptab-name.
      WHEN &apos;PB&apos;.
        s_customize-paste_break = ls_ptab-value.
      WHEN &apos;MAXROWS&apos;.
        s_customize-default_rows = ls_ptab-value.
      WHEN &apos;TECH&apos;.
        s_customize-techname = ls_ptab-value.
    ENDCASE.
  ENDLOOP.

* Save values in user parameters
  PERFORM options_save.
ENDFORM.                    &quot; OPTIONS_DISPLAY

*&amp;---------------------------------------------------------------------*
*&amp;      Form  RESULT_SAVE_FILE
*&amp;---------------------------------------------------------------------*
*       Save results into local file
*       - 1 line of header is written with technical column name
*       - Fields are separated by TAB
*       - Blank at end of char fields are removed
*----------------------------------------------------------------------*
*      --&gt;FO_RESULT    Reference to data to display
*      --&gt;FT_FIELDS    Field list
*----------------------------------------------------------------------*
FORM result_save_file USING fo_result TYPE REF TO data
                            ft_fields TYPE ty_fieldlist_table.

  DATA : lw_filename TYPE string,
         lt_file_f4  TYPE filetable,
         ls_file_f4  LIKE LINE OF lt_file_f4,
         lw_rc       TYPE i,
         lw_filter   TYPE string,
         lw_title    TYPE string,
         BEGIN OF ls_field_out,
           name TYPE char30,
         END OF ls_field_out,
         lt_fields   LIKE TABLE OF ls_field_out,
         ls_field_in LIKE LINE OF ft_fields.

  FIELD-SYMBOLS: &lt;lft_data&gt; TYPE ANY TABLE.

  lw_filter = &apos;CSV File (*.csv)|*.csv&apos;(m51).
  lw_title = &apos;Download results into file&apos;(m63).
  CALL METHOD cl_gui_frontend_services=&gt;file_open_dialog
    EXPORTING
      window_title = lw_title
      file_filter  = lw_filter
    CHANGING
      file_table   = lt_file_f4
      rc           = lw_rc
    EXCEPTIONS
      OTHERS       = 0.
  READ TABLE lt_file_f4 INTO ls_file_f4 INDEX 1.
  IF sy-subrc = 0.
    lw_filename = ls_file_f4.
  ENDIF.
  IF lw_filename IS INITIAL.
    RETURN.
  ENDIF.

  ASSIGN fo_result-&gt;* TO &lt;lft_data&gt;.
  LOOP AT ft_fields INTO ls_field_in.
    APPEND ls_field_in-ref_field TO lt_fields.
  ENDLOOP.
  CALL METHOD cl_gui_frontend_services=&gt;gui_download
    EXPORTING
      filename              = lw_filename
      write_field_separator = abap_true
      trunc_trailing_blanks = abap_true
      fieldnames            = lt_fields
    CHANGING
      data_tab              = &lt;lft_data&gt;
    EXCEPTIONS
      OTHERS                = 0.

ENDFORM.                    &quot; RESULT_SAVE_FILE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  DDIC_F4
*&amp;---------------------------------------------------------------------*
*       Display F4 help on selected DDIC tree field
*       Paste selected value in SQL Editor
*----------------------------------------------------------------------*
FORM ddic_f4.
  DATA : lw_table      TYPE dfies-tabname,
         lw_field      TYPE dfies-fieldname,
         lt_val        TYPE TABLE OF ddshretval,
         ls_val        LIKE LINE OF lt_val,
         lw_nodekey    TYPE tv_nodekey,
         lw_item       TYPE tv_itmname,                     &quot;#EC NEEDED
         ls_node       LIKE LINE OF s_tab_active-t_node_ddic,
         ls_item       LIKE LINE OF s_tab_active-t_item_ddic,
         lw_line_start TYPE i,
         lw_pos_start  TYPE i,
         lw_line_end   TYPE i,
         lw_pos_end    TYPE i,
         lw_val        TYPE string,
         lw_dummy      type c.                              &quot;#EC NEEDED

* Get selection in ddic tree
  CALL METHOD s_tab_active-o_tree_ddic-&gt;get_selected_node &quot;line selected
    IMPORTING
      node_key = lw_nodekey.
  IF lw_nodekey IS INITIAL.
    CALL METHOD s_tab_active-o_tree_ddic-&gt;get_selected_item &quot;item selected
      IMPORTING
        node_key  = lw_nodekey
        item_name = lw_item.
  ENDIF.
  IF lw_nodekey IS INITIAL.
    RETURN.
  ENDIF.

* Check selection is a field
  READ TABLE s_tab_active-t_node_ddic INTO ls_node
             WITH KEY node_key = lw_nodekey.
  IF sy-subrc NE 0 OR ls_node-isfolder = abap_true.
    RETURN.
  ENDIF.

* Get field name
  READ TABLE s_tab_active-t_item_ddic INTO ls_item
             WITH KEY node_key = lw_nodekey
                      item_name = c_ddic_col1.
  lw_field = ls_item-text.

* Get table name
  READ TABLE s_tab_active-t_item_ddic INTO ls_item
             WITH KEY node_key = ls_node-relatkey
                      item_name = c_ddic_col1.
  SPLIT ls_item-text AT &apos; AS &apos; INTO lw_table lw_dummy.

* Display standard value-list
  CALL FUNCTION &apos;F4IF_FIELD_VALUE_REQUEST&apos;
    EXPORTING
      fieldname  = lw_field
      tabname    = lw_table
    TABLES
      return_tab = lt_val
    EXCEPTIONS
      OTHERS     = 1.

  IF sy-subrc = 0.
    READ TABLE lt_val INTO ls_val INDEX 1.
    CONCATENATE &apos;&apos;&apos;&apos; ls_val-fieldval &apos;&apos;&apos;&apos; INTO lw_val.
    CONCATENATE space lw_val INTO lw_val RESPECTING BLANKS.

* Get current cursor position/selection in editor
    CALL METHOD s_tab_active-o_textedit-&gt;get_selection_pos
      IMPORTING
        from_line = lw_line_start
        from_pos  = lw_pos_start
        to_line   = lw_line_end
        to_pos    = lw_pos_end
      EXCEPTIONS
        OTHERS    = 4.
    IF sy-subrc NE 0.
      MESSAGE &apos;Cannot get cursor position&apos;(m35) TYPE c_msg_error.
    ENDIF.

*   If text is selected/highlighted, delete it
    IF lw_line_start NE lw_line_end
    OR lw_pos_start NE lw_pos_end.
      CALL METHOD s_tab_active-o_textedit-&gt;delete_text
        EXPORTING
          from_line = lw_line_start
          from_pos  = lw_pos_start
          to_line   = lw_line_end
          to_pos    = lw_pos_end.
    ENDIF.

    PERFORM editor_paste USING lw_val lw_line_start lw_pos_start.
  ENDIF.

ENDFORM.                    &quot; DDIC_F4

*&amp;---------------------------------------------------------------------*
*&amp;      Form  EDITOR_GET_DEFAULT_QUERY
*&amp;---------------------------------------------------------------------*
*       Get default query
*----------------------------------------------------------------------*
*      &lt;--FT_QUERY  Default query content
*----------------------------------------------------------------------*
FORM editor_get_default_query  CHANGING ft_query TYPE table.
  DATA lw_string TYPE string.

  APPEND &apos;* Type here your query title&apos; TO ft_query.        &quot;#EC NOTEXT
  APPEND &apos;&apos; TO ft_query.
  APPEND &apos;SELECT *&apos; TO ft_query.                            &quot;#EC NOTEXT
  APPEND &apos;FROM &lt;table_name&gt;&apos; TO ft_query.                   &quot;#EC NOTEXT

  IF s_customize-default_rows NE 0.
    lw_string = s_customize-default_rows.
    CONDENSE lw_string NO-GAPS.
    CONCATENATE &apos;UP TO&apos;
                lw_string
                &apos;ROWS&apos;
                INTO lw_string SEPARATED BY space.
    APPEND lw_string TO ft_query.                           &quot;#EC NOTEXT
  ENDIF.

  APPEND &apos;WHERE &lt;conditions&gt;&apos; TO ft_query.                  &quot;#EC NOTEXT
  APPEND &apos;.&apos; TO ft_query.                                   &quot;#EC NOTEXT

ENDFORM.                    &quot; EDITOR_GET_DEFAULT_QUERY

*&amp;---------------------------------------------------------------------*
*&amp;      Form  TAB_NEW
*&amp;---------------------------------------------------------------------*
*       Open a new tab
*----------------------------------------------------------------------*
FORM tab_new.
  DATA : l_numb TYPE i,
         l_tab TYPE string.

  DESCRIBE TABLE t_tabs LINES l_numb.
  IF l_numb GE 30.
    MESSAGE &apos;You cannot open more than 30 tabs&apos;(m64)
            TYPE c_msg_success DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

  PERFORM leave_current_tab.

* Hide alv pane if displayed
  s_tab_active-row_height = 100.
  CALL METHOD o_splitter-&gt;set_row_height
    EXPORTING
      id     = 1
      height = s_tab_active-row_height.

* Start new tab
  l_tab = l_numb + 1.
  CONCATENATE &apos;TAB&apos; l_tab INTO l_tab.
  CONDENSE l_tab NO-GAPS.
  w_tabstrip-activetab = l_tab.
*  w_tabstrip-%_SCROLLPOSITION = l_tab. &quot;bugged

* Initialize new editor / ddic / alv
  PERFORM ddic_init.
  PERFORM editor_init.
  PERFORM result_init.

* Tab management
  APPEND s_tab_active TO t_tabs.

ENDFORM.                    &quot; TAB_NEW

*&amp;---------------------------------------------------------------------*
*&amp;      Form  LEAVE_CURRENT_TAB
*&amp;---------------------------------------------------------------------*
*       Hide editor / ddic / alv for current tab and save state
*----------------------------------------------------------------------*
FORM leave_current_tab.
* Hide current editor / ddic / alv
  CALL METHOD s_tab_active-o_textedit-&gt;set_visible
    EXPORTING
      visible = space.

  CALL METHOD s_tab_active-o_tree_ddic-&gt;set_visible
    EXPORTING
      visible = space.

  IF NOT s_tab_active-o_alv_result IS INITIAL.
    CALL METHOD s_tab_active-o_alv_result-&gt;set_visible
      EXPORTING
        visible = space.
  ENDIF.
* Save ALV split height
  CALL METHOD o_splitter-&gt;get_row_height
    EXPORTING
      id     = 1
    IMPORTING
      result = s_tab_active-row_height.
  CALL METHOD cl_gui_cfw=&gt;flush.

  PERFORM tab_update_title USING space.

  MODIFY t_tabs FROM s_tab_active INDEX w_tabstrip-activetab+3.
  CLEAR s_tab_active.
ENDFORM.                    &quot; LEAVE_CURRENT_TAB

*&amp;---------------------------------------------------------------------*
*&amp;      Form  TAB_UPDATE_TITLE
*&amp;---------------------------------------------------------------------*
*       Update tab title regarding current query
*       - Display first line query if it is a comment
*       - Display query as title in other cases
*----------------------------------------------------------------------*
*      --&gt;FW_QUERY Complete query
*----------------------------------------------------------------------*
FORM tab_update_title USING fw_query TYPE string.
  DATA : lw_name(30) TYPE c,
         lt_query TYPE soli_tab,
         ls_query LIKE LINE OF lt_query,
         lw_query TYPE string.
  FIELD-SYMBOLS &lt;fs&gt; TYPE any.
  IF w_tabstrip-activetab IS INITIAL.
    lw_name = &apos;S_TAB-TITLE1&apos;.
  ELSE.
    CONCATENATE &apos;S_TAB-TITLE&apos; w_tabstrip-activetab+3 INTO lw_name.
  ENDIF.
  ASSIGN (lw_name) TO &lt;fs&gt;.
  IF sy-subrc NE 0.
    RETURN.
  ENDIF.

* Basic read query to check if first line is a comment
  CALL METHOD s_tab_active-o_textedit-&gt;get_text
    IMPORTING
      table  = lt_query[]
    EXCEPTIONS
      OTHERS = 1.
  READ TABLE lt_query INTO ls_query INDEX 1.
  IF sy-subrc NE 0.
    &lt;fs&gt; = &apos;Empty tab&apos;(m65).
    RETURN.
  ENDIF.
  IF ls_query(1) = &apos;*&apos;.
    &lt;fs&gt; = ls_query+1.
    RETURN.
  ENDIF.

* Query given, use it as title
  IF NOT fw_query IS INITIAL.
    &lt;fs&gt; = fw_query.
    RETURN.
  ENDIF.

* If no query given, try to read it
  PERFORM editor_get_query USING space CHANGING lw_query.
  &lt;fs&gt; = lw_query.

ENDFORM.                    &quot; TAB_UPDATE_TITLE

*&amp;---------------------------------------------------------------------*
*&amp;      Form  Export_xml
*&amp;---------------------------------------------------------------------*
*       Export Saved Queries in xml format
*----------------------------------------------------------------------*
FORM export_xml.
  DATA : BEGIN OF ls_xml,
           line(256) TYPE x,
         END OF ls_xml,
         lt_xml LIKE TABLE OF ls_xml,

         lw_filename TYPE string,
         lw_path TYPE string,
         lw_fullpath TYPE string.
  DATA : lo_xml TYPE REF TO if_ixml,
         lo_document TYPE REF TO if_ixml_document,
         lo_root TYPE REF TO if_ixml_element,
         lo_element TYPE REF TO if_ixml_element,
         lw_string TYPE string,
         lo_streamfactory TYPE REF TO if_ixml_stream_factory,
         lo_ostream TYPE REF TO if_ixml_ostream,
         lo_renderer TYPE REF TO if_ixml_renderer,
         lw_title TYPE string,
         lw_filter TYPE string,
         lw_name TYPE string,
         BEGIN OF ls_ztoad,
           queryid TYPE ztoad-queryid,
           visibility TYPE ztoad-visibility_group,
           text TYPE ztoad-text,
           query TYPE ztoad-query,
         END OF ls_ztoad,
         lt_ztoad LIKE TABLE OF ls_ztoad.

* Ask name of file to generate
  lw_title = &apos;Choose file to create&apos;(m57).
  lw_filter = &apos;XML File (*.xml)|*.xml&apos;(m58).
  CALL METHOD cl_gui_frontend_services=&gt;file_save_dialog
    EXPORTING
      window_title = lw_title
      file_filter  = lw_filter
    CHANGING
      path         = lw_path
      filename     = lw_filename
      fullpath     = lw_fullpath
    EXCEPTIONS
      OTHERS       = 1.
  IF sy-subrc NE 0 OR lw_filename IS INITIAL OR lw_path IS INITIAL.
    MESSAGE &apos;Action cancelled&apos;(m14) TYPE c_msg_success
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

  CONCATENATE sy-uname &apos;#%&apos; INTO lw_name.
  CONDENSE lw_name NO-GAPS.

* Get all saved query (but not history)
  SELECT queryid visibility text query
         INTO TABLE lt_ztoad
         FROM ztoad
         WHERE owner = sy-uname
         AND NOT queryid LIKE lw_name.

  lo_xml = cl_ixml=&gt;create( ).
  lo_document = lo_xml-&gt;create_document( ).

  lo_root  = lo_document-&gt;create_simple_element( name = c_xmlnode_root
                                                 parent = lo_document ).
  LOOP AT lt_ztoad INTO ls_ztoad.
    lo_element  = lo_document-&gt;create_simple_element( name = c_xmlnode_file
                                                      parent = lo_root ).
    lw_string = ls_ztoad-visibility.
    lo_element-&gt;set_attribute( name = c_xmlattr_visibility value = lw_string ).

    lw_string = ls_ztoad-text.
    lo_element-&gt;set_attribute( name = c_xmlattr_text value = lw_string ).

    lw_string = ls_ztoad-query.
    lo_element-&gt;set_value( lw_string ).
  ENDLOOP.

  lo_streamfactory = lo_xml-&gt;create_stream_factory( ).

  lo_ostream  = lo_streamfactory-&gt;create_ostream_itable( lt_xml ).

  lo_renderer = lo_xml-&gt;create_renderer( ostream  = lo_ostream
                                         document = lo_document ).
  lo_ostream-&gt;set_pretty_print( abap_true ).
  lo_renderer-&gt;render( ).

  CALL METHOD cl_gui_frontend_services=&gt;gui_download
    EXPORTING
      filename = lw_fullpath
      filetype = &apos;BIN&apos;
    CHANGING
      data_tab = lt_xml.
ENDFORM.                    &quot;Export_xml

*&amp;---------------------------------------------------------------------*
*&amp;      Form  Import_xml
*&amp;---------------------------------------------------------------------*
*       Import Saved Queries from xml format
*----------------------------------------------------------------------*
FORM import_xml.
  DATA : lt_filetab TYPE filetable,
         ls_file    TYPE file_table,
         lw_filename TYPE string,
         lw_subrc    LIKE sy-subrc,
         lw_xmldata   TYPE xstring,
         lo_xml TYPE REF TO if_ixml,
         lo_document TYPE REF TO if_ixml_document,
         lo_streamfactory TYPE REF TO if_ixml_stream_factory,
         lo_stream TYPE REF TO if_ixml_istream,
         lo_parser TYPE REF TO if_ixml_parser.
  DATA : lo_iterator TYPE REF TO if_ixml_node_iterator,
         lo_node  TYPE REF TO if_ixml_node,
         lw_node_name TYPE string,
         lo_element TYPE REF TO if_ixml_element,
         lw_title TYPE string,
         lw_filter TYPE string,
         lw_guid TYPE guid_32,
         lw_group TYPE usr02-class,
         lw_string TYPE string,
         ls_ztoad TYPE ztoad,
         lt_ztoad LIKE TABLE OF ls_ztoad.

* Choose file to import
  lw_title = &apos;Choose file to import&apos;(m59).
  lw_filter = &apos;XML File (*.xml)|*.xml&apos;(m58).
  CALL METHOD cl_gui_frontend_services=&gt;file_open_dialog
    EXPORTING
      window_title   = lw_title
      file_filter    = lw_filter
      multiselection = space
    CHANGING
      file_table     = lt_filetab
      rc             = lw_subrc.

* Check user action (1 OPEN, 2 CANCEL)
  IF lw_subrc NE 1.
    MESSAGE &apos;Action cancelled&apos;(m14) TYPE c_msg_success
            DISPLAY LIKE c_msg_error.
    RETURN.
  ENDIF.

* Read filetable
  READ TABLE lt_filetab INTO ls_file INDEX 1.
  lw_filename = ls_file-filename.

* Get xml flow from file
* Or alternatively (if method does not exist) use the method
* cl_gui_frontend_services=&gt;gui_upload and then convert the
* x-tab to xstring
  TRY.
      lw_xmldata = cl_openxml_helper=&gt;load_local_file( lw_filename ).
    CATCH cx_openxml_not_found.
      MESSAGE &apos;Error when opening the input XML file&apos;(m60)
              TYPE c_msg_error.
      RETURN.
  ENDTRY.

  lo_xml = cl_ixml=&gt;create( ).

  lo_document = lo_xml-&gt;create_document( ).
  lo_streamfactory = lo_xml-&gt;create_stream_factory( ).
  lo_stream = lo_streamfactory-&gt;create_istream_xstring( string = lw_xmldata ).

  lo_parser = lo_xml-&gt;create_parser( stream_factory = lo_streamfactory
                                     istream        = lo_stream
                                     document       = lo_document ).
*-- parse the stream
  IF lo_parser-&gt;parse( ) NE 0.
    IF lo_parser-&gt;num_errors( ) NE 0.
      MESSAGE &apos;Error when parsing the input XML file&apos;(m61)
              TYPE c_msg_error.
      RETURN.
    ENDIF.
  ENDIF.

*-- we don&apos;t need the stream any more, so let&apos;s close it...
  CALL METHOD lo_stream-&gt;close( ).
  CLEAR lo_stream.

* Get usergroup
  SELECT SINGLE class INTO lw_group
         FROM usr02
         WHERE bname = sy-uname.

* Rebuild itab t_zspro
  lo_iterator = lo_document-&gt;create_iterator( ).
  lo_node = lo_iterator-&gt;get_next( ).
  WHILE NOT lo_node IS INITIAL.
    lw_node_name = lo_node-&gt;get_name( ).
    IF lw_node_name = c_xmlnode_file.
* Cast node to element
      lo_element ?= lo_node. &quot;-&gt;query_interface( ixml_iid_element ).
      CLEAR ls_ztoad.
      ls_ztoad-visibility_group = lw_group.
      ls_ztoad-owner = sy-uname.
      CONCATENATE sy-datum sy-uzeit INTO lw_string.
      ls_ztoad-aedat = lw_string.

* Generate new GUID
      DO 100 TIMES.
* Old function to get an unique id
        CALL FUNCTION &apos;GUID_CREATE&apos;
          IMPORTING
            ev_guid_32 = lw_guid.
* New function to get an unique id (do not work on older sap system)
*    TRY.
*        lw_guid = cl_system_uuid=&gt;create_uuid_c32_static( ).
*      CATCH cx_uuid_error.
*        EXIT. &quot;exit do
*    ENDTRY.

* Check that this uid is not already used
        SELECT SINGLE queryid INTO ls_ztoad-queryid
               FROM ztoad
               WHERE queryid = lw_guid.
        IF sy-subrc NE 0.
          READ TABLE lt_ztoad WITH KEY queryid = lw_guid TRANSPORTING NO FIELDS.
          IF sy-subrc NE 0.
            EXIT. &quot;exit do
          ENDIF.
        ENDIF.
      ENDDO.
      ls_ztoad-queryid = lw_guid.
      lw_string = lo_element-&gt;get_attribute( name = c_xmlattr_visibility ).
      ls_ztoad-visibility = lw_string.
      lw_string = lo_element-&gt;get_attribute( name = c_xmlattr_text ).
      ls_ztoad-text = lw_string.
      lw_string = lo_element-&gt;get_value( ).
      ls_ztoad-query = lw_string.
      APPEND ls_ztoad TO lt_ztoad.
    ENDIF.
    lo_node = lo_iterator-&gt;get_next( ).
  ENDWHILE.

  INSERT ztoad FROM TABLE lt_ztoad.
  IF sy-subrc = 0.
    MESSAGE s031(r9). &quot;Query saved
  ELSE.
    MESSAGE e220(iqapi). &quot;Error when saving the query
  ENDIF.

* Refresh repository to display new saved query
  PERFORM repo_fill.

ENDFORM.                    &quot;import_xml

*&amp;---------------------------------------------------------------------*
*&amp;      Form  SET_STATUS_010
*&amp;---------------------------------------------------------------------*
*       Set PF-STATUS for main scren
*       Adjust list of visible tabs
*----------------------------------------------------------------------*
FORM SET_STATUS_010 .
  DATA : lw_numb TYPE i,
         lw_max TYPE i.

  AUTHORITY-CHECK OBJECT &apos;S_DEVELOP&apos; ID &apos;ACTVT&apos; FIELD &apos;03&apos;
                                     ID &apos;DEVCLASS&apos; DUMMY
                                     ID &apos;OBJTYPE&apos; DUMMY
                                     ID &apos;OBJNAME&apos; DUMMY
                                     ID &apos;P_GROUP&apos; DUMMY.
  IF sy-subrc = 0.
    SET PF-STATUS &apos;STATUS010&apos;.
  ELSE.
* If you dont have S_DEVELOP access in display, you probably dont
* understand the code generated =&gt; do not display the button
    SET PF-STATUS &apos;STATUS010&apos; EXCLUDING &apos;SHOWCODE&apos;.
  ENDIF.
  SET TITLEBAR &apos;STATUS010&apos;.

  DESCRIBE TABLE t_tabs LINES lw_max.

  LOOP AT SCREEN.
    IF screen-name(6) = &apos;S_TAB-&apos;.
      lw_numb = screen-name+11.
      IF lw_numb &gt; lw_max.
        screen-invisible = 1.
      ELSE.
        screen-invisible = 0.
      ENDIF.
      MODIFY SCREEN.
    ENDIF.
  ENDLOOP.
ENDFORM.                    &quot; SET_STATUS_010</source>
</PROG>

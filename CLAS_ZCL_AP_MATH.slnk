<?xml version="1.0" encoding="utf-8"?>
<CLAS CLSNAME="ZCL_AP_MATH" VERSION="1" LANGU="S" DESCRIPT="Calculos" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" DURATION_TYPE="0 " RISK_LEVEL="0 " ZSAPLINK_PLUGIN_MAJOR_VERSION="0 " ZSAPLINK_PLUGIN_MINOR_VERSION="1 " ZSAPLINK_PLUGIN_BUILD_VERSION="0 " ZSAPLINK_PLUGIN_INFO1="ZSAPLINK_CLASS is part of the main ZSAPLINK project --&gt; This plugin found there instead of ZSAPLINK_PLUGINS projects" ZSAPLINK_PLUGIN_INFO2="SAPLINK homepage: https://www.assembla.com/spaces/saplink/wiki" ZSAPLINK_PLUGIN_INFO3="Download from https://www.assembla.com/code/saplink/subversion/nodes" ZSAPLINK_PLUGIN_INFO4="and navigate to:  trunk -&gt; core -&gt; ZSAPLINK -&gt; CLAS -&gt; ZSAPLINK_CLASS.slnk">
 <localImplementation>*&quot;* use this source file for the definition and implementation of
*&quot;* local helper classes, interface definitions and type
*&quot;* declarations</localImplementation>
 <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
 <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
 <method CLSNAME="ZCL_AP_MATH" CMPNAME="DESVIACION_STD" VERSION="1" LANGU="S" DESCRIPT="Cálculo desviación estándar" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_AP_MATH" CMPNAME="DESVIACION_STD" SCONAME="I_DATOS" VERSION="1" LANGU="S" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="UPF_T_FLOAT"/>
  <parameter CLSNAME="ZCL_AP_MATH" CMPNAME="DESVIACION_STD" SCONAME="DESVIACION" VERSION="1" LANGU="S" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="F"/>
  <source>METHOD desviacion_std.
  DATA: l_media     TYPE f,
        l_suma      TYPE f,
        l_elementos TYPE i,
        l_variacion TYPE f,
        l_valor     TYPE f.

  CLEAR: l_suma, l_media, l_elementos.
  desviacion = 0.

  LOOP AT i_datos INTO l_valor.
    ADD 1 TO l_elementos.
    ADD l_valor TO l_suma.
  ENDLOOP.

  CHECK l_elementos &gt; 1.

  l_media = l_suma / l_elementos.

  CLEAR l_suma.
  LOOP AT i_datos INTO l_valor.
    l_suma = l_suma + ( ( l_valor - l_media ) ** 2 ).
  ENDLOOP.

*  l_variacion = ( 1 / ( l_elementos - 1 ) ) * l_suma.
  CHECK l_media NE 0.

  l_variacion = l_suma / l_elementos.

  desviacion = sqrt( l_variacion ).


ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_AP_MATH" CMPNAME="MEDIANA" VERSION="1" LANGU="S" DESCRIPT="Mediana" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_AP_MATH" CMPNAME="MEDIANA" SCONAME="I_DATOS" VERSION="1" LANGU="S" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="UPF_T_FLOAT"/>
  <parameter CLSNAME="ZCL_AP_MATH" CMPNAME="MEDIANA" SCONAME="MEDIANA" VERSION="1" LANGU="S" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="F"/>
  <source>METHOD mediana.
  DATA: datos TYPE upf_t_float.

  CLEAR mediana.

  IF i_datos IS INITIAL.
    RETURN.
  ENDIF.

  DATA(l_elementos) = lines( i_datos ).
  IF l_elementos = 1.
    mediana = i_datos[ 1 ].
    RETURN.
  ELSEIF l_elementos = 2.
    mediana = ( i_datos[ 1 ] + i_datos[ 2 ] ) / 2.
    RETURN.
  ENDIF.

  datos = i_datos.
  SORT datos.

  IF l_elementos MOD 2 = 1. &quot;Impar
    l_elementos = l_elementos DIV 2 + 1.
    mediana = datos[ l_elementos ].
  ELSE.
    l_elementos = l_elementos DIV 2.
    DATA(l_siguiente) = l_elementos + 1.
    mediana = ( datos[ l_elementos ] + datos[ l_siguiente ] ) / 2.
  ENDIF.

ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_AP_MATH" CMPNAME="REDONDEO_CONDICIONAL" VERSION="1" LANGU="S" DESCRIPT="Redondeo condicional en base a porcentaje" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_AP_MATH" CMPNAME="REDONDEO_CONDICIONAL" SCONAME="CANTIDAD" VERSION="1" LANGU="S" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_AP_MATH" CMPNAME="REDONDEO_CONDICIONAL" SCONAME="PORCENTAJE" VERSION="1" LANGU="S" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_AP_MATH" CMPNAME="REDONDEO_CONDICIONAL" SCONAME="DIFERENCIA" VERSION="1" LANGU="S" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_AP_MATH" CMPNAME="REDONDEO_CONDICIONAL" SCONAME="SALIDA" VERSION="1" LANGU="S" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="MENGV13"/>
  <source>METHOD redondeo_condicional.
  DATA: l_entero  TYPE i,
        l_dif     TYPE mengv13,
        l_dif_max TYPE mengv13.

  salida   = cantidad.
  l_entero = cantidad.
  l_dif = ABS( l_entero - cantidad ).

  CHECK l_dif NE 0.

  l_dif_max = diferencia.
  IF NOT porcentaje IS INITIAL.
    l_dif_max = porcentaje * cantidad / 100.
  ENDIF.

  IF l_dif &lt;= l_dif_max.
    salida = l_entero.
  ENDIF.

ENDMETHOD.</source>
 </method>
</CLAS>

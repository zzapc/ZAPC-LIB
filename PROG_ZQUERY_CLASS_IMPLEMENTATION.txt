*&---------------------------------------------------------------------*
*& Include ZQUERY_CLASS_IMPLEMENTATION
*&---------------------------------------------------------------------*
CLASS lcl_query IMPLEMENTATION .

  METHOD constructor.
    me->set_query( i_query ).
    me->compute_query( ).
  ENDMETHOD. "constructor

  "$. Region Getters and Setters
  METHOD set_query.
    me->t_query = i_query .
  ENDMETHOD. "set_query
  METHOD get_query.
    return = me->t_query.
  ENDMETHOD. "get_query

  METHOD set_data.
    me->o_data = i_data.
  ENDMETHOD.                    "set_data
  METHOD get_data.
    return = me->o_data.
  ENDMETHOD.                    "get_data

  METHOD set_query_string.
    me->v_query = i_query.
  ENDMETHOD.                    "set_query_string
  METHOD get_query_string.
    return = me->v_query.
  ENDMETHOD.                    "get_query_String
  "$. Endregion Getters and Setters

  METHOD split_text.
    DATA: l_length TYPE i,
    l_remains TYPE i,
    l_aux TYPE i,
    l_text TYPE string ,
    l_last_char TYPE i.

    l_length = STRLEN( i_text ).

    IF l_length <= i_outputlen.
      APPEND i_text TO return.
      RETURN.
    ELSE.

      l_remains = l_length.

      DO.
        IF i_outputlen < l_remains.
          l_text = i_text+l_aux(i_outputlen).
        ELSE.
          APPEND i_text+l_aux(l_remains) TO return.
          EXIT.
        ENDIF.

        l_last_char = STRLEN( l_text ) - 1.

        DO.
          DATA l_char TYPE char1.

          l_char = l_text+l_last_char(1).
          CONDENSE l_char NO-GAPS.

          IF l_char IS INITIAL OR l_char = space.
            EXIT.
          ENDIF.
          l_last_char = STRLEN( l_text(l_last_char) ) - 1.
        ENDDO.

        APPEND l_text(l_last_char) TO return.
        ADD l_last_char TO l_aux .
        l_remains = l_length - l_aux.
      ENDDO.
    ENDIF.
  ENDMETHOD. "split_text

  METHOD add_query_element.
    APPEND i_query_element TO me->t_query_elements.
  ENDMETHOD. "add_query_element

  METHOD get_query_elements.
    e_elements = me->t_query_elements .
  ENDMETHOD. "get_query_elements

  METHOD execute.
    CONSTANTS: c_form_name TYPE string VALUE 'F_EXECUTE'.

    DATA: o_data        TYPE REF TO data,
          o_select      TYPE REF TO lcl_select,
          o_report      TYPE REF TO lcl_report,
          t_split_1     TYPE salv_wd_t_string,
          t_split_2     TYPE salv_wd_t_string,

          l_report_name TYPE string,
          l_query       TYPE string,
          l_split_1     TYPE string,
          l_split_2     TYPE string.

    o_data = me->get_data( ).
    o_select ?= me->get_query_element( lcl_commands=>select ).

    CONCATENATE 'ZQUERY_EXEC' sy-datum sy-uzeit INTO l_report_name SEPARATED BY '_'.
    CREATE OBJECT o_report
      EXPORTING
        i_report_name = l_report_name.

    l_query = me->get_query_string( ).
    SPLIT l_query AT lcl_commands=>from_check INTO l_split_1 l_split_2.
    CONCATENATE lcl_commands=>from l_split_2 '.' INTO l_split_2 SEPARATED BY space.
    CONDENSE: l_split_1, l_split_2.
    t_split_1 = lcl_query=>split_text( i_text = l_split_1
                                       i_outputlen = 80 ).
    t_split_2 = lcl_query=>split_text( i_text = l_split_2
                                       i_outputlen = 80 ).

    o_report->add_report_name( ).
    o_report->add_source( ). "Blank line
    o_report->add_source( 'FORM F_EXECUTE.' ).
    o_report->add_source( ). "Blank line
    o_report->add_source( 'DATA: O_DATA TYPE REF TO DATA.' ).
    o_report->add_source( 'DATA: O_WA_DATA TYPE REF TO DATA.' ).
    o_report->add_source( 'DATA: V_COUNT TYPE I.' ).
    o_report->add_source( 'FIELD-SYMBOLS: <FS_TAB> TYPE STANDARD TABLE.' ).
    o_report->add_source( 'FIELD-SYMBOLS: <FS_WA> TYPE ANY.' ).
    o_report->add_source( 'FIELD-SYMBOLS: <FS_AUX> TYPE ANY.' ).
    o_report->add_source( ). "Blank line
    o_report->add_source( 'O_DATA = ZCL_ZQUERY_DATA_TRANSFER=>GET_DATA( ).' ).
    o_report->add_source( ). "Blank line
    o_report->add_source( 'ASSIGN O_DATA->* TO <FS_TAB>. CHECK SY-SUBRC IS INITIAL.' ).
    o_report->add_source( ). "Blank line

    IF o_select->get_select_type( ) = lcl_commands=>single.
      o_report->add_source( 'CREATE DATA O_WA_DATA LIKE LINE OF <FS_TAB>.' ).
      o_report->add_source( 'ASSIGN O_WA_DATA->* TO <FS_WA>. CHECK SY-SUBRC IS INITIAL.' ).
      o_report->add_source( ). "Blank line
      LOOP AT t_split_1 INTO l_split_1.
        o_report->add_source( l_split_1 ).
      ENDLOOP.
      IF me->get_fields_count( ) > lcl_select=>c_max_fields.
        o_report->add_source( 'INTO CORRESPONDING FIELDS OF <FS_WA>' ).
      ELSE.
        o_report->add_source( 'INTO <FS_WA>' ).
      ENDIF.
      LOOP AT t_split_2 INTO l_split_2.
        o_report->add_source( l_split_2 ).
      ENDLOOP.
      o_report->add_source( ). "Blank line
      o_report->add_source( 'APPEND <FS_WA> TO <FS_TAB>.' ).

    ELSEIF o_select->get_select_type( ) = lcl_commands=>count.
      o_report->add_source( 'CREATE DATA O_WA_DATA LIKE LINE OF <FS_TAB>.' ).
      o_report->add_source( 'ASSIGN O_WA_DATA->* TO <FS_WA>. CHECK SY-SUBRC IS INITIAL.' ).
      o_report->add_source( ). "Blank line
      LOOP AT t_split_1 INTO l_split_1.
        o_report->add_source( l_split_1 ).
      ENDLOOP.
      o_report->add_source( 'INTO V_COUNT' ).
      LOOP AT t_split_2 INTO l_split_2.
        o_report->add_source( l_split_2 ).
      ENDLOOP.
      o_report->add_source( ). "Blank line
      o_report->add_source( 'ASSIGN COMPONENT 1 OF STRUCTURE <FS_WA> TO <FS_AUX>. CHECK SY-SUBRC IS INITIAL.' ).
      o_report->add_source( ). "Blank line
      o_report->add_source( '<FS_AUX> = V_COUNT.' ).
      o_report->add_source( ). "Blank line
      o_report->add_source( 'APPEND <FS_WA> TO <FS_TAB>.' ).

    ELSE.
      LOOP AT t_split_1 INTO l_split_1.
        o_report->add_source( l_split_1 ).
      ENDLOOP.
      IF me->get_fields_count( ) > lcl_select=>c_max_fields.
        o_report->add_source( 'INTO CORRESPONDING FIELDS OF TABLE <FS_TAB>' ).
      ELSE.
        o_report->add_source( 'INTO TABLE <FS_TAB>' ).
      ENDIF.
      LOOP AT t_split_2 INTO l_split_2.
        o_report->add_source( l_split_2 ).
      ENDLOOP.

    ENDIF.

    o_report->add_source( ). "Blank line
    o_report->add_source( 'ZCL_ZQUERY_DATA_TRANSFER=>SET_DATA( O_DATA ).' ).
    o_report->add_source( ). "Blank line
    o_report->add_source( 'ENDFORM.' ).

    zcl_zquery_data_transfer=>set_data( o_data ).

    l_report_name = o_report->generate_report( ).
    IF sy-subrc IS INITIAL.
      o_report->execute_report( i_form_name   = c_form_name
                                i_report_name = l_report_name ).
      o_report->delete_report( l_report_name ).
    ENDIF.

    o_data = zcl_zquery_data_transfer=>get_data( ).
    me->set_data( o_data ).

  ENDMETHOD. "execute

  METHOD compute_query.
    DATA: t_aux        TYPE salv_wd_t_string,
          t_query_comp TYPE salv_wd_t_string,
          t_query      TYPE salv_wd_t_string,
          l_query      TYPE string,
          l_string     TYPE string,
          l_line       TYPE i.

    FIELD-SYMBOLS: <fs_text> TYPE char255,
    <fs_string> TYPE string.

    t_query = me->get_query( ).

    LOOP AT t_query INTO l_string.
      CONCATENATE l_query l_string INTO l_query SEPARATED BY space.
    ENDLOOP.

    TRANSLATE l_query TO UPPER CASE.
    CONDENSE l_query.
    me->set_query_string( l_query ).

    SPLIT l_query AT space INTO TABLE t_aux.

    LOOP AT t_aux INTO l_string.
      IF l_string = ''''.
        DESCRIBE TABLE t_query_comp LINES l_line.
        READ TABLE t_query_comp ASSIGNING <fs_string> INDEX l_line.
        CONCATENATE <fs_string> l_string INTO <fs_string>.
        UNASSIGN <fs_string>.
      ELSE.
        APPEND l_string TO t_query_comp.
      ENDIF.
    ENDLOOP.

    me->set_query( t_query_comp ).
  ENDMETHOD. "compute_query

  METHOD check_query_syntax.
    DATA: o_report      TYPE REF TO lcl_report,
          t_program     TYPE salv_wd_t_string,
          l_report_name TYPE string,
          l_query       TYPE string. "salv_wd_t_string

    l_query = me->get_query_string( ).

    CONCATENATE 'ZQUERY_CHECK' sy-datum sy-uzeit INTO l_report_name SEPARATED BY '_'.
    CREATE OBJECT o_report
      EXPORTING
        i_report_name = l_report_name.

    me->build_to_syntax_check( i_query  = l_query
                               i_report = o_report ).

    o_report->check_syntax( ).

    return = abap_true.

  ENDMETHOD. "check_query_syntax

  METHOD build_to_syntax_check.
    DATA: t_select       TYPE salv_wd_t_string,
          t_aux          TYPE salv_wd_t_string,
          l_split_1      TYPE string,
          l_split_2      TYPE string,
          l_query_aux    TYPE string,
          l_data         TYPE string,
          l_into         TYPE string,
          l_index        TYPE i VALUE 1,
          l_single       TYPE boolean,
          l_count        TYPE boolean,
          l_select_field TYPE string,
          l_out          TYPE boolean,
          l_aux TYPE string.
    FIELD-SYMBOLS <fs_aux> TYPE string.

    l_query_aux = i_query.

    "$. Region Check Commands
    DATA: l_length TYPE i,
          l_length_aux TYPE i.
    l_length = STRLEN( lcl_commands=>select ).
    l_length_aux = STRLEN( l_query_aux ).
    IF l_length_aux < l_length.
      l_length = l_length_aux.
    ENDIF.
    IF l_query_aux(l_length) <> lcl_commands=>select.
      RAISE EXCEPTION TYPE lcx_query_element_not_found EXPORTING i_text = 'No SELECT command found'.
    ENDIF.

    FIND lcl_commands=>from_check IN l_query_aux.
    IF NOT sy-subrc IS INITIAL.
      RAISE EXCEPTION TYPE lcx_query_element_not_found EXPORTING i_text = 'No FROM command found'.
    ENDIF.
    "$. Endregion Check Commands

    SPLIT l_query_aux AT lcl_commands=>from_check INTO l_split_1 l_split_2.
    CONDENSE: l_split_1, l_split_2.
    FIND lcl_commands=>single_check IN l_split_1.
    IF sy-subrc IS INITIAL.
      l_single = abap_true.
    ENDIF.

    SPLIT l_split_1 AT space INTO TABLE t_select.
    READ TABLE t_select WITH KEY table_line = lcl_commands=>select TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.
      DELETE t_select INDEX sy-tabix.
    ENDIF.

    READ TABLE t_select WITH KEY table_line = lcl_commands=>single TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.
      DELETE t_select INDEX sy-tabix.
    ENDIF.

    IF l_single = abap_false.
      WHILE l_out = abap_false.
        CLEAR l_select_field.
        LOOP AT t_select ASSIGNING <fs_aux> FROM l_index.
          l_index = sy-tabix.
          AT LAST.
            l_out = abap_true.
          ENDAT.

          IF <fs_aux> = lcl_commands=>count_check OR l_count = abap_true.
            l_count = abap_true.
            CONCATENATE l_select_field <fs_aux> INTO l_select_field SEPARATED BY space.
          ELSE.
            CONCATENATE l_select_field <fs_aux> INTO l_select_field SEPARATED BY space.
          ENDIF.

          IF l_count = abap_true.
            IF <fs_aux> = ')'.
              ADD 1 TO l_index.
              READ TABLE t_select INTO l_aux INDEX l_index.
              IF l_aux <> lcl_commands=>as.
                l_count = abap_false. CONDENSE l_select_field.
                APPEND l_select_field TO t_aux.
                EXIT.
              ENDIF.
            ENDIF.
          ELSE.
            ADD 1 TO l_index.
            READ TABLE t_select INTO l_aux INDEX l_index.
            IF l_aux <> lcl_commands=>as.
              CONDENSE l_select_field.
              APPEND l_select_field TO t_aux.
              EXIT.
            ENDIF.
          ENDIF.
        ENDLOOP.
        IF NOT sy-subrc IS INITIAL.
          l_out = abap_true.
        ENDIF.
      ENDWHILE.

      LOOP AT t_aux ASSIGNING <fs_aux>.
        FIND lcl_commands=>count_check IN <fs_aux>.
        IF sy-subrc IS INITIAL.
          DELETE t_aux.
        ENDIF.
      ENDLOOP.

      IF t_aux IS INITIAL.
        l_count = abap_true.
      ENDIF.
    ENDIF.

    IF l_single = abap_true OR l_count = abap_true.
      l_data = 'FIELD-SYMBOLS <fs_wa> TYPE ANY.'.           "#EC NOTEXT
      l_into = 'INTO <fs_wa>'.
    ELSE.
      l_data = 'FIELD-SYMBOLS <fs_tab> TYPE STANDARD TABLE.'. "#EC NOTEXT
      l_into = 'INTO TABLE <fs_tab>'.
    ENDIF.

    CONCATENATE lcl_commands=>from l_split_2 '.' INTO l_split_2 SEPARATED BY space.

    i_report->add_report_name( ).
    i_report->add_source( ).
    i_report->add_source( l_data ).
    i_report->add_source( ).
    i_report->add_source( l_split_1 ).
    i_report->add_source( l_into ).
    i_report->add_source( l_split_2 ).

  ENDMETHOD. "build_to_sysntax_check

  METHOD identify_query_elements.
    DATA: t_query         TYPE salv_wd_t_string,
          o_query_element TYPE REF TO lcl_query_element.
    FIELD-SYMBOLS: <fs_command> TYPE string.

    IF NOT i_element IS INITIAL.
      READ TABLE me->t_query WITH KEY table_line = i_element TRANSPORTING NO FIELDS.
      IF sy-subrc IS INITIAL.
        return = lcl_query_element_factory=>factory_query_element( i_element ).
        return->set_command_contents( i_query   = me->t_query
                                      i_command = i_element ).
      ENDIF.
    ELSE.
      LOOP AT lcl_commands=>t_identify_commands ASSIGNING <fs_command>.
        READ TABLE me->t_query WITH KEY table_line = <fs_command> TRANSPORTING NO FIELDS.
        IF sy-subrc IS INITIAL.
          o_query_element = lcl_query_element_factory=>factory_query_element( <fs_command> ).
          o_query_element->set_command_contents( i_query   = me->t_query
                                                 i_command = <fs_command> ).
          me->add_query_element( o_query_element ).
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.                    "identify_query_elements

  METHOD get_query_element.
    READ TABLE me->t_query_elements INTO return WITH KEY table_line->v_element = i_element.
  ENDMETHOD.                    "get_query_element

  METHOD get_fields_count.
    DATA: o_select TYPE REF TO lcl_select.
    o_select ?= me->get_query_element( lcl_commands=>select ).
    return = o_select->get_fields_count( ).
  ENDMETHOD.                    "get_fields_count

ENDCLASS. "lcl_query IMPLEMENTATION

*----------------------------------------------------------------------*
* CLASS lcl_select IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_select IMPLEMENTATION .

  "$. Region Getters and Setters
  METHOD set_select_type.
    me->select_type = i_select_type .
  ENDMETHOD. "set_select_type

  METHOD get_select_type.
    DATA: o_field  TYPE REF TO lcl_field,
          t_fields TYPE TABLE OF REF TO lcl_field,
          l_count TYPE boolean.

    me->get_fields( IMPORTING return = t_fields ).

    IF me->select_type = lcl_commands=>single.
      return = me->select_type.
      RETURN.

    ELSEIF me->select_type = lcl_commands=>distinct.
      return = me->select_type.
      RETURN.

    ELSEIF LINES( t_fields ) = 1.
      READ TABLE t_fields INTO o_field INDEX 1.
      IF o_field->get_field_name( ) = lcl_commands=>asterisk AND o_field->get_count_field( ) = abap_true.
        return = lcl_commands=>count.
        RETURN.
      ELSEIF o_field->get_field_name( ) = lcl_commands=>asterisk.
        return = lcl_commands=>asterisk.
        RETURN.
      ENDIF.

    ELSE.
      LOOP AT t_fields INTO o_field.
        IF o_field->get_count_field( ) = abap_true.
          l_count = abap_true.
        ELSE.
          l_count = abap_false.
          EXIT.
        ENDIF.
      ENDLOOP.
      IF l_count = abap_true.
        return = lcl_commands=>single.
      ENDIF.

    ENDIF.

  ENDMETHOD. "get_select_type
  "$. Endregion Getters and Setters

  METHOD get_fields_count.
    DESCRIBE TABLE me->t_fields LINES return.
  ENDMETHOD.                    "get_fields_count

  METHOD add_field.
    APPEND i_field TO me->t_fields.
  ENDMETHOD. "add_field

  METHOD get_fields.
    return = me->t_fields.
  ENDMETHOD.                    "get_fields

  METHOD set_command_contents.
    DATA: o_field      TYPE REF TO lcl_field,
          l_sql_func   TYPE char3,
          l_string     TYPE string,
          l_aux        TYPE string,
          l_index      TYPE sytabix,
          l_name       TYPE string,
          l_alias      TYPE string,
          l_table_name TYPE string,
          l_alias_on   TYPE boolean,
          l_count_on   TYPE boolean,
          l_out TYPE boolean.

    READ TABLE i_query WITH KEY table_line = i_command TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.

      l_index = sy-tabix.
      ADD 1 TO l_index.

      READ TABLE i_query INTO l_string INDEX l_index.
      IF l_string = lcl_commands=>single OR
         l_string = lcl_commands=>distinct.
        me->set_select_type( l_string ).
        ADD 1 TO l_index.

      ELSEIF l_string = lcl_commands=>asterisk.
        me->set_select_type( lcl_commands=>asterisk ).

      ENDIF.

      WHILE l_out = abap_false.
        LOOP AT i_query INTO l_string FROM l_index.
          l_index = sy-tabix.
          IF l_string = lcl_commands=>from  OR
             l_string = lcl_commands=>where OR
             l_string = lcl_commands=>up.
            l_out = abap_true.
            EXIT.
          ENDIF.

          CASE l_string.
            WHEN lcl_commands=>count_check.
              CREATE OBJECT o_field
                EXPORTING
                  i_field_name = space.
              o_field->set_count_field( abap_true ).

            WHEN lcl_commands=>max_check OR
                 lcl_commands=>sum_check OR
                 lcl_commands=>min_check OR
                 lcl_commands=>avg_check.
              CREATE OBJECT o_field
                EXPORTING
                  i_field_name = space.
              l_sql_func = l_string. l_string = l_sql_func.
              o_field->set_sql_function( l_string ).

            WHEN ')'.
              l_index = me->check_alias_existence( i_query = i_query
                                                   i_index = l_index
                                                   i_field = o_field ).
              CLEAR o_field. EXIT.

            WHEN OTHERS.
              IF o_field IS BOUND                        AND
                 o_field->get_count_field( ) = abap_true AND
                l_string <> lcl_commands=>distinct.
                me->split_field_name( EXPORTING i_field   = l_string
                                      IMPORTING e_name    = l_name
                                                e_tabname = l_table_name ).
                o_field->set_field_name( l_name ).
                o_field->set_table_name( l_table_name ).

              ELSEIF o_field IS BOUND AND NOT o_field->get_sql_function( ) IS INITIAL.
                me->split_field_name( EXPORTING i_field   = l_string
                                      IMPORTING e_name    = l_name
                                                e_tabname = l_table_name ).
                o_field->set_field_name( l_name ).
                o_field->set_table_name( l_table_name ).

              ELSEIF NOT o_field IS BOUND.
                me->split_field_name( EXPORTING i_field   = l_string
                                      IMPORTING e_name    = l_name
                                                e_tabname = l_table_name ).
                CREATE OBJECT o_field
                  EXPORTING
                    i_field_name = l_name
                    i_table_name = l_table_name.

                l_index = me->check_alias_existence( i_query = i_query
                                                     i_index = l_index
                                                     i_field = o_field ).
                CLEAR o_field. EXIT.
              ENDIF.

          ENDCASE.

          APPEND l_string TO me->t_command_contents.
          CONCATENATE me->v_command l_string INTO me->v_command SEPARATED BY space.
        ENDLOOP.
      ENDWHILE.

    ENDIF.
  ENDMETHOD.                    "set_command_contents

  METHOD split_field_name.
    DATA: l_aux_1 TYPE string,
          l_aux_2 TYPE string.

    SPLIT i_field AT '~' INTO l_aux_1 l_aux_2.
    IF l_aux_2 IS INITIAL.
      e_name = l_aux_1.
    ELSE.
      e_tabname = l_aux_1.
      e_name    = l_aux_2.
    ENDIF.
  ENDMETHOD.                    "split_field_name

  METHOD check_alias_existence.
    DATA: l_index TYPE i,
          l_aux   TYPE string.

    l_index = i_index.
    ADD 1 TO l_index.
    READ TABLE i_query INTO l_aux INDEX l_index.
    IF l_aux = lcl_commands=>as.
      ADD 1 TO l_index.
      READ TABLE i_query INTO l_aux INDEX l_index.
      i_field->set_field_alias( l_aux ).
      ADD 1 TO l_index.
    ENDIF.

    me->add_field( i_field ).

    return = l_index.

  ENDMETHOD.                    "check_alias_existence

ENDCLASS. "lcl_select IMPLEMENTATION
*&---------------------------------------------------------------------*
*& Class (Implementation) lcl_field
*&---------------------------------------------------------------------*
CLASS lcl_field IMPLEMENTATION .

  "$. Region Getters and Setters
  METHOD set_field_alias.
    me->v_field_alias = i_field_alias .
  ENDMETHOD. "set_field_alias

  METHOD get_field_alias.
    return = me->v_field_alias.
  ENDMETHOD. "get_field_alias

  METHOD set_field_name.
    me->v_field_name = i_field_name .
  ENDMETHOD. "set_field_name

  METHOD get_field_name.
    return = me->v_field_name.
  ENDMETHOD. "get_field_name

  METHOD set_table_name.
    me->v_table_name = i_table_name.
  ENDMETHOD.                    "set_table_name
  METHOD get_table_name.
    return = me->v_table_name.
  ENDMETHOD.                    "get_table_name

  METHOD set_count_field.
    me->v_count_field = i_count.
  ENDMETHOD.                    "set_count_field
  METHOD get_count_field.
    return = me->v_count_field.
  ENDMETHOD.                    "get_count_field

  METHOD set_sql_function.
    me->v_sql_function = i_sql_function.
  ENDMETHOD.                    "set_sql_function
  METHOD get_sql_function.
    return = me->v_sql_function.
  ENDMETHOD.                    "get_sql_function
  "$. Endregion Getters and Setters

  METHOD constructor.
    me->set_field_name( i_field_name ).
    me->set_field_alias( i_field_alias ).
    me->set_table_name( i_table_name ).
  ENDMETHOD.                    "constructor

ENDCLASS. "lcl_field

*----------------------------------------------------------------------*
*       CLASS lcl_join_fields IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_join_fields IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_fortable.
    me->v_fortable = i_fortable.
  ENDMETHOD.                    "set_fortable
  METHOD get_fortable.
    return = me->v_fortable.
  ENDMETHOD.                    "get_fortable

  METHOD set_forkey.
    me->v_forkey = i_forkey.
  ENDMETHOD.                    "set_forkey
  METHOD get_forkey.
    return = me->v_forkey.
  ENDMETHOD.                    "get_forkey

  METHOD set_checktable.
    me->v_checktable = i_checktable.
  ENDMETHOD.                    "set_checktable
  METHOD get_checktable.
    return = me->v_checktable.
  ENDMETHOD.                    "get_checktable

  METHOD set_checkfield.
    me->v_checkfield = i_checkfield.
  ENDMETHOD.                    "set_checkfield
  METHOD get_checkfield.
    return = me->v_checkfield.
  ENDMETHOD.                    "get_checkfield

  METHOD set_join_fields.
    me->t_join_fields = i_join_fields.
  ENDMETHOD.                    "set_join_fields
  METHOD get_join_fields.
    e_join_fields = me->t_join_fields.
  ENDMETHOD.                    "get_join_fields
  "$. Endregion Getters and Setters

  METHOD add_join_field.
    FIELD-SYMBOLS <fs_join_field> TYPE ty_join_fields.
    APPEND INITIAL LINE TO me->t_join_fields ASSIGNING <fs_join_field>.
    <fs_join_field>-fortable   = i_fortable. "me->get_fortable( ).
    <fs_join_field>-forkey     = i_forkey. "me->get_forkey( ).
    <fs_join_field>-checktable = i_checktable. "me->get_checktable( ).
    <fs_join_field>-checkfield = i_checkfield. "me->get_checkfield( ).
    <fs_join_field>-signal     = '='.
    UNASSIGN <fs_join_field>.
  ENDMETHOD.                    "add_join_field

  METHOD get_join_fields_count.
    DESCRIBE TABLE me->t_join_fields LINES return.
  ENDMETHOD.                    "get_join_fields_count

ENDCLASS.                    "lcl_join_fields DEFINITION

*&---------------------------------------------------------------------*
*& Class (Implementation) lcl_table
*&---------------------------------------------------------------------*
CLASS lcl_table IMPLEMENTATION .

  "$. Region Getters and setters
  METHOD set_name.
    me->v_name = i_name .
  ENDMETHOD. "set_name
  METHOD get_name.
    return = me->v_name.
  ENDMETHOD. "get_name

  METHOD set_alias.
    me->v_alias = i_alias .
  ENDMETHOD. "set_alias
  METHOD get_alias.
    return = me->v_alias.
  ENDMETHOD. "get_alias

  METHOD set_outer_join.
    me->v_outer_join = i_outer_join.
  ENDMETHOD.                    "set_outer_join
  METHOD get_outer_join.
    return = me->v_outer_join.
  ENDMETHOD.                    "get_outer_join

  METHOD set_join_fields.
    me->t_join_fields = i_join_fields.
  ENDMETHOD.                    "set_join_fields
  METHOD get_join_fields.
    e_join_fields = me->t_join_fields.
  ENDMETHOD.                    "get_join_fields

  METHOD set_join_kind.
    me->v_join_kind = i_join_kind.
  ENDMETHOD.                    "set_join_kind
  METHOD get_join_kind.
    return = me->v_join_kind.
  ENDMETHOD.                    "get_join_kind
  "$. Endregion Getters and setters

  METHOD constructor.
    me->set_name( i_name ).
    me->set_alias( i_alias ).
  ENDMETHOD.                    "constructor

  METHOD get_table_fields.
    DATA: t_fcat TYPE lvc_t_fcat,
          l_name TYPE dd02l-tabname.

    FIELD-SYMBOLS: <fs_fcat>  TYPE lvc_s_fcat,
                   <fs_field> TYPE ty_table_fields.

    l_name = me->get_name( ).

    CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
      EXPORTING
        i_buffer_active        = abap_false
        i_structure_name       = l_name
        i_bypassing_buffer     = abap_true
      CHANGING
        ct_fieldcat            = t_fcat
      EXCEPTIONS
        inconsistent_interface = 1
        program_error          = 2
        OTHERS                 = 3.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    LOOP AT t_fcat ASSIGNING <fs_fcat>.
      APPEND INITIAL LINE TO e_fields ASSIGNING <fs_field>.
      <fs_field>-tabname       = <fs_fcat>-ref_table.
      <fs_field>-fieldname     = <fs_fcat>-fieldname.
      <fs_field>-descr         = <fs_fcat>-scrtext_l.
      <fs_field>-tab_alias     = me->get_alias( ).
      <fs_field>-internal_type = <fs_fcat>-inttype.
      UNASSIGN <fs_field>.
    ENDLOOP.

  ENDMETHOD.                    "get_table_fields

  METHOD check_table_name.
    SELECT COUNT( * )
      FROM dd02l
     WHERE tabname   = i_tabname
       AND as4local  = 'A'
       AND tabclass <> 'INTTAB'.
    IF sy-subrc IS INITIAL.
      return = abap_true.
    ENDIF.
  ENDMETHOD.                    "check_table_name

  METHOD get_description_from_ddic.
    SELECT SINGLE ddtext
      INTO return
      FROM dd02t
     WHERE tabname    = me->v_name
       AND ddlanguage = sy-langu
       AND as4local   = 'A'.
  ENDMETHOD.                    "get_description_from_ddic

ENDCLASS. "lcl_table
*&---------------------------------------------------------------------*
*& Class (Implementation) lcl_from
*&---------------------------------------------------------------------*
CLASS lcl_from IMPLEMENTATION .

  METHOD add_table.
    APPEND i_table TO me->t_tables.
  ENDMETHOD. "add_table

  METHOD check_outer_join.

    DATA: l_tabix TYPE i.

    FIELD-SYMBOLS <fs_aux> TYPE string.

    return = abap_false.

    l_tabix = i_index.

    SUBTRACT 2 FROM l_tabix.
    READ TABLE i_query ASSIGNING <fs_aux> INDEX l_tabix.
    IF sy-subrc IS INITIAL.
      IF <fs_aux> = lcl_commands=>left OR <fs_aux> = lcl_commands=>outer OR <fs_aux> = lcl_commands=>right.
        return = abap_true.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "check_outer_join

  METHOD set_command_contents.
    DATA: o_table      TYPE REF TO lcl_table,
          t_query      TYPE salv_wd_t_string,
          l_string     TYPE string,
          l_alias      TYPE string,
          l_index      TYPE sytabix,
          l_tabix      TYPE i,
          l_from_index TYPE sytabix,
          l_join_on    TYPE boolean,
          l_first      TYPE boolean,
          l_outer_join TYPE boolean,
          l_length     TYPE i,
          l_aux        TYPE string.

    FIELD-SYMBOLS: <fs_aux> TYPE string.

    t_query = i_query.
    DELETE t_query WHERE table_line = '(' OR table_line = ')' OR table_line = ').'.

    READ TABLE t_query WITH KEY table_line = lcl_commands=>from TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.

      l_index = sy-tabix + 1.

      l_first = abap_true.
      LOOP AT t_query INTO l_string FROM l_index.
        IF l_string = lcl_commands=>select OR
           l_string = lcl_commands=>where  OR
           l_string = lcl_commands=>order  OR
           l_string = lcl_commands=>having OR
           l_string = lcl_commands=>group  OR
           l_string = lcl_commands=>up.
          EXIT.
        ENDIF.

        l_tabix = sy-tabix.

        l_length = STRLEN( l_string ).
        SUBTRACT 1 FROM l_length.
        IF l_string+l_length = '.' OR l_string+l_length = ';'.
          l_string = l_string(l_length).
        ENDIF.

        IF l_first = abap_true.

          CREATE OBJECT o_table
            EXPORTING
              i_name = l_string.
          l_alias = me->check_alias( i_query = t_query i_index = l_tabix ).
          IF NOT l_alias IS INITIAL.
            o_table->set_alias( l_alias ).
          ENDIF.
          me->add_table( o_table ).
          l_first = abap_false.
        ENDIF.

        IF l_join_on = abap_true.
          CREATE OBJECT o_table
            EXPORTING
              i_name = l_string.
          l_alias = me->check_alias( i_query = t_query i_index = l_tabix ).
          IF NOT l_alias IS INITIAL.
            o_table->set_alias( l_alias ).
          ENDIF.
          IF me->check_outer_join( i_query = t_query i_index = l_tabix ) = abap_true.
            o_table->set_outer_join( abap_true ).
          ENDIF.
          me->add_table( o_table ).
          me->check_join_fields( i_table = o_table
                                 i_query = t_query
                                 i_index = l_tabix ).
          l_join_on = abap_false.
        ENDIF.

        IF l_string = lcl_commands=>join.
          l_join_on = abap_true.
        ENDIF.

        APPEND l_string TO me->t_command_contents.
        CONCATENATE me->v_command l_string INTO me->v_command SEPARATED BY space.

      ENDLOOP.
    ENDIF.

  ENDMETHOD.                    "set_command_contents

  METHOD get_table.
    DATA: l_name  TYPE string,
          l_alias TYPE string.

    FIELD-SYMBOLS <fs_table> TYPE REF TO lcl_table.

    IF NOT i_index IS INITIAL.
      READ TABLE me->t_tables INTO return INDEX i_index.
    ELSE.
      LOOP AT me->t_tables ASSIGNING <fs_table>.
        l_name = <fs_table>->get_name( ).
        l_alias = <fs_table>->get_alias( ).
        IF l_name = i_table OR l_alias = i_table.
          return = <fs_table>.
          RETURN.
        ENDIF.
      ENDLOOP.
    ENDIF.

    IF return IS INITIAL.
      RAISE EXCEPTION TYPE lcx_table_not_found.
    ENDIF.

  ENDMETHOD.                    "get_table

  METHOD get_tables.
    e_tables = me->t_tables.
  ENDMETHOD.                    "get_tables

  METHOD check_join_fields.
    DATA: o_aux         TYPE REF TO lcl_table,
          t_join_fields TYPE tyt_join_fields,
          l_subtract    TYPE i,
          l_index       TYPE i,
          l_string      TYPE string,
          l_out         TYPE boolean,
          l_split_1     TYPE string,
          l_split_2     TYPE string.
    FIELD-SYMBOLS <fs_join_field> TYPE ty_join_fields.

    l_index = i_index.
    SUBTRACT 2 FROM l_index.
    READ TABLE i_query INTO l_string INDEX l_index.
    IF sy-subrc IS INITIAL AND
      ( l_string = lcl_commands=>inner OR
        l_string = lcl_commands=>left  OR
        l_string = lcl_commands=>right OR
        l_string = lcl_commands=>outer ).
      CASE l_string.
        WHEN lcl_commands=>inner.
          i_table->set_join_kind( lcl_commands=>inner_join_command ).
        WHEN lcl_commands=>left .
          i_table->set_join_kind( lcl_commands=>left_join_command ).
        WHEN lcl_commands=>right.
          i_table->set_join_kind( lcl_commands=>right_join_command ).
        WHEN lcl_commands=>outer.
          i_table->set_join_kind( lcl_commands=>outer_join_command ).
        WHEN OTHERS.
          i_table->set_join_kind( lcl_commands=>join ).
      ENDCASE.
    ELSEIF sy-subrc IS INITIAL.
      i_table->set_join_kind( lcl_commands=>join ).
    ENDIF.

    ADD 2 TO l_index.
    READ TABLE i_query INTO l_string INDEX l_index.
    IF sy-subrc IS INITIAL AND l_string = lcl_commands=>as.
      ADD 3 TO l_index. "Jump ON command
    ELSE.
      ADD 2 TO l_index.
    ENDIF.

    WHILE l_out = abap_false.
      READ TABLE i_query INTO l_string INDEX l_index.
      IF ( sy-subrc IS INITIAL AND
         ( l_string = lcl_commands=>inner  OR
           l_string = lcl_commands=>join   OR
           l_string = lcl_commands=>left   OR
           l_string = lcl_commands=>outer  OR
           l_string = lcl_commands=>right  OR
           l_string = lcl_commands=>order  OR
           l_string = lcl_commands=>having OR
           l_string = lcl_commands=>group  OR
           l_string = lcl_commands=>up ) ) OR
           NOT sy-subrc IS INITIAL.
        l_out = abap_true.
        EXIT.
      ENDIF.

      CLEAR: l_split_1, l_split_2.

      IF l_string = lcl_commands=>and.
        UNASSIGN <fs_join_field>.
      ELSE.

        IF NOT <fs_join_field> IS ASSIGNED.
          APPEND INITIAL LINE TO t_join_fields ASSIGNING <fs_join_field>.
        ENDIF.

        IF l_string = lcl_commands=>equal OR
               l_string = lcl_commands=>eq    OR
               l_string = lcl_commands=>lt    OR
               l_string = lcl_commands=>le    OR
               l_string = lcl_commands=>gt    OR
               l_string = lcl_commands=>ge.
          <fs_join_field>-signal = l_string.
        ELSE.
          SPLIT l_string AT '~' INTO l_split_1 l_split_2.
          IF NOT l_split_2 IS INITIAL.
            IF i_table->get_name( ) = l_split_1 OR i_table->get_alias( ) = l_split_1.
              <fs_join_field>-fortable = i_table->get_name( ).
              <fs_join_field>-forkey   = l_split_2.
            ELSE.
              o_aux = me->get_table( i_table = l_split_1 ).
              IF o_aux IS BOUND.
                <fs_join_field>-checktable = o_aux->get_name( ).
                <fs_join_field>-checkfield = l_split_2.
              ELSE.
                <fs_join_field>-checkfield = l_split_1.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

      ADD 1 TO l_index.

    ENDWHILE.

    i_table->set_join_fields( t_join_fields ).

  ENDMETHOD.                    "check_join_fields

ENDCLASS. "lcl_from

*&---------------------------------------------------------------------*
*& Class (Implementation) lcl_commands
*&---------------------------------------------------------------------*
CLASS lcl_commands IMPLEMENTATION .

  METHOD class_constructor.
    initialize_command_list( ).
    initialize_identify_commands( ).
  ENDMETHOD. "class_constructor

  METHOD initialize_command_list.
    APPEND select TO t_commands.
    APPEND from   TO t_commands.
    APPEND join   TO t_commands.
    APPEND inner  TO t_commands.
    APPEND outer  TO t_commands.
    APPEND left   TO t_commands.
    APPEND right  TO t_commands.
    APPEND where  TO t_commands.
    APPEND having TO t_commands.
    APPEND group  TO t_commands.
    APPEND order  TO t_commands.
  ENDMETHOD. "initialize_command_list

  METHOD initialize_identify_commands.
    APPEND select TO t_identify_commands.
    APPEND from   TO t_identify_commands.
*    APPEND where  TO t_identify_commands.
*    APPEND up     TO t_identify_commands.
*    APPEND having TO t_identify_commands.
*    APPEND group  TO t_identify_commands.
*    APPEND order  TO t_identify_commands.
  ENDMETHOD. "initialize_identify_commands

  METHOD get_command_list.
    return = t_commands.
  ENDMETHOD. "get_command_list

  METHOD get_identify_commands_list.
    return = t_identify_commands.
  ENDMETHOD. "get_identify_commands_list

ENDCLASS. "lcl_commands
*&---------------------------------------------------------------------*
*& Class (Implementation) lcl_query_element_factory
*&---------------------------------------------------------------------*
* Text
*----------------------------------------------------------------------*
CLASS lcl_query_element_factory IMPLEMENTATION .
  METHOD factory_query_element.
    CASE i_element.
      WHEN lcl_commands=>select . "SELECT
        CREATE OBJECT return TYPE lcl_select.

      WHEN lcl_commands=>from . "FROM
        CREATE OBJECT return TYPE lcl_from.

      WHEN lcl_commands=>where . "WHERE
        CREATE OBJECT return TYPE lcl_where.

    ENDCASE.
    return->v_element = i_element.
  ENDMETHOD. "factory_query_element
ENDCLASS. "lcl_query_element_factory

*----------------------------------------------------------------------*
*       CLASS lcl_screen_factory IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen_factory IMPLEMENTATION.
  METHOD factory_screen.
    CASE i_screen.
      WHEN 100.
        CREATE OBJECT return
          TYPE
            lcl_screen_100
          EXPORTING
            i_screen       = i_screen.

      WHEN 200.
        CREATE OBJECT return
          TYPE
            lcl_screen_200
          EXPORTING
            i_screen       = i_screen.

      WHEN 300.
        CREATE OBJECT return
          TYPE
            lcl_screen_300
          EXPORTING
            i_screen       = i_screen.

      WHEN 400.
        CREATE OBJECT return
          TYPE
            lcl_screen_400
          EXPORTING
            i_screen       = i_screen.

      WHEN 500.
        CREATE OBJECT return
          TYPE
            lcl_screen_500
          EXPORTING
            i_screen       = i_screen.

      WHEN 600.
        CREATE OBJECT return
          TYPE
            lcl_screen_600
          EXPORTING
            i_screen       = i_screen.

      WHEN 700.
        CREATE OBJECT return
          TYPE
            lcl_screen_700
          EXPORTING
            i_screen       = i_screen.

    ENDCASE.

    IF return IS BOUND.
      APPEND return TO t_screens.
    ENDIF.

  ENDMETHOD.                    "factory_screen

  METHOD get_screen.
    READ TABLE t_screens INTO return WITH KEY table_line->lif_screen~v_screen = i_screen.
  ENDMETHOD.                    "get_screen
ENDCLASS.                    "lcl_screen_factory IMPLEMENTATION

*&---------------------------------------------------------------------*
*& Class (Implementation) lcl_query_agent
*&---------------------------------------------------------------------*
* Text
*----------------------------------------------------------------------*
CLASS lcl_query_agent IMPLEMENTATION .

  "$. Region Getters and Setters
  METHOD set_fieldcat.
    me->t_fieldcat = i_fieldcat.
  ENDMETHOD.                    "set_fieldcat
  METHOD get_fieldcat.
    return = me->t_fieldcat.
  ENDMETHOD.                    "get_fieldcat

  METHOD set_no_conversion.
    me->v_no_conversion = i_no_conversion.
  ENDMETHOD.                    "set_no_conversion
  METHOD get_no_conversion.
    return = me->v_no_conversion.
  ENDMETHOD.                    "get_no_conversion
  "$. Endregion Getters and Setters

  METHOD get_alv.
    return = me->o_alv.
  ENDMETHOD. "get_alv

  METHOD initialize_alv.
    IF me->o_alv IS BOUND.
      me->o_alv->free( ).
      CLEAR: me->o_alv, me->o_event_handler.
    ENDIF.

    CREATE OBJECT me->o_alv
      EXPORTING
        i_parent = i_container.

    CREATE OBJECT me->o_event_handler
      EXPORTING
        i_query_agent = me.

    SET HANDLER: me->o_event_handler->handle_toolbar FOR me->o_alv,
                 me->o_event_handler->handle_user_command FOR me->o_alv,
                 me->o_event_handler->handle_menu_button FOR me->o_alv.

  ENDMETHOD. "initialize_alv

*  METHOD initialize_splitter.
*    CREATE OBJECT me->o_splitter
*      EXPORTING
*        parent  = i_container
*        rows    = i_rows
*        columns = i_cols.
*  ENDMETHOD. "initialize_splitter

  METHOD get_query_agent.
    IF o_query_agent IS INITIAL.
      CREATE OBJECT o_query_agent.
    ENDIF.
    return = o_query_agent.
  ENDMETHOD. "get_query_agent

  METHOD execute_query.

    DATA: o_data TYPE REF TO data,
          o_query_saver TYPE REF TO lcl_query_save.

    CREATE OBJECT me->o_analyzer.

    me->o_analyzer->start_runtime_analyzer( lcl_performance_analyzer=>abap ).

    "$. Region Check Query Syntax
    me->check_query_syntax( i_query ).
    "$. Endregion Check Query Syntax

    "$. Region Identify Query Elements
    me->o_query->identify_query_elements( ).
    "$. Endregion Identify Query Elements

    "$. Region Create Fieldcatalog
    me->create_fcat( ).
    "$. Endregion Create Fieldcatalog

    "$. Region Build Dynamic Structure
    o_data = me->build_dyn_struct( me->t_fieldcat ).
    me->o_query->set_data( o_data ).
    "$. Endregion Build Dynamic Structure

    "$. Region Check fields to Select
    me->check_fields_to_select( ).
    "$. Endregion Check fields to Select

    me->o_analyzer->stop_runtime_analyzer( lcl_performance_analyzer=>abap ).

    "$. Region Select Data
    me->o_analyzer->start_runtime_analyzer( lcl_performance_analyzer=>sql ).
    me->o_query->execute( ).
    me->o_analyzer->stop_runtime_analyzer( lcl_performance_analyzer=>sql ).
    "$. Endregion Select Data

  ENDMETHOD. "execute_query

  METHOD check_fields_to_select.
    DATA: o_fieldcat   TYPE REF TO lcl_fieldcat,
          o_select_gen TYPE REF TO lcl_select_generator,
          o_from       TYPE REF TO lcl_from,
          o_select     TYPE REF TO lcl_select,
          o_data       TYPE REF TO data,

          t_query      TYPE salv_wd_t_string,
          t_select     TYPE salv_wd_t_string,

          l_select_type TYPE string,
          l_query      TYPE string.

    CREATE OBJECT o_fieldcat
      EXPORTING
        i_fieldcat = me->t_fieldcat.

    IF o_fieldcat->get_fieldcat_count_fields( ) > lcl_select=>c_max_fields.
      o_from   ?= me->o_query->get_query_element( lcl_commands=>from ).
      o_select ?= me->o_query->get_query_element( lcl_commands=>select ).

      CREATE OBJECT o_select_gen
        EXPORTING
          i_element = o_from.

      l_query  = me->o_query->get_query_string( ).
      l_select_type = o_select->get_select_type( ).

      t_select = o_select_gen->generate_by_fieldcat( o_fieldcat ).
      IF NOT l_select_type = lcl_commands=>asterisk.
        o_select_gen->set_select_type( l_select_type ).
      ENDIF.

      t_query  = o_select_gen->generate_new_query_text( i_query_string = l_query
                                                        i_command_text = t_select ).

      o_data = me->o_query->get_data( ).

      CLEAR me->o_query.
      CREATE OBJECT me->o_query
        EXPORTING
          i_query = t_query.
      me->o_query->identify_query_elements( ).
      me->o_query->set_data( o_data ).

    ENDIF.

  ENDMETHOD.                    "check_fields_to_select

  METHOD check_query_syntax.
    CREATE OBJECT me->o_query
      EXPORTING
        i_query = i_query.
    me->o_query->check_query_syntax( ).
  ENDMETHOD. "check_query_syntax

  METHOD build_dyn_struct.

    TYPES: BEGIN OF yt_fields,
           field TYPE string,
           rand  TYPE salv_wd_t_string,
         END OF yt_fields.

    DATA: o_struct     TYPE REF TO cl_abap_structdescr,
          o_table      TYPE REF TO cl_abap_tabledescr,

          t_fields     TYPE TABLE OF yt_fields,
          t_components TYPE abap_component_tab,
          t_fieldcat   TYPE lvc_t_fcat,

          l_field      TYPE string,
          l_name       TYPE string,
          l_rand       TYPE string,
          l_out        TYPE boolean.

    FIELD-SYMBOLS: <fs_field>     TYPE yt_fields,
                   <fs_fcat>      TYPE lvc_s_fcat,
                   <fs_component> TYPE abap_componentdescr.

    t_fieldcat = i_fieldcat.

    LOOP AT t_fieldcat ASSIGNING <fs_fcat>.
      CLEAR: l_field, l_name, l_rand, l_out.

      READ TABLE t_fields ASSIGNING <fs_field> WITH KEY field = <fs_fcat>-fieldname.
      IF sy-subrc IS INITIAL.

        WHILE l_out = abap_false.

          CALL FUNCTION 'GENERAL_GET_RANDOM_STRING'
            EXPORTING
              number_chars  = 2
            IMPORTING
              random_string = l_rand.

          TRANSLATE l_rand TO UPPER CASE.

          READ TABLE <fs_field>-rand WITH KEY table_line = l_rand TRANSPORTING NO FIELDS.
          IF NOT sy-subrc IS INITIAL.
            APPEND l_rand TO <fs_field>-rand.
            l_out = abap_true.
          ENDIF.

        ENDWHILE.

        CONCATENATE <fs_fcat>-fieldname l_rand INTO l_field SEPARATED BY '_'.

      ELSE.

        APPEND INITIAL LINE TO t_fields ASSIGNING <fs_field>.
        <fs_field>-field = l_field = <fs_fcat>-fieldname.
        UNASSIGN <fs_field>.

      ENDIF.

      APPEND INITIAL LINE TO t_components ASSIGNING <fs_component>.
      <fs_component>-name = l_field.

      IF NOT <fs_fcat>-ref_table IS INITIAL.
        CONCATENATE <fs_fcat>-ref_table <fs_fcat>-fieldname INTO l_name SEPARATED BY '-'.
        <fs_component>-type ?= cl_abap_structdescr=>describe_by_name( l_name ).
      ELSE.
        <fs_component>-type ?= cl_abap_typedescr=>describe_by_name( <fs_fcat>-inttype ).
      ENDIF.
      UNASSIGN <fs_component>.

      <fs_fcat>-ref_field = <fs_fcat>-fieldname.
      <fs_fcat>-fieldname = l_field.

    ENDLOOP.

    o_struct = cl_abap_structdescr=>create( t_components ).
    o_table  = cl_abap_tabledescr=>create( o_struct ).

    CREATE DATA return TYPE HANDLE o_table.

    me->set_fieldcat( t_fieldcat ).

  ENDMETHOD.                    "build_dyn_struct

  METHOD create_fcat.
    DATA: o_select      TYPE REF TO lcl_select,
          o_from        TYPE REF TO lcl_from,
          o_table       TYPE REF TO lcl_table,
          o_fieldcat    TYPE REF TO lcl_fieldcat,
          t_fcat        TYPE lvc_t_fcat,
          t_fcat_aux    TYPE lvc_t_fcat,
          l_select_type TYPE string.

    CREATE OBJECT o_fieldcat.
    o_select ?= me->o_query->get_query_element( lcl_commands=>select ).
    o_from   ?= me->o_query->get_query_element( lcl_commands=>from ).

    DO.
      TRY.
          o_table    = o_from->get_table( sy-index ).
          t_fcat_aux = o_fieldcat->merge_fieldcat( i_table         = o_table
                                                   i_no_conversion = me->v_no_conversion ).
          APPEND LINES OF t_fcat_aux TO t_fcat.
        CATCH lcx_table_not_found.
          EXIT.
        CATCH lcx_no_fieldcat.
      ENDTRY.
    ENDDO.

    o_fieldcat->set_fieldcat( t_fcat ).
    o_fieldcat->compute_fieldcat_to_fields( i_select = o_select
                                            i_from   = o_from ).

    return = o_fieldcat->get_fieldcat( ).
    me->set_fieldcat( return ).

  ENDMETHOD.                    "create_fcat

  METHOD get_query_results.
    return = me->o_query->get_data( ).
  ENDMETHOD.                    "get_query_results

  METHOD show_results.

    DATA: o_data TYPE REF TO data,
          wa_layout TYPE lvc_s_layo.

    FIELD-SYMBOLS <fs_tab> TYPE ANY TABLE.

    o_data = me->get_query_results( ).
    ASSIGN o_data->* TO <fs_tab>.

    me->initialize_alv( i_container ).

    wa_layout = me->get_layout( ).

    me->o_alv->set_table_for_first_display(
      EXPORTING
        is_layout       = wa_layout
      CHANGING
        it_fieldcatalog = me->t_fieldcat
        it_outtab       = <fs_tab> ).

  ENDMETHOD.                    "show_results

  METHOD generate_types.
    DATA: o_type_gen TYPE REF TO lcl_type_generator,
          o_select   TYPE REF TO lcl_select,
          l_select_type TYPE string.

    DATA: t_fcat TYPE lvc_t_fcat,
          l_type_name TYPE string.

    o_select ?= me->o_query->get_query_element( lcl_commands=>select ).

    l_type_name = lcl_type_generator=>get_type_name_by_user( ).

    CREATE OBJECT o_type_gen
      EXPORTING
        i_type_name = l_type_name.

    t_fcat = me->get_fieldcat( ).
    o_type_gen->generate_type_by_fcat( i_fieldcat   = t_fcat ).

    CHECK o_type_gen IS BOUND.

    DATA: o_screen_200 TYPE REF TO lcl_screen_200.
    o_screen_200 ?= lcl_screen=>get_instance( 200 ).

    o_screen_200->set_type_gen_instance( o_type_gen ).
    o_screen_200->lif_screen~show( i_first_col = 10
                                   i_first_row = 2
                                   i_last_col  = 110
                                   i_last_row  = 23 ).

  ENDMETHOD.                    "generate_types

  METHOD show_performance_analyzer.

    DATA: o_screen TYPE REF TO lcl_screen_300.

    o_screen ?= lcl_screen=>get_instance( 300 ).
    o_screen->set_analyzer( me->o_analyzer ).
    o_screen->lif_screen~show( i_first_col = 5
                               i_first_row = 2
                               i_last_col  = 138
                               i_last_row  = 33 ).

  ENDMETHOD.                    "show_performance_analyzer

  METHOD get_layout.
    DATA: o_data TYPE REF TO data,
          wa_layout TYPE lvc_s_layo,
          l_time    TYPE dec_16_02_s,
          l_time_s  TYPE char50,
          l_lines   TYPE char100.

    FIELD-SYMBOLS <fs_tab> TYPE ANY TABLE.

    wa_layout-zebra = abap_true.
    wa_layout-sel_mode = 'D'.

    o_data = me->get_query_results( ).
    ASSIGN o_data->* TO <fs_tab>.
    IF <fs_tab> IS ASSIGNED.
      "Records
      DESCRIBE TABLE <fs_tab>.
      WRITE sy-tfill TO l_lines. CONDENSE l_lines NO-GAPS.
    ENDIF.

    "Time
    l_time = me->o_analyzer->calculate_runtime( i_id = lcl_performance_analyzer=>sql ).
    WRITE l_time TO l_time_s. CONDENSE l_time_s.

    CONCATENATE l_lines 'record(s) retrieved -' l_time_s 'seconds elapsed' INTO wa_layout-grid_title SEPARATED BY space.
    CONDENSE wa_layout-grid_title.

    return = wa_layout.
  ENDMETHOD.                    "get_layout

  METHOD generate_where.
    DATA: o_from      TYPE REF TO lcl_query_element,
          o_generator TYPE REF TO lcl_query_element_generator,
          t_where     TYPE salv_wd_t_string,
          t_query     TYPE salv_wd_t_string.

    me->check_query_syntax( i_query ).
    o_from = me->o_query->identify_query_elements( lcl_commands=>from ).

    CREATE OBJECT o_generator
      TYPE
        lcl_where_generator
      EXPORTING
        i_element           = o_from.

    t_where = o_generator->generate( ).
    t_query = o_generator->generate_new_query_text( i_query        = i_query
                                                    i_command_text = t_where ).
    return = t_query.
*    me->o_editor->set_selected_text_as_table( t_query ).
  ENDMETHOD.                    "generate_where

  METHOD generate_select.
    DATA: o_from      TYPE REF TO lcl_query_element,
          o_select    TYPE REF TO lcl_select,
          o_gen       TYPE REF TO lcl_select_generator,
          t_select    TYPE salv_wd_t_string,
          t_query     TYPE salv_wd_t_string.

    me->check_query_syntax( i_query ).
    o_from = me->o_query->identify_query_elements( lcl_commands=>from ).
    o_select ?= me->o_query->identify_query_elements( lcl_commands=>select ).

    CREATE OBJECT o_gen
      EXPORTING
        i_element = o_from.
    o_gen->set_select( o_select ).

    t_select = o_gen->generate( ).
    t_query = o_gen->generate_new_query_text( i_query        = i_query
                                              i_command_text = t_select ).
    return = t_query.
*    me->o_editor->set_selected_text_as_table( t_query ).

  ENDMETHOD.                    "generate_select

  METHOD inverse_fieldcat_names.
    DATA: o_fieldcat TYPE REF TO lcl_fieldcat,
          t_fcat     TYPE lvc_t_fcat.
    CREATE OBJECT o_fieldcat.
    t_fcat = o_fieldcat->inverse_fieldcat_names( me->o_alv ).
    me->set_fieldcat( t_fcat ).
  ENDMETHOD.                    "inverse_fieldcat_names

  METHOD no_routine_conversion.
    DATA: o_fieldcat  TYPE REF TO lcl_fieldcat,
          o_container TYPE REF TO cl_gui_container,
          o_screen    TYPE REF TO lcl_screen_100,
          t_fcat      TYPE lvc_t_fcat.
    CREATE OBJECT o_fieldcat.
    t_fcat = o_fieldcat->no_routine_conversion( me->o_alv ).
    me->set_fieldcat( t_fcat ).
  ENDMETHOD.                    "no_routine_conversion

  METHOD flush_alv.
    IF me->o_alv IS BOUND.
      me->o_alv->free( ).
      CLEAR me->o_alv.
    ENDIF.
  ENDMETHOD.                    "flush_alv

ENDCLASS. "lcl_query_agent

*----------------------------------------------------------------------*
* CLASS lcl_screen IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_screen.
    me->lif_screen~v_screen = i_screen.
  ENDMETHOD.                    "set_screen
  METHOD get_screen.
    return = me->lif_screen~v_screen.
  ENDMETHOD.                    "get_screen

  METHOD set_exit_command.
    me->v_exit_command = i_exit_command.
  ENDMETHOD.                    "set_exit_command
  METHOD get_exit_command.
    return = me->v_exit_command.
  ENDMETHOD.                    "get_exit_command
  "$. Endregion Getters and Setters

  METHOD constructor.
    me->set_screen( i_screen ).
  ENDMETHOD.                    "constructor

  METHOD lif_screen~exit_command.
    me->set_exit_command( abap_true ).
    LEAVE TO SCREEN 0.
  ENDMETHOD. "lif_screen~exit_command

  METHOD lif_screen~screen_status.
  ENDMETHOD. "lif_screen~screen_status

  METHOD lif_screen~user_command.
    CASE i_ucomm.
      WHEN c_back.
        LEAVE TO SCREEN 0.
    ENDCASE.
  ENDMETHOD. "lif_screen~user_command

  METHOD lif_screen~initialize_screen.
  ENDMETHOD. "lif_screen~initialize_screen

  METHOD lif_screen~show.
    me->set_exit_command( abap_false ).
    IF i_first_col IS INITIAL AND
       i_first_row IS INITIAL AND
       i_last_col  IS INITIAL AND
       i_last_row  IS INITIAL.
      CALL SCREEN me->lif_screen~v_screen.
    ELSE.
      CALL SCREEN me->lif_screen~v_screen STARTING AT i_first_col i_first_row
                                            ENDING AT i_last_col  i_last_row.
    ENDIF.
  ENDMETHOD.                    "lif_screen~show

  METHOD get_instance.
    return = lcl_screen_factory=>get_screen( i_screen ).
    IF NOT return IS BOUND.
      return = lcl_screen_factory=>factory_screen( i_screen ).
    ENDIF.
  ENDMETHOD.                    "get_instance

ENDCLASS. "lcl_screen IMPLEMENTATION

*----------------------------------------------------------------------*
* CLASS lcl_screen_100 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen_100 IMPLEMENTATION.

  METHOD get_texted_query.
    DATA: o_editor TYPE REF TO cl_gui_abapedit,
          t_text TYPE TABLE OF string .

    o_editor = get_editor( ).

    o_editor->get_selected_text_as_table( IMPORTING table = t_text ).
    IF t_text IS INITIAL AND i_blank = abap_true.
      RETURN.
    ELSEIF t_text IS INITIAL AND i_selected = abap_false.
      o_editor->select_lines( from_line = 1 to_line = 9999 ).
      o_editor->get_selected_text_as_table( IMPORTING table = t_text ).
    ENDIF.

    IF t_text IS INITIAL.
      RAISE EXCEPTION TYPE lcx_no_query.
    ENDIF.
    return = t_text.
  ENDMETHOD. "get_texted_query

  METHOD set_texted_query.
    DATA: t_aux TYPE salv_wd_t_string.
    me->o_editor->set_text( t_aux ).
    me->o_editor->set_text( i_query ).
  ENDMETHOD.                    "set_texted_query

  METHOD get_container_from_splitter.
    return = me->o_splitter->get_container( row    = i_row
                                            column = i_col ).
  ENDMETHOD. "get_container_from_splitter

  METHOD get_container_from_result.
    return = me->o_result_splitter->get_container( row    = i_row
                                                   column = i_col ).
  ENDMETHOD.                    "get_container_from_result

  METHOD get_editor.
    return = me->o_editor.
  ENDMETHOD. "get_editor

  METHOD lif_screen~user_command.

    DATA: l_message TYPE string,
          o_exception TYPE REF TO cx_root.

    TRY.
        super->lif_screen~user_command( i_ucomm ).

        CASE i_ucomm.
          WHEN c_exec.
            me->execute_query( ).
            me->show_results( ).

          WHEN c_exec_no.
            me->execute_query( abap_true ).
            me->show_results( ).

          WHEN c_check.
            me->check_query_syntax( ).
            l_message = 'Query is syntactically correct.'(001).
            lcl_message=>report_message( i_msg  = l_message
                                         i_type = 'S' ).

          WHEN c_save.
            me->save_query( ).
            l_message = 'Query saved successfully.'(002).
            lcl_message=>report_message( i_msg  = l_message
                                         i_type = 'S' ).

          WHEN c_open.
            me->open_query( ).

          WHEN c_mine.
            me->open_my_queries( ).

          WHEN c_select.
            me->generate_select( ).

          WHEN c_from.
            me->generate_from( ).

          WHEN c_where.
            me->generate_where( ).

        ENDCASE.

      CATCH lcx_no_query.
        l_message = 'No query entry to execute'(e01).
        lcl_message=>report_message( i_msg     = l_message
                                     i_type    = 'S'
                                     i_disp_as = 'E' ).
      CATCH lcx_cancel.
        l_message = 'Canceled'(e02).
        lcl_message=>report_message( i_msg     = l_message
                                     i_type    = 'S'
                                     i_disp_as = 'E' ).
      CATCH lcx_fields_overflow.
        l_message = 'Allowed only 70 fields or less'(e03).
        lcl_message=>report_message( i_msg     = l_message
                                     i_type    = 'S'
                                     i_disp_as = 'E' ).
      CATCH lcx_table_not_found.
        l_message = 'No queries found'(e04).
        lcl_message=>report_message( i_msg = l_message i_type = 'S' i_disp_as = 'E' ).

      CATCH lcx_query_element_not_found INTO o_exception.
        DATA: o_element_not_found TYPE REF TO lcx_query_element_not_found.
        o_element_not_found ?= o_exception.
        l_message = o_element_not_found->get_message( ).
        lcl_message=>report_message( i_msg  = l_message
                                     i_type = 'E' ).

      CATCH lcx_query_overflow.
        l_message = 'Please, select up to 3 queries at most.'.
        lcl_message=>report_message( i_msg = l_message i_type = 'S' i_disp_as = 'W' ).

      CATCH lcx_error_query_check INTO o_exception.
        DATA: o_query_check TYPE REF TO lcx_error_query_check.
        o_query_check ?= o_exception.
        l_message = o_query_check->get_message( ).
        lcl_message=>report_message( i_msg  = l_message
                                     i_type = 'E' ).

      CATCH lcx_no_fields_selected. "EC NO_HANDLE
    ENDTRY.

  ENDMETHOD. "lif_screen~user_command

  METHOD lif_screen~screen_status.
    SET PF-STATUS 'PF_0100'.
    SET TITLEBAR 'TITLE_0100'.
  ENDMETHOD. "lif_screen~screen_status

  METHOD lif_screen~initialize_screen.
    IF me->o_cust_cont IS INITIAL.
      DATA o_container TYPE REF TO cl_gui_container.

      CREATE OBJECT me->o_cust_cont
        EXPORTING
          container_name = 'C_CONTAINER'.

      me->initialize_splitter( i_container = me->o_cust_cont
                               i_rows      = 2
                               i_cols      = 1 ).

      o_container = me->get_container_from_splitter( i_row = 1
                                                     i_col = 1 ).
      me->initialize_editor( o_container ).
    ENDIF.
  ENDMETHOD. "lif_screen~initialize_screen

  METHOD execute_query.
    DATA: o_query_agent  TYPE REF TO lcl_query_agent,
          o_query_saver  TYPE REF TO lcl_query_save,
          t_texted_query TYPE salv_wd_t_string,
          t_queries      TYPE yt_t_query.
    FIELD-SYMBOLS <fs_query> TYPE salv_wd_t_string.

    CLEAR me->t_query_agents.

    t_texted_query = me->get_texted_query( ).

    me->split_queries( EXPORTING i_text    = t_texted_query
                       IMPORTING e_queries = t_queries ).

    LOOP AT t_queries ASSIGNING <fs_query>.
      CREATE OBJECT o_query_agent.
      o_query_agent->set_no_conversion( i_no_conversion ).
      o_query_agent->execute_query( <fs_query> ).
      me->add_query_agent( o_query_agent ).
    ENDLOOP.

    "$. Region Buffer Texted Query
    o_query_saver = lcl_query_save=>get_instance( ).
    o_query_saver->buffer_query_texted( t_texted_query ).
    "$. Endregion Buffer Texted Query

  ENDMETHOD. "execute_query

  METHOD split_queries.
    DATA: t_text    TYPE salv_wd_t_string,
          t_aux     TYPE salv_wd_t_string,
          t_queries TYPE yt_t_query,
          t_query   TYPE salv_wd_t_string,
          l_query   TYPE string,
          l_length  TYPE i.

    FIELD-SYMBOLS <fs_text> TYPE string.

    t_aux = i_text.
    lcl_report=>delete_comments( CHANGING i_text = t_aux ).

    LOOP AT t_aux ASSIGNING <fs_text>.
      SPLIT <fs_text> AT space INTO TABLE t_query.
      APPEND LINES OF t_query TO t_text.
    ENDLOOP.

    CLEAR: t_query.

    DELETE t_text WHERE table_line IS INITIAL.

    LOOP AT t_text ASSIGNING <fs_text>.
      l_length = STRLEN( <fs_text> ).
      SUBTRACT 1 FROM l_length.
      CONCATENATE l_query <fs_text> INTO l_query SEPARATED BY space.
      IF <fs_text>+l_length(1) = '.'.
        CONDENSE l_query.
        t_query = lcl_query=>split_text( i_text      = l_query
                                         i_outputlen = 100 ).
        APPEND t_query TO e_queries.
        AT LAST.
          EXIT.
        ENDAT.
        CLEAR l_query.
      ENDIF.

      AT LAST.
        CONDENSE l_query.
        t_query = lcl_query=>split_text( i_text      = l_query
                                         i_outputlen = 100 ).
        APPEND t_query TO e_queries.
        EXIT.
      ENDAT.

    ENDLOOP.

    IF LINES( e_queries ) > 3.
      RAISE EXCEPTION TYPE lcx_query_overflow.
    ENDIF.

  ENDMETHOD.                    "split_queries

  METHOD check_query_syntax.
    DATA: o_query_agent  TYPE REF TO lcl_query_agent,
          t_texted_query TYPE salv_wd_t_string,
          t_queries      TYPE yt_t_query.

    t_texted_query = me->get_texted_query( ).

    me->split_queries( EXPORTING i_text = t_texted_query
                       IMPORTING e_queries = t_queries ).

    LOOP AT t_queries INTO t_texted_query.
      CREATE OBJECT o_query_agent.
      o_query_agent->check_query_syntax( t_texted_query ).
    ENDLOOP.

  ENDMETHOD. "check_query_syntax

  METHOD show_results.
    DATA: o_container TYPE REF TO cl_gui_container,
          o_alv_cont  TYPE REF TO cl_gui_container,
          l_lines     TYPE i.
    FIELD-SYMBOLS <fs_query_agent> TYPE REF TO lcl_query_agent.

    IF o_result_splitter IS BOUND.
      o_result_splitter->free( ).
      CLEAR o_result_splitter.
    ENDIF.

    l_lines = me->get_query_agents_lines( ).

    CHECK l_lines > 0.

    o_container = me->get_container_from_splitter( i_row = 2
                                                   i_col = 1 ).

    CREATE OBJECT me->o_result_splitter
      EXPORTING
        parent  = o_container
        rows    = l_lines
        columns = 1.

    LOOP AT me->t_query_agents ASSIGNING <fs_query_agent>.
      o_alv_cont = me->o_result_splitter->get_container( row    = sy-tabix
                                                         column = 1 ).
      <fs_query_agent>->show_results( o_alv_cont ).
    ENDLOOP.

  ENDMETHOD.                    "show_results

  METHOD save_query.
    DATA: o_save  TYPE REF TO lcl_query_save,
          l_name  TYPE string,
          t_query TYPE salv_wd_t_string.

    o_save = lcl_query_save=>get_instance( ).
    l_name = o_save->get_query_name( ).
    t_query = me->get_texted_query( ).
    o_save->save_query( i_name  = l_name
                        i_query = t_query ).
  ENDMETHOD.                    "save_query

  METHOD open_query.
    DATA: o_selection_screen TYPE REF TO lcl_selection_screen.
    CLEAR: p_qname, s_user.

    o_selection_screen ?= lcl_screen=>get_instance( 400 ).
    o_selection_screen->lif_screen~show( i_first_col = 10
                                         i_first_row = 3 ).


  ENDMETHOD.                    "open_query

  METHOD open_my_queries.
    DATA: o_save    TYPE REF TO lcl_query_save,
          o_agent   TYPE REF TO lcl_query_agent,
          o_400     TYPE REF TO lcl_screen_400,
          t_user    TYPE tyt_user_range,
          l_query_name TYPE string,

          t_queries TYPE tyt_query,
          t_aux     TYPE tyt_query,
          t_texted_query TYPE salv_wd_t_string.

    o_save  = lcl_query_save=>get_instance( ).
    o_agent = lcl_query_agent=>get_query_agent( ).
    o_400  ?= lcl_screen=>get_instance( 400 ).

    o_400->compute_user_range( EXPORTING i_user = sy-uname
                               IMPORTING e_user_range = t_user ).
    l_query_name = o_400->compute_query_name( ).

    o_save->search_queries( EXPORTING
                              i_user       = t_user
                              i_query_name = l_query_name
                            IMPORTING
                              e_queries    = t_queries ).
    o_save->set_selected_query( t_queries ).

    o_save->display_queries( EXPORTING
                               i_queries = t_queries
                               i_mine    = abap_true
                             IMPORTING
                               e_selected = t_aux ).

    t_texted_query = o_save->compute_selected_queries( t_aux ).
    me->set_texted_query( t_texted_query ).

  ENDMETHOD.                    "open_my_queries

  METHOD generate_where.
    DATA: o_from         TYPE REF TO lcl_query_element,
          o_generator    TYPE REF TO lcl_query_element_generator,
          o_query        TYPE REF TO lcl_query,
          t_texted_query TYPE salv_wd_t_string,
          t_where        TYPE salv_wd_t_string,
          t_query        TYPE salv_wd_t_string.

    t_texted_query = me->get_texted_query( abap_true ).
    CREATE OBJECT o_query
      EXPORTING
        i_query = t_texted_query.

    o_from = o_query->identify_query_elements( lcl_commands=>from ).

    CREATE OBJECT o_generator
      TYPE
        lcl_where_generator
      EXPORTING
        i_element           = o_from.

    t_where = o_generator->generate( ).
    t_query = o_generator->generate_new_query_text( i_query        = t_texted_query
                                                    i_command_text = t_where ).
    me->o_editor->set_selected_text_as_table( t_query ).

  ENDMETHOD.                    "generate_where

  METHOD generate_select.
    DATA: t_texted_query TYPE salv_wd_t_string,
          o_from      TYPE REF TO lcl_query_element,
          o_select    TYPE REF TO lcl_select,
          o_gen       TYPE REF TO lcl_select_generator,
          o_query     TYPE REF TO lcl_query,
          t_select    TYPE salv_wd_t_string,
          l_select_type TYPE string,
          t_query     TYPE salv_wd_t_string.

    t_texted_query = me->get_texted_query( abap_true ).
    CREATE OBJECT o_query
      EXPORTING
        i_query = t_texted_query.

    o_query->check_query_syntax( ).
    o_from    = o_query->identify_query_elements( lcl_commands=>from ).
    o_select ?= o_query->identify_query_elements( lcl_commands=>select ).
    l_select_type = o_select->get_select_type( ).

    CREATE OBJECT o_gen
      EXPORTING
        i_element = o_from.
    o_gen->set_select( o_select ).
    IF l_select_type <> lcl_commands=>asterisk.
      o_gen->set_select_type( l_select_type ).
    ENDIF.

    t_select = o_gen->generate( ).
    t_query = o_gen->generate_new_query_text( i_query        = t_texted_query
                                              i_command_text = t_select ).
    me->o_editor->set_selected_text_as_table( t_query ).

  ENDMETHOD.                    "generate_select

  METHOD generate_from.
    DATA: t_texted_query TYPE salv_wd_t_string,
          o_from      TYPE REF TO lcl_query_element,
          o_select    TYPE REF TO lcl_select,
          o_gen       TYPE REF TO lcl_from_generator,
          o_query     TYPE REF TO lcl_query,
          t_from      TYPE salv_wd_t_string,
          t_query     TYPE salv_wd_t_string,
          l_from_line	TYPE i,
          l_from_pos  TYPE i.


    t_texted_query = me->get_texted_query( i_blank = abap_true ).
    CREATE OBJECT o_query
      EXPORTING
        i_query = t_texted_query.
    IF NOT t_texted_query IS INITIAL.
      o_query->check_query_syntax( ).
    ENDIF.

    o_from = o_query->identify_query_elements( lcl_commands=>from ).

    CREATE OBJECT o_gen
      EXPORTING
        i_element = o_from.
    t_from  = o_gen->generate( ).
    t_query = o_gen->generate_new_query_text( i_query        = t_texted_query
                                              i_command_text = t_from ).
    IF t_texted_query IS INITIAL.
      me->o_editor->get_selection_pos( IMPORTING from_line = l_from_line
                                                 from_pos  = l_from_pos ).

      me->o_editor->insert_block_at_position( line     = l_from_line
                                              pos      = l_from_pos
                                              text_tab = t_query ).
    ELSE.
      me->o_editor->set_selected_text_as_table( t_query ).
    ENDIF.

  ENDMETHOD.                    "generate_from

  METHOD initialize_splitter.
    CREATE OBJECT me->o_splitter
      EXPORTING
        parent  = i_container
        rows    = i_rows
        columns = i_cols.
  ENDMETHOD. "initialize_splitter

  METHOD initialize_editor.

    DATA: o_query_saver TYPE REF TO lcl_query_save,
          t_query TYPE salv_wd_t_string.

    CLEAR me->o_editor.

    CREATE OBJECT o_editor
      EXPORTING
        parent = i_container.

    TRY.
        o_query_saver = lcl_query_save=>get_instance( ).
        t_query = o_query_saver->get_buffered_query( ).
      CATCH: lcx_existent_object, cx_root.               "#EC NO_HANDLE
    ENDTRY.

    me->o_editor->set_text( t_query ).
    me->o_editor->set_source_type( 'ABAP' ).
    me->o_editor->set_focus( i_container ).

  ENDMETHOD. "initialize_editor

  METHOD add_query_agent.
    APPEND i_query_agent TO me->t_query_agents.
  ENDMETHOD.                    "add_query_agent

  METHOD get_query_agents_lines.
    return = LINES( me->t_query_agents ).
  ENDMETHOD.                    "get_query_agents_lines

  METHOD flush.
    IF me->o_result_splitter IS BOUND.
      me->o_result_splitter->free( ).
    ENDIF.
    CLEAR: me->t_query_agents, me->o_result_splitter.
  ENDMETHOD.                    "flush

ENDCLASS. "lcl_screen_100 IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_200 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen_200 IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_type_gen_instance.
    me->o_type_generator = i_type_gen.
  ENDMETHOD.                    "set_type_gen_instance
  METHOD get_type_gen_instance.
    return = me->o_type_generator.
  ENDMETHOD.                    "get_type_gen_instance

  METHOD set_editor.
    me->o_editor = i_editor.
  ENDMETHOD.                    "set_editor
  METHOD get_editor.
    return = me->o_editor.
  ENDMETHOD.                    "get_editor
  "$. Endregion Getters and Setters

  METHOD lif_screen~user_command.
    CASE sy-ucomm.
      WHEN c_enter.
        LEAVE TO SCREEN 0.
    ENDCASE.
  ENDMETHOD.                    "lif_screen~user_command

  METHOD lif_screen~screen_status.
    SET PF-STATUS 'PF_0200'.
  ENDMETHOD.                    "lif_screen~screen_status

  METHOD lif_screen~initialize_screen.
    IF me->o_cust_cont IS INITIAL.
      CREATE OBJECT me->o_cust_cont
        EXPORTING
          container_name = 'C_TYPE_CONTAINER'.
      CREATE OBJECT me->o_editor
        EXPORTING
          parent = me->o_cust_cont.
    ENDIF.

    DATA t_type TYPE salv_wd_t_string.
    t_type = me->o_type_generator->get_command_line( ).
    me->o_editor->set_selected_text_as_table( t_type ).
    me->o_editor->set_first_visible_line( ).
    me->o_editor->set_focus( me->o_cust_cont ).

    DESCRIBE TABLE t_type.
    me->o_editor->select_lines( from_line = 1 to_line = sy-tfill ).

  ENDMETHOD.                    "lif_screen~initialize_screen

ENDCLASS.                    "lcl_screen_200 IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_300 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen_300 IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_analyzer.
    me->o_analyzer = i_analyzer.
  ENDMETHOD.                    "set_analyzer
  METHOD get_analyzer.
    return = me->o_analyzer.
  ENDMETHOD.                    "get_analyzer
  "$. Endregion Getters and Setters

  METHOD lif_screen~user_command.
    CASE sy-ucomm.
      WHEN c_enter.
        LEAVE TO SCREEN 0.
    ENDCASE.
  ENDMETHOD.                    "lif_screen~user_command

  METHOD lif_screen~screen_status.
*    SET PF-STATUS 'PF_0300'.
  ENDMETHOD.                    "lif_screen~screen_status

  METHOD lif_screen~initialize_screen.

    CLEAR: me->t_texts, me->t_values.

    me->generate_graphic_data( me->o_analyzer ).
    me->display_graphic( ).

  ENDMETHOD.                    "lif_screen~initialize_screen

  METHOD add_text.
    APPEND i_text TO me->t_texts.
  ENDMETHOD.                    "add_text

  METHOD add_value.

    DATA: l_field TYPE string,
          l_id    TYPE string.

    FIELD-SYMBOLS: <fs_value> TYPE gprval,
                   <fs_aux>   TYPE ANY.

    APPEND INITIAL LINE TO me->t_values ASSIGNING <fs_value>.
    <fs_value>-rowtxt = i_rowtxt.

    l_id = i_id.
    CONCATENATE 'VAL' l_id INTO l_field. CONDENSE l_field NO-GAPS.
    ASSIGN COMPONENT l_field OF STRUCTURE <fs_value> TO <fs_aux>.
    IF sy-subrc IS INITIAL.
      <fs_aux> = i_val.
    ENDIF.

    UNASSIGN <fs_value>.

  ENDMETHOD.                    "add_value

  METHOD display_graphic.

    CALL FUNCTION 'GFW_PRES_SHOW'
      EXPORTING
        container         = 'GRAPH_CONTAINER'
        presentation_type = gfw_prestype_vertical_bars
        header            = 'Performance Analyzer'(003)
      TABLES
        values            = me->t_values
        column_texts      = me->t_texts
      EXCEPTIONS
        error_occurred    = 1
        OTHERS            = 2.

  ENDMETHOD.                    "display_graphic

  METHOD generate_graphic_data.

    DATA: t_analyzer TYPE tyt_analyzer,

          l_description TYPE string,
          l_rowtxt      TYPE char100,
          l_runtime     TYPE dec_16_02_s.

    FIELD-SYMBOLS <fs_analyzer> TYPE yt_analyzer.

    i_analyzer->get_analyzer_table( IMPORTING t_analyzer = t_analyzer ).

    LOOP AT t_analyzer ASSIGNING <fs_analyzer>.

      l_runtime = i_analyzer->calculate_runtime( i_start = <fs_analyzer>-start_runtime
                                                 i_end   = <fs_analyzer>-end_runtime ).
      WRITE l_runtime TO l_rowtxt.
      l_description = l_rowtxt. CONDENSE l_description.
      CONCATENATE l_description 'seconds' INTO l_description SEPARATED BY space.
      me->add_text( l_description ).

      l_description = lcl_performance_analyzer=>get_analyzer_description( <fs_analyzer>-analyzer_id ).
      me->add_value( i_rowtxt = l_description
                     i_val    = l_runtime
                     i_id     = <fs_analyzer>-analyzer_id ).

    ENDLOOP.


  ENDMETHOD.                    "generate_values

ENDCLASS.                    "lcl_screen_300 IMPLEMENTATION

*----------------------------------------------------------------------*
* CLASS lcl_message IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_message IMPLEMENTATION.
  METHOD report_message.
    IF i_disp_as IS INITIAL.
      MESSAGE i_msg TYPE i_type.
    ELSE.
      MESSAGE i_msg TYPE i_type DISPLAY LIKE i_disp_as.
    ENDIF.
  ENDMETHOD. "report_message

  METHOD user_choice.
    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        titlebar      = i_title
        text_question = i_question
        text_button_1 = i_option_1
        text_button_2 = i_option_2
        popup_type    = i_icon
      IMPORTING
        answer        = return.
  ENDMETHOD.                    "user_choice

ENDCLASS. "lcl_message IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_query_element IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_query_element IMPLEMENTATION.

  METHOD get_command_contents.
    return = me->t_command_contents.
  ENDMETHOD.                    "set_command_contents

  METHOD check_alias.

    DATA: l_tabix TYPE i.

    FIELD-SYMBOLS <fs_aux> TYPE string.

    l_tabix = i_index.

    ADD 1 TO l_tabix.
    READ TABLE i_query ASSIGNING <fs_aux> INDEX l_tabix.
    IF sy-subrc IS INITIAL AND <fs_aux> = lcl_commands=>as.
      ADD 1 TO l_tabix.
      READ TABLE i_query ASSIGNING <fs_aux> INDEX l_tabix.
      return = <fs_aux>.
    ENDIF.

  ENDMETHOD.                    "check_alias

  METHOD to_string.
    CONDENSE me->v_command.
    return = me->v_command.
  ENDMETHOD.                    "to_string

ENDCLASS.                    "lcl_query_element IMPLEMENTATION

*&---------------------------------------------------------------------*
*&       Class (Implementation)  lcl_where
*&---------------------------------------------------------------------*
CLASS lcl_where IMPLEMENTATION.

  METHOD set_command_contents.

    DATA: l_string     TYPE string,
          l_index      TYPE sytabix,
          l_tabix      TYPE i,
          l_first      TYPE boolean,
          l_length     TYPE i.

    FIELD-SYMBOLS: <fs_aux> TYPE string.

    READ TABLE i_query WITH KEY table_line = i_command TRANSPORTING NO FIELDS.
    IF sy-subrc IS INITIAL.

      l_index = sy-tabix + 1.

      l_first = abap_true.
      LOOP AT i_query INTO l_string FROM l_index.
        IF l_string = lcl_commands=>having OR
           l_string = lcl_commands=>group  OR
           l_string = lcl_commands=>up.
          EXIT.
        ENDIF.

        l_tabix = sy-tabix.

        l_length = STRLEN( l_string ).
        SUBTRACT 1 FROM l_length.
        IF l_string+l_length = '.' OR l_string+l_length = ';'.
          l_string = l_string(l_length).
        ENDIF.

        APPEND l_string TO me->t_command_contents.
        CONCATENATE me->v_command l_string INTO me->v_command SEPARATED BY space.

      ENDLOOP.
    ENDIF.

  ENDMETHOD.                    "set_command_contents

ENDCLASS.               "lcl_where

*----------------------------------------------------------------------*
*       CLASS lcl_event_handler IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_event_handler IMPLEMENTATION.

  METHOD constructor.
    me->o_query_agent = i_query_agent.
  ENDMETHOD.                    "constructor

  METHOD handle_added_function.

    CASE e_salv_function.
      WHEN c_del.
        DATA: o_save TYPE REF TO lcl_query_save.
        o_save = lcl_query_save=>get_instance( ).
        o_save->delete_selected_query( ).
    ENDCASE.

  ENDMETHOD.                    "handle_added_function

  METHOD handle_user_command.
    DATA o_query_agent TYPE REF TO lcl_query_agent.

    CASE e_ucomm.
      WHEN lcl_event_handler=>c_tech.
        me->o_query_agent->inverse_fieldcat_names( ).

      WHEN lcl_event_handler=>c_type.
        TRY.
            me->o_query_agent->generate_types( ).
          CATCH lcx_cancel.                              "#EC NO_HANDLE
        ENDTRY.

      WHEN lcl_event_handler=>c_perf.
        me->o_query_agent->show_performance_analyzer( ).

      WHEN lcl_event_handler=>c_no_conv.
        me->o_query_agent->no_routine_conversion( ).

    ENDCASE.
  ENDMETHOD.                    "handle_user_command

  METHOD handle_toolbar.

    me->add_button( EXPORTING
                      i_butn_type = 3
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

    me->add_button( EXPORTING
                      i_function  = lcl_event_handler=>c_tech
                      i_icon      = '@B_ACTY@'
                      i_quickinfo = 'Inverse Names'(004)
                      i_butn_type = 0
                      i_disabled  = abap_false
                      i_text      = 'Inverse Names'(004)
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

    me->add_button( EXPORTING
                      i_function  = lcl_event_handler=>c_type
                      i_icon      = '@MSGTYP@'
                      i_quickinfo = 'Generate Type'(005)
                      i_butn_type = 0
                      i_disabled  = abap_false
                      i_text      = 'Generate Type'(005)
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

    me->add_button( EXPORTING
                      i_function  = lcl_event_handler=>c_perf
                      i_icon      = '@B_TINA@'
                      i_quickinfo = 'Performance Analyzer'(006)
                      i_butn_type = 0
                      i_disabled  = abap_false
                      i_text      = 'Performance Analyzer'(006)
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

*    me->add_button( EXPORTING
*                      i_function  = lcl_event_handler=>c_no_conv
*                      i_icon      = '@F_UNDO@'
*                      i_quickinfo = 'No Conversion'
*                      i_butn_type = 0
*                      i_disabled  = abap_false
*                      i_text      = 'No Conversion'
*                    CHANGING
*                      t_toolbar = e_object->mt_toolbar ).

*    me->add_button( EXPORTING
*                      i_function  = 'TESTE'
*                      i_quickinfo = 'Teste boto'(006)
*                      i_butn_type = 2
*                      i_disabled  = abap_false
*                      i_text      = 'Teste boto'(006)
*                    CHANGING
*                      t_toolbar = e_object->mt_toolbar ).

  ENDMETHOD.                    "handle_toolbar

  METHOD add_button.

    FIELD-SYMBOLS <fs_button> TYPE stb_button.

    APPEND INITIAL LINE TO t_toolbar ASSIGNING <fs_button>.
    <fs_button>-function  = i_function.
    <fs_button>-icon      = i_icon.
    <fs_button>-quickinfo = i_quickinfo.
    <fs_button>-butn_type = i_butn_type.
    <fs_button>-disabled  = i_disabled.
    <fs_button>-text      = i_text.
    UNASSIGN <fs_button>.

  ENDMETHOD.                    "add_button

  METHOD handle_menu_button.
*    e_object->add_function( fcode = 'TESTE'
*                            text  = 'Teste 1' ).
    "icon  = '@B_ACTY@' ).
  ENDMETHOD.                    "handle_menu_button

  METHOD handle_row_drag.
    DATA: o_drag_drop TYPE REF TO lcl_drag_drop,
          o_screen    TYPE REF TO lcl_screen_500,
          t_fields    TYPE tyt_table_fields,
          l_index     TYPE i.

    FIELD-SYMBOLS <fs_field> TYPE ty_table_fields.

    o_screen ?= lcl_screen=>get_instance( 500 ).
    o_screen->check_changed_data( ).
    o_screen->get_fields( IMPORTING e_fields = t_fields ).

    l_index = e_row-index.

    READ TABLE t_fields ASSIGNING <fs_field> INDEX l_index.
    CHECK sy-subrc IS INITIAL.

    CREATE OBJECT o_drag_drop.
    o_drag_drop->set_index( l_index ).
    o_drag_drop->set_data( <fs_field> ).

    e_dragdropobj->object = o_drag_drop.
  ENDMETHOD.                    "handle_row_drag

  METHOD handle_row_drop.
    DATA: o_drag_drop TYPE REF TO lcl_drag_drop,
          o_screen    TYPE REF TO lcl_screen_500,

          t_fields    TYPE tyt_table_fields,

          wa_stable   TYPE lvc_s_stbl,
          wa_field    TYPE ty_table_fields,

          l_index     TYPE i.

    wa_stable-row = abap_true. wa_stable-col = abap_true.

    CATCH SYSTEM-EXCEPTIONS move_cast_error = 1.
      o_drag_drop ?= e_dragdropobj->object.
      wa_field = o_drag_drop->get_data( ).

      o_screen ?= lcl_screen=>get_instance( 500 ).
      o_screen->get_fields( IMPORTING e_fields = t_fields ).

      l_index = o_drag_drop->get_index( ).

      DELETE t_fields INDEX l_index.
      INSERT wa_field INTO t_fields INDEX e_row-index.

      o_screen->set_fields( t_fields ).
      o_screen->refresh_alv( i_soft_refresh = abap_true
                             i_stable       = wa_stable ).

    ENDCATCH.
    IF sy-subrc IS INITIAL.
      e_dragdropobj->abort( ).
    ENDIF.

  ENDMETHOD.                    "handle_row_drop

  METHOD handle_toolbar_select_gen.
    me->add_button( EXPORTING
                      i_butn_type = 3
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

    me->add_button( EXPORTING
                      i_function  = lcl_event_handler=>c_sall
                      i_icon      = '@B_MRKA@'
                      i_quickinfo = 'Select All'
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

    me->add_button( EXPORTING
                      i_function  = lcl_event_handler=>c_dall
                      i_icon      = '@B_MRKD@'
                      i_quickinfo = 'Deselect All'
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

  ENDMETHOD.                    "handle_toolbar_select_gen

  METHOD handle_user_command_select_gen.
    DATA: o_screen TYPE REF TO lcl_screen_500.
    o_screen ?= lcl_screen=>get_instance( 500 ).

    CASE e_ucomm.
      WHEN c_sall.
        o_screen->mark_fields( ).
        o_screen->refresh_alv( ).

      WHEN c_dall.
        o_screen->unmark_fields( ).
        o_screen->refresh_alv( ).

    ENDCASE.

  ENDMETHOD.                    "handle_user_command_select_gen

  METHOD handle_toolbar_from_gen.
    me->add_button( EXPORTING
                      i_butn_type = 3
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

    me->add_button( EXPORTING
                      i_function  = lcl_event_handler=>c_add
                      i_icon      = '@B_INSR@'
                      i_quickinfo = 'Add join table'
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

    me->add_button( EXPORTING
                      i_function  = lcl_event_handler=>c_del
                      i_icon      = '@B_DELR@'
                      i_quickinfo = 'Delete join table'
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

    me->add_button( EXPORTING
                      i_butn_type = 3
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

    me->add_button( EXPORTING
                      i_function  = lcl_event_handler=>c_sugest
                      i_icon      = '@B_RESH@'
                      i_quickinfo = 'Suggest join tabls'
                      i_butn_type = 0
                      i_disabled  = abap_false
                      i_text      = 'Suggest Join'
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

  ENDMETHOD.                    "handle_toolbar_from_gen

  METHOD handle_user_command_from_gen.
    DATA: o_screen TYPE REF TO lcl_screen_600.
    o_screen ?= lcl_screen=>get_instance( 600 ).

    TRY.
        CASE e_ucomm.
          WHEN c_add.
            o_screen->add_line( ).
            o_screen->refresh_alv( ).

          WHEN c_del.
            o_screen->delete_line( ).
            o_screen->refresh_alv( ).

          WHEN c_sugest.
            o_screen->suggest_join( ).
            o_screen->refresh_alv( ).

        ENDCASE.

      CATCH lcx_no_fields_selected.
        lcl_message=>report_message( i_msg     = 'Please, select at least one row'
                                     i_type    = 'S'
                                     i_disp_as = 'E' ).
    ENDTRY.

  ENDMETHOD.                    "handle_user_command_from_gen

  METHOD handle_hotspot_from_gen.
    DATA: o_screen TYPE REF TO lcl_screen_600.
    o_screen ?= lcl_screen=>get_instance( 600 ).
    o_screen->open_join_fields( e_row_id-index ).
  ENDMETHOD.                    "handle_hotspot_from_gen

  METHOD handle_f4_from_gen.
    DATA: o_screen TYPE REF TO lcl_screen_600.
    o_screen ?= lcl_screen=>get_instance( 600 ).
    o_screen->search_help_for_tabname( es_row_no-row_id ).
  ENDMETHOD.                    "handle_f4_from_gen

  METHOD handle_toolbar_join.
    me->add_button( EXPORTING
                      i_butn_type = 3
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

    me->add_button( EXPORTING
                      i_function  = lcl_event_handler=>c_add
                      i_icon      = '@B_INSR@'
                      i_quickinfo = 'Add Field'
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

    me->add_button( EXPORTING
                      i_function  = lcl_event_handler=>c_del
                      i_icon      = '@B_DELR@'
                      i_quickinfo = 'Delete Field(s)'
                      i_butn_type = 0
                      i_disabled  = abap_false
                    CHANGING
                      t_toolbar = e_object->mt_toolbar ).

  ENDMETHOD.                    "handle_toolbar_join

  METHOD handle_user_command_join.
    DATA: o_screen TYPE REF TO lcl_screen_700.
    o_screen ?= lcl_screen=>get_instance( 700 ).

    TRY.
        CASE e_ucomm.
          WHEN c_add.
            o_screen->add_line( ).
            o_screen->refresh_alv( ).

          WHEN c_del.
            o_screen->delete_line( ).
            o_screen->refresh_alv( ).

        ENDCASE.

      CATCH lcx_no_fields_selected.
        lcl_message=>report_message( i_msg     = 'Please, select at least one row'
                                     i_type    = 'S'
                                     i_disp_as = 'E' ).
    ENDTRY.

  ENDMETHOD.                    "handle_user_command_join

  METHOD handle_data_change_join.
    DATA: o_screen TYPE REF TO lcl_screen_700,
          wa_stable TYPE lvc_s_stbl.

    FIELD-SYMBOLS <fs_mod_cells> TYPE lvc_s_modi.

    o_screen ?= lcl_screen=>get_instance( 700 ).

    LOOP AT er_data_changed->mt_mod_cells ASSIGNING <fs_mod_cells>.
      IF <fs_mod_cells>-fieldname = 'CHECKTABLE'.
        o_screen->set_handle_checkfield( i_index = <fs_mod_cells>-row_id
                                         i_value = <fs_mod_cells>-value ).

        wa_stable-col = abap_true. wa_stable-row = abap_true.
        o_screen->refresh_alv( i_stable	      = wa_stable
                               i_soft_refresh = abap_true ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    "handle_data_change_join

ENDCLASS.                   "lcl_event_handler IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_drag_drop IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_drag_drop IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_index.
    me->v_index = i_index.
  ENDMETHOD.                    "set_index
  METHOD get_index.
    return = me->v_index.
  ENDMETHOD.                    "get_index

  METHOD set_data.
*    GET REFERENCE OF i_data INTO me->o_data.
    me->o_data = i_data.
  ENDMETHOD.                    "set_data
  METHOD get_data.
    return = me->o_data.
  ENDMETHOD.                    "get_data
  "$. Endregion Getters and Setters

ENDCLASS.                    "lcl_drag_drop IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_type_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_type_generator IMPLEMENTATION.
  "$. Region Getters and Setters
  METHOD set_type_name.
    me->v_type_name = i_type_name.
  ENDMETHOD.                    "set_type_name
  METHOD get_type_name.
    return = me->v_type_name.
  ENDMETHOD.                    "get_type_name

  METHOD get_command_line.
    return = me->t_command_line.
  ENDMETHOD.                    "get_command_line
  "$. Endregion Getters and Setters

  METHOD constructor.
    me->set_type_name( i_type_name ).
  ENDMETHOD.                    "constructor

  METHOD generate_generic_type.

    DATA: l_tabname TYPE string,
          l_line TYPE string.

    l_tabname = i_table_name.
    TRANSLATE l_tabname TO LOWER CASE.

    CONCATENATE 'DATA t_' l_tabname ' TYPE TABLE OF ' l_tabname '. "Internal table' INTO l_line RESPECTING BLANKS. "#EC NOTEXT
    me->add_command_line( l_line ).

    CONCATENATE 'DATA wa_' l_tabname ' TYPE ' l_tabname '. "Structure' l_tabname INTO l_line RESPECTING BLANKS. "#EC NOTEXT
    me->add_command_line( l_line ).

    CONCATENATE 'FIELD-SYMBOLS <fs_' l_tabname '> TYPE ' l_tabname '. "Memory pointer structure' INTO l_line RESPECTING BLANKS. "#EC NOTEXT
    me->add_command_line( l_line ).

  ENDMETHOD.                    "generate_generic_type

  METHOD generate_type_by_fcat.

    DATA: l_line    TYPE string,
          l_tabname TYPE string.

    FIELD-SYMBOLS: <fs_fcat> TYPE lvc_s_fcat.

    me->add_command_line( 'TYPES:' ).

    CONCATENATE  cl_abap_char_utilities=>horizontal_tab
                 'BEGIN OF '
                 me->v_type_name ', ' INTO l_line RESPECTING BLANKS.
    me->add_command_line( l_line ).

    LOOP AT i_fieldcat ASSIGNING <fs_fcat>.

      CONCATENATE <fs_fcat>-ref_table '-' <fs_fcat>-ref_field INTO l_line.
      CONDENSE l_line NO-GAPS.

      CONCATENATE cl_abap_char_utilities=>horizontal_tab
                  cl_abap_char_utilities=>horizontal_tab
                  <fs_fcat>-fieldname
                  ' TYPE '
                  l_line
                  ', "'
                  <fs_fcat>-scrtext_l
             INTO l_line RESPECTING BLANKS.

      CONDENSE l_line.
      me->add_command_line( l_line ).

    ENDLOOP.

    CONCATENATE cl_abap_char_utilities=>horizontal_tab 'END OF ' me->v_type_name '.' INTO l_line RESPECTING BLANKS.
    me->add_command_line( l_line ).

    me->add_command_line( ).

    me->generate_generic_type( me->v_type_name ).

  ENDMETHOD.                    "generate_type_by_fcat

  METHOD add_command_line.
    IF i_line IS INITIAL.
      APPEND INITIAL LINE TO me->t_command_line.
    ELSE.
      APPEND i_line TO me->t_command_line.
    ENDIF.
  ENDMETHOD.                    "add_command_line

  METHOD get_type_name_by_user.

    DATA l_targettext TYPE trm080-text.

    CALL FUNCTION 'ADA_POPUP_TEXT_INPUT'
      EXPORTING
        titel        = 'Type name'(007)
        start_column = 10
        start_row    = 2
      CHANGING
        targettext   = l_targettext.

    IF l_targettext IS INITIAL.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    return = l_targettext.

  ENDMETHOD.                    "get_type_name_by_user

ENDCLASS.                    "lcl_type_generator IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_performance_analyzer IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_performance_analyzer IMPLEMENTATION.

  METHOD class_constructor.
*    lcl_performance_analyzer=>add_analyzer_id( i_id    = lcl_performance_analyzer=>check_syntax
*                                               i_descr = 'Syntax Check' ).
*    lcl_performance_analyzer=>add_analyzer_id( i_id    = lcl_performance_analyzer=>identify_query_elements
*                                               i_descr = 'Identify Query Elements' ).
*    lcl_performance_analyzer=>add_analyzer_id( i_id    = lcl_performance_analyzer=>fieldcat_creation
*                                               i_descr = 'Fieldcatalog Creation' ).
*    lcl_performance_analyzer=>add_analyzer_id( i_id    = lcl_performance_analyzer=>build_dynamic_structure
*                                               i_descr = 'Dymanic Structure Creation' ).
    lcl_performance_analyzer=>add_analyzer_id( i_id    = lcl_performance_analyzer=>sql
                                               i_descr = 'SQL Statement'(008) ).
    lcl_performance_analyzer=>add_analyzer_id( i_id    = lcl_performance_analyzer=>abap
                                               i_descr = 'ABAP Procedures'(009) ).
  ENDMETHOD.                    "class_constructor

  METHOD add_analyzer_id.
    FIELD-SYMBOLS <fs_analyzer_id> TYPE yt_analyzer_ids.
    APPEND INITIAL LINE TO t_analyzer_ids ASSIGNING <fs_analyzer_id>.
    <fs_analyzer_id>-analyzer_id = i_id.
    <fs_analyzer_id>-description = i_descr.
    UNASSIGN <fs_analyzer_id>.
  ENDMETHOD.                    "add_analyzer_id

  METHOD get_analyzer_description.
    FIELD-SYMBOLS <fs_analyzer_id> TYPE yt_analyzer_ids.
    READ TABLE t_analyzer_ids ASSIGNING <fs_analyzer_id> WITH KEY analyzer_id = i_id.
    IF sy-subrc IS INITIAL.
      return = <fs_analyzer_id>-description.
    ENDIF.
  ENDMETHOD.                    "get_analyzer_description

  METHOD start_runtime_analyzer.
    me->add_analyzer( i_analyzer_id ).
  ENDMETHOD.                    "start_runtime_analyzer

  METHOD stop_runtime_analyzer.
    FIELD-SYMBOLS: <fs_analyzer> TYPE yt_analyzer.
    READ TABLE me->t_analyzer ASSIGNING <fs_analyzer> WITH KEY analyzer_id = i_analyzer_id.
    <fs_analyzer>-end_runtime = me->get_runtime_field( ).
    UNASSIGN <fs_analyzer>.
  ENDMETHOD.                    "stop_runtime_analyzer

  METHOD add_analyzer.
    FIELD-SYMBOLS <fs_analyzer> TYPE yt_analyzer.
    APPEND INITIAL LINE TO me->t_analyzer ASSIGNING <fs_analyzer>.
    <fs_analyzer>-analyzer_id = i_id.
    <fs_analyzer>-start_runtime = me->get_runtime_field( ).
    UNASSIGN <fs_analyzer>.
  ENDMETHOD.                    "add_analyzer

  METHOD get_runtime_field.
    GET RUN TIME FIELD return.
  ENDMETHOD.                    "get_runtime_field

  METHOD get_analyzer.
    READ TABLE me->t_analyzer INTO return WITH KEY analyzer_id = i_id.
  ENDMETHOD.                    "get_analyzer

  METHOD get_analyzer_table.
    t_analyzer = me->t_analyzer.
  ENDMETHOD.                    "get_analyzer_table

  METHOD calculate_runtime.
    DATA: wa_analyzer TYPE yt_analyzer,
          l_time_diff TYPE f,
          l_time_dec  TYPE p DECIMALS 2,
          l_start     TYPE i,
          l_end       TYPE i.

    IF NOT i_id IS INITIAL.
      wa_analyzer = me->get_analyzer( i_id ).
      l_start = wa_analyzer-start_runtime.
      l_end   = wa_analyzer-end_runtime.
    ELSE.
      l_start = i_start.
      l_end   = i_end.
    ENDIF.

    l_time_diff = l_end - l_start.
    l_time_dec = l_time_diff.
    return = l_time_dec / 1000000.
  ENDMETHOD.                    "calculate_runtime

ENDCLASS.                    "lcl_performance_analyzer IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_query_saver IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_query_save IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_selected_query.
    me->t_selected_query = i_query.
  ENDMETHOD.                    "set_selected_query
  METHOD get_selected_query.
    e_query = me->t_selected_query.
  ENDMETHOD.                    "get_selected_query

  METHOD set_refresh.
    me->v_refresh = i_refresh.
  ENDMETHOD.                    "set_refresh
  "$. Endregion Getters and Setters

  METHOD get_instance.
    IF o_instance IS INITIAL.
      CREATE OBJECT o_instance.
    ENDIF.
    return = o_instance.
  ENDMETHOD.                    "get_instance

  METHOD buffer_query_texted.
    DATA: t_lines   TYPE TABLE OF tline,
          t_query   TYPE salv_wd_t_string,
          t_aux     TYPE salv_wd_t_string,
          wa_header TYPE thead.

    FIELD-SYMBOLS: <fs_line>  TYPE tline,
                   <fs_query> TYPE string.

    LOOP AT i_query ASSIGNING <fs_query>.
      t_aux = lcl_query=>split_text( i_text = <fs_query>
                                     i_outputlen = 200 ).
      APPEND LINES OF t_aux TO t_query.
    ENDLOOP.


    CONCATENATE me->c_buffer_prefix sy-uname INTO wa_header-tdname RESPECTING BLANKS.
    wa_header-tdobject   = 'TEXT'.
    wa_header-tdid       = 'ST'.
    wa_header-tdspras    = 'E'.
    wa_header-tdlinesize = 250.

    LOOP AT t_query ASSIGNING <fs_query>.
      APPEND INITIAL LINE TO t_lines ASSIGNING <fs_line>.
      <fs_line>-tdformat = '/('.
      <fs_line>-tdline = <fs_query>.
      UNASSIGN <fs_line>.
    ENDLOOP.

    CALL FUNCTION 'SAVE_TEXT'
      EXPORTING
        client          = sy-mandt
        header          = wa_header
        savemode_direct = 'X'
      TABLES
        lines           = t_lines
      EXCEPTIONS
        id              = 1
        language        = 2
        name            = 3
        object          = 4
        OTHERS          = 5.

  ENDMETHOD.                    "buffer_query

  METHOD get_buffered_query.
    DATA l_qname TYPE string.
    CONCATENATE c_buffer_prefix sy-uname INTO l_qname RESPECTING BLANKS.
    return = me->read_query( l_qname ).
  ENDMETHOD.                    "get_buffered_query

  METHOD get_query_name.

    DATA l_targettext TYPE trm080-text.

    CALL FUNCTION 'ADA_POPUP_TEXT_INPUT'
      EXPORTING
        titel        = 'Query name'(010)
        start_column = 10
        start_row    = 2
      CHANGING
        targettext   = l_targettext.

    IF l_targettext IS INITIAL.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    CONCATENATE c_zquery_prefix l_targettext INTO return.
    CONDENSE return NO-GAPS. TRANSLATE return TO UPPER CASE.

  ENDMETHOD.                    "get_query_name

  METHOD save_query.

    DATA: o_exception TYPE REF TO lcx_existent_object,
          t_lines TYPE TABLE OF tline,
          wa_header TYPE thead.

    TRY.
        me->check_existent_query( i_name ).
      CATCH lcx_existent_object INTO o_exception.
        DATA: l_question TYPE string.
        l_question = 'Overwrite existing query?'(011).
        IF o_exception->continue_process( l_question ) = abap_false.
          RAISE EXCEPTION TYPE lcx_cancel.
        ENDIF.
    ENDTRY.

    me->compute_query( EXPORTING
                         i_query = i_query
                       IMPORTING
                         e_lines = t_lines ).

    wa_header-tdname     = i_name.
    wa_header-tdobject   = 'TEXT'.
    wa_header-tdid       = 'ST'.
    wa_header-tdspras    = 'E'.
    wa_header-tdlinesize = 132.

    CALL FUNCTION 'SAVE_TEXT'
      EXPORTING
        client          = sy-mandt
        header          = wa_header
        savemode_direct = 'X'
      TABLES
        lines           = t_lines
      EXCEPTIONS
        id              = 1
        language        = 2
        name            = 3
        object          = 4
        OTHERS          = 5.

  ENDMETHOD.                    "save_query

  METHOD delete_query.
    DATA: l_qname TYPE thead-tdname.
    l_qname = i_query_name.
    CALL FUNCTION 'DELETE_TEXT'
      EXPORTING
        client    = sy-mandt
        id        = 'ST'
        language  = 'E'
        name      = l_qname
        object    = 'TEXT'
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
  ENDMETHOD.                    "delete_query

  METHOD check_existent_query.
    me->read_query( i_query_name = i_name
                    i_check      = abap_true ).
  ENDMETHOD.                    "check_existent_query

  METHOD compute_query.
    FIELD-SYMBOLS: <fs_query> TYPE string,
                   <fs_line>  TYPE tline.
    LOOP AT i_query ASSIGNING <fs_query>.
      APPEND INITIAL LINE TO e_lines ASSIGNING <fs_line>.
      <fs_line>-tdformat = '/('.
      <fs_line>-tdline = <fs_query>.
      UNASSIGN <fs_line>.
    ENDLOOP.
  ENDMETHOD.                    "compute_query

  METHOD read_query.
    DATA: t_lines TYPE TABLE OF tline,
          l_qname TYPE thead-tdname.
    FIELD-SYMBOLS <fs_line> TYPE tline.

    l_qname = i_query_name.

    CALL FUNCTION 'READ_TEXT'
      EXPORTING
        client                  = sy-mandt
        id                      = 'ST'
        language                = 'E'
        name                    = l_qname
        object                  = 'TEXT'
      TABLES
        lines                   = t_lines
      EXCEPTIONS
        id                      = 1
        language                = 2
        name                    = 3
        not_found               = 4
        object                  = 5
        reference_check         = 6
        wrong_access_to_archive = 7
        OTHERS                  = 8.
    IF sy-subrc IS INITIAL AND i_check = abap_true.
      RAISE EXCEPTION TYPE lcx_existent_object.
    ENDIF.

    IF sy-subrc IS INITIAL AND NOT t_lines IS INITIAL.
      LOOP AT t_lines ASSIGNING <fs_line>.
        APPEND <fs_line>-tdline TO return.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.                    "read_query

  METHOD get_queries.

    TYPES: BEGIN OF yt_stxh,
             tdname  TYPE stxh-tdname,
             tdfuser TYPE stxh-tdfuser,
             tdfdate TYPE stxh-tdfdate,
           END OF yt_stxh.

    DATA: t_stxh TYPE TABLE OF yt_stxh,
          l_length TYPE i.

    FIELD-SYMBOLS: <fs_stxh> TYPE yt_stxh,
                   <fs_query> TYPE yt_query.

    SELECT tdname
           tdfuser
           tdfdate
      FROM stxh
      INTO TABLE t_stxh
     WHERE tdobject  = 'TEXT'
       AND tdname LIKE i_query_name "LIKE 'YZQUERY%'
       AND tdid      = 'ST'
       AND tdfuser  IN i_user "= sy-uname
       AND tdspras   = 'E'.

    IF NOT sy-subrc IS INITIAL.
      RAISE EXCEPTION TYPE lcx_table_not_found.
    ENDIF.

    l_length = STRLEN( lcl_query_save=>c_zquery_prefix ).

    LOOP AT t_stxh ASSIGNING <fs_stxh>.
      APPEND INITIAL LINE TO e_queries ASSIGNING <fs_query>.
      <fs_query>-query  = <fs_stxh>-tdname+l_length.
      <fs_query>-date   = <fs_stxh>-tdfdate.
      <fs_query>-user   = <fs_stxh>-tdfuser.
      UNASSIGN <fs_query>.
    ENDLOOP.

  ENDMETHOD.                    "get_queries

  METHOD search_queries.
    me->get_queries( EXPORTING
                       i_user       = i_user
                       i_query_name = i_query_name
                     IMPORTING
                       e_queries    = e_queries ).
  ENDMETHOD.                    "search_queries

  METHOD display_queries.

    DATA: o_selections TYPE REF TO cl_salv_selections,
          o_columns    TYPE REF TO cl_salv_columns_table,
          o_column     TYPE REF TO cl_salv_column,
          t_queries    TYPE tyt_query,
          t_rows       TYPE salv_t_row.

    FIELD-SYMBOLS: <fs_query>     TYPE yt_query,
                   <fs_cell_type> TYPE salv_s_int4_column,
                   <fs_row>       TYPE i.

    me->set_selected_query( i_queries ).

    me->set_refresh( abap_true ).
    WHILE me->is_refresh( ) = abap_true.
      TRY.
          cl_salv_table=>factory( IMPORTING
                                  r_salv_table = me->o_table
                                CHANGING
                                  t_table = me->t_selected_query ).
        CATCH cx_salv_msg.
          RETURN.
      ENDTRY.

      o_selections = me->o_table->get_selections( ).
      o_selections->set_selection_mode( if_salv_c_selection_mode=>multiple ).

      me->o_table->set_screen_popup( start_column = 20
                                     end_column   = 85
                                     start_line   = 3
                                     end_line     = 20 ).

      LOOP AT me->t_selected_query ASSIGNING <fs_query>.
        CLEAR <fs_query>-check.
        APPEND INITIAL LINE TO <fs_query>-t_cell_type ASSIGNING <fs_cell_type>.
        <fs_cell_type>-columnname = 'CHECK'.
        <fs_cell_type>-value = cl_salv_column_list=>button.
        UNASSIGN <fs_cell_type>.
      ENDLOOP.

      TRY.
          o_columns = me->o_table->get_columns( ).
          o_columns->set_cell_type_column( value = 'T_CELL_TYPE' ).
          o_column = o_columns->get_column( 'CHECK' ).
          IF o_column IS BOUND.
            o_column->set_output_length( 2 ).
          ENDIF.
        CATCH: cx_salv_not_found, cx_salv_data_error.
          RETURN.
      ENDTRY.

      IF i_mine = abap_true.
        DATA: o_handler TYPE REF TO lcl_event_handler,
              o_events  TYPE REF TO cl_salv_events.
        CREATE OBJECT o_handler.
        me->o_table->set_screen_status( report   = sy-repid
                                        pfstatus = 'PF_SALV_STATUS' ).
        o_events = me->o_table->get_event( ).
        SET HANDLER o_handler->handle_added_function FOR o_events.
      ENDIF.


      me->set_refresh( abap_false ).
      me->o_table->display( ).
*      IF me->is_refresh( ) = abap_true.
*        me->o_table->set_data( CHANGING t_table = me->t_selected_query ).
*      ENDIF.
    ENDWHILE.


    t_rows = o_selections->get_selected_rows( ).
    IF t_rows IS INITIAL.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    LOOP AT t_rows ASSIGNING <fs_row>.
      READ TABLE me->t_selected_query ASSIGNING <fs_query> INDEX <fs_row>.
      APPEND <fs_query> TO e_selected.
    ENDLOOP.

  ENDMETHOD.                    "display_queries

  METHOD compute_selected_queries.
    DATA: o_query_save TYPE REF TO lcl_query_save,
          t_queries    TYPE tyt_query,
          t_text       TYPE salv_wd_t_string,
          l_query_name TYPE string.
    FIELD-SYMBOLS: <fs_query> TYPE yt_query.

    o_query_save = lcl_query_save=>get_instance( ).
    t_queries = i_queries.
    LOOP AT t_queries ASSIGNING <fs_query>.
      CLEAR: l_query_name, t_text.
      CONCATENATE lcl_query_save=>c_zquery_prefix <fs_query>-query INTO l_query_name RESPECTING BLANKS.
      t_text = o_query_save->read_query( l_query_name ).
      APPEND LINES OF t_text TO return.
      APPEND INITIAL LINE TO return.
    ENDLOOP.

  ENDMETHOD.                    "compute_selected_queries

  METHOD delete_selected_query.
    DATA: o_selections TYPE REF TO cl_salv_selections,
          t_rows       TYPE salv_t_row,
          t_aux        TYPE tyt_query,
          l_answer     TYPE c.

    o_selections = me->o_table->get_selections( ).
    t_rows = o_selections->get_selected_rows( ).

    CHECK NOT t_rows IS INITIAL.

    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        text_question         = 'The selected record(s) will be deleted. Are you sure?'(012)
        text_button_1         = 'Yes'(018)
        text_button_2         = 'No'(019)
        default_button        = '1'
        display_cancel_button = 'X'
      IMPORTING
        answer                = l_answer
      EXCEPTIONS
        text_not_found        = 1
        OTHERS                = 2.
    IF l_answer <> '1'.
      RETURN.
    ENDIF.

    me->get_selected_queries_by_rows( EXPORTING i_rows = t_rows
                                      IMPORTING e_query = t_aux ).
    me->process_delete_query( t_aux ).

    me->set_refresh( abap_true ).

    me->o_table->close_screen( ).

  ENDMETHOD.                    "delete_selected_query

  METHOD get_selected_queries_by_rows.
    FIELD-SYMBOLS: <fs_row> TYPE i,
                   <fs_query> TYPE yt_query.
    LOOP AT i_rows ASSIGNING <fs_row>.
      READ TABLE me->t_selected_query ASSIGNING <fs_query> INDEX <fs_row>.
      IF sy-subrc IS INITIAL.
        APPEND <fs_query> TO e_query.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.                    "get_selected_queries_by_rows

  METHOD process_delete_query.
    DATA: l_name TYPE string.
    FIELD-SYMBOLS <fs_query> TYPE yt_query.
    LOOP AT i_query ASSIGNING <fs_query>.
      CLEAR: l_name.
      CONCATENATE lcl_query_save=>c_zquery_prefix <fs_query>-query INTO l_name RESPECTING BLANKS.
      me->delete_query( l_name ).
      READ TABLE me->t_selected_query WITH KEY query = <fs_query>-query TRANSPORTING NO FIELDS.
      IF sy-subrc IS INITIAL.
        DELETE me->t_selected_query INDEX sy-tabix.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    "process_delete_query

  METHOD is_refresh.
    return = me->v_refresh.
  ENDMETHOD.                    "is_refresh

ENDCLASS.                    "lcl_query_saver IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcx_error_query_check IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcx_error_query_check IMPLEMENTATION.
  METHOD constructor.
    super->constructor( ).
    me->v_message = i_message.
  ENDMETHOD.                    "constructor

  METHOD get_message.
    return = me->v_message.
  ENDMETHOD.                    "get_message
ENDCLASS.                    "lcx_error_query_check IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcx_existent_object IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcx_existent_object IMPLEMENTATION.
  METHOD continue_process.

    DATA: l_answer TYPE c.

    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        text_question         = i_question
        text_button_1         = 'Yes'
        text_button_2         = 'No'
        default_button        = '1'
        display_cancel_button = 'X'
      IMPORTING
        answer                = l_answer
      EXCEPTIONS
        text_not_found        = 1
        OTHERS                = 2.
    IF sy-subrc IS INITIAL AND l_answer = '1'.
      return = abap_true.
    ENDIF.

  ENDMETHOD.                    "continue_process
ENDCLASS.                    "lcx_existent_object IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_selection_screen IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_selection_screen IMPLEMENTATION.

  METHOD lif_screen~show.
    IF i_first_col IS INITIAL AND
       i_first_row IS INITIAL AND
       i_last_col  IS INITIAL AND
       i_last_row  IS INITIAL.
      CALL SELECTION-SCREEN me->lif_screen~v_screen.
    ELSE.
      CALL SELECTION-SCREEN me->lif_screen~v_screen STARTING AT i_first_col i_first_row
                                                      ENDING AT i_last_col  i_last_row.
    ENDIF.
  ENDMETHOD.                    "lif_screen~show

ENDCLASS.                    "lcl_selection_screen IMPLEMENTATION
*&---------------------------------------------------------------------*
*&       Class (Implementation)  lcl_screen_400
*&---------------------------------------------------------------------*
CLASS lcl_screen_400 IMPLEMENTATION.

  METHOD lif_screen~user_command.
    TRY.
        CASE i_ucomm.
          WHEN c_exec.
            me->execute( ).
        ENDCASE.
      CATCH lcx_table_not_found.
    ENDTRY.
  ENDMETHOD.                    "lif_screen~user_command

  METHOD execute.
    DATA: o_save    TYPE REF TO lcl_query_save,
          o_agent   TYPE REF TO lcl_query_agent,
          o_screen  TYPE REF TO lcl_screen_100,
          t_user    TYPE tyt_user_range,
          l_query_name TYPE string,

          t_queries TYPE tyt_query,
          t_aux     TYPE tyt_query,
          t_texted_query TYPE salv_wd_t_string.

    o_save  = lcl_query_save=>get_instance( ).
    o_agent = lcl_query_agent=>get_query_agent( ).

    me->compute_user_range( EXPORTING i_user = i_user
                            IMPORTING e_user_range = t_user ).
    l_query_name = me->compute_query_name( ).

    o_save->search_queries( EXPORTING
                              i_user       = t_user
                              i_query_name = l_query_name
                            IMPORTING
                              e_queries    = t_queries ).

    o_save->display_queries( EXPORTING
                               i_queries = t_queries
                             IMPORTING
                               e_selected = t_aux ).
    o_save->set_selected_query( t_aux ).

    t_texted_query = o_save->compute_selected_queries( t_aux ).

    o_screen ?= lcl_screen=>get_instance( 100 ).
    o_screen->set_texted_query( t_texted_query ).

  ENDMETHOD.                    "execute

  METHOD compute_user_range.
    FIELD-SYMBOLS <fs_user> LIKE LINE OF s_user.
    IF NOT i_user IS INITIAL.
      APPEND INITIAL LINE TO e_user_range ASSIGNING <fs_user>.
      <fs_user>-sign = 'I'.
      <fs_user>-option = 'EQ'.
      <fs_user>-low = i_user.
      UNASSIGN <fs_user>.
    ELSE.
      LOOP AT s_user ASSIGNING <fs_user>.
        APPEND <fs_user> TO e_user_range.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.                    "compute_user_range

  METHOD compute_query_name.
    DATA l_name TYPE string.
    l_name = p_qname.
    TRANSLATE p_qname USING '*%'.
    CONCATENATE lcl_query_save=>c_zquery_prefix l_name '%' INTO return RESPECTING BLANKS.
  ENDMETHOD.                    "compute_query_name

ENDCLASS.               "lcl_screen_400

*----------------------------------------------------------------------*
*       CLASS lcl_where_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_where_generator IMPLEMENTATION.

  METHOD generate.
    DATA: o_from   TYPE REF TO lcl_from,
          t_fields TYPE tyt_where_fields,
          t_tables TYPE yt_t_table.
    o_from ?= me->get_query_element( ).
    me->get_fields( EXPORTING i_from = o_from
                    IMPORTING e_fields = t_fields ).
    o_from->get_tables( IMPORTING e_tables = t_tables ).
    me->select_fields( CHANGING c_fields = t_fields ).
    return = me->get_dynamic_selections( i_fields = t_fields
                                         i_tables = t_tables ).
  ENDMETHOD.                    "generate_where

  METHOD generate_new_query_text.
    DATA: t_text TYPE salv_wd_t_string,
          t_new_text TYPE TABLE OF string,
          l_string   TYPE string,
          l_result   TYPE string,
          l_garbage  TYPE string,
          l_split    TYPE boolean,
          l_lines    TYPE i,
          l_length   TYPE i.
    FIELD-SYMBOLS <fs_aux> TYPE string.
    t_text = i_query.

    LOOP AT t_text INTO l_string.
      CLEAR: l_result, l_garbage.
      IF NOT l_string = lcl_commands=>where.
        SPLIT l_string AT lcl_commands=>where INTO l_result l_garbage.
        IF l_garbage IS INITIAL.
          APPEND l_result TO t_new_text.
        ELSE.
          IF NOT l_result IS INITIAL.
            APPEND l_result TO t_new_text.
          ENDIF.
          EXIT.
        ENDIF.
      ELSE.
        EXIT.
      ENDIF.
    ENDLOOP.

    l_lines = LINES( t_new_text ).
    READ TABLE t_new_text ASSIGNING <fs_aux> INDEX l_lines.
    IF sy-subrc IS INITIAL.
      l_length = STRLEN( <fs_aux> ). SUBTRACT 1 FROM l_length.
      IF <fs_aux>+l_length(1) = lcl_commands=>dot.
        <fs_aux> = <fs_aux>(l_length).
      ENDIF.
    ENDIF.

    LOOP AT i_command_text INTO l_result.
      IF sy-tabix = 1.
        CONCATENATE lcl_commands=>where l_result INTO l_string SEPARATED BY space.
      ELSE.
        l_string = l_result.
      ENDIF.
      AT LAST.
        CONCATENATE l_string lcl_commands=>dot INTO l_string RESPECTING BLANKS.
      ENDAT.
      CONDENSE l_string.
      APPEND l_string TO t_new_text.
    ENDLOOP.

    return = t_new_text.

  ENDMETHOD.                    "generate_new_query_text

  METHOD get_fields.
    DATA: o_table TYPE REF TO lcl_table,
          o_fieldcat TYPE REF TO lcl_fieldcat,
          t_fcat  TYPE lvc_t_fcat,
          t_fcat_aux TYPE lvc_t_fcat.

    FIELD-SYMBOLS: <fs_fcat> TYPE lvc_s_fcat,
                   <fs_field> TYPE ty_where_fields.

    CREATE OBJECT o_fieldcat.

    DO.
      TRY.
          o_table = i_from->get_table( i_index = sy-index ).
          t_fcat_aux = o_fieldcat->merge_fieldcat( o_table ).
          APPEND LINES OF t_fcat_aux TO t_fcat.
        CATCH lcx_table_not_found.
          EXIT.
        CATCH lcx_no_fieldcat.
          EXIT.
      ENDTRY.
    ENDDO.

    LOOP AT t_fcat ASSIGNING <fs_fcat>.
      CHECK <fs_fcat>-fieldname <> 'MANDT'.
      APPEND INITIAL LINE TO e_fields ASSIGNING <fs_field>.
      <fs_field>-tabname     = <fs_fcat>-ref_table.
      <fs_field>-fieldname   = <fs_fcat>-fieldname.
      <fs_field>-description = <fs_fcat>-scrtext_l.
      <fs_field>-type        = <fs_fcat>-inttype.
      <fs_field>-where_leng  = <fs_fcat>-intlen.
      <fs_field>-sign        = <fs_fcat>-no_sign.
      <fs_field>-decimals    = <fs_fcat>-decimals_o.
      UNASSIGN <fs_field>.
    ENDLOOP.
  ENDMETHOD.                    "get_fields

  METHOD select_fields.
    DATA: t_fields TYPE tyt_where_fields,
          t_fcat       TYPE slis_t_fieldcat_alv.

    FIELD-SYMBOLS <fs_fcat> TYPE slis_fieldcat_alv.

    t_fields = c_fields.

    "$. Region Fieldcat
    APPEND INITIAL LINE TO t_fcat ASSIGNING <fs_fcat>.
    <fs_fcat>-fieldname = 'TABNAME'.
    <fs_fcat>-reptext_ddic = 'Table Name'(013).
    <fs_fcat>-outputlen = 10.
    UNASSIGN <fs_fcat>.

    APPEND INITIAL LINE TO t_fcat ASSIGNING <fs_fcat>.
    <fs_fcat>-fieldname = 'FIELDNAME'.
    <fs_fcat>-reptext_ddic = 'Field Name'(014).
    <fs_fcat>-outputlen = 10.
    UNASSIGN <fs_fcat>.

    APPEND INITIAL LINE TO t_fcat ASSIGNING <fs_fcat>.
    <fs_fcat>-fieldname = 'DESCRIPTION'.
    <fs_fcat>-reptext_ddic = 'Description'(015).
    <fs_fcat>-outputlen = 40.
    UNASSIGN <fs_fcat>.
    "$. Endregion Fieldcat

    CALL FUNCTION 'REUSE_ALV_POPUP_TO_SELECT'
      EXPORTING
        i_title               = 'Select fields to WHERE clause'(016)
        i_zebra               = abap_true
        i_screen_start_column = 10
        i_screen_start_line   = 2
        i_checkbox_fieldname  = 'MARK'
        i_tabname             = 'T_FIELDS'
        it_fieldcat           = t_fcat
      TABLES
        t_outtab              = t_fields
      EXCEPTIONS
        program_error         = 1
        OTHERS                = 2.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    DELETE t_fields WHERE mark = abap_false.
    DESCRIBE TABLE t_fields.
    IF sy-tfill > 70.
      RAISE EXCEPTION TYPE lcx_fields_overflow.
    ELSEIF sy-tfill = 0.
      RAISE EXCEPTION TYPE lcx_no_fields_selected.
    ENDIF.

    c_fields = t_fields.
  ENDMETHOD.                    "select_fields

  METHOD get_dynamic_selections.
    DATA: t_tables     TYPE yt_t_table,
          t_tables_tab TYPE yt_rsdstabs,
          t_fields_tab TYPE yt_rsdsfields,
          t_twhere     TYPE rsds_twhere,
          l_selid      TYPE rsdynsel-selid.

    me->build_fields_to_selection( EXPORTING i_fields = i_fields
                                             i_tables = i_tables
                                   IMPORTING e_tables_tab = t_tables_tab
                                             e_fields_tab = t_fields_tab ).
    me->init_free_selection( CHANGING c_tables_tab = t_tables_tab
                                      c_fields_tab = t_fields_tab
                                      c_selid      = l_selid ).
    me->call_select_dialog( CHANGING c_selid      = l_selid
                                     c_fields_tab = t_fields_tab
                                     c_twhere     = t_twhere  ).
    return = me->get_dynamic_where( i_tables = i_tables
                                    i_fields = i_fields
                                    i_twhere = t_twhere ).

  ENDMETHOD.                    "get_dynamic_selections

  METHOD build_fields_to_selection.
    DATA: o_table TYPE REF TO lcl_table.
    FIELD-SYMBOLS: <fs_field> TYPE ty_where_fields,
                   <fs_field_tab> TYPE rsdsfields,
                   <fs_tab>       TYPE rsdstabs.

    LOOP AT i_fields ASSIGNING <fs_field>.
      APPEND INITIAL LINE TO e_fields_tab ASSIGNING <fs_field_tab>.
      <fs_field_tab>-tablename  = <fs_field>-tabname.
      <fs_field_tab>-fieldname  = <fs_field>-fieldname.
      <fs_field_tab>-type       = <fs_field>-type.
      <fs_field_tab>-where_leng = <fs_field>-where_leng.
      <fs_field_tab>-sign       = <fs_field>-sign.
      <fs_field_tab>-decimals   = <fs_field>-decimals.
      UNASSIGN <fs_field_tab>.
    ENDLOOP.

    LOOP AT i_tables INTO o_table.
      APPEND INITIAL LINE TO e_tables_tab ASSIGNING <fs_tab>.
      <fs_tab>-prim_tab = o_table->get_name( ).
      UNASSIGN <fs_tab>.
    ENDLOOP.

  ENDMETHOD.                    "build_fields_to_selection

  METHOD init_free_selection.
    CALL FUNCTION 'FREE_SELECTIONS_INIT'
      EXPORTING
        kind                     = 'T'
      IMPORTING
        selection_id             = c_selid
      TABLES
        tables_tab               = c_tables_tab
        fields_tab               = c_fields_tab
      EXCEPTIONS
        fields_incomplete        = 01
        fields_no_join           = 02
        field_not_found          = 03
        no_tables                = 04
        table_not_found          = 05
        expression_not_supported = 06
        incorrect_expression     = 07
        illegal_kind             = 08
        area_not_found           = 09
        inconsistent_area        = 10
        kind_f_no_fields_left    = 11
        kind_f_no_fields         = 12
        too_many_fields          = 13.
  ENDMETHOD.                    "init_free_selection

  METHOD call_select_dialog.
    CALL FUNCTION 'FREE_SELECTIONS_DIALOG'
      EXPORTING
        selection_id    = c_selid
        title           = 'WHERE Generator'(017)
        tree_visible    = ' '
        as_window       = 'X'
        start_row       = 2
        start_col       = 3
      IMPORTING
        where_clauses   = c_twhere
      TABLES
        fields_tab      = c_fields_tab
      EXCEPTIONS
        internal_error  = 1
        no_action       = 2
        selid_not_found = 3
        illegal_status  = 4.
    IF NOT sy-subrc IS INITIAL.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.
  ENDMETHOD.                    "call_select_dialog

  METHOD get_dynamic_where.
    DATA: o_table        TYPE REF TO lcl_table,
          t_where_fields TYPE tyt_where_fields,
          t_twhere       TYPE rsds_twhere,
          t_result       TYPE TABLE OF string,
          t_char72       TYPE TABLE OF rsdswhere,
          t_aux          TYPE TABLE OF string,
          l_tabname      TYPE string,
          l_alias        TYPE string,
          l_field        TYPE string,
          l_first_time   TYPE boolean VALUE 'X',
          l_where        TYPE string,
          l_aux          TYPE string,
          l_index        TYPE sy-tabix,
          l_replace      TYPE string.

    FIELD-SYMBOLS: <fs_where_fields> TYPE ty_where_fields,
                   <fs_aux>          TYPE string,
                   <fs_rsdswhere>    TYPE rsdswhere,
                   <fs_where>        TYPE rsds_where.

    t_where_fields = i_fields.
    t_twhere       = i_twhere.

    SORT: t_twhere       BY tablename,
          t_where_fields BY tabname.

    IF t_twhere IS INITIAL.
      RAISE EXCEPTION TYPE lcx_query_element_not_found EXPORTING i_text = 'No WHERE criteria inputed'.
    ENDIF.

    LOOP AT i_tables INTO o_table.
      l_tabname = o_table->get_name( ).
      l_alias   = o_table->get_alias( ).

      READ TABLE t_twhere ASSIGNING <fs_where> WITH KEY tablename = l_tabname BINARY SEARCH.
      CHECK sy-subrc IS INITIAL.

      READ TABLE t_where_fields WITH KEY tabname = l_tabname TRANSPORTING NO FIELDS BINARY SEARCH.
      IF sy-subrc IS INITIAL.
        l_index = sy-tabix.
        CLEAR: t_aux, l_where.
        LOOP AT <fs_where>-where_tab ASSIGNING <fs_rsdswhere>.
          CONDENSE <fs_rsdswhere>. l_aux = <fs_rsdswhere>.
          l_aux = lcl_report=>compute_apostrophes( l_aux ).
*          CONCATENATE l_where <fs_rsdswhere> INTO l_where SEPARATED BY space.
          CONCATENATE l_where l_aux INTO l_where SEPARATED BY space.
        ENDLOOP.

        CONDENSE l_where.
        SPLIT l_where AT space INTO TABLE t_aux.

        LOOP AT t_where_fields ASSIGNING <fs_where_fields> FROM l_index.
          IF <fs_where_fields>-tabname <> l_tabname.
            EXIT.
          ENDIF.

          CLEAR: l_field.

          IF l_alias IS INITIAL.
            CONCATENATE l_tabname '~' <fs_where_fields>-fieldname INTO l_field RESPECTING BLANKS.
          ELSE.
            CONCATENATE l_alias '~' <fs_where_fields>-fieldname INTO l_field RESPECTING BLANKS.
          ENDIF.


          LOOP AT t_aux ASSIGNING <fs_aux>.
            IF <fs_aux> = <fs_where_fields>-fieldname.
              <fs_aux> = l_field.
            ENDIF.
          ENDLOOP.

          AT END OF tabname.
            CLEAR l_where.
            LOOP AT t_aux ASSIGNING <fs_aux>.
              CONCATENATE l_where <fs_aux> INTO l_where SEPARATED BY space.
            ENDLOOP.

            IF l_first_time = abap_true.
              l_first_time = abap_false.
            ELSE.
              CONCATENATE 'AND' l_where INTO l_where SEPARATED BY space.
            ENDIF.

            CONDENSE l_where.

            t_aux = lcl_query=>split_text( i_text      = l_where
                                           i_outputlen = 72 ).
            APPEND LINES OF t_aux TO return.
          ENDAT.
        ENDLOOP.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.                    "get_dynamic_where

ENDCLASS.                    "lcl_where_generator IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_query_element_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_query_element_generator IMPLEMENTATION.
  "$. Region Getters and Setters
  METHOD set_query_element.
    me->o_query_element = i_element.
  ENDMETHOD.                    "set_query_element
  METHOD get_query_element.
    return = me->o_query_element.
  ENDMETHOD.                    "get_query_element
  "$. Endregion Getters and Setters

  METHOD constructor.
    me->set_query_element( i_element ).
  ENDMETHOD.                    "constructor

  METHOD find_command.
    DATA: t_split TYPE salv_wd_t_string.
    SPLIT i_text AT space INTO TABLE t_split.
    FIND i_command IN TABLE t_split.
    return = sy-subrc.
  ENDMETHOD.                    "find_command

ENDCLASS.                    "lcl_query_element_generator IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_select_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_select_generator IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_select_type.
    me->v_select_type = i_select_type.
  ENDMETHOD.                    "set_select_type
  METHOD get_select_type.
    return = me->v_select_type.
  ENDMETHOD.                    "get_select_type

  METHOD set_select.
    me->o_select = i_select.
  ENDMETHOD.                    "set_select
  METHOD get_select.
    return = me->o_select.
  ENDMETHOD.                    "get_select

  METHOD set_aggregation.
    me->v_aggregation = i_aggregation.
  ENDMETHOD.                    "set_aggregation
  METHOD get_aggregation.
    return = me->v_aggregation.
  ENDMETHOD.                    "get_aggregation
  "$. Endregion Getters and Setters

  METHOD generate.
    DATA: o_from TYPE REF TO lcl_from,
          t_tables TYPE yt_t_table,
          t_fields TYPE tyt_table_fields,
          t_text TYPE salv_wd_t_string.

    o_from ?= me->get_query_element( ).
    o_from->get_tables( IMPORTING e_tables = t_tables ).
    me->get_fields( EXPORTING i_tables = t_tables
                    IMPORTING e_fields = t_fields ).

    me->select_fields( CHANGING e_fields = t_fields ).
    return = me->compute_fields( t_fields ).
    me->t_fields = t_fields.
  ENDMETHOD.                    "generate

  METHOD generate_new_query_text.
    DATA: t_text     TYPE salv_wd_t_string,
          t_new_text TYPE TABLE OF string,
          t_split    TYPE TABLE OF string,

          l_find     TYPE boolean,
          l_string   TYPE string,
          l_result   TYPE string,
          l_garbage  TYPE string,
          l_split    TYPE boolean,
          l_select_type TYPE string.

    CHECK NOT i_command_text IS INITIAL.

    IF i_query IS INITIAL.
      APPEND i_query_string TO t_text.
    ELSE.
      t_text = i_query.
    ENDIF.

    l_select_type = me->get_select_type( ).

    IF l_select_type = lcl_commands=>count.
      CONCATENATE lcl_commands=>select lcl_commands=>count_command INTO l_string SEPARATED BY space.
      APPEND l_string TO t_new_text.
    ELSE.
      LOOP AT i_command_text INTO l_result.
        IF sy-tabix = 1.
          CONCATENATE lcl_commands=>select l_select_type l_result INTO l_string SEPARATED BY space.
        ELSE.
          l_string = l_result.
        ENDIF.
        CONDENSE l_string.
        APPEND l_string TO t_new_text.
      ENDLOOP.
    ENDIF.

    CLEAR: l_string, l_result.

    LOOP AT t_text INTO l_string.
      IF l_find = abap_false.
        CLEAR t_split.
        SPLIT l_string AT space INTO TABLE t_split.
        FIND lcl_commands=>from IN TABLE t_split.
        IF sy-subrc IS INITIAL.
          l_find = abap_true.
        ENDIF.
      ENDIF.

      CHECK l_find = abap_true.

      SPLIT l_string AT lcl_commands=>from INTO l_result l_garbage.
      IF NOT l_garbage IS INITIAL.
*        CONCATENATE cl_abap_char_utilities=>horizontal_tab lcl_commands=>from l_garbage INTO l_garbage SEPARATED BY space.
        CONCATENATE lcl_commands=>from l_garbage INTO l_garbage SEPARATED BY space.
        CONDENSE l_garbage.
        APPEND l_garbage TO t_new_text.
      ELSE.
        IF NOT l_result IS INITIAL.
          CONDENSE l_result.
          APPEND l_result TO t_new_text.
        ELSE.
          APPEND lcl_commands=>from TO t_new_text.
        ENDIF.
      ENDIF.

    ENDLOOP.

    IF me->get_aggregation( ) = abap_true.
      DATA: t_group_by TYPE salv_wd_t_string.
      t_group_by = me->compute_aggregation_clause( ).
      APPEND LINES OF t_group_by TO t_new_text.
    ENDIF.

    return = t_new_text.

  ENDMETHOD.                    "generate_new_query_text

  METHOD get_fields.
    DATA: o_table TYPE REF TO lcl_table,
          t_aux   TYPE tyt_table_fields.
    FIELD-SYMBOLS: <fs_field> TYPE ty_table_fields.

    LOOP AT i_tables INTO o_table.
      CLEAR t_aux.
      o_table->get_table_fields( IMPORTING e_fields = t_aux ).
      APPEND LINES OF t_aux TO e_fields.
    ENDLOOP.

  ENDMETHOD.                    "get_fields

  METHOD mark_fields.
    FIELD-SYMBOLS <fs_field> TYPE ty_table_fields.

    IF me->o_select IS BOUND.
      IF me->o_select->get_select_type( ) = lcl_commands=>asterisk.
        LOOP AT e_fields ASSIGNING <fs_field>.
          <fs_field>-mark = abap_true.
        ENDLOOP.
      ELSE.

        DATA: o_field         TYPE REF TO lcl_field,
              t_select_fields TYPE yt_t_fields,
              l_name          TYPE string,
              l_table_name    TYPE string.

        me->o_select->get_fields( IMPORTING return = t_select_fields ).
        IF me->o_select->get_fields_count( ) = 1.
          READ TABLE t_select_fields INTO o_field INDEX 1.
          IF o_field->get_field_name( ) = lcl_commands=>asterisk.
            LOOP AT e_fields ASSIGNING <fs_field>.
              <fs_field>-mark = abap_true.
            ENDLOOP.
            RETURN.
          ENDIF.
        ENDIF.

        LOOP AT t_select_fields INTO o_field.
          l_name = o_field->get_field_name( ).
          l_table_name = o_field->get_table_name( ).
          IF l_table_name IS INITIAL.
            READ TABLE e_fields ASSIGNING <fs_field> WITH KEY fieldname = l_name.
            IF sy-subrc IS INITIAL.
              <fs_field>-mark = abap_true.
            ENDIF.
          ELSE.
            READ TABLE e_fields ASSIGNING <fs_field> WITH KEY tabname   = l_table_name
                                                              fieldname = l_name.
            IF sy-subrc IS INITIAL.
              <fs_field>-mark = abap_true.
            ENDIF.
          ENDIF.
        ENDLOOP.
      ENDIF.
    ENDIF.
  ENDMETHOD.                    "mark_fields

  METHOD select_fields.
    DATA: o_screen      TYPE REF TO lcl_screen_500,
          t_fields      TYPE tyt_table_fields,
          t_fcat        TYPE slis_t_fieldcat_alv,
          l_select_type TYPE string.

    FIELD-SYMBOLS <fs_fcat> TYPE slis_fieldcat_alv.

    t_fields = e_fields.

    me->mark_fields( CHANGING e_fields = t_fields ).

    o_screen ?= lcl_screen=>get_instance( 500 ).
    o_screen->flush( ).
    o_screen->set_select_type( me->v_select_type ).
    o_screen->set_fields( t_fields ).
    o_screen->show( i_first_col = 10
                    i_first_row = 2
                    i_last_col  = 130
                    i_last_row  = 20 ).

    IF o_screen->get_exit_command( ) = abap_true.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    o_screen->get_fields( IMPORTING e_fields = t_fields ).
    l_select_type = o_screen->get_select_type( ).
    me->set_select_type( l_select_type ).
    me->check_aggregation( t_fields ).

    e_fields = t_fields.

  ENDMETHOD.                    "select_fields

  METHOD compute_fields.
    DATA: l_field          TYPE string,
          l_aux            TYPE string,
          l_select_command TYPE string.

    FIELD-SYMBOLS <fs_field> TYPE ty_table_fields.

    CHECK NOT i_fields IS INITIAL.

    LOOP AT i_fields ASSIGNING <fs_field>.
      IF NOT <fs_field>-tab_alias IS INITIAL.
        CONCATENATE <fs_field>-tab_alias '~' <fs_field>-fieldname INTO l_field.
      ELSE.
        CONCATENATE <fs_field>-tabname '~' <fs_field>-fieldname INTO l_field.
      ENDIF.

      TRANSLATE l_field TO LOWER CASE.

      IF NOT <fs_field>-sql_function IS INITIAL.
        CONCATENATE <fs_field>-sql_function '(' INTO l_aux. CONDENSE l_aux NO-GAPS.
        CONCATENATE l_aux l_field ')' INTO l_field SEPARATED BY space.
      ENDIF.

      IF NOT <fs_field>-field_alias IS INITIAL.
        CONCATENATE l_field 'AS' <fs_field>-field_alias INTO l_field SEPARATED BY space.
      ENDIF.

      CONCATENATE l_select_command l_field INTO l_select_command SEPARATED BY space.
    ENDLOOP.

    CONDENSE l_select_command.

    return = lcl_query=>split_text( i_text      = l_select_command
                                    i_outputlen = 80 ).

  ENDMETHOD.                    "compute_fields

  METHOD check_aggregation.
    DATA: t_fields TYPE tyt_table_fields.
    t_fields = i_fields.
    DELETE t_fields WHERE sql_function IS INITIAL.
    IF LINES( t_fields ) > 0.
      me->set_aggregation( abap_true ).
    ENDIF.
  ENDMETHOD.                    "check_aggregation

  METHOD compute_aggregation_clause.
    DATA: t_fields           TYPE tyt_table_fields,
          l_field            TYPE string,
          l_aux              TYPE string,
          l_group_by_command TYPE string.

    FIELD-SYMBOLS <fs_field> TYPE ty_table_fields.

    t_fields = me->t_fields.
    DELETE t_fields WHERE sql_function IS NOT INITIAL.

    CHECK NOT t_fields IS INITIAL.

    CONCATENATE cl_abap_char_utilities=>horizontal_tab lcl_commands=>group lcl_commands=>by
           INTO l_group_by_command SEPARATED BY space.


    LOOP AT t_fields ASSIGNING <fs_field>.
      IF NOT <fs_field>-tab_alias IS INITIAL.
        CONCATENATE <fs_field>-tab_alias '~' <fs_field>-fieldname INTO l_field.
      ELSE.
        CONCATENATE <fs_field>-tabname '~' <fs_field>-fieldname INTO l_field.
      ENDIF.

      TRANSLATE l_field TO LOWER CASE.

      CONCATENATE l_group_by_command l_field INTO l_group_by_command SEPARATED BY space.
    ENDLOOP.

    CONDENSE l_group_by_command.

    return = lcl_query=>split_text( i_text      = l_group_by_command
                                    i_outputlen = 80 ).
  ENDMETHOD.                    "compute_aggregation_clause

  METHOD generate_by_fieldcat.
    DATA: o_table    TYPE REF TO lcl_table,
          o_from     TYPE REF TO lcl_from,
          t_fieldcat TYPE lvc_t_fcat,
          t_fields   TYPE tyt_table_fields,
          l_table    TYPE string.

    FIELD-SYMBOLS: <fs_fcat> TYPE lvc_s_fcat,
                   <fs_field> TYPE ty_table_fields.

    t_fieldcat = i_fieldcat->get_fieldcat( ).
    o_from ?= me->get_query_element( ).

    LOOP AT t_fieldcat ASSIGNING <fs_fcat>.
      APPEND INITIAL LINE TO t_fields ASSIGNING <fs_field>.
      l_table = <fs_fcat>-ref_table.
      o_table = o_from->get_table( i_table = l_table ).
      <fs_field>-tabname     = <fs_fcat>-ref_table.
      <fs_field>-tab_alias   = o_table->get_alias( ).
      <fs_field>-fieldname   = <fs_fcat>-ref_field.
      <fs_field>-field_alias = <fs_fcat>-fieldname.
      UNASSIGN <fs_field>.
    ENDLOOP.

    return = me->compute_fields( t_fields ).

  ENDMETHOD.                    "generate_by_fieldcat

ENDCLASS.                    "lcl_select_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*       CLASS lcl_screen_500 IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_screen_500 IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_fields.
    me->t_fields = i_fields.
  ENDMETHOD.                    "set_fields
  METHOD get_fields.
    e_fields = me->t_fields.
  ENDMETHOD.                    "get_fields
  "$. Endregion Getters and Setters

  METHOD flush.
    IF me->o_grid IS BOUND.
      me->o_grid->free( ).
      me->o_container->free( ).
      CLEAR: me->o_grid, me->o_container, v_select_type, me->t_fields,
             me->o_select_type, me->o_event_handler, me->o_behaviour_alv.
    ENDIF.
  ENDMETHOD.                    "flush

  METHOD lif_screen~user_command.
    me->o_grid->check_changed_data( ).
    CASE i_ucomm.
      WHEN c_enter.
        IF me->verify_selected_fields( ) = abap_true.
          LEAVE TO SCREEN 0.
        ENDIF.

    ENDCASE.
  ENDMETHOD.                    "user_command

  METHOD lif_screen~screen_status.
    SET PF-STATUS 'PF_0500'.
  ENDMETHOD.                    "screen_status

  METHOD lif_screen~initialize_screen.
    me->initialize_alv( ).
    me->initialize_select_type( ).
  ENDMETHOD.                    "initialize_screen

  METHOD create_fcat.
    me->add_field_to_fcat( EXPORTING
                             i_fieldname = 'MARK'
                             i_edit      = abap_true
                             i_descr     = 'Select Field'
                             i_outputlen = 10
                             i_checkbox  = abap_true
                           CHANGING
                             e_fieldcat = return ).
    me->add_field_to_fcat( EXPORTING
                             i_fieldname = 'TABNAME'
                             i_edit      = abap_false
                             i_descr     = 'Table Name'
                             i_outputlen = 12
                           CHANGING
                             e_fieldcat = return ).
    me->add_field_to_fcat( EXPORTING
                             i_fieldname = 'FIELDNAME'
                             i_edit      = abap_false
                             i_descr     = 'Fieldname Name'
                             i_outputlen = 15
                           CHANGING
                             e_fieldcat = return ).
    me->add_field_to_fcat( EXPORTING
                             i_fieldname = 'DESCR'
                             i_edit      = abap_false
                             i_descr     = 'Field Description'
                             i_outputlen = 20
                           CHANGING
                             e_fieldcat = return ).
    me->add_field_to_fcat( EXPORTING
                             i_fieldname = 'TAB_ALIAS'
                             i_edit      = abap_false
                             i_descr     = 'Table Alias'
                             i_outputlen = 12
                           CHANGING
                             e_fieldcat = return ).
    me->add_field_to_fcat( EXPORTING
                             i_fieldname = 'FIELD_ALIAS'
                             i_edit      = abap_true
                             i_descr     = 'Field Alias'
                             i_outputlen = 15
                           CHANGING
                             e_fieldcat = return ).
    me->add_field_to_fcat( EXPORTING
                             i_fieldname  = 'SQL_FUNCTION'
                             i_edit       = abap_true
                             i_descr      = 'SQL Function'
                             i_outputlen  = 20
                             i_drop_down  = 1
                             i_drop_alias = abap_true
                           CHANGING
                             e_fieldcat = return ).
  ENDMETHOD.                    "create_fcat

  METHOD add_field_to_fcat.
    FIELD-SYMBOLS <fs_fcat> TYPE lvc_s_fcat.
    APPEND INITIAL LINE TO e_fieldcat ASSIGNING <fs_fcat>.
    <fs_fcat>-fieldname  = i_fieldname.
    <fs_fcat>-coltext    = i_descr.
    <fs_fcat>-edit       = i_edit.
    <fs_fcat>-outputlen  = i_outputlen.
    <fs_fcat>-drdn_hndl  = i_drop_down.
    <fs_fcat>-drdn_alias = i_drop_alias.
    <fs_fcat>-checkbox   = i_checkbox.
    UNASSIGN <fs_fcat>.
  ENDMETHOD.                    "add_field_to_fcat

  METHOD create_layout.
    return-stylefname = 'STYLE'.
  ENDMETHOD.                    "create_layout

  METHOD exclude_functions.
    DATA ls_exclude TYPE ui_func.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_delete_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_append_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_insert_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_move_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_cut.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste_new_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_undo.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_print.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_graph.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_info.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_refresh.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_view.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_check.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_views.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_export.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_subtot.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_sum.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_variant.
    APPEND ls_exclude TO return.
  ENDMETHOD.                    "exclude_functions

  METHOD get_sql_functions_drop_down.
    me->add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = space
                                   i_int_value = space
                                 CHANGING
                                   e_drop_down = return ).
    me->add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=>sum
                                   i_int_value = lcl_commands=>sum
                                 CHANGING
                                   e_drop_down = return ).
    me->add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=>avg
                                   i_int_value = lcl_commands=>avg
                                 CHANGING
                                   e_drop_down = return ).
    me->add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=>max
                                   i_int_value = lcl_commands=>max
                                 CHANGING
                                   e_drop_down = return ).
    me->add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=>min
                                   i_int_value = lcl_commands=>min
                                 CHANGING
                                   e_drop_down = return ).
  ENDMETHOD.                    "get_sql_functions_drop_down

  METHOD add_option_to_drop_down.
    FIELD-SYMBOLS <fs_drop_down> TYPE lvc_s_dral.
    APPEND INITIAL LINE TO e_drop_down ASSIGNING <fs_drop_down>.
    <fs_drop_down>-handle    = i_handle.
    <fs_drop_down>-value     = i_value.
    <fs_drop_down>-int_value = i_int_value.
    UNASSIGN <fs_drop_down>.
  ENDMETHOD.                    "add_option_to_drop_down

  METHOD initialize_alv.
    IF me->o_grid IS INITIAL.
      DATA: t_fcat      TYPE lvc_t_fcat,
            t_exclude   TYPE ui_functions,
            t_drop_down TYPE lvc_t_dral,
            wa_layout   TYPE lvc_s_layo,
            l_effect    TYPE i.

      CREATE OBJECT me->o_container
        EXPORTING
          container_name = 'CONTAINER'.

      CREATE OBJECT me->o_grid
        EXPORTING
          i_parent = me->o_container.

      CREATE OBJECT me->o_event_handler.
      SET HANDLER: me->o_event_handler->handle_row_drag                FOR me->o_grid,
                   me->o_event_handler->handle_row_drop                FOR me->o_grid,
                   me->o_event_handler->handle_toolbar_select_gen      FOR me->o_grid,
                   me->o_event_handler->handle_user_command_select_gen FOR me->o_grid.

      CREATE OBJECT me->o_behaviour_alv.
      l_effect = cl_dragdrop=>move.
      me->o_behaviour_alv->add( flavor     = 'Line'         "#EC NOTEXT
                                dragsrc    = abap_true
                                droptarget = abap_true
                                effect     = l_effect ).

      wa_layout = me->create_layout( ).
      me->o_behaviour_alv->get_handle( IMPORTING handle = wa_layout-s_dragdrop-row_ddid ).

      t_fcat      = me->create_fcat( ).
      t_exclude   = me->exclude_functions( ).
      t_drop_down = me->get_sql_functions_drop_down( ).
      me->lock_drop_down( ).

      me->o_grid->set_ready_for_input( 1 ).
      me->o_grid->set_table_for_first_display( EXPORTING
                                                 is_layout            = wa_layout
                                                 it_toolbar_excluding = t_exclude
                                               CHANGING
                                                 it_outtab            = t_fields
                                                 it_fieldcatalog      = t_fcat ).
      me->o_grid->set_drop_down_table( it_drop_down_alias = t_drop_down ).
      me->o_grid->refresh_table_display( ).
    ENDIF.
  ENDMETHOD.                    "initialize_alv

  METHOD initialize_select_type.
    IF me->o_select_type IS INITIAL.
      DATA: t_values TYPE vrm_values.

      GET REFERENCE OF v_select_type INTO me->o_select_type.

      t_values = me->create_vrm_values( ).

      CALL FUNCTION 'VRM_SET_VALUES'
        EXPORTING
          id     = 'V_SELECT_TYPE'
          values = t_values.
    ENDIF.
  ENDMETHOD.                    "initialize_select_type

  METHOD create_vrm_values.
    me->add_vrm_value( EXPORTING
                         i_key    = space
                         i_text   = 'Default'
                       CHANGING
                         e_values = return ).
    me->add_vrm_value( EXPORTING
                         i_key    = lcl_commands=>single
                         i_text   = lcl_commands=>single
                       CHANGING
                         e_values = return ).
    me->add_vrm_value( EXPORTING
                         i_key    = lcl_commands=>distinct
                         i_text   = lcl_commands=>distinct
                       CHANGING
                         e_values = return ).
  ENDMETHOD.                    "create_vrm_values

  METHOD add_vrm_value.
    FIELD-SYMBOLS <fs_value> TYPE vrm_value.
    APPEND INITIAL LINE TO e_values ASSIGNING <fs_value>.
    <fs_value>-key  = i_key.
    <fs_value>-text = i_text.
    UNASSIGN <fs_value>.
  ENDMETHOD.                    "add_vrm_value

  METHOD get_select_type.
    FIELD-SYMBOLS <fs_aux> TYPE ANY.
    ASSIGN o_select_type->* TO <fs_aux>.
    CHECK sy-subrc IS INITIAL.
    return = <fs_aux>.
  ENDMETHOD.                    "get_select_type

  METHOD set_select_type.
    v_select_type = i_select_type.
  ENDMETHOD.                    "set_select_type

  METHOD check_changed_data.
    me->o_grid->check_changed_data( ).
  ENDMETHOD.                    "check_changed_data

  METHOD refresh_alv.
    me->o_grid->refresh_table_display( is_stable      = i_stable
                                       i_soft_refresh = i_soft_refresh ).
  ENDMETHOD.                    "refresh_alv

  METHOD lock_drop_down.
    DATA: wa_style TYPE lvc_s_styl.
    FIELD-SYMBOLS: <fs_field> TYPE ty_table_fields.
    IF i_all = abap_true.
      LOOP AT me->t_fields ASSIGNING <fs_field>.
        CLEAR <fs_field>-style.
        wa_style-fieldname = 'SQL_FUNCTION'.
        wa_style-style = cl_gui_alv_grid=>mc_style_disabled.
        APPEND wa_style TO <fs_field>-style.
      ENDLOOP.
    ELSE.
      LOOP AT me->t_fields ASSIGNING <fs_field>.
        IF <fs_field>-internal_type <> 'I' AND
           <fs_field>-internal_type <> 'P' AND
           <fs_field>-internal_type <> 'F'.
          CLEAR <fs_field>-style.
          wa_style-fieldname = 'SQL_FUNCTION'.
          wa_style-style = cl_gui_alv_grid=>mc_style_disabled.
          APPEND wa_style TO <fs_field>-style.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.                    "lock_drop_down

  METHOD mark_fields.
    FIELD-SYMBOLS <fs_field> TYPE ty_table_fields.
    LOOP AT me->t_fields ASSIGNING <fs_field>.
      <fs_field>-mark = abap_true.
    ENDLOOP.
  ENDMETHOD.                    "mark_fields

  METHOD unmark_fields.
    FIELD-SYMBOLS <fs_field> TYPE ty_table_fields.
    LOOP AT me->t_fields ASSIGNING <fs_field>.
      <fs_field>-mark = abap_false.
    ENDLOOP.
  ENDMETHOD.                    "unmark_fields

  METHOD verify_selected_fields.
    DATA: t_aux TYPE tyt_table_fields.

    me->get_fields( IMPORTING e_fields = t_aux ).

    DELETE t_aux WHERE mark IS INITIAL.
    IF t_aux IS INITIAL.
      lcl_message=>report_message( i_msg     = 'Please, select at least one row'
                                   i_type    = 'I'
                                   i_disp_as = 'E' ).
    ELSE.
      me->set_fields( t_aux ).
      return = abap_true.
    ENDIF.

  ENDMETHOD.                    "verify_selected_fields

ENDCLASS.               "lcl_screen_500

*----------------------------------------------------------------------*
*       CLASS lcx_query_element_not_found IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcx_query_element_not_found IMPLEMENTATION.
  METHOD constructor.
    super->constructor( ).
    me->v_text = i_text.
  ENDMETHOD.                    "constructor
  METHOD get_message.
    return = me->v_text.
  ENDMETHOD.                    "get_message
ENDCLASS.                    "lcx_query_element_not_found IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcx_join_error IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcx_join_error IMPLEMENTATION.
  METHOD constructor.
    super->constructor( ).
    me->v_index = i_index.
    me->v_field = i_field.
    me->v_message = i_message.
  ENDMETHOD.                    "constructor

  METHOD get_index.
    return = me->v_index.
  ENDMETHOD.                    "get_index
  METHOD get_field.
    return = me->v_field.
  ENDMETHOD.                    "get_field
  METHOD get_message.
    return = me->v_message.
  ENDMETHOD.                    "get_message

ENDCLASS.                    "lcx_join_error IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_report IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_report IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_report_name.
    me->v_report_name = i_report_name.
  ENDMETHOD.                    "set_report_name
  METHOD get_report_name.
    return = me->v_report_name.
  ENDMETHOD.                    "get_report_name
  "$. Endregion Getters and Setters

  METHOD constructor.
    me->set_report_name( i_report_name ).
  ENDMETHOD.                    "constructor

  METHOD get_source.
    return = me->t_source.
  ENDMETHOD.                    "get_source

  METHOD add_source.
    APPEND i_line TO me->t_source.
  ENDMETHOD.                    "add_source

  METHOD check_syntax.
    DATA: t_program TYPE salv_wd_t_string,
          l_error   TYPE string,
          l_line    TYPE i,
          l_word    TYPE string.

    IF i_source IS INITIAL.
      t_program = me->t_source.
    ELSE.
      t_program = i_source.
    ENDIF.

    SYNTAX-CHECK FOR t_program MESSAGE l_error LINE l_line WORD l_word. "#EC *

    IF sy-subrc = 4.
      RAISE EXCEPTION TYPE lcx_error_query_check EXPORTING i_message = l_error.
    ENDIF.

  ENDMETHOD.                    "check_syntax

  METHOD add_report_name.
    DATA: l_report TYPE string.
    CONCATENATE 'REPORT ' me->v_report_name '.' INTO l_report RESPECTING BLANKS.
    me->add_source( l_report ).
  ENDMETHOD.                    "add_report_name

  METHOD generate_report.
    DATA: BEGIN OF syn_msg,
                   l1(72),
                   l2(72),
                   l3(72),
          END OF syn_msg.
    DATA: syn_lin TYPE i, syn_wrd(30).                      "#EC NEEDED
    DATA: l_report TYPE progname,
          l_message TYPE string.

    l_report = return = me->v_report_name.

    INSERT REPORT l_report FROM me->t_source.
*    GENERATE REPORT me->t_source
*    GENERATE SUBROUTINE POOL me->t_source
*                        NAME return
*                     MESSAGE syn_msg
*                        LINE syn_lin
*                        WORD syn_wrd.

    IF NOT sy-subrc IS INITIAL.
      CONCATENATE syn_msg-l1 syn_msg-l2 syn_msg-l3 INTO l_message SEPARATED BY space.
      CONDENSE l_message.
      RAISE EXCEPTION TYPE lcx_error_query_check EXPORTING i_message = l_message.
    ENDIF.

  ENDMETHOD.                    "generate_subroutine

  METHOD execute_report.
    PERFORM (i_form_name) IN PROGRAM (i_report_name).
  ENDMETHOD.                    "execute_subroutine

  METHOD delete_comments.
    DATA: t_text TYPE salv_wd_t_string,
          l_offset TYPE sy-fdpos.
    FIELD-SYMBOLS <fs_text> TYPE string.

    t_text = i_text.
    DELETE t_text WHERE table_line IS INITIAL.
    LOOP AT t_text ASSIGNING <fs_text>.
      IF <fs_text>(1) = lcl_commands=>asterisk.
        DELETE t_text.
      ELSE.
        FIND '"' IN <fs_text> MATCH OFFSET l_offset.
        IF sy-subrc IS INITIAL.
          <fs_text> = <fs_text>(l_offset).
        ENDIF.
      ENDIF.
    ENDLOOP.

    i_text = t_text.

  ENDMETHOD.                    "delete_comments

  METHOD compute_apostrophes.
    DATA: l_on     TYPE boolean,
          l_length TYPE i,
          l_index  TYPE i.

    l_length = STRLEN( i_text ).

    DO l_length TIMES.
      l_index = sy-index - 1.

      IF i_text+l_index(1) CA cl_abap_char_utilities=>get_simple_spaces_for_cur_cp( )  AND
         l_on = abap_true.
        ADD 1 TO l_index.
        IF i_text+l_index(1) = ''''.
          CONTINUE.
        ENDIF.

      ELSEIF i_text+l_index(1) = '''' AND l_on = abap_false.
        l_on = abap_true.

      ELSEIF i_text+l_index(1) = '''' AND l_on = abap_true.
        l_on = abap_false.
      ENDIF.

      CONCATENATE return i_text+l_index(1) INTO return RESPECTING BLANKS.
    ENDDO.

  ENDMETHOD.                    "compute_apostrophes

  METHOD delete_report.
    DATA: l_report TYPE progname.
    l_report = i_report_name.
    DELETE REPORT l_report.
  ENDMETHOD.                    "delete_report

ENDCLASS.                    "lcl_report IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_fieldcat IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_fieldcat IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_fieldcat.
    me->t_fieldcat = i_fieldcat.
  ENDMETHOD.                    "set_fieldcat
  METHOD get_fieldcat.
    return = me->t_fieldcat.
  ENDMETHOD.                    "get_fieldcat
  "$. Endregion Getters and Setters

  METHOD constructor.
    me->set_fieldcat( i_fieldcat ).
  ENDMETHOD.                    "constructor

  METHOD add_field_to_fcat.
    IF NOT i_fieldcat_tab IS INITIAL.
      APPEND LINES OF i_fieldcat_tab TO me->t_fieldcat.
    ELSEIF NOT i_fieldcat IS INITIAL.
      APPEND i_fieldcat TO me->t_fieldcat.
    ELSE.
      FIELD-SYMBOLS <fs_fcat> TYPE lvc_s_fcat.
      APPEND INITIAL LINE TO me->t_fieldcat ASSIGNING <fs_fcat>.
      <fs_fcat>-fieldname  = i_fieldname.
      <fs_fcat>-scrtext_s = <fs_fcat>-scrtext_m = <fs_fcat>-scrtext_l = i_scrtext.
      <fs_fcat>-coltext    = i_descr.
      <fs_fcat>-edit       = i_edit.
      <fs_fcat>-outputlen  = i_outputlen.
      <fs_fcat>-inttype    = i_inttype.
      <fs_fcat>-intlen     = i_intlen.
      <fs_fcat>-drdn_hndl  = i_drop_down.
      <fs_fcat>-drdn_alias = i_drop_alias.
      <fs_fcat>-drdn_field = i_drdn_field.
      <fs_fcat>-checkbox   = i_checkbox.
      <fs_fcat>-icon       = i_icon.
      <fs_fcat>-hotspot    = i_hotspot.
      <fs_fcat>-just       = i_just.
      <fs_fcat>-f4availabl = i_f4_avaliable.
      <fs_fcat>-checktable = i_checktable.
      UNASSIGN <fs_fcat>.
    ENDIF.
  ENDMETHOD.                    "add_field_to_fcat

  METHOD merge_fieldcat.
    DATA: t_fcat TYPE lvc_t_fcat,
          l_name TYPE dd02l-tabname.

    FIELD-SYMBOLS <fs_fcat> TYPE lvc_s_fcat.

    l_name = i_table->get_name( ).

    CALL FUNCTION 'LVC_FIELDCATALOG_MERGE'
      EXPORTING
        i_buffer_active        = abap_false
        i_structure_name       = l_name
        i_bypassing_buffer     = abap_true
      CHANGING
        ct_fieldcat            = t_fcat
      EXCEPTIONS
        inconsistent_interface = 1
        program_error          = 2
        OTHERS                 = 3.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE lcx_no_fieldcat.
    ENDIF.

    LOOP AT t_fcat ASSIGNING <fs_fcat>.
      <fs_fcat>-no_out = <fs_fcat>-tech = abap_false.
      <fs_fcat>-ref_field = <fs_fcat>-fieldname.
      <fs_fcat>-no_convext = i_no_conversion.
    ENDLOOP.

    return = t_fcat.
  ENDMETHOD.                    "merge_fieldcat_by_struct_name

  METHOD inverse_fieldcat_names.

    DATA: t_fcat TYPE lvc_t_fcat.
    FIELD-SYMBOLS <fs_fcat> TYPE lvc_s_fcat.

    i_alv->get_frontend_fieldcatalog( IMPORTING et_fieldcatalog = t_fcat ).

    LOOP AT t_fcat ASSIGNING <fs_fcat>.
      IF <fs_fcat>-coltext IS INITIAL.
        <fs_fcat>-coltext = <fs_fcat>-fieldname.
      ELSE.
        CLEAR <fs_fcat>-coltext.
      ENDIF.
    ENDLOOP.

    i_alv->set_frontend_fieldcatalog( t_fcat ).
    i_alv->refresh_table_display( ).
    return = t_fcat.
  ENDMETHOD.                    "inverse_fieldcat_names

  METHOD no_routine_conversion.

    DATA: t_fcat TYPE lvc_t_fcat.
    FIELD-SYMBOLS <fs_fcat> TYPE lvc_s_fcat.

    i_alv->get_frontend_fieldcatalog( IMPORTING et_fieldcatalog = t_fcat ).

    LOOP AT t_fcat ASSIGNING <fs_fcat>.
      IF <fs_fcat>-no_convext = abap_true.
        CLEAR <fs_fcat>-no_convext.
      ELSE.
        <fs_fcat>-no_convext = abap_true.
      ENDIF.
    ENDLOOP.

*    i_alv->set_frontend_fieldcatalog( t_fcat ).
*    i_alv->refresh_table_display( ).
    return = t_fcat.
  ENDMETHOD.                    "no_routine_conversion

  METHOD compute_fieldcat_to_fields.
    DATA: o_table      TYPE REF TO lcl_table,
          t_fields     TYPE TABLE OF REF TO lcl_field,
          t_fcat       TYPE lvc_t_fcat,

          wa_fcat      TYPE lvc_s_fcat,

          l_table_name TYPE string,
          l_name       TYPE string,
          l_descr      TYPE string.

    FIELD-SYMBOLS: <fs_field> TYPE REF TO lcl_field,
                   <fs_fcat>  TYPE lvc_s_fcat.

    i_select->get_fields( IMPORTING return = t_fields ).
    t_fcat = me->get_fieldcat( ). CLEAR me->t_fieldcat.

    LOOP AT t_fields ASSIGNING <fs_field>.
      CLEAR: wa_fcat, l_name, l_table_name.
      l_name       = <fs_field>->get_field_name( ).
      l_table_name = <fs_field>->get_table_name( ).

      IF <fs_field>->get_count_field( ) = abap_true.
        IF <fs_field>->get_field_name( ) = lcl_commands=>asterisk.
          me->add_field_to_fcat( i_fieldname  = 'COUNT'
                                 i_scrtext    = 'Count'
                                 i_inttype    = 'I' ).
        ELSE.
          TRY.
              wa_fcat = me->get_fieldcat_struct( i_field_name = l_name
                                                 i_table_name = l_table_name
                                                 i_from       = i_from
                                                 i_fieldcat   = t_fcat ).

              CONCATENATE 'COUNT' wa_fcat-fieldname INTO l_name SEPARATED BY '_'.
              l_descr = wa_fcat-scrtext_l.
              me->add_field_to_fcat( i_fieldname  = l_name
                                     i_scrtext    = l_descr
                                     i_inttype    = 'I' ).
            CATCH lcx_table_not_found.                   "#EC NO_HANDLE
          ENDTRY.

        ENDIF.

      ELSEIF <fs_field>->get_field_name( ) = lcl_commands=>asterisk.
        me->add_field_to_fcat( t_fcat ).

      ELSE.
        wa_fcat = me->get_fieldcat_struct( i_field_name = l_name
                                           i_table_name = l_table_name
                                           i_from       = i_from
                                           i_fieldcat   = t_fcat ).
        me->add_field_to_fcat( i_fieldcat = wa_fcat ).

      ENDIF.

    ENDLOOP.

    me->adjust_column_positions( ).

  ENDMETHOD.                    "compute_fieldcat_to_fields

  METHOD get_fieldcat_struct.
    DATA: o_table TYPE REF TO lcl_table,
          l_table TYPE string.
    IF NOT i_table_name IS INITIAL.
      o_table = i_from->get_table( i_table = i_table_name ).
      l_table = o_table->get_name( ).
      READ TABLE i_fieldcat INTO return WITH KEY fieldname = i_field_name
                                                 ref_table = l_table.
    ELSE.
      READ TABLE i_fieldcat INTO return WITH KEY fieldname = i_field_name.
    ENDIF.
  ENDMETHOD.                    "get_fieldcat_struct

  METHOD adjust_column_positions.
    FIELD-SYMBOLS <fs_fcat> TYPE lvc_s_fcat.
    LOOP AT me->t_fieldcat ASSIGNING <fs_fcat>.
      <fs_fcat>-col_pos = sy-tabix.
    ENDLOOP.
  ENDMETHOD.                    "adjust_column_positions

  METHOD get_fieldcat_count_fields.
    DESCRIBE TABLE me->t_fieldcat LINES return.
  ENDMETHOD.                    "get_fieldcat_count_fields

ENDCLASS.                    "lcl_fieldcat IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_screen_600 IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_screen_600 IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_tabname.
    v_tabname = i_tabname.
  ENDMETHOD.                    "set_tabname
  METHOD get_tabname.
    return = v_tabname.
  ENDMETHOD.                    "get_tabname

  METHOD set_tabalias.
    v_tabalias = i_tabalias.
  ENDMETHOD.                    "set_tabalias
  METHOD get_tabalias.
    return = v_tabalias.
  ENDMETHOD.                    "get_tabalias

  METHOD set_tabdescr.
    v_tabdescr = i_descr.
  ENDMETHOD.                    "set_tabdescr
  METHOD get_tabdescr.
    return = v_tabdescr.
  ENDMETHOD.                    "get_tabdescr

  METHOD set_join_tables.
    me->t_join_tables = i_join_tables.
  ENDMETHOD.                    "set_join_tables
  METHOD get_join_tables.
    FIELD-SYMBOLS <fs_join_table> TYPE ty_join_table.
    INSERT INITIAL LINE INTO me->t_join_tables ASSIGNING <fs_join_table> INDEX 1.
    <fs_join_table>-tabname = me->get_tabname( ).
    <fs_join_table>-alias   = me->get_tabalias( ).
    UNASSIGN <fs_join_table>.
    e_join_tables = me->t_join_tables.
  ENDMETHOD.                    "get_join_tables

  METHOD get_create_select.
    return = v_create_select.
  ENDMETHOD.                    "get_create_select
  METHOD get_create_where.
    return = v_create_where.
  ENDMETHOD.                    "get_create_where

  METHOD set_block_flags.
    me->v_block_flags = i_block.
  ENDMETHOD.                    "set_block_flags
  METHOD get_block_flags.
    return = me->v_block_flags.
  ENDMETHOD.                    "get_block_flags

  METHOD set_direct_initialize.
    me->v_direct_initialize = i_direct_initialize.
  ENDMETHOD.                    "set_direct_initialize
  "$. Endregion Getters and Setters

  METHOD lif_screen~user_command.
    DATA: o_error   TYPE REF TO lcx_join_error,
          l_message TYPE string.

    TRY.
        super->user_command( i_ucomm ).
        CASE i_ucomm.
          WHEN c_tabname.
            me->check_table_name( ).
            me->initialize_join_grid( ).

          WHEN c_tabalias.
            me->check_table_alias( ).

          WHEN c_save.
            IF me->o_alv IS BOUND.
              me->o_alv->check_changed_data( ).
            ENDIF.
            me->check_join_tables( abap_true ).
            LEAVE TO SCREEN 0.

        ENDCASE.

      CATCH lcx_table_not_found.
        l_message = 'Table is unknown!'.
        lcl_message=>report_message( i_msg  = l_message
                                     i_type = 'E' ).

      CATCH lcx_table_alias.
        lcl_message=>report_message( i_msg  = 'Table alias invalid!'
                                     i_type = 'E' ).

      CATCH lcx_join_error INTO o_error.
        DATA: wa_row_id    TYPE lvc_s_row,
              wa_column_id TYPE lvc_s_col,
              wa_row_no    TYPE lvc_s_roid .
        l_message = o_error->get_message( ).
        wa_row_no-row_id = wa_row_id-index = o_error->get_index( ).
        wa_column_id-fieldname = o_error->get_field( ).
        me->o_alv->set_current_cell_via_id( is_row_id    = wa_row_id
                                            is_column_id = wa_column_id
                                            is_row_no    = wa_row_no ).
        lcl_message=>report_message( i_msg     = l_message
                                     i_type    = 'S'
                                     i_disp_as = 'E' ).
    ENDTRY.

  ENDMETHOD.                    "lif_screen~user_command

  METHOD lif_screen~initialize_screen.
    LOOP AT SCREEN.
      IF screen-name = 'V_CREATE_SELECT' OR screen-name = 'V_CREATE_WHERE'.
        IF me->get_block_flags( ) = abap_true.
          screen-input = 0.
        ELSE.
          screen-input = 1.
        ENDIF.
        MODIFY SCREEN.
      ENDIF.
    ENDLOOP.

    IF me->v_direct_initialize = abap_true AND me->o_container IS INITIAL.
      me->initialize_container( ).
      me->initialize_alv( ).
      CLEAR me->v_direct_initialize.
    ENDIF.

  ENDMETHOD.                    "lif_screen~initialize_screen

  METHOD lif_screen~screen_status.
    SET PF-STATUS 'PF_0600'.
  ENDMETHOD.                    "lif_screen~screen_status

  METHOD check_table_name.
    DATA: o_table   TYPE REF TO lcl_table,
          l_tabname TYPE string,
          l_descr   TYPE string.

    l_tabname = me->get_tabname( ).
    IF lcl_table=>check_table_name( l_tabname ) = abap_false.
      RAISE EXCEPTION TYPE lcx_table_not_found.
    ENDIF.

    me->flush( abap_true ).

    CREATE OBJECT o_table
      EXPORTING
        i_name = l_tabname.
    l_descr = o_table->get_description_from_ddic( ).
    me->set_tabname( l_tabname ).
    me->set_tabdescr( l_descr ).

  ENDMETHOD.                    "check_table_name

  METHOD check_table_alias.
    DATA: l_tabalias TYPE string.
    l_tabalias = me->get_tabalias( ).
    IF l_tabalias CO '0123456789 '.
      RAISE EXCEPTION TYPE lcx_table_alias.
    ENDIF.
  ENDMETHOD.                    "check_table_alias

  METHOD initialize_join_grid.
    IF me->o_container IS INITIAL.
      me->initialize_container( ).
      me->initialize_alv( ).
    ENDIF.
  ENDMETHOD.                    "initialize_join_grid

  METHOD initialize_container.
    CREATE OBJECT me->o_container
      EXPORTING
        container_name = 'CONTAINER_FROM'.
  ENDMETHOD.                    "initialize_container

  METHOD initialize_alv.
    DATA: t_exclude  TYPE ui_functions,
          t_fieldcat TYPE lvc_t_fcat,
          t_dropdown TYPE lvc_t_dral,
          t_f4       TYPE lvc_t_f4,

          wa_layout  TYPE lvc_s_layo.

    CREATE OBJECT me->o_alv
      EXPORTING
        i_parent = me->o_container.

    CREATE OBJECT me->o_handler.
    SET HANDLER: me->o_handler->handle_user_command_from_gen FOR me->o_alv,
                 me->o_handler->handle_toolbar_from_gen      FOR me->o_alv,
                 me->o_handler->handle_hotspot_from_gen      FOR me->o_alv,
                 me->o_handler->handle_f4_from_gen           FOR me->o_alv.

    t_exclude  = me->exclude_functions( ).
    t_fieldcat = me->get_fieldcat( ).
    t_dropdown = me->get_drop_down( ).
    t_f4       = me->get_f4_fields( ).
    wa_layout-stylefname = 'STYLE'.

    me->o_alv->set_ready_for_input( 1 ).
    me->o_alv->set_drop_down_table( it_drop_down_alias = t_dropdown ).
    me->o_alv->register_f4_for_fields( t_f4 ).

    me->o_alv->set_table_for_first_display( EXPORTING
                                              is_layout            = wa_layout
                                              it_toolbar_excluding = t_exclude
                                            CHANGING
                                              it_outtab            = me->t_join_tables
                                              it_fieldcatalog      = t_fieldcat ).
    me->o_alv->set_focus( me->o_container ).

  ENDMETHOD.                    "initialize_alv

  METHOD refresh_alv.
    me->o_alv->refresh_table_display( is_stable      = i_stable
                                      i_soft_refresh = i_soft_refresh ).
  ENDMETHOD.                    "refresh_alv

  METHOD add_option_to_drop_down.
    FIELD-SYMBOLS <fs_drop_down> TYPE lvc_s_dral.
    APPEND INITIAL LINE TO e_drop_down ASSIGNING <fs_drop_down>.
    <fs_drop_down>-handle    = i_handle.
    <fs_drop_down>-value     = i_value.
    <fs_drop_down>-int_value = i_int_value.
    UNASSIGN <fs_drop_down>.
  ENDMETHOD.                    "add_option_to_drop_down

  METHOD get_drop_down.
    me->add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=>join
                                   i_int_value = lcl_commands=>join
                                 CHANGING
                                   e_drop_down = return ).

    me->add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=>inner_join_command
                                   i_int_value = lcl_commands=>inner_join_command
                                 CHANGING
                                   e_drop_down = return ).

    me->add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=>outer_join_command
                                   i_int_value = lcl_commands=>outer_join_command
                                 CHANGING
                                   e_drop_down = return ).

    me->add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=>left_join_command
                                   i_int_value = lcl_commands=>left_join_command
                                 CHANGING
                                   e_drop_down = return ).

    me->add_option_to_drop_down( EXPORTING
                                   i_handle    = 1
                                   i_value     = lcl_commands=>right_join_command
                                   i_int_value = lcl_commands=>right_join_command
                                 CHANGING
                                   e_drop_down = return ).
  ENDMETHOD.                    "get_drop_down

  METHOD get_fieldcat.
    DATA: o_fieldcat TYPE REF TO lcl_fieldcat.
    CREATE OBJECT o_fieldcat.
    o_fieldcat->add_field_to_fcat( i_fieldname    = 'TABNAME'
                                   i_edit         = abap_true
                                   i_descr        = 'Table Name'
                                   i_f4_avaliable = abap_true
                                   i_outputlen    = 20 ).

    o_fieldcat->add_field_to_fcat( i_fieldname  = 'ALIAS'
                                   i_edit       = abap_true
                                   i_descr      = 'Table Alias'
                                   i_outputlen  = 10 ).

    o_fieldcat->add_field_to_fcat( i_fieldname  = 'JOIN_KIND'
                                   i_edit       = abap_true
                                   i_descr      = 'Kind of Join'
                                   i_outputlen  = 20
                                   i_drop_down  = 1
                                   i_drop_alias = abap_true ).

    o_fieldcat->add_field_to_fcat( i_fieldname  = 'ICON'
                                   i_edit       = abap_false
                                   i_descr      = 'Join Fields'
                                   i_outputlen  = 11
                                   i_icon       = abap_true
                                   i_hotspot    = abap_true ).

    return = o_fieldcat->get_fieldcat( ).
  ENDMETHOD.                    "get_fieldcat

  METHOD flush.
    IF NOT me->o_container IS INITIAL.
      me->o_alv->free( ).
      me->o_container->free( ).
    ENDIF.

    CLEAR: v_tabname, v_tabdescr, me->o_container, me->o_alv, me->t_join_tables.

    IF i_no_flags = abap_false.
      CLEAR: v_create_select, v_create_where, v_tabalias.
    ENDIF.

  ENDMETHOD.                    "flush

  METHOD exclude_functions.
    DATA ls_exclude TYPE ui_func.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_delete_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_append_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_insert_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_move_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_cut.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste_new_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_undo.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_print.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_graph.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_info.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_refresh.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_view.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_check.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_views.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_export.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_subtot.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_sum.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_variant.
    APPEND ls_exclude TO return.
  ENDMETHOD.                    "exclude_functions

  METHOD add_line.
    FIELD-SYMBOLS <fs_join_table> TYPE ty_join_table.
    APPEND INITIAL LINE TO me->t_join_tables ASSIGNING <fs_join_table>.
    <fs_join_table>-icon = icon_enter_more.
    UNASSIGN <fs_join_table>.
  ENDMETHOD.                    "add_line

  METHOD delete_line.
    DATA: t_index_rows  TYPE lvc_t_row,
          t_aux         TYPE tyt_join_table,
          l_answer      TYPE c.

    FIELD-SYMBOLS: <fs_index_row> TYPE lvc_s_row,
                   <fs_aux>       TYPE ty_join_table.

    me->o_alv->get_selected_rows( IMPORTING et_index_rows	= t_index_rows ).
    IF t_index_rows IS INITIAL.
      RAISE EXCEPTION TYPE lcx_no_fields_selected.
    ENDIF.

    l_answer = lcl_message=>user_choice( i_title    = 'Delete join tables'
                                         i_question = 'Delete selected lines?'
                                         i_option_1 = 'Yes'
                                         i_option_2 = 'No'
                                         i_icon     = '@M_QUES@' ).
    CHECK l_answer = '1'.

    LOOP AT t_index_rows ASSIGNING <fs_index_row>.
      READ TABLE me->t_join_tables ASSIGNING <fs_aux> INDEX <fs_index_row>-index.
      IF sy-subrc IS INITIAL.
        APPEND <fs_aux> TO t_aux.
      ENDIF.
    ENDLOOP.

    LOOP AT t_aux ASSIGNING <fs_aux>.
      DELETE me->t_join_tables WHERE tabname = <fs_aux>-tabname.
    ENDLOOP.

  ENDMETHOD.                    "delete_line

  METHOD suggest_join.
    DATA: t_tables TYPE dd05mttyp,
          l_tabname TYPE string.

    IF NOT me->t_join_tables IS INITIAL.
      DATA: l_answer TYPE c.
      l_answer = lcl_message=>user_choice( i_question = 'Are you sure you want a suggested join?'
                                           i_option_1 = 'Yes'
                                           i_option_2 = 'No' ).
      IF l_answer <> '1'.
        RETURN.
      ENDIF.
    ENDIF.

    CLEAR me->t_join_tables.
    l_tabname = me->get_tabname( ).
    t_tables = me->get_related_tables( l_tabname ).
    me->compute_related_tables( t_tables ).

  ENDMETHOD.                    "suggest_join

  METHOD get_related_tables.
    DATA: l_name TYPE dcobjdef-name.
    l_name = i_tabname.
    CALL FUNCTION 'DD_FKEYS_GET'
      EXPORTING
        name           = l_name
        langu          = sy-langu
      TABLES
        dd05m_tab      = return
      EXCEPTIONS
        illegal_input  = 1
        not_found      = 2
        expand_failure = 3
        OTHERS         = 4.
  ENDMETHOD.                    "get_related_tables

  METHOD compute_related_tables.
    DATA: t_aux         TYPE dd05mttyp,
          t_join_fields TYPE dd05mttyp,
          o_join_fields TYPE REF TO lcl_join_fields,
          wa_table      TYPE dd05m.

    FIELD-SYMBOLS: <fs_table>      TYPE dd05m,
                   <fs_aux>        TYPE dd05m,
                   <fs_join_field> TYPE dd05m,
                   <fs_join_table> TYPE ty_join_table.

    t_aux = i_tables.

    SORT t_aux BY checktable.
    DELETE ADJACENT DUPLICATES FROM t_aux COMPARING checktable.

    LOOP AT t_aux ASSIGNING <fs_aux>.
      CLEAR o_join_fields.
      CREATE OBJECT o_join_fields.
      LOOP AT i_tables ASSIGNING <fs_table> WHERE checktable = <fs_aux>-checktable.
        o_join_fields->add_join_field( i_fortable   = <fs_table>-checktable
                                       i_forkey     = <fs_table>-checkfield
                                       i_checktable = <fs_table>-fortable
                                       i_checkfield = <fs_table>-forkey ).
      ENDLOOP.

      APPEND INITIAL LINE TO me->t_join_tables ASSIGNING <fs_join_table>.
      <fs_join_table>-tabname     = <fs_aux>-checktable.
      <fs_join_table>-join_kind   = lcl_commands=>inner_join_command.
      <fs_join_table>-icon        = icon_display_more.
      <fs_join_table>-join_fields = o_join_fields.
      <fs_join_table>-style       = me->get_block_style_for_join_table( ).
      UNASSIGN <fs_join_table>.
    ENDLOOP.

  ENDMETHOD.                    "compute_related_tables

  METHOD get_block_style_for_join_table.
    me->add_style( EXPORTING
                     i_fieldname = 'TABNAME'
                     i_style = cl_gui_alv_grid=>mc_style_disabled
                   CHANGING
                     e_style = return ).
  ENDMETHOD.                    "get_block_style_for_join_table

  METHOD add_style.
    DATA: wa_style TYPE lvc_s_styl.
    wa_style-fieldname = i_fieldname.
    wa_style-style     = i_style.
    APPEND wa_style TO e_style.
  ENDMETHOD.                    "add_style

  METHOD open_join_fields.
    DATA: o_screen     TYPE REF TO lcl_screen_700,
          o_error      TYPE REF TO lcx_join_error,
          l_index      TYPE i,
          l_join_table TYPE string,
          t_tables     TYPE salv_wd_t_string.

    FIELD-SYMBOLS <fs_join_table> TYPE ty_join_table.

    me->o_alv->check_changed_data( ).
    l_index = i_index.

    TRY.
        me->check_join_tables( ).

        READ TABLE me->t_join_tables ASSIGNING <fs_join_table> INDEX i_index.
        IF sy-subrc IS INITIAL.
          l_join_table = <fs_join_table>-tabname.
          t_tables = me->get_tables( ).

          o_screen ?= lcl_screen=>get_instance( 700 ).
          o_screen->flush( ).
          o_screen->set_join_table( l_join_table ).
          o_screen->consist_tables( t_tables ).
          o_screen->set_join_fields( <fs_join_table>-join_fields ).
          o_screen->show( i_first_col = 20
                          i_first_row = 5
                          i_last_col  = 115
                          i_last_row  = 15 ).

          CHECK o_screen->get_exit_command( ) = abap_false.
          <fs_join_table>-join_fields = o_screen->get_join_fields( ).
          IF <fs_join_table>-join_fields IS BOUND.
            <fs_join_table>-icon = icon_display_more.
          ELSE.
            <fs_join_table>-icon = icon_enter_more.
          ENDIF.

          DATA: wa_stable TYPE lvc_s_stbl.
          wa_stable-col = abap_true. wa_stable-row = abap_true.
          me->refresh_alv( i_stable       = wa_stable
                           i_soft_refresh = abap_true ).

        ENDIF.

      CATCH lcx_join_error INTO o_error.
        DATA: l_message    TYPE string,
              wa_row_id    TYPE lvc_s_row,
              wa_column_id TYPE lvc_s_col,
              wa_row_no    TYPE lvc_s_roid .
        l_message = o_error->get_message( ).
        wa_row_no-row_id = wa_row_id-index = o_error->get_index( ).
        wa_column_id-fieldname = o_error->get_field( ).
        me->o_alv->set_current_cell_via_id( is_row_id    = wa_row_id
                                            is_column_id = wa_column_id
                                            is_row_no    = wa_row_no ).
        lcl_message=>report_message( i_msg     = l_message
                                     i_type    = 'S'
                                     i_disp_as = 'E' ).
    ENDTRY.

  ENDMETHOD.                    "open_join_fields

  METHOD search_help_for_tabname.
    DATA: t_return_tab TYPE TABLE OF ddshretval,
          wa_stable	      TYPE lvc_s_stbl.
    FIELD-SYMBOLS: <fs_return> TYPE ddshretval,
                   <fs_join_table> TYPE ty_join_table.

    CALL FUNCTION 'F4IF_FIELD_VALUE_REQUEST'
      EXPORTING
        tabname           = space
        fieldname         = space
        searchhelp        = 'DD_DBTB_16'
        shlpparam         = 'TABNAME'
      TABLES
        return_tab        = t_return_tab
      EXCEPTIONS
        field_not_found   = 1
        no_help_for_field = 2
        inconsistent_help = 3
        no_values_found   = 4
        OTHERS            = 5.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.

    READ TABLE t_return_tab ASSIGNING <fs_return> INDEX 1.
    IF sy-subrc IS INITIAL.
      READ TABLE me->t_join_tables ASSIGNING <fs_join_table> INDEX i_index.
      IF sy-subrc IS INITIAL.
        <fs_join_table>-tabname = <fs_return>-fieldval.

        wa_stable-row = abap_true. wa_stable-col = abap_true.
        me->refresh_alv( i_stable       = wa_stable
                         i_soft_refresh = abap_true ).

      ENDIF.
    ENDIF.

  ENDMETHOD.                    "search_help_for_tabname

  METHOD get_f4_fields.
    DATA: wa_f4 TYPE lvc_s_f4.
    wa_f4-fieldname = 'TABNAME'.
    wa_f4-register  = abap_true.
    APPEND wa_f4 TO return.
  ENDMETHOD.                    "get_f4_fields

  METHOD check_join_tables.
    FIELD-SYMBOLS <fs_join_table> TYPE ty_join_table.
    IF NOT i_index IS INITIAL.
      READ TABLE me->t_join_tables ASSIGNING <fs_join_table> INDEX i_index.
      IF sy-subrc IS INITIAL.
        me->consist_join_table( i_join_table          = <fs_join_table>
                                i_index               = i_index
                                i_consist_join_fields = i_consist_join_fields ).
      ENDIF.
    ELSE.
      LOOP AT me->t_join_tables ASSIGNING <fs_join_table>.
        me->consist_join_table( i_join_table          = <fs_join_table>
                                i_index               = sy-tabix
                                i_consist_join_fields = i_consist_join_fields ).
      ENDLOOP.
    ENDIF.
  ENDMETHOD.                    "check_join_tables

  METHOD consist_join_table.
    DATA: l_message TYPE string,
          l_field   TYPE string.

    IF i_join_table-tabname IS INITIAL.
      l_message = 'Table name is required.'. l_field = 'TABNAME'.

    ELSEIF lcl_table=>check_table_name( i_join_table-tabname ) = abap_false.
      CONCATENATE 'Table' i_join_table-tabname 'is unknown.' INTO l_message SEPARATED BY space.
      l_field = 'TABNAME'.

    ELSEIF i_join_table-join_kind IS INITIAL.
      l_message = 'Kind of join is required.'.
      l_field = 'JOIN_KIND'.

    ELSEIF NOT i_join_table-alias IS INITIAL AND i_join_table-alias CO '0123456789 '.
      l_message = 'Table alias can not contain only numbers.'.
      l_field = 'ALIAS'.

    ELSEIF i_consist_join_fields = abap_true AND NOT i_join_table-join_fields IS BOUND.
      l_message = 'Join Fields is required.'.
      l_field = 'JOIN_FIELDS'.

    ENDIF.

    IF NOT l_message IS INITIAL.
      CONDENSE l_message.
      RAISE EXCEPTION TYPE lcx_join_error
        EXPORTING
          i_message = l_message
          i_field   = l_field
          i_index   = i_index.
    ENDIF.

  ENDMETHOD.                    "consist_join_table

  METHOD get_tables.
    FIELD-SYMBOLS <fs_join_table> TYPE ty_join_table.

    APPEND v_tabname TO return.

    LOOP AT me->t_join_tables ASSIGNING <fs_join_table>.
      APPEND <fs_join_table>-tabname TO return.
    ENDLOOP.

  ENDMETHOD.                    "get_tables

  METHOD build_join_tables.
    DATA: t_tables      TYPE TABLE OF REF TO lcl_table,
          t_join_tables TYPE tyt_join_table,
          t_join_fields TYPE tyt_join_fields,
          l_tabname     TYPE string,
          l_alias       TYPE string.

    FIELD-SYMBOLS: <fs_table> TYPE REF TO lcl_table,
                   <fs_join_table> TYPE ty_join_table.

    i_from->get_tables( IMPORTING e_tables = t_tables ).

    LOOP AT t_tables ASSIGNING <fs_table>.

      l_tabname = <fs_table>->get_name( ).
      l_alias = <fs_table>->get_alias( ).

      IF sy-tabix = 1. "FROM Table
        me->set_tabname( l_tabname ).
        me->set_tabalias( l_alias ).

      ELSE. "Join Tables
        APPEND INITIAL LINE TO t_join_tables ASSIGNING <fs_join_table>.
        <fs_join_table>-tabname     = <fs_table>->get_name( ).
        <fs_join_table>-alias       = <fs_table>->get_alias( ).
        <fs_join_table>-join_kind   = <fs_table>->get_join_kind( ).
        <fs_join_table>-icon        = icon_display_more.

        CREATE OBJECT <fs_join_table>-join_fields.
        <fs_table>->get_join_fields( IMPORTING e_join_fields = t_join_fields ).
        <fs_join_table>-join_fields->set_join_fields( t_join_fields ).
        <fs_join_table>-style = me->get_block_style_for_join_table( ).
        UNASSIGN <fs_join_table>.

      ENDIF.

    ENDLOOP.

    me->set_join_tables( t_join_tables ).

  ENDMETHOD.                    "build_join_tables

ENDCLASS.                    "lcl_screen_600 IMPLEMENTATION

*----------------------------------------------------------------------*
*       CLASS lcl_from_generator IMPLEMENTATION
*----------------------------------------------------------------------*
*
*----------------------------------------------------------------------*
CLASS lcl_from_generator IMPLEMENTATION.

  METHOD generate.
    DATA: o_query          TYPE REF TO lcl_query,
          o_from           TYPE REF TO lcl_from,
          o_generator      TYPE REF TO lcl_query_element_generator,
          t_join_tables    TYPE tyt_join_table,
          t_select_command TYPE salv_wd_t_string,
          t_from_command   TYPE salv_wd_t_string,
          t_where_command  TYPE salv_wd_t_string.

    me->select_join_tables( IMPORTING e_join_tables = t_join_tables ).
    return = me->compute_join_tables( t_join_tables ).

    CREATE OBJECT o_query
      EXPORTING
        i_query = return.
    o_from ?= o_query->identify_query_elements( lcl_commands=>from ).

    IF me->v_gen_select = abap_true.
      CREATE OBJECT o_generator
        TYPE
          lcl_select_generator
        EXPORTING
          i_element            = o_from.
      TRY.
          t_select_command = o_generator->generate( ).
          return = o_generator->generate_new_query_text( i_query        = return
                                                         i_command_text = t_select_command ).
        CATCH cx_dynamic_check.                          "#EC NO_HANDLE
      ENDTRY.

    ENDIF.

    IF me->v_gen_where = abap_true.
      TRY .
          CREATE OBJECT o_generator
            TYPE
              lcl_where_generator
            EXPORTING
              i_element           = o_from.
          t_where_command = o_generator->generate( ).
          return = o_generator->generate_new_query_text( i_query        = return
                                                         i_command_text = t_where_command ).
        CATCH cx_dynamic_check.                          "#EC NO_HANDLE
      ENDTRY.

    ENDIF.
  ENDMETHOD.                    "generate

  METHOD generate_new_query_text.
    DATA: t_text        TYPE salv_wd_t_string,
          t_select      TYPE salv_wd_t_string,
          t_where       TYPE salv_wd_t_string,
          t_split       TYPE TABLE OF string,
          l_find        TYPE boolean,
          l_string      TYPE string,
          l_result      TYPE string,
          l_garbage     TYPE string,
          l_split       TYPE boolean,
          l_command     TYPE string,
          l_index       TYPE i.

    IF i_query IS INITIAL.
      APPEND LINES OF i_command_text TO return.

    ELSE.

      t_text = i_query.

      CLEAR: l_string, l_result.
      LOOP AT t_text INTO l_string.
        TRANSLATE l_string TO UPPER CASE.
        IF l_find = abap_false.
          CLEAR t_split.
          SPLIT l_string AT space INTO TABLE t_split.
          FIND lcl_commands=>from IN TABLE t_split.
          IF sy-subrc IS INITIAL.
            SPLIT l_string AT lcl_commands=>from INTO l_result l_garbage.
            APPEND l_result TO t_select.
            EXIT.
          ELSE.
            APPEND l_string TO t_select.
          ENDIF.
        ENDIF.
      ENDLOOP.

      LOOP AT t_text INTO l_string.
        TRANSLATE l_string TO UPPER CASE.
        IF l_find = abap_false.
          CLEAR t_split.
          SPLIT l_string AT space INTO TABLE t_split.
          CASE 0.
            WHEN me->find_command( i_command = lcl_commands=>where  i_text = l_string ).
              l_find = abap_true.
              l_command = lcl_commands=>where.

            WHEN me->find_command( i_command = lcl_commands=>up     i_text = l_string ).
              l_find = abap_true.
              l_command = lcl_commands=>up.

            WHEN me->find_command( i_command = lcl_commands=>order  i_text = l_string ).
              l_find = abap_true.
              l_command = lcl_commands=>order.

            WHEN me->find_command( i_command = lcl_commands=>group  i_text = l_string ).
              l_find = abap_true.
              l_command = lcl_commands=>group.

            WHEN me->find_command( i_command = lcl_commands=>having i_text = l_string ).
              l_find = abap_true.
              l_command = lcl_commands=>having.

          ENDCASE.
        ENDIF.

        CHECK l_find = abap_true.

        SPLIT l_string AT l_command INTO l_result l_garbage.
        IF NOT l_garbage IS INITIAL.
          CONCATENATE l_command l_garbage INTO l_garbage SEPARATED BY space.
          CONDENSE l_garbage.
          APPEND l_garbage TO t_where.
        ELSE.
          IF NOT l_result IS INITIAL.
            CONDENSE l_result.
            APPEND l_result TO t_where.
          ELSE.
            APPEND l_command TO t_where.
          ENDIF.
        ENDIF.

      ENDLOOP.

      APPEND LINES OF t_select TO return.
      APPEND LINES OF i_command_text TO return.
      APPEND LINES OF t_where TO return.

    ENDIF.

  ENDMETHOD.                    "generate_new_query_text

  METHOD select_join_tables.
    DATA: o_screen TYPE REF TO lcl_screen_600,
          o_from   TYPE REF TO lcl_from.

    o_screen ?= lcl_screen=>get_instance( 600 ).
    o_screen->flush( ).

    o_from ?= me->get_query_element( ).
    IF o_from IS BOUND.
      o_screen->build_join_tables( o_from ).
      o_screen->set_block_flags( abap_true ).
      o_screen->set_direct_initialize( abap_true ).
    ELSE.
      o_screen->set_block_flags( abap_false ).
    ENDIF.

    o_screen->show( i_first_col = 10  i_first_row = 3
                    i_last_col  = 122 i_last_row  = 25 ).

    IF o_screen->get_exit_command( ) = abap_true.
      RAISE EXCEPTION TYPE lcx_cancel.
    ENDIF.

    me->v_gen_select = o_screen->get_create_select( ).
    me->v_gen_where  = o_screen->get_create_where( ).

    o_screen->get_join_tables( IMPORTING e_join_tables = e_join_tables ).

  ENDMETHOD.                    "select_join_tables

  METHOD compute_join_tables.
    DATA: o_join_fields TYPE REF TO lcl_join_fields,
          t_join_fields TYPE tyt_join_fields,
          t_aux         TYPE salv_wd_t_string,
          l_field_1     TYPE string,
          l_field_2     TYPE string,
          l_command     TYPE string.

    FIELD-SYMBOLS: <fs_join_table> TYPE ty_join_table,
                   <fs_aux>        TYPE ty_join_table,
                   <fs_join_field> TYPE ty_join_fields.

    READ TABLE i_join_tables ASSIGNING <fs_join_table> INDEX 1.
    IF sy-subrc IS INITIAL.
      CONCATENATE lcl_commands=>from <fs_join_table>-tabname INTO l_command SEPARATED BY space.
      IF NOT <fs_join_table>-alias IS INITIAL.
        CONCATENATE l_command lcl_commands=>as <fs_join_table>-alias INTO l_command SEPARATED BY space.
      ENDIF.
      CONDENSE l_command.
      APPEND l_command TO return.
    ENDIF.

    LOOP AT i_join_tables ASSIGNING <fs_join_table> FROM 2.
      CLEAR: l_command, t_join_fields.

      CONCATENATE <fs_join_table>-join_kind <fs_join_table>-tabname INTO l_command SEPARATED BY space.
      IF NOT <fs_join_table>-alias IS INITIAL.
        CONCATENATE l_command lcl_commands=>as <fs_join_table>-alias INTO l_command SEPARATED BY space.
      ENDIF.

      o_join_fields = <fs_join_table>-join_fields.
      o_join_fields->get_join_fields( IMPORTING e_join_fields = t_join_fields ).
      LOOP AT t_join_fields ASSIGNING <fs_join_field>.
        CLEAR: l_field_1, l_field_2.

        IF sy-tabix = 1.
          CONCATENATE l_command lcl_commands=>on INTO l_command SEPARATED BY space.
        ELSE.
          CONCATENATE l_command lcl_commands=>and INTO l_command SEPARATED BY space.
        ENDIF.

        READ TABLE i_join_tables ASSIGNING <fs_aux> WITH KEY tabname = <fs_join_field>-fortable.
        IF sy-subrc IS INITIAL.
          IF NOT <fs_aux>-alias IS INITIAL.
            CONCATENATE <fs_aux>-alias '~' <fs_join_field>-forkey INTO l_field_1 RESPECTING BLANKS.
          ELSE.
            CONCATENATE <fs_join_field>-fortable '~' <fs_join_field>-forkey INTO l_field_1 RESPECTING BLANKS.
          ENDIF.
        ENDIF.

        IF <fs_join_field>-checktable IS INITIAL.
          l_field_2 = <fs_join_field>-checkfield.
        ELSE.
          READ TABLE i_join_tables ASSIGNING <fs_aux> WITH KEY tabname = <fs_join_field>-checktable.
          IF sy-subrc IS INITIAL.
            IF NOT <fs_aux>-alias IS INITIAL.
              CONCATENATE <fs_aux>-alias '~' <fs_join_field>-checkfield INTO l_field_2 RESPECTING BLANKS.
            ELSE.
              CONCATENATE <fs_join_field>-checktable '~' <fs_join_field>-checkfield INTO l_field_2 RESPECTING BLANKS.
            ENDIF.
          ENDIF.
        ENDIF.
        CONDENSE: l_field_1 NO-GAPS,
                  l_field_2 NO-GAPS.

        CONCATENATE l_command l_field_1 <fs_join_field>-signal l_field_2 INTO l_command SEPARATED BY space.

      ENDLOOP.

      CONDENSE l_command.
      t_aux = lcl_query=>split_text( i_text      = l_command
                                     i_outputlen = 80 ).

      APPEND LINES OF t_aux TO return.

    ENDLOOP.

  ENDMETHOD.                    "compute_join_tables

ENDCLASS.                    "lcl_from_generator IMPLEMENTATION
*&---------------------------------------------------------------------*
*&       Class (Implementation)  lcl_screen_700
*&---------------------------------------------------------------------*
CLASS lcl_screen_700 IMPLEMENTATION.

  "$. Region Getters and Setters
  METHOD set_join_fields.
    IF i_join_fields IS BOUND.
      i_join_fields->get_join_fields( IMPORTING e_join_fields = me->t_join_fields ).
      me->compute_join_fields( ).
    ENDIF.
  ENDMETHOD.                    "set_join_fields
  METHOD get_join_fields.
    FIELD-SYMBOLS <fs_join_field> TYPE ty_join_fields.
    IF NOT me->t_join_fields IS INITIAL.
      CREATE OBJECT return.
      LOOP AT me->t_join_fields ASSIGNING <fs_join_field>.
        return->add_join_field( i_fortable   = <fs_join_field>-fortable
                                i_forkey     = <fs_join_field>-forkey
                                i_checktable = <fs_join_field>-checktable
                                i_checkfield = <fs_join_field>-checkfield ).
      ENDLOOP.
    ENDIF.
  ENDMETHOD.                    "get_join_fields

  METHOD set_join_table.
    me->v_join_table = i_table.
  ENDMETHOD.                    "set_join_table
  METHOD get_join_table.
    return = me->v_join_table.
  ENDMETHOD.                    "get_join_table
  "$. Endregion Getters and Setters

  METHOD compute_join_fields.
    DATA: l_tabname TYPE string.
    FIELD-SYMBOLS <fs_join_field> TYPE ty_join_fields.
    LOOP AT me->t_join_fields ASSIGNING <fs_join_field>.
      l_tabname = <fs_join_field>-fortable.
      <fs_join_field>-dd_handle_forkey = me->get_field_handle( l_tabname ).
      <fs_join_field>-dd_handle_checktable = 2.
      l_tabname = <fs_join_field>-checktable.
      <fs_join_field>-dd_handle_checkfield = me->get_field_handle( l_tabname ).
      <fs_join_field>-style = me->get_style_block_fields( ).
    ENDLOOP.
  ENDMETHOD.                    "compute_join_fields

  METHOD flush.
    IF NOT me->o_container IS INITIAL.
      me->o_grid->free( ).
      me->o_container->free( ).
    ENDIF.
    CLEAR: me->o_container, me->o_grid, me->t_join_fields, me->v_join_table,
           me->t_handle, me->t_drop_down.
  ENDMETHOD.                    "flush

  METHOD lif_screen~user_command.
    DATA: o_error TYPE REF TO lcx_join_error.

    CASE i_ucomm.
      WHEN c_enter.
        TRY.
            me->check_join_fields( ).
            LEAVE TO SCREEN 0.

          CATCH lcx_join_error INTO o_error.
            DATA: l_message    TYPE string,
                  wa_row_id    TYPE lvc_s_row,
                  wa_column_id TYPE lvc_s_col,
                  wa_row_no    TYPE lvc_s_roid .
            l_message = o_error->get_message( ).
            wa_row_no-row_id = wa_row_id-index = o_error->get_index( ).
            wa_column_id-fieldname = o_error->get_field( ).
            me->o_grid->set_current_cell_via_id( is_row_id    = wa_row_id
                                                is_column_id = wa_column_id
                                                is_row_no    = wa_row_no ).
            lcl_message=>report_message( i_msg     = l_message
                                         i_type    = 'S'
                                         i_disp_as = 'E' ).
        ENDTRY.


    ENDCASE.
  ENDMETHOD.                    "lif_screen~user_command

  METHOD lif_screen~screen_status.
    SET PF-STATUS 'PF_0700'.
  ENDMETHOD.                    "lif_screen~screen_status

  METHOD lif_screen~initialize_screen.
    IF me->o_container IS INITIAL.
      me->initialize_container( ).
      me->initialize_alv( ).

    ENDIF.
  ENDMETHOD.                    "lif_screen~initialize_screen

  METHOD initialize_container.
    CREATE OBJECT me->o_container
      EXPORTING
        container_name = 'CONTAINER_JOIN'.
  ENDMETHOD.                    "initialize_container

  METHOD initialize_alv.
    DATA: o_handler  TYPE REF TO lcl_event_handler,
          t_fieldcat TYPE lvc_t_fcat,
          t_exclude  TYPE ui_functions,
          t_drop_down TYPE lvc_t_drop,
          wa_layout  TYPE lvc_s_layo.

    CREATE OBJECT me->o_grid
      EXPORTING
        i_parent = me->o_container.

    t_fieldcat  = me->create_fieldcat( ).
    t_exclude   = me->exclude_functions( ).
    t_drop_down = me->t_drop_down.
    wa_layout-stylefname = 'STYLE'.

    CREATE OBJECT o_handler.
    SET HANDLER: o_handler->handle_toolbar_join      FOR me->o_grid,
                 o_handler->handle_user_command_join FOR me->o_grid,
                 o_handler->handle_data_change_join  FOR me->o_grid.

    me->o_grid->set_ready_for_input( 1 ).
    me->o_grid->set_drop_down_table( EXPORTING it_drop_down = t_drop_down ).
    me->o_grid->register_edit_event( cl_gui_alv_grid=>mc_evt_modified ).
    me->o_grid->set_table_for_first_display( EXPORTING
                                               is_layout            = wa_layout
                                               it_toolbar_excluding = t_exclude
                                             CHANGING
                                               it_fieldcatalog      = t_fieldcat
                                               it_outtab            = me->t_join_fields ).

  ENDMETHOD.                    "initialize_alv

  METHOD create_fieldcat.
    DATA: o_fieldcat TYPE REF TO lcl_fieldcat.

    CREATE OBJECT o_fieldcat.

    o_fieldcat->add_field_to_fcat( i_fieldname  = 'FORTABLE'
                                   i_edit       = abap_true
                                   i_descr      = 'Table Name'
                                   i_outputlen  = 20 ).

    o_fieldcat->add_field_to_fcat( i_fieldname  = 'FORKEY'
                                   i_edit       = abap_true
                                   i_descr      = 'Field Name'
                                   i_drdn_field = 'DD_HANDLE_FORKEY'
                                   i_checktable = '!'
                                   i_outputlen  = 20 ).

    o_fieldcat->add_field_to_fcat( i_fieldname  = 'SIGNAL'
                                   i_edit       = abap_false
                                   i_descr      = space
                                   i_just       = 'C'
                                   i_outputlen  = 2 ).

    o_fieldcat->add_field_to_fcat( i_fieldname  = 'CHECKTABLE'
                                   i_edit       = abap_true
                                   i_descr      = 'Table Name'
                                   i_drdn_field = 'DD_HANDLE_CHECKTABLE'
                                   i_checktable = '!'
                                   i_outputlen  = 20 ).

    o_fieldcat->add_field_to_fcat( i_fieldname  = 'CHECKFIELD'
                                   i_edit       = abap_true
                                   i_descr      = 'Field Name'
                                   i_drdn_field = 'DD_HANDLE_CHECKFIELD'
                                   i_checktable = '!'
                                   i_outputlen  = 20 ).

    return = o_fieldcat->get_fieldcat( ).

  ENDMETHOD.                    "create_fieldcat

  METHOD exclude_functions.
    DATA ls_exclude TYPE ui_func.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_delete_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_append_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_insert_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_move_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_copy.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_cut.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_paste_new_row.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_loc_undo.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_print.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_graph.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_info.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_refresh.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_view.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_check.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_fc_views.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_export.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_subtot.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_sum.
    APPEND ls_exclude TO return.
    ls_exclude = cl_gui_alv_grid=>mc_mb_variant.
    APPEND ls_exclude TO return.
  ENDMETHOD.                    "exclude_functions

  METHOD refresh_alv.
    me->o_grid->refresh_table_display( is_stable      = i_stable
                                       i_soft_refresh = i_soft_refresh ).
  ENDMETHOD.                    "refresh_alv

  METHOD add_line.
    DATA: l_tabname TYPE string.
    FIELD-SYMBOLS <fs_join_field> TYPE ty_join_fields.
    APPEND INITIAL LINE TO me->t_join_fields ASSIGNING <fs_join_field>.
    l_tabname = me->get_join_table( ).
    <fs_join_field>-fortable = l_tabname.
    <fs_join_field>-signal   = '='.
    <fs_join_field>-style    = me->get_style_block_fields( ).
    <fs_join_field>-dd_handle_forkey = me->get_field_handle( l_tabname ).
    <fs_join_field>-dd_handle_checktable = 2.
    UNASSIGN <fs_join_field>.
  ENDMETHOD.                    "add_line

  METHOD delete_line.
    DATA: t_index_rows  TYPE lvc_t_row,
          t_aux         TYPE tyt_join_fields,
          l_answer      TYPE c.

    FIELD-SYMBOLS: <fs_index_row> TYPE lvc_s_row,
                   <fs_aux>       TYPE ty_join_fields.

    me->o_grid->get_selected_rows( IMPORTING et_index_rows  = t_index_rows ).
    IF t_index_rows IS INITIAL.
      RAISE EXCEPTION TYPE lcx_no_fields_selected.
    ENDIF.

    l_answer = lcl_message=>user_choice( i_title    = 'Delete Join Fields'
                                         i_question = 'Delete selected lines?'
                                         i_option_1 = 'Yes'
                                         i_option_2 = 'No'
                                         i_icon     = '@M_QUES@' ).
    CHECK l_answer = '1'.

    LOOP AT t_index_rows ASSIGNING <fs_index_row>.
      READ TABLE me->t_join_fields ASSIGNING <fs_aux> INDEX <fs_index_row>-index.
      IF sy-subrc IS INITIAL.
        APPEND <fs_aux> TO t_aux.
      ENDIF.
    ENDLOOP.

    LOOP AT t_aux ASSIGNING <fs_aux>.
      READ TABLE me->t_join_fields WITH KEY fortable   = <fs_aux>-fortable
                                            forkey     = <fs_aux>-forkey
                                            checktable = <fs_aux>-checktable
                                            checkfield = <fs_aux>-checkfield TRANSPORTING NO FIELDS.
      IF sy-subrc IS INITIAL.
        DELETE me->t_join_fields INDEX sy-tabix.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.                    "delete_line

  METHOD get_style_block_fields.
    DATA: wa_style TYPE lvc_s_styl.
    wa_style-style = cl_gui_alv_grid=>mc_style_disabled.
    wa_style-fieldname = 'FORTABLE'.
    APPEND wa_style TO return.
    wa_style-fieldname = 'SIGNAL'.
    APPEND wa_style TO return.
  ENDMETHOD.                    "get_style_block_fields

  METHOD consist_tables.
    DATA: o_table        TYPE REF TO lcl_table,
          t_tables       TYPE salv_wd_t_string,
          t_fields       TYPE tyt_table_fields,
          l_tabname      TYPE string,
          l_field_handle TYPE i VALUE 2.

    FIELD-SYMBOLS <fs_field> TYPE ty_table_fields.

    t_tables = i_tables.
    l_tabname = me->get_join_table( ).

    LOOP AT t_tables INTO l_tabname.
      CHECK l_tabname <> me->get_join_table( ).
      me->add_dropdown( i_handle = 2
                        i_value  = l_tabname ).
    ENDLOOP.

    LOOP AT t_tables INTO l_tabname.
      CLEAR t_fields.
      CREATE OBJECT o_table
        EXPORTING
          i_name = l_tabname.
      o_table->get_table_fields( IMPORTING e_fields = t_fields ).

      ADD 1 TO l_field_handle.

      IF l_tabname = me->get_join_table( ).
        me->add_handle( i_tabname       = l_tabname
                        i_tab_handle    = 1
                        i_fields_handle = l_field_handle ).
      ELSE.
        me->add_handle( i_tabname       = l_tabname
                        i_tab_handle    = 2
                        i_fields_handle = l_field_handle ).
      ENDIF.

      me->add_dropdown( i_handle = l_field_handle
                        i_fields = t_fields ).
    ENDLOOP.

  ENDMETHOD.                    "consist_tables

  METHOD add_handle.
    FIELD-SYMBOLS <fs_handle> TYPE ty_handle.
    APPEND INITIAL LINE TO me->t_handle ASSIGNING <fs_handle>.
    <fs_handle>-tabname       = i_tabname.
    <fs_handle>-tab_handle    = i_tab_handle.
    <fs_handle>-fields_handle = i_fields_handle.
    UNASSIGN <fs_handle>.
  ENDMETHOD.                    "add_handle

  METHOD add_dropdown.
    FIELD-SYMBOLS: <fs_drop_down> TYPE lvc_s_drop,
                   <fs_field> TYPE ty_table_fields.
    IF NOT i_fields IS INITIAL.
      LOOP AT i_fields ASSIGNING <fs_field>.
        APPEND INITIAL LINE TO me->t_drop_down ASSIGNING <fs_drop_down>.
        <fs_drop_down>-handle = i_handle.
        <fs_drop_down>-value = <fs_field>-fieldname.
        UNASSIGN <fs_drop_down>.
      ENDLOOP.
    ELSE.
      APPEND INITIAL LINE TO me->t_drop_down ASSIGNING <fs_drop_down>.
      <fs_drop_down>-handle = i_handle.
      <fs_drop_down>-value = i_value.
      UNASSIGN <fs_drop_down>.
    ENDIF.
  ENDMETHOD.                    "add_dropdown

  METHOD get_field_handle.
    FIELD-SYMBOLS <fs_handle> TYPE ty_handle.
    READ TABLE me->t_handle ASSIGNING <fs_handle> WITH KEY tabname = i_tabname.
    IF sy-subrc IS INITIAL.
      return = <fs_handle>-fields_handle.
    ENDIF.
  ENDMETHOD.                    "get_field_handle

  METHOD set_handle_checkfield.
    FIELD-SYMBOLS <fs_join_field> TYPE ty_join_fields.
    READ TABLE me->t_join_fields ASSIGNING <fs_join_field> INDEX i_index.
    IF sy-subrc IS INITIAL.
      IF i_value IS INITIAL.
        CLEAR <fs_join_field>-dd_handle_checkfield.
      ELSE.
        <fs_join_field>-dd_handle_checkfield = me->get_field_handle( i_value ).
      ENDIF.
    ENDIF.
  ENDMETHOD.                    "set_handle_checkfield

  METHOD check_join_fields.
    DATA: l_message TYPE string,
          l_field   TYPE string.
    FIELD-SYMBOLS: <fs_join_field> TYPE ty_join_fields.

    me->o_grid->check_changed_data( ).

    LOOP AT me->t_join_fields ASSIGNING <fs_join_field>.
      IF <fs_join_field>-forkey IS INITIAL.
        l_message = 'Join field is required.'.
        l_field = 'FORKEY'.

      ELSEIF NOT <fs_join_field>-checktable IS INITIAL AND <fs_join_field>-checkfield IS INITIAL.
        l_message = 'Join field is required.'.
        l_field = 'CHECKFIELD'.

      ENDIF.

      IF NOT l_message IS INITIAL.
        RAISE EXCEPTION TYPE lcx_join_error
          EXPORTING
            i_index   = sy-tabix
            i_field   = l_field
            i_message = l_message.
      ENDIF.

    ENDLOOP.
  ENDMETHOD.                    "check_join_fields

ENDCLASS.               "lcl_screen_700
